{
  "templates": [
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"0-5V Input Channel \");\n    switch (inputChannels[inputChannelIndex]) {\n        case INPUT_05V_CH01: Serial.print(\"01\"); break;\n        case INPUT_05V_CH02: Serial.print(\"02\"); break;\n        case INPUT_05V_CH03: Serial.print(\"03\"); break;\n        case INPUT_05V_CH04: Serial.print(\"04\"); break;\n        case INPUT_05V_CH05: Serial.print(\"05\"); break;\n        case INPUT_05V_CH06: Serial.print(\"06\"); break;\n        case INPUT_05V_CH07: Serial.print(\"07\"); break;\n        case INPUT_05V_CH08: Serial.print(\"08\"); break;\n        default: break;"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "digitalWrite",
        "analogWrite",
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "blynkAnotherDevice",
          "body": "//向被控制端发送数据\n  if (value) {\n    bridge1.digitalWrite(12, HIGH);  //被控制端的12号管脚将被设为 HIGH\n    bridge1.virtualWrite(V5, 1); // 向被控制端V5管脚发送1，被控制端需要用BLYNK_WRITE(V5) 接收\n\n    /////////////////////////////////////////////////////////////////////////////////////////\n    //特别注意，如果向被控制端的虚拟管脚发送数据，\n    //被控制端需要用 BLYNK_WRITE函数来接收，类似于接收来自app端的虚拟管脚数据\n    //\n    //    BLYNK_WRITE(V5){\n    //    int pinData = param.asInt(); // 接收来自bridge的数据\n    //"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, blynkAnotherDevice);  // 每秒钟调用 blynkAnotherDevice 函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(2, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(2, HIGH);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "attachInterrupt"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "notifyOnButtonPress",
          "body": "int isButtonPressed = !digitalRead(2);\n  if (isButtonPressed) {\n    Serial.println(\"Button is pressed.\");\n    Blynk.notify(\"Yaaay... button is pressed!\");\n    // 你也可以使用 {DEVICE_NAME"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  pinMode(2, INPUT_PULLUP);//设置GPIO2为中断管脚\n  attachInterrupt(digitalPinToInterrupt(2), notifyOnButtonPress, CHANGE);//GPIO2添加中断函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin(custom_main_menu)) {\n    app.enableButtons();\n    /* Allow greater angular velocity than the default one. */\n    Braccio.setAngularVelocity(45.0f);"
        },
        {
          "name": "loop",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // Configure and start Serial Communication\n  Serial.begin(9600); \n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward() == HIGH)\n    Serial.println(\"Forward Button was pressed!\");\n\n  // Check the backward button signal\n  if(axis.readBtnBackward() == HIGH)\n    Serial.println(\"Backward Button was pressed!\");\n  \n  // Check the Endstop Home switch signal\n  if(axis.readEndstopHome() == HIGH)\n    Serial.println(\"Endstop Home was pressed!\");\n\n  // Check the Endstop Far switch signal\n  if(axis.readEndstopFar() == HIGH)\n    Serial.println(\"Endstop Far was pressed!\");\n  \n  // Check the Emergency Stop Button signal\n  if(axis.readBtnEmergencyStop() == LOW)\n    // The emergency stop button is attached in the interrupt service routine\n    // So when you click the button, you will see the Emergency message printed too\n    Serial.println(\"Emergency Stop Button was pressed!\");"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "COLOR_TEAL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();"
        },
        {
          "name": "loop",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();"
        },
        {
          "name": "directionScreen",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "TIME_DELAY",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin()){\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n\n    /* Move to home position. */\n    gripper.move().to(initialAngle);       delay(TIME_DELAY);\n    wristRoll.move().to(initialAngle);     delay(TIME_DELAY);\n    wristPitch.move().to(initialAngle);    delay(TIME_DELAY);\n    elbow.move().to(initialAngle);         delay(TIME_DELAY);\n    shoulder.move().to(initialAngle);      delay(TIME_DELAY);\n    base.move().to(initialBase);           delay(TIME_DELAY);"
        },
        {
          "name": "loop",
          "body": "// Fetch the joints positions\n  Braccio.positions(angles);\n\n  // Print the joint angles\n  Serial.println(\"************* Joints Angles *************\");\n  Serial.println(\"|\\tMotor ID\\t|\\tAngle\\t|\");\n  Serial.println(\"----------------------------------------\");\n  Serial.print(\"| 1 - Gripper\\t\\t|\\t\" + String(angles[0]) + \"\\t|\\n\" + \n               \"| 2 - Wrist Rotation\\t|\\t\" + String(angles[1]) + \"\\t|\\n\" +\n               \"| 3 - Wrist Vertical\\t|\\t\" + String(angles[2]) + \"\\t|\\n\" + \n               \"| 4 - Elbow\\t\\t|\\t\" + String(angles[3]) + \"\\t|\\n\" + \n               \"| 5 - Shoulder\\t\\t|\\t\" + String(angles[4]) + \"\\t|\\n\" + \n               \"| 6 - Base\\t\\t|\\t\" + String(angles[5]) + \"\\t|\\n\");\n  Serial.println(\"*****************************************\\n\\n\\n\\n\\n\");\n  Serial.println(\"\\n\\n\\n\\n\");\n  \n  delay(TIME_DELAY);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  lv_obj_t * btn1 = lv_btn_create(lv_scr_act());\n  lv_obj_set_size(btn1, 120, 75);\n  lv_obj_t * label1 = lv_label_create(btn1);\n  lv_label_set_text(label1, \"BTN 1\");\n  lv_obj_align(btn1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_center(label1);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "/* Set the meter value */\n  Braccio.lvgl_lock();\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 8, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(meterScreen);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle <= 315 ) {\n      currentAngle += 15.0;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial){"
        },
        {
          "name": "loop",
          "body": "int joystickPos = Braccio.getKey();\n  message = checkJoystick(joystickPos);\n  if(message != \"\"){\n    Serial.println(message);\n    message = \"\";"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin();\n  delay(500);\n  \n  Serial.begin(115200);\n  while(!Serial){"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"To start, send any key to the serial port:\");\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n   Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);\n// 创建LabeledValue组件，输入管脚设置为V5"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n   Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "notifyUptime",
          "body": "long uptime = millis() / 60000L;\n  Blynk.notify(String(\"Running for \") + uptime + \" minutes.\");//通知手机该项目运行时间\n  // 你也可以使用 {DEVICE_NAME"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  Blynk.notify(\"Device started\");//开机是发送通知\n  timer.setInterval(60000L, notifyUptime);//每分钟调用一次该函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "TimeLib.h",
        "WidgetRTC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  // 更多资料，请参考: http://www.pjrc.com/teensy/td_libs_Time.html\n  setSyncInterval(10 * 60); // 设置同步间隔时间，10分钟。\n  timer.setInterval(1000L, clockDisplay);//每隔1s，运行clockDisplay，显示时间"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "requestTime",
          "body": "//查询时间\n  Blynk.sendInternal(\"rtc\", \"sync\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(10000L, requestTime);//每隔10s运行requestTime"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward() == HIGH)\n    axis.moveForward();  // Motor rotates clockwise\n\n  // Check the backward button signal\n  if(axis.readBtnBackward() == HIGH)\n    axis.moveBackward(); // Motor rotates anticlockwise"
        }
      ]
    },
    {
      "name": "COLOR_TEAL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();"
        },
        {
          "name": "loop",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();"
        },
        {
          "name": "directionScreen",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward() == HIGH)\n    axisX.moveForward();\n  \n  // Check the forward button signal\n  if(axisY.readBtnForward() == HIGH)\n    axisY.moveForward();\n\n  // Check the forward button signal\n  if(axisX.readBtnBackward() == HIGH)\n    axisX.moveBackward();\n\n  // Check the forward button signal\n  if(axisY.readBtnBackward() == HIGH)\n    axisY.moveBackward();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin(custom_main_menu)) {\n    app.enableButtons();"
        },
        {
          "name": "loop",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of steps: \");\n\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "COLOR_TEAL",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style;\n  lv_style_init(&style);\n  lv_style_set_bg_color(&style, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style, lv_color_hex(COLOR_TEAL));\n  lv_style_set_border_width(&style, 5);\n  lv_style_set_text_color(&style, lv_color_hex(COLOR_ORANGE));\n\n  lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); \n  lv_obj_set_size(btn1, 120, 75);\n  \n  lv_obj_t * label1 = lv_label_create(btn1);\n  lv_label_set_text(label1, \"BTN 1\");\n  \n  lv_obj_align(btn1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_center(label1);\n\n  lv_obj_add_style(btn1, &style, 0);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_PRESSED) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was selected\\n\", txt);\n    Serial.println(String(txt) + \" was selected.\");"
        },
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n  \n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object"
        },
        {
          "name": "eventHandlerMenu",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen(); // Load meter screen\n  lv_obj_del(btnm); // Delete the object"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 8, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(motorMenu);\n\n  delay(5000); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1500); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 15.00;"
        }
      ]
    },
    {
      "name": "BUTTON_ENTER",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin();\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for(int i = 1; i <= 6; i++){\n    Braccio.move(i).to(0.0f);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "// Check if the control key pressed is the Enter Button\n  if(Braccio.getKey() == BUTTON_ENTER){\n    \n    if(motorID <= 6){\n      \n      motorID++;  // Increment the ID\n      \n      if(motorID > 6){\n        motorID = 1; // Restart the ID to motor 1"
        }
      ]
    },
    {
      "name": "BUTTON_ENTER",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin()){\n    /* Warning:\n       Keep a safe distance from the robot until you make sure the code is properly\n       working. Be mindful of the robot’s movement prior to that, as it could be\n       speedy and accidentally hit someone.\n    */\n\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(TIME_DELAY);"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n    movement = true; // Trigger joints' movements\n\n  if (movement) {\n    Braccio.moveTo(WAVE_POS[0], WAVE_POS[1], WAVE_POS[2], WAVE_POS[3], WAVE_POS[4], WAVE_POS[5]);\n    delay(TIME_DELAY);\n\n    for (int i = 1; i <= 5; i++) {\n      wristPitch.move().to(120.0f);         delay(TIME_DELAY);\n      wristPitch.move().to(200.0f);         delay(2*TIME_DELAY);\n      wristPitch.move().to(WAVE_POS[3]);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "attachInterrupt"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "body": "int isButtonPressed = !digitalRead(2); \n  if (isButtonPressed) // 你可以在此设置任何触发邮件发送的条件\n  {//按钮按下时，发送邮件\n    Serial.println(\"Button is pressed.\"); // 串口输出\n    Blynk.email(\"your_email@mail.com\", \"Subject: Button Logger\", \"You just pushed the button...\");\n    // 如果只是想在手机app上显示，可以用以下格式\n    //Blynk.email(\"Subject: Button Logger\", \"You just pushed the button...\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  //当开发板连接到服务器时，发送一封邮件\n  //收件人，邮件主题，邮件内容\n  Blynk.email(\"your_email@mail.com\", \"Subject\", \"My Blynk project is online.\");\n  // 设置按钮管脚为中断输入\n  pinMode(2, INPUT_PULLUP);\n  // 为GPIO2设置中断，中断函数为emailOnButtonPress\n  attachInterrupt(digitalPinToInterrupt(2), emailOnButtonPress, CHANGE);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, blinkLedWidget);//每隔1秒执行blinkLedWidget函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "blinkLedWidget",
          "body": "if (ledStatus) {\n    led1.setColor(BLYNK_RED);//设置为红色\n    Serial.println(\"LED on V1: red\");\n    ledStatus = false;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  led1.on();//点亮LED\n  timer.setInterval(1000L, blinkLedWidget);//每隔一秒运行blinkLedWidget函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(300L, fadeLedWidget);//每隔300毫秒执行fadeLedWidget函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "buttonLedWidget",
          "body": "boolean isPressed = (digitalRead(btnPin) == LOW);//读取按钮是否按下，注意，此处是针对 低电平 有效的按钮\n  if (isPressed != btnState) {//如果当前按钮状态与之前不一样\n    if (isPressed) {//如果当前是按下的\n      led3.on();//点亮led"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  pinMode(btnPin, INPUT_PULLUP);//btnPin管脚设为上升中断模式\n  timer.setInterval(500L, buttonLedWidget);//每隔500毫秒执行buttonLedWidget"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  // Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(motor.readBtnForward() == HIGH)\n    motor.moveForward();        // Motor rotates clockwise\n\n  // Check the backward button signal\n  if(motor.readBtnBackward() == HIGH)\n    motor.moveBackward();       // Motor rotates anticlockwise"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the step: \");\n  \n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object"
        },
        {
          "name": "eventHandlerMenu",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen();\n  lv_obj_del(btnm);"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 22, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(motorMenu);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 10.00;"
        }
      ]
    },
    {
      "name": "BUTTON_ENTER",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin()){\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n    movement = true; // Trigger joints' movements\n\n  if (movement) {\n    Braccio.moveTo(AGREE_POS[0], AGREE_POS[1], AGREE_POS[2], AGREE_POS[3], AGREE_POS[4], AGREE_POS[5]);\n    delay(TIME_DELAY/10);\n\n    for (int i = 1; i <= 10; i++) {\n      wristPitch.move().to(190.0f);       delay(TIME_DELAY/2);\n      wristPitch.move().to(240.0f);       delay(TIME_DELAY);\n      wristPitch.move().to(AGREE_POS[3]);"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin(); // Initialize Braccio\n  \n  delay(500); // Waits for the Braccio initialization\n  \n  // Sets the initial angle for the motors\n  for(int i = 1; i <= 6; i++){\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n  \n  // Check if the control key pressed is the Enter Button\n  if(pressedKey == BUTTON_ENTER){\n    if(motorID < 6){\n      \n      motorID++;  // Increment the ID"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_PRESSING) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s is pressed\\n\", txt);\n    Serial.println(String(txt) + \" is pressed.\");"
        },
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n\n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n\n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the step for X-axis: \");\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n//Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the position: \");\n  \n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial",
        "analogRead"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// read the input pin\n  speedMotor = analogRead(potentiometer);\n\n  // Re-maps an analog value to speed value\n  speedMotor = map(speedMotor, 0, 1023, MIN_SPEED, MAX_SPEED);\n\n  Serial.println(speedMotor); // Send the new value to serial monitor\n\n  motor.setSpeed(speedMotor); // Sets the motor speed\n  \n  // Check the forward button signal\n  if(motor.readBtnForward() == HIGH)\n    motor.moveForward();      // Motor rotates clockwise"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object"
        },
        {
          "name": "eventHandlerMenu",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen();\n  lv_obj_del(btnm);"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 22, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 3, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(motorMenu);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 10.00;"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_RELEASED) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was released\\n\", txt);\n    Serial.println(String(txt) + \" was released.\");"
        },
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n\n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n\n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin();\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  // Check if the control key pressed is the Joystick Up\n  if (pressedKey == JOYSTICK_UP) {\n\n    if (motorID < 6) {\n      motorID++;  // Increment the ID"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(0xFFFFFF));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_width(btnm1, 3, 2);  // Make \"Option 4\" twice as wide as \"Option 5\"\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial)\n  {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the position for X-axis: \");\n  // Waits for the user to send a value via serial port\n  while ((Serial.available() <= 0))\n  {"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "sendFlagToServer",
          "body": "if (flag) {\n    Blynk.virtualWrite(V0, 1);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, sendFlagToServer);//每秒执行一次"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  // Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n\n  lcd.clear(); //LCD清屏\n  lcd.print(4, 0, \"Hello\"); // 使用格式: (X坐标: 0-15, Y坐标: 0-1, \"Message you want to print\")\n  lcd.print(4, 1, \"World\");\n  //如果在主函数中使用该函数，请通过调用事件的方式显示，如果直接显示会导致硬件掉线。"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "sendSeconds",
          "body": "//发送秒到V0\n  Blynk.virtualWrite(V0, millis() / 1000);"
        },
        {
          "name": "sendMillis",
          "body": "//发送微秒到V1\n  Blynk.virtualWrite(V1, millis());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n\n  timer.setInterval(1000L, sendSeconds);//发送秒\n  timer.setInterval(1000L, sendMillis);//发送微秒"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n\n  // If you want to remove all points:\n  //myMap.clear();\n\n  int index = 0;\n  float lat = 51.5074;\n  float lon = 0.1278;\n  myMap.location(index, lat, lon, \"value\");"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    robot.drawLine(5,5,5,10);   // Draws one line\n    delay(500);\n\n    robot.drawLine(5,10,10,10); // Draws other line\n    delay(500);\n\n    robot.drawLine(10,10,5,5);  // Draws a diagonal line\n    delay(500);"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "digitalWrite",
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(trigPin, OUTPUT);     // Sets the trigPin as an OUTPUT\n  pinMode(echoPin, INPUT);      // Sets the echoPin as an INPUT\n\n  Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward()){\n    positionNum = readUltrasonic() - motorOffset;\n    // Moves the robot carriage\n    axis.toPosition(positionNum);"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_BG));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_BTN));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_BORDER));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEXT));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_width(btnm1, 1, 2);  // Make \"Button 2\" twice as wide as \"Button 3\"\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);\n  Blynk.virtualWrite(V6, millis() / 1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  // Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);\n   timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    robot.drawLine(5,5,5,10);   // Draws horizontal line\n    delay(500);\n\n    robot.drawLine(5,10,10,10); // Draws vertical line\n    delay(500);\n\n    robot.drawLine(10,10,10,5); // Draws horizontal line\n    delay(500);\n\n    robot.drawLine(10,5,5,5);   // Draws a vertical line\n    delay(500);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "Adafruit_NeoPixel.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);\n  strip.begin();\n  strip.show();"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n\n  // Clear the terminal content\n  terminal.clear();\n\n  // This will print Blynk Software version to the Terminal Widget when\n  // your hardware gets connected to Blynk Server\n  terminal.println(F(\"Blynk v\" BLYNK_VERSION \": Device started\"));\n  terminal.println(F(\"-------------\"));\n  terminal.println(F(\"Type 'Marco' and get a reply, or type\"));\n  terminal.println(F(\"anything else and get it printed back.\"));\n  terminal.flush();"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  Blynk.virtualWrite(V0, \"https://raw.githubusercontent.com/blynkkk/blynk-library/master/extras/logo.txt\");\n\n  // You can perform HTTPS requests even if your hardware alone can't handle SSL\n  // 如果您使用的开发板有足够的RAM，\n  //Blynk也可以接收更大的消息。你可以设置BLYNK_MAX_READBYTES 为4096\n  //Blynk.virtualWrite(V0, \"https://api.sunrise-sunset.org/json?lat=50.4495484&lng=30.5253873&date=2016-10-01\");"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    // Draws a circle\n    robot.drawCircle(CENTER_X, CENTER_Y, RADIUS);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_19V);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"19V Input Channel \");\n    Serial.print(\": \");\n\n    auto [ voltsMuxer, voltsReference ] = getAverageAnalogRead(INPUT_19V_REF);\n\n    Serial.print(voltsReference);\n    Serial.print(\" (\");\n    Serial.print(voltsMuxer);\n    Serial.println(\")\");\n    delay(1000);"
        }
      ]
    },
    {
      "name": "LGFX_M5STACK",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp",
        "LGFX_AUTODETECT.hpp",
        "lgfx_user/LGFX_ESP32_sample.hpp",
        "LGFX_TFT_eSPI.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// 最初に初期化関数を呼び出します。\n  lcd.init();\n\n\n// 回転方向を 0～3 の4方向から設定します。(4～7を使用すると上下反転になります。)\n  lcd.setRotation(1);\n\n\n// バックライトの輝度を 0～255 の範囲で設定します。\n  lcd.setBrightness(128);\n\n\n// 必要に応じてカラーモードを設定します。（初期値は16）\n// 16の方がSPI通信量が少なく高速に動作しますが、赤と青の諧調が5bitになります。\n// 24の方がSPI通信量が多くなりますが、諧調表現が綺麗になります。\n//lcd.setColorDepth(16);  // RGB565の16ビットに設定\n  lcd.setColorDepth(24);  // RGB888の24ビットに設定(表示される色数はパネル性能によりRGB666の18ビットになります)\n\n\n// 基本的な図形の描画関数は以下の通りです。\n/*\n  fillScreen    (                color);  // 画面全体の塗り潰し\n  drawPixel     ( x, y         , color);  // 点\n  drawFastVLine ( x, y   , h   , color);  // 垂直線\n  drawFastHLine ( x, y, w      , color);  // 水平線\n  drawRect      ( x, y, w, h   , color);  // 矩形の外周\n  fillRect      ( x, y, w, h   , color);  // 矩形の塗り\n  drawRoundRect ( x, y, w, h, r, color);  // 角丸の矩形の外周\n  fillRoundRect ( x, y, w, h, r, color);  // 角丸の矩形の塗り\n  drawCircle    ( x, y      , r, color);  // 円の外周\n  fillCircle    ( x, y      , r, color);  // 円の塗り\n  drawEllipse   ( x, y, rx, ry , color);  // 楕円の外周\n  fillEllipse   ( x, y, rx, ry , color);  // 楕円の塗り\n  drawLine      ( x0, y0, x1, y1        , color); // ２点間の直線\n  drawTriangle  ( x0, y0, x1, y1, x2, y2, color); // ３点間の三角形の外周\n  fillTriangle  ( x0, y0, x1, y1, x2, y2, color); // ３点間の三角形の塗り\n  drawBezier    ( x0, y0, x1, y1, x2, y2, color); // ３点間のベジエ曲線\n  drawBezier    ( x0, y0, x1, y1, x2, y2, x3, y3, color); // ４点間のベジエ曲線\n  drawArc       ( x, y, r0, r1, angle0, angle1, color);   // 円弧の外周\n  fillArc       ( x, y, r0, r1, angle0, angle1, color);   // 円弧の塗り\n*/\n\n\n// 例えばdrawPixelで点を書く場合は、引数は X座標,Y座標,色 の３つ。\n  lcd.drawPixel(0, 0, 0xFFFF); // 座標0:0に白の点を描画\n\n\n// カラーコードを生成する関数が用意されており、色の指定に使用できます。\n// 引数は、赤,緑,青をそれぞれ 0～255で指定します。\n// 色情報の欠落を防ぐため、color888を使う事を推奨します。\n  lcd.drawFastVLine(2, 0, 100, lcd.color888(255,   0,   0)); // 赤で垂直の線を描画\n  lcd.drawFastVLine(4, 0, 100, lcd.color565(  0, 255,   0)); // 緑で垂直の線を描画\n  lcd.drawFastVLine(6, 0, 100, lcd.color332(  0,   0, 255)); // 青で垂直の線を描画\n\n\n// カラーコード生成関数を使用しない場合は以下のようになります。\n// RGB888 24ビットで指定 uint32_t型\n// RGB565 16ビットで指定 uint16_t型、int32_t型\n// RGB332  8ビットで指定 uint8_t型\n\n// uint32_t型を使用すると、RGB888の24ビットとして扱われます。\n// 16進数2桁で赤緑青の順に記述できます。\n// uint32_t型の変数を使うか、末尾にUを付けるか、uint32_t型にキャストして使用します。\n  uint32_t red = 0xFF0000;\n  lcd.drawFastHLine(0, 2, 100, red);            // 赤で水平の線を描画\n  lcd.drawFastHLine(0, 4, 100, 0x00FF00U);      // 緑で水平の線を描画\n  lcd.drawFastHLine(0, 6, 100, (uint32_t)0xFF); // 青で水平の線を描画\n\n\n// uint16_t型およびint32_t型を使用すると、RGB565の16ビットとして扱われます。\n// 特別な書き方をしない場合はint32_t型として扱われるので、この方式になります。\n// （AdafruitGFX や TFT_eSPI との互換性のために、このようにしています。）\n  uint16_t green = 0x07E0;\n  lcd.drawRect(10, 10, 50, 50, 0xF800);         // 赤で矩形の外周を描画\n  lcd.drawRect(12, 12, 50, 50, green);          // 緑で矩形の外周を描画\n  lcd.drawRect(14, 14, 50, 50, (uint16_t)0x1F); // 青で矩形の外周を描画\n\n\n// int8_t型、uint8_t型を使用すると、RGB332の8ビットとして扱われます。\n  uint8_t blue = 0x03;\n  lcd.fillRect(20, 20, 20, 20, (uint8_t)0xE0);  // 赤で矩形の塗りを描画\n  lcd.fillRect(30, 30, 20, 20, (uint8_t)0x1C);  // 緑で矩形の塗りを描画\n  lcd.fillRect(40, 40, 20, 20, blue);           // 青で矩形の塗りを描画\n\n\n// 描画関数の引数の色は省略できます。\n// 省略した場合、setColor関数で設定した色 または最後に使用した色を描画色として使用します。\n// 同じ色で繰り返し描画する場合は、省略した方がわずかに速く動作します。\n  lcd.setColor(0xFF0000U);                        // 描画色に赤色を指定\n  lcd.fillCircle ( 40, 80, 20    );               // 赤色で円の塗り\n  lcd.fillEllipse( 80, 40, 10, 20);               // 赤色で楕円の塗り\n  lcd.fillArc    ( 80, 80, 20, 10, 0, 90);        // 赤色で円弧の塗り\n  lcd.fillTriangle(80, 80, 60, 80, 80, 60);       // 赤色で三角の塗り\n  lcd.setColor(0x0000FFU);                        // 描画色に青色を指定\n  lcd.drawCircle ( 40, 80, 20    );               // 青色で円の外周\n  lcd.drawEllipse( 80, 40, 10, 20);               // 青色で楕円の外周\n  lcd.drawArc    ( 80, 80, 20, 10, 0, 90);        // 青色で円弧の外周\n  lcd.drawTriangle(60, 80, 80, 80, 80, 60);       // 青色で三角の外周\n  lcd.setColor(0x00FF00U);                        // 描画色に緑色を指定\n  lcd.drawBezier( 60, 80, 80, 80, 80, 60);        // 緑色で二次ベジエ曲線\n  lcd.drawBezier( 60, 80, 80, 20, 20, 80, 80, 60);// 緑色で三次ベジエ曲線\n\n// グラデーションの線を描画するdrawGradientLine は色の指定を省略できません。\n  lcd.drawGradientLine( 0, 80, 80, 0, 0xFF0000U, 0x0000FFU);// 赤から青へのグラデーション直線\n\n  delay(1000);\n\n// clearまたはfillScreenで画面全体を塗り潰せます。\n// fillScreenはfillRectの画面全体を指定したのと同じで、色の指定は描画色の扱いになります。\n  lcd.fillScreen(0xFFFFFFu);  // 白で塗り潰し\n  lcd.setColor(0x00FF00u);    // 描画色に緑色を指定\n  lcd.fillScreen();           // 緑で塗り潰し\n\n// clearは描画系の関数とは別で背景色という扱いで色を保持しています。\n// 背景色は出番が少ないですが、スクロール機能使用時の隙間を塗る色としても使用されます。\n  lcd.clear(0xFFFFFFu);       // 背景色に白を指定して塗り潰し\n  lcd.setBaseColor(0x000000u);// 背景色に黒を指定\n  lcd.clear();                // 黒で塗り潰し\n\n\n// SPIバスの確保と解放は描画関数を呼び出した時に自動的に行われますが、\n// 描画スピードを重視する場合は、描画処理の前後に startWriteとendWriteを使用します。\n// SPIバスの確保と解放が抑制され、速度が向上します。\n// 電子ペーパー(EPD)の場合、startWrite()以降の描画は、endWrite()を呼ぶ事で画面に反映されます。\n  lcd.drawLine(0, 1, 39, 40, red);       // SPIバス確保、線を描画、SPIバス解放\n  lcd.drawLine(1, 0, 40, 39, blue);      // SPIバス確保、線を描画、SPIバス解放\n  lcd.startWrite();                      // SPIバス確保\n  lcd.drawLine(38, 0, 0, 38, 0xFFFF00U); // 線を描画\n  lcd.drawLine(39, 1, 1, 39, 0xFF00FFU); // 線を描画\n  lcd.drawLine(40, 2, 2, 40, 0x00FFFFU); // 線を描画\n  lcd.endWrite();                        // SPIバス解放\n\n\n// startWriteとendWriteは呼出し回数を内部でカウントしており、\n// 繰り返し呼び出した場合は最初と最後のみ動作します。\n// startWriteとendWriteは必ず対になるように使用してください。\n// (SPIバスを占有して構わない場合は、最初にstartWriteを一度呼び、endWriteしない使い方も可能です。)\n  lcd.startWrite();     // カウント+1、SPIバス確保\n  lcd.startWrite();     // カウント+1\n  lcd.startWrite();     // カウント+1\n  lcd.endWrite();       // カウント-1\n  lcd.endWrite();       // カウント-1\n  lcd.endWrite();       // カウント-1、SPIバス解放\n  lcd.endWrite();       // 何もしない\n// なお過剰にendWriteを呼び出した場合は何も行わず、カウントがマイナスになることもありません。\n\n\n// startWriteのカウントの状態に依らず、強制的にSPIバスを解放・確保したい場合は、\n// endTransaction・beginTransactionを使用します。\n// カウントはクリアされないので、辻褄が合わなくならないよう注意してください。\n  lcd.startWrite();       // カウント+1、SPIバス確保\n  lcd.startWrite();       // カウント+1\n  lcd.drawPixel(0, 0);    // 描画\n  lcd.endTransaction();   // SPIバス解放\n  // ここで他のSPIデバイスの使用が可能\n  // 同じSPIバスの別のデバイス(SDカード等)を使う場合、\n  // 必ずSPIバスが解放された状態で行ってください。\n  lcd.beginTransaction(); // SPIバスの確保\n  lcd.drawPixel(0, 0);    // 描画\n  lcd.endWrite();         // カウント-1\n  lcd.endWrite();         // カウント-1、SPIバス解放\n\n\n\n// drawPixelとは別に、writePixelという点を描画する関数があります。\n// drawPixelは必要に応じてSPIバスの確保を行うのに対し、\n// writePixelはSPIバスの状態をチェックしません。\n  lcd.startWrite();  // SPIバス確保\n  for (uint32_t x = 0; x < 128; ++x) {\n    for (uint32_t y = 0; y < 128; ++y) {\n      lcd.writePixel(x, y, lcd.color888( x*2, x + y, y*2));"
        },
        {
          "name": "loop",
          "body": "static int count = 0;\n  static int a = 0;\n  static int x = 0;\n  static int y = 0;\n  static float zoom = 3;\n  ++count;\n  if ((a += 1) >= 360) a -= 360;\n  if ((x += 2) >= lcd.width()) x -= lcd.width();\n  if ((y += 1) >= lcd.height()) y -= lcd.height();\n  sprite.setPaletteColor(1, lcd.color888( 0, 0, count & 0xFF));\n  sprite.setPaletteColor(2, lcd.color888( 0,~count & 0xFF, 0));\n  sprite.setPaletteColor(3, lcd.color888( count & 0xFF, 0, 0));\n\n  sprite.pushRotateZoom(x, y, a, zoom, zoom, 0);\n\n  if ((count % 100) == 0) lcd.display(); // 電子ペーパーの場合の表示更新を 100回に一度行う"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// SPIバスとパネルの初期化を実行すると使用可能になります。\n  display.init();\n\n  display.setTextSize((std::max(display.width(), display.height()) + 255) >> 8);\n\n  // タッチが使用可能な場合のキャリブレーションを行います。（省略可）\n  if (display.touch())\n  {\n    if (display.width() < display.height()) display.setRotation(display.getRotation() ^ 1);\n\n    // 画面に案内文章を描画します。\n    display.setTextDatum(textdatum_t::middle_center);\n    display.drawString(\"touch the arrow marker.\", display.width()>>1, display.height() >> 1);\n    display.setTextDatum(textdatum_t::top_left);\n\n    // タッチを使用する場合、キャリブレーションを行います。画面の四隅に表示される矢印の先端を順にタッチしてください。\n    std::uint16_t fg = TFT_WHITE;\n    std::uint16_t bg = TFT_BLACK;\n    if (display.isEPD()) std::swap(fg, bg);\n    display.calibrateTouch(nullptr, fg, bg, std::max(display.width(), display.height()) >> 3);"
        },
        {
          "name": "loop",
          "body": "display.startWrite();\n  display.setRotation(++count & 7);\n  display.setColorDepth((count & 8) ? 16 : 24);\n\n  display.setTextColor(TFT_WHITE);\n  display.drawNumber(display.getRotation(), 16, 0);\n\n  display.setTextColor(0xFF0000U);\n  display.drawString(\"R\", 30, 16);\n  display.setTextColor(0x00FF00U);\n  display.drawString(\"G\", 40, 16);\n  display.setTextColor(0x0000FFU);\n  display.drawString(\"B\", 50, 16);\n\n  display.drawRect(30,30,display.width()-60,display.height()-60,count*7);\n  display.drawFastHLine(0, 0, 10);\n\n  display.endWrite();\n\n  int32_t x, y;\n  if (display.getTouch(&x, &y)) {\n    display.fillRect(x-2, y-2, 5, 5, count*7);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    while(!Serial);\n\n    delay(1000);\n\n    Serial.println(\"3-Wire Valve Demo\");\n\n    EdgeControl.begin();\n    Latching.begin();\n\n    Serial.println(\"Starting\");"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Closing\");\n    Latching.channelDirection(LATCHING_OUT_1, POSITIVE);\n    Latching.strobe(4500);\n\n    delay(2500);\n\n    Serial.println(\"Opening\");\n    Latching.channelDirection(LATCHING_OUT_1, NEGATIVE);\n    Latching.strobe(4500);\n    delay(2500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "drawGradation",
          "body": "// 背景にグラデーションを描画する\n  lcd.startWrite();\n  lcd.setAddrWindow(0, 0, lcd.width(), lcd.height());\n  for (int y = 0; y < lcd.height(); ++y) {\n    for (int x = 0; x < lcd.width(); ++x) {\n      lcd.writeColor(lcd.color888(x>>1, (x + y) >> 2, y>>1), 1);"
        },
        {
          "name": "setup",
          "body": "lcd.init();\n\n  drawGradation();\n\n  // 文字の描画方法には大きく分けて２通り、print 系の関数と drawString 系の関数があります。\n\n  // drawString 関数では、第１引数で文字列を指定し、第２引数でX座標、第３引数でY座標を指定します。\n  lcd.drawString(\"string!\", 10, 10);\n\n  // drawNumber 関数では、第１引数が数値になります。\n  lcd.drawNumber(123, 100, 10);\n\n  // drawFloat 関数では、第１引数が数値、第２引数が小数点以下の桁数になり、第３引数がX座標、第４引数がY座標になります。\n  lcd.drawFloat(3.14, 2, 150, 10);\n\n  // print 関数では、setCursor関数で指定した座標 (またはprint関数で最後に描画した文字の続き)に描画します。\n  lcd.setCursor(10, 20);\n  lcd.print(\"print!\");\n\n  // printf関数で、第２引数以降の内容を描画できます。(C言語のprintf準拠ですので文字列や浮動小数も描画できます)\n  int value = 123;\n  lcd.printf(\"test %d\", value);\n\n  // println関数で、文字列を描画後に改行できます。print(\"\\n\");と同じ効果です。\n  lcd.println(\"println\");\n\n  // フォントを変更するには、setFont関数を使用します。\n  // TFT_eSPIのsetTextFont関数と同じフォントは Font0 ～ Font8 になります。\n  // ※ エディタの入力支援が使える場合、引数に&fonts::まで入力する事でフォント一覧が表示されます\n  lcd.setFont(&fonts::Font4);\n  lcd.println(\"TestFont4\");\n\n  // TFT_eSPIとの互換性のためにsetTextFont関数による番号でのフォント変更にも対応しています。\n  // 引数に指定できる数字は 0, 2, 4, 6, 7, 8 です。(TFT_eSPI準拠です)\n  // ※ ただし この方法は、他の番号のフォントも強制的にバイナリに含まれサイズが膨らむため、非推奨です。\n  lcd.setTextFont(2);\n  lcd.println(\"TestFont2\");\n\n\n  // setTextColorで色を変更できます。\n  // １つ目の引数が文字色、２つ目の引数が背景色になります。\n  lcd.setTextColor(0x00FFFFU, 0xFF0000U);\n  lcd.print(\"CyanText RedBack\");\n  // ※ 同じ場所に文字を繰り返し描画し直したい場合、背景色を指定して重ね書きすることを推奨します。\n  //    fillRect等で消去してから書き直すと、ちらつきが発生する可能性があります。\n\n\n  // setTextColorで第１引数のみを指定し第２引数を省略した場合は、\n  // 背景を塗り潰さず文字だけを描画します。\n  lcd.setTextColor(0xFFFF00U);\n  lcd.print(\"YellowText ClearBack\");\n\n\n  // Font6は時計用の文字のみが収録されています。\n  lcd.setFont(&fonts::Font6);\n  lcd.print(\"apm.:-0369\");\n\n  // Font7は７セグメント液晶風のフォントが収録されています。\n  lcd.setFont(&fonts::Font7);\n  lcd.print(\".:-147\");\n\n  // Font8は数字のみが収録されています。\n  lcd.setFont(&fonts::Font8);\n  lcd.print(\".:-258\");\n\n\n  delay(3000);\n  drawGradation();\n\n// IPAフォントをコンバートした日本語フォントが４種類ｘ９サイズ = 36通りプリセットされています。\n// 末尾の数字がサイズを表しており、8, 12, 16, 20, 24, 28, 32, 36, 40 が用意されています。\n// fonts::lgfxJapanMincho_12      // 明朝体 サイズ12 固定幅フォント\n// fonts::lgfxJapanMinchoP_16     // 明朝体 サイズ16 プロポーショナルフォント\n// fonts::lgfxJapanGothic_20      // ゴシック体 サイズ20 固定幅フォント\n// fonts::lgfxJapanGothicP_24     // ゴシック体 サイズ24 プロポーショナルフォント\n\n// efontをコンバートした日本語・韓国語・中国語（簡体字・繁体字）フォントが各４種類ｘ５サイズ＝20通りプリセットされています。\n// 数字がサイズを表しており、10, 12, 14, 16, 24 が用意されています。\n// 末尾の文字は b= ボールド(太字) / i= イタリック(斜体) を表しています。\n// fonts::efontJA_10              // 日本語 サイズ10\n// fonts::efontCN_12_b            // 簡体字 サイズ12 ボールド\n// fonts::efontTW_14_bi           // 繁体字 サイズ14 ボールドイタリック\n// fonts::efontKR_16_i            // 韓国語 サイズ16 イタリック\n\n  lcd.setCursor(0, 0);\n  lcd.setFont(&fonts::lgfxJapanMincho_16);   lcd.print(\"明朝体 16 Hello World\\nこんにちは世界\\n\");\n//lcd.setFont(&fonts::lgfxJapanMinchoP_16);  lcd.print(\"明朝 P 16 Hello World\\nこんにちは世界\\n\");\n  lcd.setFont(&fonts::lgfxJapanGothic_16);   lcd.print(\"ゴシック体 16 Hello World\\nこんにちは世界\\n\");\n//lcd.setFont(&fonts::lgfxJapanGothicP_16);  lcd.print(\"ゴシック P 16 Hello World\\nこんにちは世界\\n\");\n\n// ※ やまねこ氏の [日本語フォントサブセットジェネレーター](https://github.com/yamamaya/lgfxFontSubsetGenerator)\n//    を使用することで、必要な文字だけを含む小サイズのフォントデータを作成できます。\n\n\n  delay(3000);\n  drawGradation();\n\n\n  // LovyanGFXでは AdafruitGFX フォントも setFont 関数で使用できます。\n  // (TFT_eSPIとの互換性のために setFreeFont関数も用意しています)\n  lcd.setFont(&fonts::FreeSerif9pt7b);\n\n\n  // 右揃え や 中央揃え で描画したい場合は、setTextDatum 関数で基準位置を指定します。\n  // 縦方向が top、middle、baseline、bottomの4通り、横方向が left、center、rightの3通りです。\n  // 縦と横の指定を組み合わせた12通りの中から指定します。\n  lcd.setTextDatum( textdatum_t::top_left        );\n  lcd.setTextDatum( textdatum_t::top_center      );\n  lcd.setTextDatum( textdatum_t::top_right       );\n  lcd.setTextDatum( textdatum_t::middle_left     );\n  lcd.setTextDatum( textdatum_t::middle_center   );\n  lcd.setTextDatum( textdatum_t::middle_right    );\n  lcd.setTextDatum( textdatum_t::baseline_left   );\n  lcd.setTextDatum( textdatum_t::baseline_center );\n  lcd.setTextDatum( textdatum_t::baseline_right  );\n  lcd.setTextDatum( textdatum_t::bottom_left     );\n  lcd.setTextDatum( textdatum_t::bottom_center   );\n  lcd.setTextDatum( textdatum_t::bottom_right    );\n  // ※  \"textdatum_t::\" は省略可能です\n  // ※ print系関数には縦方向の指定のみ効果があり、横方向の指定は効果がありません。\n\n  // 右下揃え\n  lcd.setTextDatum( bottom_right );\n  lcd.drawString(\"bottom_right\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 左下揃え\n  lcd.setTextDatum( bottom_left );\n  lcd.drawString(\"bottom_left\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 右上揃え\n  lcd.setTextDatum( top_right );\n  lcd.drawString(\"top_right\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 左上揃え\n  lcd.setTextDatum( top_left );\n  lcd.drawString(\"top_left\",  lcd.width() / 2,  lcd.height() / 2);\n\n\n  // 基準座標に中心線を描画\n  lcd.drawFastVLine(lcd.width() / 2, 0, lcd.height(), 0xFFFFFFU);\n  lcd.drawFastHLine(0, lcd.height() / 2, lcd.width(), 0xFFFFFFU);\n\n\n  delay(3000);\n  drawGradation();\n\n  lcd.setFont(&Font2);\n  lcd.setCursor(0, 0);\n\n\n  lcd.drawRect(8, 8, lcd.width() - 16, lcd.height() - 16, 0xFFFFFFU);\n\n  // setClipRect関数で描画する範囲を限定できます。指定した範囲外には描画されなくなります。\n  // ※ テキスト系のみならず、すべての描画関数に影響します。\n  lcd.setClipRect(10, 10, lcd.width() - 20, lcd.height() - 20);\n\n\n  // setTextSize 関数で 文字の拡大率を指定します。\n  // 第１引数で横方向の倍率、第２引数で縦方向の倍率を指定します。\n  // 第２引数を省略した場合は、第１引数の倍率が縦と横の両方に反映されます。\n  lcd.setTextSize(2.7, 4);\n  lcd.println(\"Size 2.7 x 4\");\n\n  lcd.setTextSize(2.5);\n  lcd.println(\"Size 2.5 x 2.5\");\n\n  lcd.setTextSize(1.5, 2);\n  lcd.println(\"Size 1.5 x 2\");\n\n  delay(1000);\n\n  lcd.setTextColor(0xFFFFFFU, 0);\n  for (float i = 0; i < 30; i += 0.01) {\n    lcd.setTextSize(sin(i)+1.1, cos(i)+1.1);\n    lcd.drawString(\"size test\", 10, 10);"
        },
        {
          "name": "drawNumberTest",
          "body": "lcd.setFont(font);\n\n  lcd.fillScreen(0x0000FF);\n\n  lcd.setColor(0xFFFF00U);\n  lcd.drawFastVLine( 80, 0, 240);\n  lcd.drawFastVLine(160, 0, 240);\n  lcd.drawFastVLine(240, 0, 240);\n  lcd.drawFastHLine(0,  45, 320);\n  lcd.drawFastHLine(0,  95, 320);\n  lcd.drawFastHLine(0, 145, 320);\n  lcd.drawFastHLine(0, 195, 320);\n\n  for (int i = 0; i < 200; ++i) {\n    lcd.setTextDatum( textdatum_t::bottom_right    );     lcd.drawNumber(i,  80,  45);\n    lcd.setTextDatum( textdatum_t::bottom_center   );     lcd.drawNumber(i, 160,  45);\n    lcd.setTextDatum( textdatum_t::bottom_left     );     lcd.drawNumber(i, 240,  45);\n    lcd.setTextDatum( textdatum_t::baseline_right  );     lcd.drawNumber(i,  80,  95);\n    lcd.setTextDatum( textdatum_t::baseline_center );     lcd.drawNumber(i, 160,  95);\n    lcd.setTextDatum( textdatum_t::baseline_left   );     lcd.drawNumber(i, 240,  95);\n    lcd.setTextDatum( textdatum_t::middle_right    );     lcd.drawNumber(i,  80, 145);\n    lcd.setTextDatum( textdatum_t::middle_center   );     lcd.drawNumber(i, 160, 145);\n    lcd.setTextDatum( textdatum_t::middle_left     );     lcd.drawNumber(i, 240, 145);\n    lcd.setTextDatum( textdatum_t::top_right       );     lcd.drawNumber(i,  80, 195);\n    lcd.setTextDatum( textdatum_t::top_center      );     lcd.drawNumber(i, 160, 195);\n    lcd.setTextDatum( textdatum_t::top_left        );     lcd.drawNumber(i, 240, 195);"
        },
        {
          "name": "loop",
          "body": "// ※ 名前が\"Free\"で始まるフォントは 9pt 12pt 18pt 24ptの４種類があります。\n  drawNumberTest( &fonts::Font0                   );\n  drawNumberTest( &fonts::Font2                   );\n  drawNumberTest( &fonts::Font4                   );\n  drawNumberTest( &fonts::Font6                   );\n  drawNumberTest( &fonts::Font7                   );\n  drawNumberTest( &fonts::Font8                   );\n  drawNumberTest( &fonts::TomThumb                );\n  drawNumberTest( &fonts::FreeMono9pt7b           );\n  drawNumberTest( &fonts::FreeMonoBold9pt7b       );\n  drawNumberTest( &fonts::FreeMonoOblique9pt7b    );\n  drawNumberTest( &fonts::FreeMonoBoldOblique9pt7b);\n  drawNumberTest( &fonts::FreeSans9pt7b           );\n  drawNumberTest( &fonts::FreeSansBold9pt7b       );\n  drawNumberTest( &fonts::FreeSansOblique9pt7b    );\n  drawNumberTest( &fonts::FreeSansBoldOblique9pt7b);\n  drawNumberTest( &fonts::FreeSerif9pt7b          );\n  drawNumberTest( &fonts::FreeSerifBold9pt7b      );\n  drawNumberTest( &fonts::FreeSerifItalic9pt7b    );\n  drawNumberTest( &fonts::FreeSerifBoldItalic9pt7b);\n  drawNumberTest( &fonts::Orbitron_Light_24       );\n  drawNumberTest( &fonts::Roboto_Thin_24          );\n  drawNumberTest( &fonts::Satisfy_24              );\n  drawNumberTest( &fonts::Yellowtail_32           );"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_19V);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"4-20mA Input Channel \");\n    switch (inputChannels[inputChannelIndex]) {\n        case INPUT_420mA_CH01: Serial.print(\"01\"); break;\n        case INPUT_420mA_CH02: Serial.print(\"02\"); break;\n        case INPUT_420mA_CH03: Serial.print(\"03\"); break;\n        case INPUT_420mA_CH04: Serial.print(\"04\"); break;\n        default: break;"
        }
      ]
    },
    {
      "name": "R",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "lcd.init();\n  lcd.startWrite();"
        },
        {
          "name": "loop",
          "body": "/*\n  画像データを描画する関数は幾つか種類があります。\n\n方法１．事前に描画範囲を設定しておき、次にデータの長さを指定して描画する方法\n方法２．描画する座標と幅・高さを指定してデータを描画する方法\n\n\n\n方法１．事前に描画範囲を設定しておき、次にデータの長さを指定して描画する方法\n\nこの方法では、setWindow/setAddrWindow関数で描画範囲を設定したあと、\nwritePixels/pushPixels関数で画像データの長さを指定して描画します。\n\n  setWindow( x0, y0, x1, y1 );   // 描画範囲の指定。左上座標と右下座標を指定します。\n  setAddrWindow( x, y, w, h );   // 描画範囲の指定。左上座標と幅と高さを指定します。\n\nsetWindow は画面外の座標を指定した場合の動作は保証されません。\nsetAddrWindow は描画範囲外が指定された場合は範囲内に調整されます。\n ※ ただし自動調整された結果、実際に設定される幅や高さが指定した値より小さくなる可能性があるので注意が必要です。\n\n  writePixels   ( *data, len, swap );  // 画像を描画する。(事前にstartWrite、事後にendWriteが必要）\n  pushPixels    ( *data, len, swap );  // 画像を描画する。(startWrite・endWriteは不要）\n\n ※ writePixelsはAdafruitGFX由来の関数で、pushPixelsはTFT_eSPI由来の関数です。\n    描画内容は同等ですが、startWrite/endWriteが自動で行われるか否かが違います。\n\n第１引数：画像データのポインタ（データ型に応じて色の形式を判断して変換が行われます。）\n第２引数：画像データのピクセル数（バイト数でない点に注意。）\n第３引数：バイト順変換フラグ（省略時は事前にsetSwapBytes関数で設定した値が使用されます。）\n\n第１引数のdataの型に基づいて色の形式変換が行われます。\n  uint8_t*  の場合、 8bitカラー RGB332として扱います。\n  uint16_t* の場合、16bitカラー RGB565として扱います。\n  void*     の場合、24bitカラー RGB888として扱います。\n ※ （３バイトのプリミティブ型が無いため、void*型を24bitカラー扱いとしています）\n\n ※ LCDに描画する際に、LCDの色数モードに応じて色形式の変換が自動的に行われます。\n*/\n  lcd.clear(TFT_DARKGREY);\n  lcd.setColorDepth(16);  // LCDを16bitカラーモードに設定する。\n  lcd.setSwapBytes(true); // バイト順変換を有効にする。\n  int len = image_width * image_height;\n\n  // 画像の幅と高さをsetAddrWindowで事前に設定し、writePixelsで描画します。\n  lcd.setAddrWindow(0, 0, image_width, image_height);         // 描画範囲を設定。\n  lcd.writePixels((uint16_t*)rgb565, len); // RGB565の16bit画像データを描画。\n\n  // データとバイト順変換の指定が一致していない場合、色化けします。\n  lcd.setAddrWindow(0, 40, image_width, image_height);\n  // 第3引数でfalseを指定することでバイト順変換の有無を指定できます。\n  lcd.writePixels((uint16_t*)rgb565, len, false); // RGB565の画像をバイト順変換無しで描画すると色が化ける。\n\n  // 描画範囲が画面外にはみ出すなどして画像の幅や高さと合わなくなった場合、描画結果が崩れます。\n  lcd.setAddrWindow(-1, 80, image_width, image_height); // X座標が-1（画面外）のため、正しく設定できない。\n  lcd.writePixels((uint16_t*)rgb565, len); // 描画先の幅と画像の幅が不一致のため描画内容が崩れる。\n\n  // データと型が一致していない場合も、描画結果が崩れます。\n  lcd.setAddrWindow(0, 120, image_width, image_height);\n  // RGB565のデータをわざとuint8_tにキャストし、RGB332の8bitカラーとして扱わせる。\n  lcd.writePixels((uint8_t*)rgb565, len);  // 画像の形式と型が一致していないため描画が乱れる。\n\n  // データと型が一致していれば、描画先の色数に合わせて適切な形式変換が行われます。\n  lcd.setAddrWindow(0, 160, image_width, image_height);\n  lcd.writePixels((uint8_t*)rgb332, len);  // RGB332のデータでも16bitカラーのLCDに正しく描画できる。\n\n\n// ※ LCDへの画像データの送信は、メモリの若いアドレスにあるデータから順に1Byte単位で送信されます。\n//    このため、例えばRGB565の16bit型のデータを素直にuint16_tの配列で用意すると、送信の都合としてはバイト順が入れ替わった状態になります。\n//    この場合は事前にsetSwapBytes(true)を使用したり、第３引数にtrueを指定する事で、バイト順の変換が行われて正常に描画できます。\n//    なお用意する画像データを予め上位下位バイトを入れ替えた状態で作成すれば、この変換は不要になり速度面で有利になります。\n\n  lcd.setAddrWindow(40,  0, image_width, image_height);\n  lcd.writePixels((uint16_t*)swap565, len, false); // 予め上位下位が入れ替わった16bitデータの場合はバイト順変換を無効にする。\n\n  lcd.setAddrWindow(40, 40, image_width, image_height);\n  lcd.writePixels((uint16_t*)swap565, len, true);  // 逆に、予め上位下位が入れ替わったデータにバイト順変換を行うと色が化ける。\n\n  lcd.setAddrWindow(40, 80, image_width, image_height);\n  lcd.writePixels((void*)rgb888, len, true);  // 24bitのデータも同様に、RGB888の青が下位側にあるデータはバイト順変換が必要。\n\n  lcd.setAddrWindow(40, 120, image_width, image_height);\n  lcd.writePixels((void*)bgr888, len, false);  // 同様に、BGR888の赤が下位側にあるデータはバイト順変換は不要。\n\n  lcd.setAddrWindow(40, 160, image_width, image_height);\n  lcd.writePixels((void*)bgr888, len, true);  // 設定を誤ると、色が化ける。（赤と青が入れ替わる）\n\n  lcd.display();\n  delay(4000);\n  lcd.clear(TFT_DARKGREY);\n\n/*\n方法２．描画する座標と幅・高さを指定してデータを描画する方法\n\nこの方法では、pushImage関数を用いて描画範囲と描画データを指定して描画します。\n\n  pushImage( x, y, w, h, *data);                  // 指定された座標に画像を描画する。\n\n方法１と違い、画面外にはみ出す座標を指定しても描画が乱れることはありません。（はみ出した部分は描画されません。）\n方法１と違い、バイト順の変換を指定する引数が無いため、事前にsetSwapBytesによる設定が必要です。\nなお方法１と同様に、dataの型に応じて色変換が行われます。\n*/\n\n  lcd.setSwapBytes(true); // バイト順変換を有効にする。\n\n  // 描画先の座標と画像の幅・高さを指定して画像データを描画します。\n  lcd.pushImage(   0, 0, image_width, image_height, (uint16_t*)rgb565); // RGB565の16bit画像データを描画。\n\n  // データとバイト順変換の指定が一致していない場合、色化けします。\n  lcd.pushImage(   0, 40, image_width, image_height, (uint16_t*)swap565); // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n\n  // 描画範囲が画面外にはみ出すなどした場合でも、描画結果が崩れることはありません。\n  lcd.pushImage(-1, 80, image_width, image_height, (uint16_t*)rgb565); // X座標-1（画面外）を指定しても描画は乱れない。\n\n  // データと型が一致していない場合は、描画結果が崩れます。\n  lcd.pushImage(0, 120, image_width, image_height, (uint8_t*)rgb565); // RGB565のデータをuint8_tにキャストし、RGB332として扱わせると描画が乱れる。\n\n  // データと型が一致していれば、適切に形式変換が行われます。\n  lcd.pushImage(0, 160, image_width, image_height, (uint8_t*)rgb332); // RGB332のデータでも正しく描画できる。\n\n\n  lcd.setSwapBytes(false);   // バイト順の変換を無効にする。\n  lcd.pushImage( 40,   0, image_width, image_height, (uint8_t* )rgb332);  // good. RGB332のデータはバイト順変換の影響を受けない。\n  lcd.pushImage( 40,  40, image_width, image_height, (uint16_t*)rgb565);  // NG. RGB565のデータはバイト順変換が必要。\n  lcd.pushImage( 40,  80, image_width, image_height, (void*    )rgb888);  // NG. RGB888のデータはバイト順変換が必要。\n  lcd.pushImage( 40, 120, image_width, image_height, (uint16_t*)swap565); // good. バイト順変換済みRGB565のデータは色化けしない。\n  lcd.pushImage( 40, 160, image_width, image_height, (void*    )bgr888);  // good. バイト順変換済みRGB888のデータは色化けしない。\n\n  lcd.setSwapBytes(true);   // バイト順の変換を有効にする。\n  lcd.pushImage( 80,   0, image_width, image_height, (uint8_t* )rgb332);  // good. RGB332のデータはバイト順変換の影響を受けない。\n  lcd.pushImage( 80,  40, image_width, image_height, (uint16_t*)rgb565);  // good. バイト順変換が有効ならRGB565のデータは色化けしない。\n  lcd.pushImage( 80,  80, image_width, image_height, (void*    )rgb888);  // good. バイト順変換が有効ならRGB888のデータは色化けしない。\n  lcd.pushImage( 80, 120, image_width, image_height, (uint16_t*)swap565); // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n  lcd.pushImage( 80, 160, image_width, image_height, (void*    )bgr888);  // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n\n// データの型として、lgfx::名前空間に定義されている型を利用する事もできます。\n// これらの型にキャストする場合はsetSwapBytesの設定は無視されます。\n  lcd.pushImage(120,   0, image_width, image_height, (lgfx:: rgb332_t*) rgb332); // good  8bitデータ\n  lcd.pushImage(120,  40, image_width, image_height, (lgfx:: rgb565_t*) rgb565); // good 16bitデータ\n  lcd.pushImage(120,  80, image_width, image_height, (lgfx:: rgb888_t*) rgb888); // good 24bitデータ\n  lcd.pushImage(120, 120, image_width, image_height, (lgfx::swap565_t*)swap565); // good バイト順変換済み16bitデータ\n  lcd.pushImage(120, 160, image_width, image_height, (lgfx:: bgr888_t*) bgr888); // good バイト順変換済み24bitデータ\n\n// 第６引数で透過色を指定できます。透過指定された色のある部分は描画されません。\n  lcd.pushImage(160,   0, image_width, image_height, (lgfx:: rgb332_t*) rgb332, 0);                   // 黒を透過指定\n  lcd.pushImage(160,  40, image_width, image_height, (lgfx:: rgb565_t*) rgb565, (uint8_t)0xE0);       // 赤を透過指定\n  lcd.pushImage(160,  80, image_width, image_height, (lgfx:: rgb888_t*) rgb888, (uint16_t)0x07E0);    // 緑を透過指定\n  lcd.pushImage(160, 120, image_width, image_height, (lgfx::swap565_t*)swap565, (uint32_t)0x0000FFU); // 青を透過指定\n  lcd.pushImage(160, 160, image_width, image_height, (lgfx:: bgr888_t*) bgr888, TFT_WHITE);           // 白を透過指定\n\n  lcd.display();\n  delay(4000);\n  lcd.clear(TFT_DARKGREY);\n\n// pushImageRotateZoom関数を使うと、画像を回転拡大縮小させて描画できます。\n  for (int angle = 0; angle <= 360; ++angle) {\n    lcd.pushImageRotateZoom\n      ( lcd.width()  >> 2  // 描画先の中心座標X\n      , lcd.height() >> 1  // 描画先の中心座標Y\n      , image_width  >> 1  // 画像の中心座標X\n      , image_height >> 1  // 画像の中心座標Y\n      , angle              // 回転角度\n      , 3.0                // X方向の描画倍率 (マイナス指定で反転可能)\n      , 3.0                // Y方向の描画倍率 (マイナス指定で反転可能)\n      , image_width        // 画像データの幅\n      , image_height       // 画像データの高さ\n      , rgb332             // 画像データのポインタ\n      );\n\n// pushImageRotateZoomWithAA関数を使うと、アンチエイリアスが有効になります。\n    lcd.pushImageRotateZoomWithAA\n      ( lcd.width()*3>> 2\n      , lcd.height() >> 1\n      , image_width  >> 1\n      , image_height >> 1\n      , angle\n      , 3.0\n      , 3.0\n      , image_width\n      , image_height\n      , rgb332\n      );\n\n    if ((angle % 36) == 0) { lcd.display();"
        }
      ]
    },
    {
      "name": "EXPANDER_ID",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n//\twhile (!Serial);\t\t// For Leonardo only. No effect on other Arduino.\n\n\tAccessories::begin();\n\n\t// Ports setups\n\n\texpander.begin(EXPANDER_ID, 1, 2, 3, 4);\n\n\tPortLight0.begin(EXPANDER_PIN(EXPANDER_ID, 0), DIGITAL);\n\tPortLight1.begin(EXPANDER_PIN(EXPANDER_ID, 4), DIGITAL);\n\tPortLight2.begin(EXPANDER_PIN(EXPANDER_ID, 7), DIGITAL);\n\t\n\t// Accessories setups\n\n    // Declare accessories.\n\tlight0.begin(&PortLight0, 1, 1000);\n\tlight1.begin(&PortLight1, 2, 550);\n\tlight2.begin(&PortLight2, 3, 1500);\n\t\n\t// Declare light fading/dimming.\n\t//light0.SetFading(20, 10);\n\t//light1.SetFading(20, 10);\n\t//light2.SetFading(20, 10);\n\n\tlight0.Blink();\n\tlight1.Blink();\n\tlight2.Blink();"
        },
        {
          "name": "loop",
          "body": "Accessories::loop();"
        }
      ]
    },
    {
      "name": "FAULT_ADDRESS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  A4963.begin();\n  \n  A4963.setPWM(pwm_value);"
        },
        {
          "name": "ping",
          "body": "Serial.write(\"A4963\");"
        },
        {
          "name": "write",
          "body": "uint8_t data[3];\n  Serial.readBytes(data, 3);\n  \n  uint16_t address=data[0];\n  uint16_t value=(uint16_t(data[1]) | uint16_t(data[2])<<8);\n  uint16_t result=0;\n\n  if(address<8)\n  {\n    result=A4963.write(address<<13, value);"
        },
        {
          "name": "read",
          "body": "uint8_t data[1];\n  Serial.readBytes(data, 1);\n  \n  uint16_t address=data[0];\n  uint16_t result=0;\n\n  if(address<8)\n  {\n    result=A4963.read(address<<13);"
        },
        {
          "name": "loop",
          "body": "uint8_t command=Serial.read();\n  switch(command)\n  {\n    case 'p':\n      ping();\n      break;\n    case 'w':\n      write();\n      break;\n    case 'r':\n      read();\n      break;\n    default:;"
        }
      ]
    },
    {
      "name": "LED_PIN",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "A4990MotorShield.h"
      ],
      "functions": [
        {
          "name": "stopIfFault",
          "body": "if (motors.getFault())\n  {\n    motors.setSpeeds(0,0);\n    Serial.println(\"Fault\");\n    while(1);"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_PIN, OUTPUT);\n  Serial.begin(115200);\n  Serial.println(\"Pololu A4990 Dual Motor Driver Shield for Arduino\");\n  \n  // uncomment one or both of the following lines if your motors' directions need to be flipped\n  //motors.flipM1(true);\n  //motors.flipM2(true);"
        },
        {
          "name": "loop",
          "body": "// run M1 motor with positive speed\n\n  digitalWrite(LED_PIN, HIGH);\n  \n  for (int speed = 0; speed <= 400; speed++)\n  {\n    motors.setM1Speed(speed);\n    stopIfFault();\n    delay(2);"
        }
      ]
    },
    {
      "name": "RCVSIZE",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "stdio.h",
        "adk.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "cpu_irq_enable();\n  printf(\"\\r\\nADK demo start\\r\\n\");\n  delay(200);"
        },
        {
          "name": "loop",
          "body": "uint8_t buf[RCVSIZE];\n  uint32_t nbread = 0;\n  char helloworld[] = \"Hello World!\\r\\n\";\n\n  Usb.Task();\n\n  if (adk.isReady()) {\n    /* Write hello string to ADK */\n    adk.write(strlen(helloworld), (uint8_t *)helloworld);\n\n    delay(1000);\n\n    /* Read data from ADK and print to UART */\n    adk.read(&nbread, RCVSIZE, buf);\n    if (nbread > 0) {\n      printf(\"RCV: \");\n      for (uint32_t i = 0; i < nbread; ++i) {\n        printf(\"%c\", (char)buf[i]);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoBearSSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"Key: \");\n  printHex(key, 16);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(enc_iv, 16);\n  Serial.println(\" \");\n  Serial.print(\"AES128 Encryption of '\");\n  printHex(input, 16);\n  Serial.print(\"' is 0x\");\n  AES128.runEnc(key, 16, input, 16, enc_iv);   // expect 0x65D0F7758B094114AFA6D33A5EA0716A\n  printHex(input, 16);\n  Serial.println(\" \");\n  Serial.println(\" \");\n  Serial.print(\"Key: \");\n  printHex(key, 16);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(dec_iv, 16);\n  Serial.println(\" \");\n  Serial.print(\"AES128 Decryption of '\");\n  printHex(input, 16);\n  Serial.print(\"' is 0x\");\n  AES128.runDec(key, 16, input, 16, dec_iv);\n  printHex(input, 16);\n  Serial.println(\" \");\n  while (1);"
        },
        {
          "name": "printHex",
          "body": "for (byte i = 0; i < size; i = i + 1) {\n    if (text[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AccelStepper.h",
        "AFMotor.h"
      ],
      "functions": [
        {
          "name": "forwardstep",
          "body": "motor1.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep",
          "body": "motor1.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n   Serial.println(\"Stepper test!\");\n  \n   stepper.setSpeed(50);"
        },
        {
          "name": "loop",
          "body": "stepper.runSpeed();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "AccelStepper.h",
        "AFMotor.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "body": "motor1.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "body": "motor1.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "forwardstep2",
          "body": "motor2.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep2",
          "body": "motor2.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "body": "stepper1.setMaxSpeed(200.0);\n    stepper1.setAcceleration(100.0);\n    stepper1.moveTo(24);\n    \n    stepper2.setMaxSpeed(300.0);\n    stepper2.setAcceleration(100.0);\n    stepper2.moveTo(1000000);"
        },
        {
          "name": "loop",
          "body": "// Change direction at the limits\n    if (stepper1.distanceToGo() == 0)\n\tstepper1.moveTo(-stepper1.currentPosition());\n    stepper1.run();\n    stepper2.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  int16_t state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[APRS] Sending position ... \"));\n  \n  // send a location without message or timestamp\n  char destination[] = \"N0CALL\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  int state = aprs.sendPosition(destination, 0, latitude, longitude);\n  delay(500);\n  \n  // send a location with message and without timestamp\n  char message[] = \"I'm here!\";\n  state |= aprs.sendPosition(destination, 0, latitude, longitude, message);\n  delay(500);\n  \n  // send a location with message and timestamp\n  char timestamp[] = \"093045z\";\n  state |= aprs.sendPosition(destination, 0, latitude, longitude, message, timestamp);\n  delay(500);\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[AFSK] Executing Order 66 ... \"));\n\n  // calculate whole note duration\n  int wholenote = (60000 * 4) / 120;\n\n  // iterate over the melody\n  for(unsigned int note = 0; note < sizeof(melody) / sizeof(melody[0]); note += 2) {\n    // calculate the duration of each note\n    int noteDuration = 0;\n    int divider = melody[note + 1];\n    if(divider > 0) {\n      // regular note, just proceed\n      noteDuration = wholenote / divider;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// AFSKClient can be used to transmit tones,\n  // same as Arduino tone() function\n  \n  // 400 Hz tone\n  Serial.print(F(\"[AFSK] 400 Hz tone ... \"));\n  audio.tone(400);\n  delay(1000);\n\n  // silence\n  Serial.println(F(\"done!\"));\n  audio.noTone();\n  delay(1000);\n\n  // AFSKClient can also be used to transmit HAM-friendly\n  // RTTY, Morse code, Hellschreiber, SSTV and AX.25.\n  // Details on how to use AFSK are in the example\n  // folders for each of the above modes."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// AFSKClient can be used to transmit tones,\n  // same as Arduino tone() function\n\n  // 400 Hz tone\n  Serial.print(F(\"[AFSK] 400 Hz tone ... \"));\n  audio.tone(400);\n  delay(1000);\n\n  // silence\n  Serial.println(F(\"done!\"));\n  audio.noTone();\n  delay(1000);\n\n  // AFSKClient can also be used to transmit HAM-friendly\n  // RTTY, Morse code, Hellschreiber, SSTV and AX.25.\n  // Details on how to use AFSK are in the example\n  // folders for each of the above modes.\n\n  // CAUTION: Unlike standard AFSK, the result when using OOK\n  // must be demodulated as AM!"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(13, OUTPUT); // Set Digital Pin 13 as an Output"
        },
        {
          "name": "loop",
          "body": "digitalWrite(13, HIGH); // Turn the LED ON\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)\n\tdigitalWrite(13, LOW); // Turn the LED OFF\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(12, INPUT_PULLUP); // Set Digital Pin 12 as an Input with a Pullup to 5V\n\tpinMode(13, OUTPUT); // Set Digital Pin 13 as an Output"
        },
        {
          "name": "loop",
          "body": "// See if button is being pushed\n\t// BUtton UN-Pushed returns high (pull-up)\n\t// Button PUSHED returns LOW (switch connects D12 to Ground)\n\t// Notice the double == in the line below\n\t// - a single = sets the two sides equal (not what we want)\n\t// - a double == Compares the two sides\n\tif (digitalRead(12) == LOW)\n\t{\n\t\t// Button is pressed, wait until it's released\n\t\twhile (digitalRead(12) == LOW)\n\t\t\t; // Do nothing while we wait\n\t\tblink = !blink; // Reverse the value of blink (if it was true, make it false, and vice-versa)\n\t\tledState = LOW;\n\t\tdigitalWrite(13, ledState);\n\t\tdelay(200); // Delay for 200ms to ignore any \"bounce\" in the switch"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(buzzer_pin, OUTPUT); // Configure the buzzer pin as an output pin"
        },
        {
          "name": "loop",
          "body": "// Play low to high frequencies\n\tfor(i = 25; i < 120; i++)\n\t{\n\t\ttone(buzzer_pin, 20 * i, 200); // Create a tone/note from 500 to 2400 Hz\n\t\tdelay(20);"
        }
      ]
    },
    {
      "name": "USE_ALB_DS1302",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Start Serial port so we can see the results\n\n\tSerial.println(\"DS1302RTC Read Test\");\n\tSerial.println(\"-------------------\");\n\n\tSerial.println(\"RTC module activated\");\n\tSerial.println();\n\tdelay(500);\n\n\tif (RTC.haltRTC())\n\t{\n\t\tSerial.println(\"The DS1302 is stopped.  Set the time as shown\");\n\t\tSerial.println(\"below to initialize the clock and begin running.\");\n\t\tSerial.println();"
        },
        {
          "name": "loop",
          "body": "tmElements_t tm;\n\ttime_t t;\n\n\t//check for input to set the RTC, minimum length is 12, i.e. yy,m,d,h,m,s\n\tif (Serial.available() >= 12)\n\t{\n\t\t//note that the tmElements_t Year member is an offset from 1970,\n\t\t//but the RTC wants the last two digits of the calendar year.\n\t\t//use the convenience macros from Time.h to do the conversions.\n\t\tint y = Serial.parseInt();\n\t\tif (y >= 100 && y < 1000)\n\t\t\tSerial.println(\"Error: Year must be two digits or four digits!\");\n\t\telse\n\t\t{\n\t\t\tif (y >= 1000)\n\t\t\t\ttm.Year = CalendarYrToTm(y);\n\t\t\telse    //(y < 100)\n\t\t\t\ttm.Year = y2kYearToTm(y);\n\t\t\ttm.Month = Serial.parseInt();\n\t\t\ttm.Day = Serial.parseInt();\n\t\t\ttm.Hour = Serial.parseInt();\n\t\t\ttm.Minute = Serial.parseInt();\n\t\t\ttm.Second = Serial.parseInt();\n\t\t\tt = makeTime(tm);\n\t\t\t//use the time_t value to ensure correct weekday is set\n\t\t\tif(RTC.set(t) == 0)   // Success\n\t\t\t{\n\t\t\t\tsetTime(t);\n\t\t\t\tSerial.println(\"RTC set.\");"
        },
        {
          "name": "print2digits",
          "body": "if (number >= 0 && number < 10)\n\t\tSerial.write('0');\n\tSerial.print(number);"
        }
      ]
    },
    {
      "name": "USE_ALB_I2C_Scan",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial port at 9600 baud for debugging\n\tSerial.begin(9600);\n\n\ti2c_scan.scan();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Vx",
      "keywords": [
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(Vx, INPUT); // Configure Vx (A0) as an Input\n\tpinMode(Vy, INPUT); // Configure Vy (A1) as an Input\n\tpinMode(Button, INPUT_PULLUP); // Configure Button (A2) as an Input, internally \"pulled-up\" to 5V\n\t                               // Note, we're configuring an Analog input as digital input\n\t                               // which is perfectly fine.  I did this to make the wiring easier\n\t                               // and keep all of the wires on the same side of the board\n\n\tSerial.begin(9600); // Initialize Serial Port at 9600 baud to display the results"
        },
        {
          "name": "loop",
          "body": "int x, y, btn;\n\t\n\tx = analogRead(Vx);\t// Read the analog value of Vx (Analog Values are from 0-1023 which equate to 0V to 5V)\n\ty = analogRead(Vy); // Read the analog value of Vy\n\tbtn = digitalRead(Button); // Read the button.  When the button is open (unpushed),\n\t                           // the input will read High (+5V)\n\t                           // When the button is closed (pressed), the input pin\n\t                           // is connected to ground and will read Low (0V)\n\t\n\tSerial.print(x);\t// Print the X value to the serial port\n\tSerial.print(\"\\t\"); // Print a Tab character \n\tSerial.print(y); \t// Print the Y value\n\tSerial.print(\"\\t\"); // Print a Tab\n\tSerial.println(btn); // Print the value of the Btn (0=Pushed, 1 = Not Pushed)\n\t\n\tdelay(250); // Delay 250ms so the results don't print too quickly"
        }
      ]
    },
    {
      "name": "USE_ALB_LCD_I2C",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "lcd.init(); // Initialize the LCD\n\tlcd.clear(); // Clear the LCD (set cursor to 0, 0)\n\tlcd.backlight(); // Turn on the LCD backlight\n\tlcd.print(\"Arduino Learning\"); // Print \"Arduino Learning\" on the first line\n\tlcd.setCursor(5, 1); // Move the cursor to (x, y)  (y=1 is 2nd line)\n\tlcd.print(\"Board!\"); // Print \"Board!\" in the middle of the 2nd line"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USE_ALB_LCD_I2C",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "lcd.init(); // Initialize the LCD\n\tlcd.clear(); // Clear the LCD (set cursor to 0, 0)\n\tlcd.backlight(); // Turn on the LCD backlight\n\tlcd.print(\"Arduino Learning\"); // Print \"Arduino Learning\" on the first line\n\tlcd.setCursor(5, 1); // Move the cursor to (x, y)  (y=1 is 2nd line)\n\tlcd.print(\"Board!\"); // Print \"Board!\" in the middle of the 2nd line\n\t\n\tdelay(3000); // Wait 3 seconds\n\tlcd.clear(); // Clear Display"
        },
        {
          "name": "loop",
          "body": "lcd.setCursor(0, 0);\n\tlcd.print(\"counter = \"); // Display \"counter =\"\n\tlcd.print(counter);\n\t\n\tcounter++;  // Increment the counter value\n\tif (counter > 9999) {\n\t\tcounter = 0; // Reset counter to 0 after it reaches 9999\n\t\tlcd.clear();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(10, OUTPUT); // Set Digital Pin 10 as an Output"
        },
        {
          "name": "loop",
          "body": "digitalWrite(10, HIGH); // Turn the LED ON\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)\n\tdigitalWrite(10, LOW); // Turn the LED OFF\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)"
        }
      ]
    },
    {
      "name": "USE_ALB_MPU6050",
      "keywords": [
        "Serial",
        "Wire",
        "attachInterrupt",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "dmpDataReady",
          "body": "mpuInterrupt = true;"
        },
        {
          "name": "setup",
          "body": "// join I2C bus (I2Cdev library doesn't do this automatically)\n\tWire.begin();\n\tTWBR = 24; // 400kHz I2C clock (200kHz if CPU is 8MHz)\n\n\t// initialize serial communication\n\t// (115200 chosen because it is required for Teapot Demo output, but it's\n\t// really up to you depending on your project)\n\tSerial.begin(115200);\n\n\t// initialize device\n\tSerial.println(F(\"Initializing I2C devices...\"));\n\tmpu.initialize();\n\n\t// verify connection\n\tSerial.println(F(\"Testing device connections...\"));\n\tSerial.println(mpu.testConnection() ? F(\"MPU6050 connection successful\") : F(\"MPU6050 connection failed\"));\n\n\t// wait for ready\n\tSerial.println(F(\"\\nSend any character to begin DMP programming and demo: \"));\n\twhile (Serial.available() && Serial.read()); // empty buffer\n\twhile (!Serial.available());                 // wait for data\n\twhile (Serial.available() && Serial.read()); // empty buffer again\n\n\t// load and configure the DMP\n\tSerial.println(F(\"Initializing DMP...\"));\n\tdevStatus = mpu.dmpInitialize();\n\n\t// supply your own gyro offsets here, use the output of ALB_MPU650_Calibrate\n\t// since each gyro is a little different from the factory\n\tmpu.setXAccelOffset(-3058);\n\tmpu.setYAccelOffset(2105);\n\tmpu.setZAccelOffset(1313);\n\tmpu.setXGyroOffset(8);\n\tmpu.setYGyroOffset(-11);\n\tmpu.setZGyroOffset(11);\n\n\t// make sure it worked (returns 0 if so)\n\tif (devStatus == 0)\n\t{\n\t\t// turn on the DMP, now that it's ready\n\t\tSerial.println(F(\"Enabling DMP...\"));\n\t\tmpu.setDMPEnabled(true);\n\n\t\t// enable Arduino interrupt detection\n\t\tSerial.println(F(\"Enabling interrupt detection (Arduino external interrupt 0)...\"));\n\t\tattachInterrupt(0, dmpDataReady, RISING);\n\t\tmpuIntStatus = mpu.getIntStatus();\n\n\t\t// set our DMP Ready flag so the main loop() function knows it's okay to use it\n\t\tSerial.println(F(\"DMP ready! Waiting for first interrupt...\"));\n\t\tdmpReady = true;\n\n\t\t// get expected DMP packet size for later comparison\n\t\tpacketSize = mpu.dmpGetFIFOPacketSize();"
        },
        {
          "name": "loop",
          "body": "// if programming failed, don't try to do anything\n\tif (!dmpReady) return;\n\n\t// wait for MPU interrupt or extra packet(s) available\n\twhile (!mpuInterrupt && fifoCount < packetSize)\n\t{\n\t\t// other program behavior stuff here\n\t\t// .\n\t\t// .\n\t\t// .\n\t\t// if you are really paranoid you can frequently test in between other\n\t\t// stuff to see if mpuInterrupt is true, and if so, \"break;\" from the\n\t\t// while() loop to immediately process the MPU data\n\t\t// .\n\t\t// .\n\t\t// ."
        }
      ]
    },
    {
      "name": "USE_ALB_MPU6050",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// join I2C bus (I2Cdev library doesn't do this automatically)\n\tWire.begin();\n\t// COMMENT NEXT LINE IF YOU ARE USING ARDUINO DUE\n\tTWBR = 24; // 400kHz I2C clock (200kHz if CPU is 8MHz). Leonardo measured 250kHz.\n\n\t// initialize serial communication\n\tSerial.begin(115200);\n\n\t// initialize device\n\tmpu.initialize();\n\n\t// wait for ready\n\twhile (Serial.available() && Serial.read()); // empty buffer\n\twhile (!Serial.available())\n\t{\n\t\tSerial.println(F(\"Send any character to start sketch.\\n\"));\n\t\tdelay(1500);"
        },
        {
          "name": "loop",
          "body": "if (state == 0)\n\t{\n\t\tSerial.println(\"\\nReading sensors for first time...\");\n\t\tmeansensors();\n\t\tstate++;\n\t\tdelay(1000);"
        },
        {
          "name": "meansensors",
          "body": "long i = 0, buff_ax = 0, buff_ay = 0, buff_az = 0, buff_gx = 0, buff_gy = 0, buff_gz = 0;\n\n\twhile (i < (buffersize + 101))\n\t{\n\t\t// read raw accel/gyro measurements from device\n\t\tmpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n\n\t\tif (i > 100 && i <= (buffersize + 100)) //First 100 measures are discarded\n\t\t{\n\t\t\tbuff_ax = buff_ax + ax;\n\t\t\tbuff_ay = buff_ay + ay;\n\t\t\tbuff_az = buff_az + az;\n\t\t\tbuff_gx = buff_gx + gx;\n\t\t\tbuff_gy = buff_gy + gy;\n\t\t\tbuff_gz = buff_gz + gz;"
        },
        {
          "name": "calibration",
          "body": "ax_offset = -mean_ax / 8;\n\tay_offset = -mean_ay / 8;\n\taz_offset = (16384 - mean_az) / 8;\n\n\tgx_offset = -mean_gx / 4;\n\tgy_offset = -mean_gy / 4;\n\tgz_offset = -mean_gz / 4;\n\n\twhile (1) \n\t{\n\t\tint ready = 0;\n\t\tmpu.setXAccelOffset(ax_offset);\n\t\tmpu.setYAccelOffset(ay_offset);\n\t\tmpu.setZAccelOffset(az_offset);\n\n\t\tmpu.setXGyroOffset(gx_offset);\n\t\tmpu.setYGyroOffset(gy_offset);\n\t\tmpu.setZGyroOffset(gz_offset);\n\n\t\tmeansensors();\n\n\t\t// Serial.println(\"...\");\n\t\t/*\n\t\tSerial.print(\"ax: \");\n\t\tSerial.print(mean_ax);\n\t\tSerial.print(\"\\tay: \");\n\t\tSerial.print(mean_ay);\n\t\tSerial.print(\"\\taz: \");\n\t\tSerial.print(mean_az);\n\t\tSerial.print(\"\\tgx: \");\n\t\tSerial.print(mean_gx);\n\t\tSerial.print(\"\\tgy: \");\n\t\tSerial.print(mean_gy);\n\t\tSerial.print(\"\\tgz: \");\n\t\tSerial.print(mean_gz);\n\t\t*/\n\n\t\tif (abs(mean_ax) <= acel_deadzone) ready++;\n\t\telse ax_offset = ax_offset - mean_ax / acel_deadzone;\n\n\t\tif (abs(mean_ay) <= acel_deadzone) ready++;\n\t\telse ay_offset = ay_offset - mean_ay / acel_deadzone;\n\n\t\tif (abs(16384 - mean_az) <= acel_deadzone) ready++;\n\t\telse az_offset = az_offset + (16384 - mean_az) / acel_deadzone;\n\n\t\tif (abs(mean_gx) <= giro_deadzone) ready++;\n\t\telse gx_offset = gx_offset - mean_gx / (giro_deadzone + 1);\n\n\t\tif (abs(mean_gy) <= giro_deadzone) ready++;\n\t\telse gy_offset = gy_offset - mean_gy / (giro_deadzone + 1);\n\n\t\tif (abs(mean_gz) <= giro_deadzone) ready++;\n\t\telse gz_offset = gz_offset - mean_gz / (giro_deadzone + 1);\n\n\t\tSerial.print(ready);\n\t\tSerial.println(\" of 6 offsets calculated.\");\n\n\t\tif (ready == 6) break;"
        }
      ]
    },
    {
      "name": "USE_ALB_RFID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\tSPI.begin();\n\trfid.init();"
        },
        {
          "name": "loop",
          "body": "if(rfid.isCard())\n\t{\n\t\tif(rfid.readCardSerial())\n\t\t{\n\t\t\tSerial.print(rfid.serNum[0], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[1], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[2], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[3], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[4], HEX);\n\t\t\tSerial.println(\"\");\n\t\t\tdelay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(2, OUTPUT); // Set Digital Pin 2 as an Output (Relay Control)\n\tpinMode(3, INPUT_PULLUP); // Set Digital Pin 3 as an Input (From the Button)\n\tpinMode(13, OUTPUT); // Set Digital Pin 13 as an Output (Nano LED)"
        },
        {
          "name": "loop",
          "body": "button = digitalRead(3); // Read from D3\n\t\n\t// Reverse the value of button (! = \"Not\", so !button = \"Not\" Button)\n\t// If Button is HIGH (or 1), !button will be LOW (or 0)\n\tbutton = !button;\n\tdigitalWrite(2, button); // Set the relay control to the button\n\tdigitalWrite(13, button); // Mirror the button and relay on the Nano LED\n\t\n\tdelay(250); // Delay for 250ms to reduce the bounce in the relay"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// Start serial communications at 9600 baud\n\tSerial.begin(9600);\n\n\t// Print \"Hello World!\" and move to the next line\n\tSerial.println(\"Hello World!\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Start serial communications at 9600 baud\n\tSerial.println(\"Hello World!\");"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"i = \"); // Print \"i = \" to the serial port\n\tSerial.println(i);    // Print the value of \"i\"\n\ti = i + 1;\t\t\t  // Add one to \"i\" (so it's higher for the next time)\n\tdelay(1000);\t\t  // delay 1 second"
        }
      ]
    },
    {
      "name": "USE_ALB_Servo",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "myservo.attach(2);  // attaches the servo on pin 2 to the servo object\n\tmyservo.write(90);  // Center Servo\n\tdelay(3000);        // Delay 3 seconds"
        },
        {
          "name": "loop",
          "body": "for(pos = 0; pos <= 180; pos++) // goes from 0 degrees to 180 degrees\n\t{\n\t\tmyservo.write(pos);         // tell servo to go to position in variable 'pos'\n\t\tdelay(10);                  // waits 10ms for the servo to reach the position"
        }
      ]
    },
    {
      "name": "USE_ALB_SevenSegment",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte numDigits = 4; // Only 1 digit for this demo\n  byte digitPins[] = { 2, 5, 6, 13"
        },
        {
          "name": "loop",
          "body": "static unsigned long timer = millis();\n  static int value = 0;\n  \n  if (millis() >= timer) {\n    value++;\n    timer += 100; \n    if (value == 10000) { // Reset to 0 after counting past 9999\n      value = 0;"
        }
      ]
    },
    {
      "name": "USE_ALB_SevenSegment",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte numDigits = 1; // Only 1 digit for this demo\n  byte digitPins[] = { 5"
        },
        {
          "name": "loop",
          "body": "static unsigned long timer = millis();\n  static int value = 0;\n  \n  if (millis() >= timer) {\n    value++;\n    timer += 500; \n    if (value == 10) { // Reset to 0 after counting past 9\n      value = 0;"
        }
      ]
    },
    {
      "name": "trigPin",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\tpinMode(trigPin, OUTPUT);\n\tpinMode(echoPin, INPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(trigPin, LOW);\n\tdelayMicroseconds(2);\n\tdigitalWrite(trigPin, HIGH);\n\tdelayMicroseconds(10);\n\tdigitalWrite(trigPin, LOW);\n\n\t// Call pulseIn function to wait for High pulse\n\t// result will be time in microseconds until pulse is detected\n\tduration = pulseIn(echoPin, HIGH);\n\n\tif (duration < 100000)\n\t{\n\t\tinches = microSecondsToInches(duration);\n\t\tcm = microSecondsToCentimeters(duration);\n\n\t\tSerial.print(\"Ping Time: \");\n\t\tSerial.print(duration);\n\t\tSerial.print(\"uS, \");\n\t\tSerial.print(cm);\n\t\tSerial.print(\"cm, \");\n\t\tSerial.print(inches);\n\t\tSerial.println(\"in\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);  \t\t// Configure on-board LED pin as an output\n\tdigitalWrite(led, lamp);\t// Set LED to On or Off to simulate Lamp\n\tpinMode(digitalPin, INPUT);\t// Configure D2 as an input from Sound Sensor module\n\n\tSerial.begin(9600);\t\t\t// Open Serial Port\n\tSerial.println(\"Sound Sensor Test\");\n\n\tdigitalVal = digitalRead(digitalPin); // Read current value from Sound Sensor\n\tSerial.println(digitalVal);\t// Print current value of sound sensor (0 or 1)\n\tprevVal = digitalVal;\t    // Keep track of prior value (so we know when it changes)"
        },
        {
          "name": "loop",
          "body": "digitalVal = digitalRead(digitalPin); // Read current value from Sound Sensor\n\tif (digitalVal != prevVal)\t// Detect change\n\t{\n\t\tSerial.println(digitalVal);  // Print new value\n\t\tlamp = !lamp;\t// If lamp was On, turn it Off and vice-versa\n\t\tdigitalWrite(led, lamp);\t// Set LED to On or Off to simulate Lamp\n\t\tdelay(500);\t// Delay 500ms to \"debounce\" input\n\t\tdigitalVal = digitalRead(digitalPin); // Read current value again\n\t\tSerial.println(digitalVal);\t// Print new value\n\t\tprevVal = digitalVal;\t// Keep track of prior value"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n\tdigitalWrite(led, lamp);\n\tpinMode(analogPin, INPUT);\n\n\tSerial.begin(115200);\n\tSerial.println(\"Sound Sensor Test\");\n\n\tanalogVal = analogRead(analogPin);\n\tSerial.println(analogVal);\n\tprevVal = analogVal;"
        },
        {
          "name": "loop",
          "body": "analogVal = analogRead(analogPin);\n\tif ((analogVal > analogTrigger) && (prevVal < analogTrigger))\n\t{\n\t\tSerial.println(analogVal);\n\t\tlamp = !lamp;\n\t\tdigitalWrite(led, lamp);\n\t\tdelay(500);\n\t\tanalogVal = analogRead(analogPin);\n\t\tSerial.println(analogVal);\n\t\tprevVal = analogVal;"
        }
      ]
    },
    {
      "name": "USE_ALB_Stepper",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  \n  stepper1.setMaxSpeed(1000.0);\n  stepper1.setAcceleration(300.0);\n  stepper1.setSpeed(1000);\n  stepper1.moveTo(5000);\n\n  Serial.println(\"Moving Stepper to Position 5000\");"
        },
        {
          "name": "loop",
          "body": "// Serial.println(stepper1.currentPosition());\n  \t\n  //Change direction when the stepper reaches the target position\n  if (stepper1.distanceToGo() == 0) {\n  \tSerial.print(\"Stepper Arrived at Destination. MoveTo(\");\n  \tSerial.print(-stepper1.currentPosition());\n  \tSerial.println(\")\");\n    stepper1.moveTo(-stepper1.currentPosition());"
        }
      ]
    },
    {
      "name": "USE_ALB_DHT11",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Start Serial port so we can see the results\n\t\n\tdht11.begin(); // Get the DHT11 class to start reading"
        },
        {
          "name": "loop",
          "body": "// Wait a few seconds between measurements.\n\tdelay(2000);\n\n\t// Reading temperature or humidity takes about 250 milliseconds\n\tfloat h = dht11.readHumidity();\n\t// Read temperature as Celsius (the default)\n\tfloat c = dht11.readTemperatureC();\n\t// Read temperature as Fahrenheit (isFahrenheit = true)\n\tfloat f = dht11.readTemperatureF();\n\n\t// Check if any reads failed and exit early (to try again).\n\tif (isnan(h) || isnan(c) || isnan(f))\n\t{\n\t\tSerial.println(\"Failed to read from DHT sensor!\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(tiltPin, INPUT_PULLUP); // Configure Tilt Pin as Input w/ Pullup\n\tpinMode(ledPin, OUTPUT);\t\t// Configure LED pin as Output\n\tdigitalWrite(ledPin, LOW);\t\t// Initially turn off LED"
        },
        {
          "name": "loop",
          "body": "tiltValue = digitalRead(tiltPin); // Read current value from digital input\n\t// When the sensor is still, the two pins are connected and \n\t// D2 is pulled LOW.  On motion, the switch opens and the digital input\n\t// will report a High value\n\tif (tiltValue == HIGH) {\n\t\tdigitalWrite(ledPin, HIGH);  // Turn on the LED\n\t\tdelay(1500);\t// Delay 1.5 Seconds so we can see that the LED turned on\n\t\tdigitalWrite(ledPin, LOW);   // Turn off the LED"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// Configure Touch Buttons as Inputs\n\tpinMode(2, INPUT);\n\tpinMode(3, INPUT);\n\tpinMode(4, INPUT);\n\tpinMode(5, INPUT);\n\t\n\tSerial.begin(9600); // Initialize serial communications"
        },
        {
          "name": "loop",
          "body": "// Read buttons (HIGH = button pushed, LOW = button not pushed)\n\tb1 = digitalRead(2);\n\tb2 = digitalRead(3);\n\tb3 = digitalRead(4);\n\tb4 = digitalRead(5);\n\t\n\t// Output values of all buttons to serial port\n\tSerial.print(b1);\n\tSerial.print(\" \");\n\tSerial.print(b2);\n\tSerial.print(\" \");\n\tSerial.print(b3);\n\tSerial.print(\" \");\n\tSerial.println(b4);\n\t\n\tdelay(500);"
        }
      ]
    },
    {
      "name": "C4",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// Configure Touch Buttons as Inputs\n\tpinMode(2, INPUT);\n\tpinMode(3, INPUT);\n\tpinMode(4, INPUT);\n\tpinMode(5, INPUT);\n\t\n\t// Configure Passive Buzzer pin as Outputs\n\tpinMode(12, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// Read buttons (HIGH = button pushed, LOW = button not pushed)\n\tb1 = digitalRead(2);\n\tb2 = digitalRead(3);\n\tb3 = digitalRead(4);\n\tb4 = digitalRead(5);\n\n\tif (b1)\n\t\ttone(12, C4);\n\telse if (b2)\n\t\ttone(12, E4);\n\telse if (b3)\n\t\ttone(12, G4);\n\telse if (b4)\n\t\ttone(12, C5);\n\telse\n\t\tnoTone(12);"
        }
      ]
    },
    {
      "name": "AM2315_DEBUG",
      "keywords": [
        "Wire",
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "static float temperature, humidity;\n\n  temperature = AM2315.readTemperature();\n  humidity    = AM2315.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V1, String(temperature, 1));\n    Blynk.virtualWrite(V2, String(humidity, 1));\n\n#if AM2315_DEBUG\n    Serial.println(\"Temp *C: \" + String(temperature));\n    Serial.println(\"Humid %: \" + String(humidity));\n#endif"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "AM2315_DEBUG",
      "keywords": [
        "Wire",
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(\"Failed to read data from AM2315\");\n#endif\n\n    return;"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(\"B\");"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP8266 using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(\"\\nStarting AM2315_ESP8266 using EEPROM\");\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "W5100_CS",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(F(\"Failed to read data from AM2315\"));\n#endif\n\n    return;"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart AM2315_W5100 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "AM2315_DEBUG",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(F(\"Failed to read data from AM2315\"));\n#endif\n\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart AM2315_W5500 using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart AM2315_W5500 on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif;\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  // NOTE: moved to ISM band on purpose\n  //       DO NOT transmit in APRS bands without ham radio license!\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[APRS] Sending Mic-E position ... \"));\n  int state = aprs.sendMicE(49.1945, 16.6000, 120, 10, RADIOLIB_APRS_MIC_E_TYPE_EN_ROUTE);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  // NOTE: moved to ISM band on purpose\n  //       DO NOT transmit in APRS bands without ham radio license!\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK(434.0);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.println(F(\"[APRS] Sending location reports\"));\n  \n  // send a location without message or timestamp\n  char destination[] = \"N0CALL\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  int state = aprs.sendPosition(destination, 0, latitude, longitude);\n  if(state != RADIOLIB_ERR_NONE) {\n    Serial.print(F(\"[APRS] Failed to send location, code \"));\n    Serial.println(state);"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with the settings necessary for LoRa iGates\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // frequency:                   433.775 MHz\n  // bandwidth:                   125 kHz\n  // spreading factor:            12\n  // coding rate:                 4/5\n  int state = radio.begin(433.775, 125, 12, 5);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[APRS] Sending position ... \"));\n  \n  // send a location with message and timestamp\n  // SSID is set to 1, as APRS over LoRa uses WIDE1-1 path by default\n  char destination[] = \"GPS\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  char message[] = \"I'm here!\";\n  char timestamp[] = \"093045z\";\n  int state = aprs.sendPosition(destination, 1, latitude, longitude, message, timestamp);\n  delay(500);\n\n  // you can also send Mic-E encoded messages\n  state |= state = aprs.sendMicE(49.1945, 16.6000, 120, 10, RADIOLIB_APRS_MIC_E_TYPE_EN_ROUTE);\n  delay(500);\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// compare the previous status to the current status\n  if (status != WiFi.status()) {\n    // it has changed update the variable\n    status = WiFi.status();\n\n    if (status == WL_AP_CONNECTED) {\n      byte remoteMac[6];\n\n      // a device has connected to the AP\n      Serial.print(\"Device connected to AP, MAC address: \");\n      WiFi.APClientMacAddress(remoteMac);\n      printMacAddress(remoteMac);"
        },
        {
          "name": "printWiFiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");\n  // print where to go in a browser:\n  Serial.print(\"To see this page in action, open a browser to http://\");\n  Serial.println(ip);"
        },
        {
          "name": "printMacAddress",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoGraphics.h"
      ],
      "functions": [
        {
          "name": "set",
          "body": "// the r parameter is (mis)used to set the character to draw with\n      _canvasBuffer[x][y] = r;\n      // cast unused parameters to void to fix \"unused parameter\" warning\n      (void)g;\n      (void)b;"
        },
        {
          "name": "endDraw",
          "body": "ArduinoGraphics::endDraw();\n\n      for (byte row = 0; row < canvasHeight; row++) {\n        for (byte column = 0; column < canvasWidth; column++) {\n          // handle unset parts of buffer\n          if (_canvasBuffer[column][row] == 0) {\n            _canvasBuffer[column][row] = ' ';"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "SERIAL_PORT_MONITOR",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "createPage",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>ATWebServer_BigData-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleRoot",
          "body": "//out.reserve(STRING_SIZE);\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < (100 * MULTIPLY_FACTOR); lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"ATWebServer_BigData_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "out.reserve(STRING_SIZE);\n\n  //Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart ATWebServer_BigData on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "TINY_GSM_MODEM_SIM800",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(6000);"
        },
        {
          "name": "loop",
          "body": "if (!rate) { rate = TinyGsmAutoBaud(SerialAT);"
        }
      ]
    },
    {
      "name": "BAUD_RATE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AltSoftSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SPY.begin(115200);\n\n  MODEM_TX.begin(BAUD_RATE);\n  BOARD_TX.begin(BAUD_RATE);\n  delay(6000);"
        },
        {
          "name": "loop",
          "body": "while (MODEM_TX.available()) {\n    SPY.write(MODEM_TX.read());"
        }
      ]
    },
    {
      "name": "OTETHERNET",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "SD.h",
        "Ethernet.h",
        "ArduinoOTA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial:\n  Serial.begin(9600);\n  while (!Serial);\n\n  // setup SD card\n  Serial.print(\"Initializing SD card...\");\n  if (!SD.begin(SDCARD_SS_PIN)) {\n    Serial.println(\"initialization failed!\");\n    // don't continue:\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// check for updates\n  ArduinoOTA.poll();\n\n  // add your normal loop code below ..."
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleStream.h",
        "SoftwareServo.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  // Blynk will work through SoftwareSerial\n  // Do not read or write this serial manually in your sketch\n  SwSerial.begin(9600);\n  Blynk.begin(SwSerial, auth);\n\n  // Sometimes you need to calibrate your ATtiny timer\n  //OSCCAL = 175;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "TX_PIN",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "initTXPin();\n    Serial.println(F(\"START \" __FILE__ \" from \" __DATE__ \"\\r\\nUsing library version \" VERSION_ATTINY_SERIAL_OUT));\n\n    writeString(\"OSCCAL=\");\n#if !defined(__AVR_ATtiny13__) && !defined(__AVR_ATtiny13A__)\n    writeUnsignedByteHexWithPrefix(OSCCAL);\n#endif"
        },
        {
          "name": "loop",
          "body": "static uint8_t tIndex = 0;\n    /*\n     * Example of 3 byte output. View in combined ASSCI / HEX View in HTerm (http://www.der-hammer.info/terminal/)\n     * Otherwise use writeUnsignedByteHexWithoutPrefix or writeUnsignedByteHex\n     */\n    write1Start8Data1StopNoParityWithCliSei('I');\n    writeBinary(tIndex);                    // 1 byte binary output\n\n#if !defined(__AVR_ATtiny13__) && !defined(__AVR_ATtiny13A__) // the utoa() function used in writeUnsignedByte etc. requires too much program space!\n    writeUnsignedByte(tIndex);              // 1-3 byte ASCII output\n    writeUnsignedByteHexWithPrefix(tIndex); // 4 byte output\n    writeUnsignedByteHex(tIndex);           // 2 byte output\n    write1Start8Data1StopNoParityWithCliSei('\\n');\n\n    /*\n     * Serial.print usage example\n     */\n    Serial.print(\"I=\");\n    Serial.print((char) tIndex);\n    Serial.print(\" | \");\n    Serial.print(tIndex);\n    Serial.print(\" | \");\n    Serial.print(tIndex, HEX);\n    Serial.print(\" | \");\n    Serial.printHex(tIndex);\n    Serial.print(\" | \");\n    Serial.println(tIndex);\n#endif\n    tIndex++;\n    delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif\n\n#if USE_AUNIT == 1\n  // These are useful for debugging.\n  //TestRunner::setVerbosity(Verbosity::kAll);\n  //TestRunner::setVerbosity(Verbosity::kTestRunSummary);\n  //TestRunner::list();\n\n  // If set to 0, meaning infinite timeout, some testing() may accidentally run\n  // forever. Default is 10s, let's set it to 5s to verify that it can be\n  // changed.\n  TestRunner::setTimeout(5);\n#else\n  //Test::min_verbosity = TEST_VERBOSITY_ALL;\n#endif"
        },
        {
          "name": "loop",
          "body": "#if USE_AUNIT == 1\n  // Should get something like:\n  // TestRunner summary:\n  //    10 passed, 0 failed, 2 skipped, 0 timed out, out of 12 test(s).\n  TestRunner::run();\n#else\n  // Should get something like:\n  // Test summary: 6 passed, 1 failed, and 1 skipped, out of 8 test(s).\n  Test::run();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif"
        },
        {
          "name": "loop",
          "body": "TestRunner::run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AUnit.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // wait for stability on some boards to prevent garbage Serial\n#endif\n  Serial.begin(115200); // ESP8266 default of 74880 not supported on Linux\n  while(!Serial); // for the Arduino Leonardo/Micro only\n#if defined(EPOXY_DUINO)\n  Serial.setLineModeUnix();\n#endif"
        },
        {
          "name": "loop",
          "body": "aunit::TestRunner::run();"
        }
      ]
    },
    {
      "name": "USE_AUNIT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h",
        "aunit/string_util.h",
        "ArduinoUnit.h"
      ],
      "functions": [
        {
          "name": "testCommon",
          "body": "assertLess(m, subject);"
        },
        {
          "name": "assertFailing",
          "body": "assertEqual(1, 2);"
        },
        {
          "name": "testCommon",
          "body": "assertLess(m, subject);"
        },
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif\n\n#if USE_AUNIT == 1\n  // These are useful for debugging.\n  //TestRunner::setVerbosity(Verbosity::kAll);\n  //TestRunner::setVerbosity(Verbosity::kTestRunSummary);\n  //TestRunner::list();\n#else\n  //Test::min_verbosity = TEST_VERBOSITY_ALL;\n#endif"
        },
        {
          "name": "loop",
          "body": "#if USE_AUNIT == 1\n  // Should get something like:\n  // TestRunner summary:\n  //    21 passed, 0 failed, 0 skipped, 0 timed out, out of 23 test(s).\n  TestRunner::run();\n#else\n  // Should get something like:\n  // Test summary: 12 passed, 0 failed, and 0 skipped, out of 12 test(s).\n  Test::run();\n#endif"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Das Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 100)\n  {\n    t1 = millis();\n\n    byte note = random(15, 80);\n    byte velocity = random(55, 100);\n    byte channel = 1;\n\n    //   DBG(F(\"\\nsendNoteOn\"), note, velocity, channel);\n    MIDI.sendNoteOn(note, velocity, channel);\n    //MIDI.sendNoteOff(note, velocity, channel);"
        },
        {
          "name": "OnAppleMidiException",
          "body": "switch (e)\n  {\n    case APPLEMIDI_NAMESPACE::Exception::BufferFullException:\n      DBG(F(\"*** BufferFullException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParseException:\n      DBG(F(\"*** ParseException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::TooManyParticipantsException:\n      DBG(F(\"*** TooManyParticipantsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UnexpectedInviteException:\n      DBG(F(\"*** UnexpectedInviteException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParticipantNotFoundException:\n      DBG(F(\"*** ParticipantNotFoundException\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ComputerNotInDirectory:\n      DBG(F(\"*** ComputerNotInDirectory\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NotAcceptingAnyone:\n      DBG(F(\"*** NotAcceptingAnyone\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ListenerTimeOutException:\n      DBG(F(\"*** ListenerTimeOutException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::MaxAttemptsException:\n      DBG(F(\"*** MaxAttemptsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NoResponseFromConnectionRequestException:\n      DBG(F(\"***:yyy did't respond to the connection request. Check the address and port, and any firewall or router settings. (time)\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::SendPacketsDropped:\n      DBG(F(\"*** SendPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ReceivedPacketsDropped:\n      DBG(F(\"*** ReceivedPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UdpBeginPacketFailed:\n      DBG(F(\"*** UdpBeginPacketFailed\"), value);\n      break;"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    //    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet3.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n//    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "onUpdateCallback",
          "body": "Serial.print(F(\"DDNSGeneric - IP Change Detected: \"));\n  Serial.println(newIP);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart AVR_ESP_AT_DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n  \n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "onUpdateCallback",
          "body": "Serial.print(\"DDNSGeneric - IP Change Detected: oldIP = \");\n  Serial.print(oldIP);\n  Serial.print(\", newIP = \");\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "body": "#if USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));  \n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#elif USE_UIP_ETHERNET\n  ET_LOGWARN(F(\"=========== USE_UIP_ETHERNET ===========\"));  \n#else\n  ET_LOGWARN(F(\"=========== USE_CUSTOM_ETHERNET ===========\"));\n#endif\n\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n\n  // For other boards, to change if necessary\n  #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n    // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n    Ethernet.init (USE_THIS_SS_PIN);\n    \n  #elif USE_CUSTOM_ETHERNET\n    // You have to add initialization for your Custom Ethernet here\n    // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n    //Ethernet.init(USE_THIS_SS_PIN);\n    \n  #endif  //( ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  \n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AVR_Ethernet_DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n  initEthernet();\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());\n\n  server.begin();\n\n  DDNSGeneric.service(\"duckdns\");    // Enter your DDNS Service Name - \"duckdns\" / \"noip\"\n\n  /*\n    For DDNS Providers where you get a token:\n    DDNSGeneric.client(\"domain\", \"token\");\n\n    For DDNS Providers where you get username and password: ( Leave the password field empty \"\" if not required )\n    DDNSGeneric.client(\"domain\", \"username\", \"password\");\n  */\n  DDNSGeneric.client(\"account.duckdns.org\", \"12345678-1234-1234-1234-123456789012\");\n\n  DDNSGeneric.onUpdate(onUpdateCallback);"
        },
        {
          "name": "loop",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send note on/off every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "ONE_PARTICIPANT",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  if (Ethernet.begin(mac) == 0)  for (;;);\n\n  MIDI.begin();\n\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char*) {\n    isConnected++;\n    digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    MIDI.sendNoteOn(54, 100, 1);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI1.read();\n  MIDI2.read();\n\n  // send note on/off every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n\n    MIDI1.sendNoteOn(note, velocity, 1);\n    MIDI2.sendNoteOn(note, velocity, 2);"
        },
        {
          "name": "OnAppleMidiConnected",
          "body": "isConnected++;\n  DBG(F(\"Connected to session\"), ssrc, name);"
        },
        {
          "name": "OnAppleMidiDisconnected",
          "body": "isConnected--;\n  DBG(F(\"Disconnected\"), ssrc);"
        },
        {
          "name": "OnMidiNoteOn",
          "body": "DBG(F(\"in\\tNote on\"), note, \" Velocity\", velocity, \"\\t\", channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n//    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();"
        },
        {
          "name": "OnAppleMidiStartReceived",
          "body": "DBG(F(\"Start receiving\"), ssrc);"
        },
        {
          "name": "OnAppleMidiReceivedByte",
          "body": "SerialMon.println(data, HEX);"
        },
        {
          "name": "OnAppleMidiEndReceive",
          "body": "DBG(F(\"End receiving\"), ssrc);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n //   MIDI.sendSysEx(sizeof(sysexBig), sysexBig, true);\n    t1 = millis();"
        },
        {
          "name": "OnMidiSysEx",
          "body": "SerialMon.print(F(\"SYSEX: (\"));\n  SerialMon.print(getSysExStatus(data, length));\n  SerialMon.print(F(\", \"));\n  SerialMon.print(length);\n  SerialMon.print(F(\" bytes) \"));\n  for (uint16_t i = 0; i < length; i++)\n  {\n    SerialMon.print(data[i], HEX);\n    SerialMon.print(\" \");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (gsmAccess.status() != GSM_READY || gprs.status() != GPRS_READY) {\n    connectGSM();"
        },
        {
          "name": "connectGSM",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((gsmAccess.begin(pinnumber) != GSM_READY) ||\n         (gprs.attachGPRS(gprs_apn, gprs_login, gprs_password) != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "MKRNB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (nbAccess.status() != NB_READY || gprs.status() != GPRS_READY) {\n    connectNB();"
        },
        {
          "name": "connectNB",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((nbAccess.begin(pinnumber) != NB_READY) ||\n         (gprs.attachGPRS() != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "Arduino_ConnectionHandler.h",
        "Arduino_JSON.h",
        "NTPClient.h",
        "mbed_mktime.h",
        "Ethernet.h",
        "EthernetUdp.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    // Wait for Serial Monitor or start after 2.5s\n    for (const auto startNow = millis() + 2500; !Serial && millis() < startNow; delay(250));\n\n    // Set the callbacks for connectivity management\n    conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n    conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n    conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n    // Check for HSM\n    if (!ECCX08.begin()) {\n        Serial.println(\"No ECCX08 present!\");\n        while (1)\n            ;"
        },
        {
          "name": "loop",
          "body": "// Automatically manage connectivity\n    const auto conStatus = conMan.check();\n\n    if (conStatus != NetworkConnectionState::CONNECTED)\n        return;\n\n    if (!mqttClient.connected()) {\n        // MQTT client is disconnected, connect\n        connectMQTT();"
        },
        {
          "name": "setNtpTime",
          "body": "timeClient.forceUpdate();\n    const auto epoch = timeClient.getEpochTime();\n    set_time(epoch);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n    Serial.print(broker);\n    Serial.print(\":\");\n    Serial.print(port);\n    Serial.println();\n\n    int status;\n    while ((status = mqttClient.connect(broker, port)) == 0) {\n        // failed, retry\n        Serial.println(status);\n        delay(1000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n    JSONVar payload;\n    String msg = \"Hello, World! \";\n    msg += millis();\n    payload[\"message\"] = msg;\n\n    JSONVar message;\n    message[\"ts\"] = static_cast<unsigned long>(time(nullptr));\n    message[\"payload\"] = payload;\n\n    String messageString = JSON.stringify(message);\n    Serial.println(messageString);\n\n    // send message, the Print interface can be used to set the message contents\n    constexpr char outgoingTopic[] { \"arduino/outgoing\""
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n    Serial.println();\n    Serial.print(\"Received a message with topic '\");\n    Serial.print(mqttClient.messageTopic());\n    Serial.print(\"', length \");\n    Serial.print(messageSize);\n    Serial.println(\" bytes:\");\n\n    /*\n    // Message from AWS MQTT Test Client\n    {\n      \"message\": \"Hello from AWS IoT console\""
        },
        {
          "name": "onNetworkConnect",
          "body": "Serial.println(\">>>> CONNECTED to network\");\n    printEthernetStatus();\n\n    setNtpTime();\n    connectMQTT();"
        },
        {
          "name": "onNetworkDisconnect",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "body": "Serial.println(\">>>> ERROR\");"
        },
        {
          "name": "printEthernetStatus",
          "body": "// print your board's IP address:\n    Serial.print(\"Local IP: \");\n    Serial.println(Ethernet.localIP());\n    Serial.print(\"Local GW: \");\n    Serial.println(Ethernet.gatewayIP());\n    Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "Arduino_ConnectionHandler.h",
        "Arduino_JSON.h",
        "NTPClient.h",
        "mbed_mktime.h",
        "WiFi.h",
        "WiFiUdp.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    // Wait for Serial Monitor or start after 2.5s\n    for (const auto startNow = millis() + 2500; !Serial && millis() < startNow; delay(250));\n\n    // Set the callbacks for connectivity management\n    conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n    conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n    conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n    // Check for HSM\n    if (!ECCX08.begin()) {\n        Serial.println(\"No ECCX08 present!\");\n        while (1)\n            ;"
        },
        {
          "name": "loop",
          "body": "// Automatically manage connectivity\n    const auto conStatus = conMan.check();\n\n    if (conStatus != NetworkConnectionState::CONNECTED)\n        return;\n\n    if (!mqttClient.connected()) {\n        // MQTT client is disconnected, connect\n        connectMQTT();"
        },
        {
          "name": "setNtpTime",
          "body": "timeClient.forceUpdate();\n    const auto epoch = timeClient.getEpochTime();\n    set_time(epoch);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n    Serial.print(broker);\n    Serial.print(\":\");\n    Serial.print(port);\n    Serial.println();\n\n    int status;\n    while ((status = mqttClient.connect(broker, port)) == 0) {\n        // failed, retry\n        Serial.println(status);\n        delay(1000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n    JSONVar payload;\n    String msg = \"Hello, World! \";\n    msg += millis();\n    payload[\"message\"] = msg;\n    payload[\"rssi\"] = WiFi.RSSI();\n\n    JSONVar message;\n    message[\"ts\"] = static_cast<unsigned long>(time(nullptr));\n    message[\"payload\"] = payload;\n\n    String messageString = JSON.stringify(message);\n    Serial.println(messageString);\n\n    // send message, the Print interface can be used to set the message contents\n    constexpr char outgoingTopic[] { \"arduino/outgoing\""
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n    Serial.println();\n    Serial.print(\"Received a message with topic '\");\n    Serial.print(mqttClient.messageTopic());\n    Serial.print(\"', length \");\n    Serial.print(messageSize);\n    Serial.println(\" bytes:\");\n\n    /*\n    // Message from AWS MQTT Test Client\n    {\n      \"message\": \"Hello from AWS IoT console\""
        },
        {
          "name": "onNetworkConnect",
          "body": "Serial.println(\">>>> CONNECTED to network\");\n\n    printWifiStatus();\n    setNtpTime();\n    connectMQTT();"
        },
        {
          "name": "onNetworkDisconnect",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "body": "Serial.println(\">>>> ERROR\");"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n    Serial.print(\"SSID: \");\n    Serial.println(WiFi.SSID());\n\n    // print the received signal strength:\n    Serial.print(\"signal strength (RSSI):\");\n    Serial.print(WiFi.RSSI());\n    Serial.println(\" dBm\");\n    Serial.println();\n\n    // print your board's IP address:\n    Serial.print(\"Local IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.print(\"Local GW: \");\n    Serial.println(WiFi.gatewayIP());\n    Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "WiFiNINA.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    connectWiFi();"
        },
        {
          "name": "connectWiFi",
          "body": "Serial.print(\"Attempting to connect to SSID: \");\n  Serial.print(ssid);\n  Serial.print(\" \");\n\n  while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // carrier frequency:           434.0 MHz\n  // bit rate:                    1.2 kbps (1200 baud 2-FSK AX.25)\n  // frequency deviation:         0.5 kHz  (1200 baud 2-FSK AX.25)\n  int state = radio.beginFSK(434.0, 1.2, 0.5);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// create AX.25 Unnumbered Information frame\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  // source station callsign:          \"N7LEM\"\n  // source station SSID:              0\n  // control field:                    UI, P/F not used, unnumbered frame\n  // protocol identifier:              no layer 3 protocol implemented\n  // information field:                \"Hello World!\"\n  AX25Frame frameUI(\"NJ7P\", 0, \"N7LEM\", 0, RADIOLIB_AX25_CONTROL_U_UNNUMBERED_INFORMATION |\n                    RADIOLIB_AX25_CONTROL_POLL_FINAL_DISABLED | RADIOLIB_AX25_CONTROL_UNNUMBERED_FRAME,\n                    RADIOLIB_AX25_PID_NO_LAYER_3, \"Hello World (unnumbered)!\");\n\n  // send the frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  int state = ax25.sendFrame(&frameUI);\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // carrier frequency:           434.0 MHz\n  // bit rate:                    1.2 kbps (1200 baud 2-FSK AX.25)\n  int state = radio.beginFSK(434.0, 1.2);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// send AX.25 unnumbered information frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  int state = ax25.transmit(\"Hello World!\", \"NJ7P\");\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// send AX.25 unnumbered information frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  int state = ax25.transmit(\"Hello World!\", \"NJ7P\");\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte value;\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 1: Find Chip Address.\");\n\n  psg.begin();\n\n  // Find chip address\n  byte foundAddress;\n  foundAddress = psg.findChipAddress();\n  Serial.print(\"Default Chip Address: \");\n  Serial.println(psg.getChipAddress(), HEX);\n\n  if (foundAddress == 0xFF) {\n    Serial.println(\"ERROR: Unable to detect chip address, check hardware.\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte value;\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 2: Test Regsiters.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered with non-default address.\n\n  Serial.println(\"\");\n  Serial.println(\"Note that registers 0x1, 0x3, 0x5, 0xD are only 4 bits wide, and\");\n  Serial.println(\"registers 0x6, 0x8, 0x9, 0xA are only 5 bits wide.\");\n  Serial.println(\"\");\n\n  for (byte i = AY3891x::ChA_Tone_Period_Fine_Reg; i <= AY3891x:: IO_Port_B_Reg; i++) {\n    Serial.print(\"Write value 0x\");\n    Serial.print(0x50 | i, HEX);\n    Serial.print(\" to register:   0x\");\n    Serial.println(i, HEX);\n    psg.write(i, 0x50 | i);\n    value = psg.read(i);\n    Serial.print(\"Read value  0x\");\n    Serial.print(value, HEX);\n    Serial.print(\" from register: 0x\");\n    Serial.println(i, HEX);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 3: Simple Tone Generator.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  // Use less than max amplitude, in case external amp can't handle the higher level (start low and increase after testing)\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  psg.write(AY3891x::Enable_Reg, ~(MIXER_TONE_A_DISABLE | MIXER_TONE_B_DISABLE));   // Enable Channel A and B tone generator output\n\n  for (byte i = 0; i < sizeof(notes_to_play) / sizeof(notes_to_play[0]); i++) {\n    Serial.print(\"Playing note freq: \");\n    Serial.println(1000000UL/16/pgm_read_word(&Notes[notes_to_play[i]]));\n    psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[notes_to_play[i]]) >> 8);\n    psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[notes_to_play[i]]) & TONE_GENERATOR_FINE);\n    psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[notes_to_play[i]]) >> 8);\n    psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[notes_to_play[i]]) & TONE_GENERATOR_FINE);\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 4: I/O Ports.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  // By default, the I/O ports are set up as inputs.\n  // There are internal pull-ups connected to the input ports, so if the pins\n  // are left floating, they should read as zero when set to input.\n  psg.write(AY3891x::Enable_Reg, ~(MIXER_INPUTS_DISABLE));  // Disable audio, I/O ports to input mode\n  Serial.println(\"Input Mode has internal pullups.\");\n  Serial.print(\"Input Port A read value: 0x\");\n  Serial.println(psg.read(AY3891x::IO_Port_A_Reg), HEX);\n  Serial.print(\"Input Port B read value: 0x\");\n  Serial.println(psg.read(AY3891x::IO_Port_B_Reg), HEX);\n  delay(1000);\n\n  // Set lines to output with value 0xA5 on Port A and 0x5A on Port B\n  // Measure with a DMM or scope to test\n  Serial.println(\"Setting ports to OUTPUT...\");\n  delay(1000);\n  psg.write(AY3891x::Enable_Reg, MIXER_ALL_DISABLED); // Ports to output mode, audio disabled\n  Serial.println(\"Writing 0xA5 to A and 0x5A to B.\");\n  psg.write(AY3891x::IO_Port_A_Reg, 0xA5);\n  psg.write(AY3891x::IO_Port_B_Reg, 0x5A);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "cmd_unrecognized",
          "body": "sender->GetSerial()->print(F(\"Unrecognized command [\"));\n\tsender->GetSerial()->print(cmd);\n\tsender->GetSerial()->println(F(\"]\"));"
        },
        {
          "name": "cmd_enable",
          "body": "// \"enable all\"        -- enables all tone and noise generators\n  // \"enable all tones\"  -- enables all tone generators\n  // \"enable all noises\" -- enables all noise generators\n  // \"enable tone a\"     -- enables tone generator A\n  // \"enable tone b\"     -- enables tone generator A\n  // \"enable tone c\"     -- enables tone generator A\n  // \"enable noise a\"    -- enables noise generator A\n  // \"enable noise b\"    -- enables noise generator B\n  // \"enable noise c\"    -- enables noise generator C\n  enum{ALL, TONE, NOISE, TONES, NOISES, CHANA, CHANB, CHANC, NONE"
        },
        {
          "name": "cmd_disable",
          "body": "// \"disable\"        -- disables all tone and noise generators\n  byte value;\n\n  sender->GetSerial()->println(F(\"Disabling all tones and noises.\"));\n\n  value = psg.read(AY3891x::Enable_Reg);\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONES_DISABLE | value);"
        },
        {
          "name": "cmd_write",
          "body": "char* param1 = sender->Next();  // Register\n  char* param2 = sender->Next();  // Value\n  byte p1, p2;\n\n  if (param1 == NULL) cmd_unrecognized(sender, buffer);\n  else\n  {\n    p1 = atoi(param1);\n    if (p1 > AY3891x::IO_Port_B_Reg) cmd_unrecognized(sender, buffer);\n    else\n    {\n      if (param2 == NULL) cmd_unrecognized(sender, buffer);\n      else\n      {\n        p2 = atoi(param2);\n        sender->GetSerial()->print(F(\"Writing register 0x\"));\n        sender->GetSerial()->print(p1, HEX);\n        sender->GetSerial()->print(F(\" with value 0x\"));\n        sender->GetSerial()->println(p2, HEX);\n        psg.write(p1, p2);"
        },
        {
          "name": "cmd_read",
          "body": "char* param1 = sender->Next();  // Register\n  byte p1;\n  if (param1 == NULL) cmd_unrecognized(sender, buffer);\n  else\n  {\n    p1 = atoi(param1);\n    if (p1 > AY3891x::IO_Port_B_Reg) cmd_unrecognized(sender, buffer);\n    else\n    {\n      sender->GetSerial()->print(F(\"Reading value from register 0x\"));\n      sender->GetSerial()->print(p1, HEX);\n      sender->GetSerial()->print(F(\": 0x\"));\n      sender->GetSerial()->println(psg.read(p1), HEX);"
        },
        {
          "name": "cmd_middlec",
          "body": "sender->GetSerial()->println(\"Enable Middle C on channels A and B\");\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONE_C_DISABLE);    // Disable the noise, enable tones on A and B\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n  psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);"
        },
        {
          "name": "cmd_gunshot",
          "body": "sender->GetSerial()->println(\"Playing gunshot sound on A, B, C\");\n  // Register programming values adopted from AY-3-8910 Data Manual, Secion 6.2\n  psg.write(AY3891x::Noise_Period_Reg, 0xF); // Set Noise period to mid-value\n  psg.write(AY3891x::Enable_Reg, MIXER_TONES_DISABLE); // Enable noise only on A,B,C\n  psg.write(AY3891x::ChA_Amplitude, 0x10); // Set full amplitude range under direct control of Envelope Generator\n  psg.write(AY3891x::ChB_Amplitude, 0x10);\n  psg.write(AY3891x::ChC_Amplitude, 0x10);\n  psg.write(AY3891x::Env_Period_Coarse_Reg, 4); // Set envlope period\n  psg.write(AY3891x::Env_Period_Fine_Reg, 0);\n  psg.write(AY3891x::Env_Shape_Cycle, 0);  // Envelope decay, one cycle only"
        },
        {
          "name": "cmd_explosion",
          "body": "sender->GetSerial()->println(\"Playing explosion sound on A, B, C\");\n  // Register programming values adopted from AY-3-8910 Data Manual, Secion 6.2\n  psg.write(AY3891x::Noise_Period_Reg, 0x0); // Set Noise period to max value\n  psg.write(AY3891x::Enable_Reg, MIXER_TONES_DISABLE); // Enable noise only on A,B,C\n  psg.write(AY3891x::ChA_Amplitude, 0x10); // Set full amplitude range under direct control of Envelope Generator\n  psg.write(AY3891x::ChB_Amplitude, 0x10);\n  psg.write(AY3891x::ChC_Amplitude, 0x10);\n  psg.write(AY3891x::Env_Period_Coarse_Reg, 0x1c); // Set envlope period\n  psg.write(AY3891x::Env_Period_Fine_Reg, 0);\n  psg.write(AY3891x::Env_Shape_Cycle, 0);  // Envelope decay, one cycle only"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\tSerial.begin(38400);\n\n\tserial_commands_.SetDefaultHandler(cmd_unrecognized);\n\tserial_commands_.AddCommand(&cmd_enable_);\n  serial_commands_.AddCommand(&cmd_disable_);\n  serial_commands_.AddCommand(&cmd_write_);\n  serial_commands_.AddCommand(&cmd_read_);\n  serial_commands_.AddCommand(&cmd_middlec_);\n  serial_commands_.AddCommand(&cmd_gunshot_);\n  serial_commands_.AddCommand(&cmd_explosion_);\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n  // Set up a tone on channel A and B to make testing easier.\n  // By default, the tone and noise generators are enabled when the chip comes out of reset, I/O pins are set to INPUT\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONE_C_DISABLE);    // Disable the noise and channel C\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  Serial.print(F(\"Configuring note: C4 (middle C)\"));\n  psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n  psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n\n  Serial.println(F(\"\"));\n  Serial.println(F(\"AY-3-891x Sound Chip Library Example 5: Serial Commands.\"));\n  Serial.println(F(\"\"));\n  Serial.println(F(\"Available commands:\"));\n  Serial.println(F(\"  enable all [tones|noises]\"));\n  Serial.println(F(\"  enable tone a|b|c\"));\n  Serial.println(F(\"  enable noise a|b|c\"));\n  Serial.println(F(\"  disable\"));\n  Serial.println(F(\"  write register value\"));\n  Serial.println(F(\"  read register\"));\n  Serial.println(F(\"  middlec\"));\n  Serial.println(F(\"  gunshot\"));\n  Serial.println(F(\"  explosion\"));\n  Serial.println(F(\"Enter command: \"));"
        },
        {
          "name": "loop",
          "body": "serial_commands_.ReadSerial();"
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address."
        },
        {
          "name": "loop",
          "body": "byte i;\n\n  if (micros() - prev_micros > INTERVAL)\n  {\n    prev_micros = micros();\n\n    for (i= 0; i < 14; i++) {\n      psg.write(i, pgm_read_byte(&psg_data[data_index++]));"
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\n  pinMode(CS, OUTPUT);\n  pinMode(NEXT_BUTTON, INPUT_PULLUP);\n  Serial.begin(9600);\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  Serial.println(F(\"\"));\n  Serial.println(F(\"AY-3-891x Sound Chip Library Example 7: Sound Chip YM data player.\"));\n  Serial.print(F(\"Press button on pin \"));\n  Serial.print(NEXT_BUTTON);\n  Serial.println(F(\" to advance to next song on SD card.\"));\n  Serial.println(F(\"\"));\n\n  if (!SD.begin(CS))\n  {\n    Serial.println(F(\"SD Initialization Failed: program stopped.\"));\n    while (1); // Infinite loop here"
        },
        {
          "name": "loop",
          "body": "int i;\n  byte register_data[14];\n\n  switch (state) {\n\n    case PLAYING:\n      if (micros() - prev_micros > INTERVAL)\n      {\n        prev_micros = micros();\n        if (current_song.available())\n        {\n          for (i = 0; i < 14; i++) {\n            register_data[i] = current_song.read();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  BHY2.begin();\n  accel.begin();\n  gyro.begin();"
        },
        {
          "name": "loop",
          "body": "static auto printTime = millis();\n\n  // Update function should be continuously polled\n  BHY2.update();\n\n  if (millis() - printTime >= 50) {\n    printTime = millis();\n\n    // Accelerometer values\n    Serial.print(\"acc_X:\");\n    Serial.print(accel.x());\n    Serial.print(\",\");\n    Serial.print(\"acc_Y:\");\n    Serial.print(accel.y());\n    Serial.print(\",\");\n    Serial.print(\"acc_Z:\");\n    Serial.print(accel.z());\n    Serial.print(\",\");\n\n    // Gyroscope values\n    Serial.print(\"gyro_X:\");\n    Serial.print(gyro.x());\n    Serial.print(\",\");\n    Serial.print(\"gyro_Y:\");\n    Serial.print(gyro.y());\n    Serial.print(\",\");\n    Serial.print(\"gyro_Z:\");\n    Serial.println(gyro.z());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h",
        "AccelStepper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "SPI.begin();\n  stepper.init(amisSlaveSelect);\n  delay(1);\n\n  stepper.resetSettings();\n  stepper.setCurrentMilliamps(132);\n  stepper.setStepMode(32);\n  stepper.enableDriver();\n\n  accelStepper.setMaxSpeed(2000.0);\n  accelStepper.setAcceleration(500.0);"
        },
        {
          "name": "loop",
          "body": "accelStepper.runToNewPosition(0);\n  delay(500);\n  accelStepper.runToNewPosition(10000);\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AccelStepper.h",
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "body": "myStepper1->onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "body": "myStepper1->onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n   Serial.println(\"Stepper test!\");\n\n  if (!AFMS.begin()) {         // create with the default frequency 1.6KHz\n  // if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz\n    Serial.println(\"Could not find Motor Shield. Check wiring.\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "Astepper1.runSpeed();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "AccelStepper.h",
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "body": "myStepper1->onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "body": "myStepper1->onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "forwardstep2",
          "body": "myStepper2->onestep(FORWARD, DOUBLE);"
        },
        {
          "name": "backwardstep2",
          "body": "myStepper2->onestep(BACKWARD, DOUBLE);"
        },
        {
          "name": "forwardstep3",
          "body": "myStepper3->onestep(FORWARD, INTERLEAVE);"
        },
        {
          "name": "backwardstep3",
          "body": "myStepper3->onestep(BACKWARD, INTERLEAVE);"
        },
        {
          "name": "setup",
          "body": "AFMSbot.begin(); // Start the bottom shield\n  AFMStop.begin(); // Start the top shield\n\n  stepper1.setMaxSpeed(100.0);\n  stepper1.setAcceleration(100.0);\n  stepper1.moveTo(24);\n\n  stepper2.setMaxSpeed(200.0);\n  stepper2.setAcceleration(100.0);\n  stepper2.moveTo(50000);\n\n  stepper3.setMaxSpeed(300.0);\n  stepper3.setAcceleration(100.0);\n  stepper3.moveTo(1000000);"
        },
        {
          "name": "loop",
          "body": "// Change direction at the limits\n    if (stepper1.distanceToGo() == 0)\n\tstepper1.moveTo(-stepper1.currentPosition());\n\n    if (stepper2.distanceToGo() == 0)\n\tstepper2.moveTo(-stepper2.currentPosition());\n\n    if (stepper3.distanceToGo() == 0)\n\tstepper3.moveTo(-stepper3.currentPosition());\n\n    stepper1.run();\n    stepper2.run();\n    stepper3.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);\n  while(!Serial);\n  \n  Accelerometer.begin();"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // 3 axis\n  Serial.print(\"x:\"); \n  Serial.print(Accelerometer.readX()); \n  Serial.print(\"  \");\n  Serial.print(\"y:\"); \n  Serial.print(Accelerometer.readY());        \n  Serial.print(\"  \");\n  Serial.print(\"z:\"); \n  Serial.println(Accelerometer.readZ());\n \n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 bits per second for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n    accelerometer.initialize(); // Set-up for MPU \n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelrometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G"
        },
        {
          "name": "loop",
          "body": "acc = accelerometer.getSample(); // Gets and saves 3-axis acceleration reading (G)\n\n    Serial.print(\"Acceleration in Gs, X-Axis: \"); Serial.print(acc.x, 8); // Prints out 3-axis acceleration (G)\n    Serial.print(\" Y-Axis: \"); Serial.print(acc.y, 8);\n    Serial.print(\" Z-Axis: \"); Serial.print(acc.z, 8);\n    Serial.println();\n    \n    delay(500); // Waits 500ms (half a second)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n\n    accelerometer.initialize(); // Set-up for MPU \n\n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelrometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G\n\n    pinMode(LED, OUTPUT); // Sets LED\n    \n    delay(50); // Allow time for sensor initialization to complete\n\n    for(int i = 0; i < 3; i++){ // Calibration period of 3 seconds\n        startTime = millis(); // Keeps track of start time before getting measurements\n\n        accelRaw = accelerometer.getRawAcc(); // Gets and saves raw acceleration \n        accelG = accelerometer.getGAccel(accelRaw); // Gets and saves acceleration in G's\n        accelMPS = accelerometer.getMPSAccel(accelG); // Gets and saves acceleration in MPS\n        \n        Serial.print(\"MPS, X-Axis: \"); // Prints out 3-axis acceleration (MPS)\n        Serial.println(accelMPS.x, 8);\n        Serial.print(\"MPS, Y-Axis: \");\n        Serial.println(accelMPS.y, 8);\n        Serial.print(\"MPS, Z-Axis: \");\n        Serial.println(accelMPS.z, 8);\n        Serial.println();\n    \n        staticAcceleration = staticAcceleration + sqrt(pow(accelMPS.x,2) + pow(accelMPS.y,2) + pow(accelMPS.z,2)); // Adds up magnitude of \n                                                                                                                   // current acceleration\n        endTime = millis(); // Keeps track of end time after getting measurements \n        delay(1000 - (endTime - startTime)); // Change of time factored into a one second delay"
        },
        {
          "name": "loop",
          "body": "startTime = millis(); // Keeps track of start time before getting measurements\n\n    accelRaw = accelerometer.getRawAcc(); // Gets and saves raw acceleration\n    accelG = accelerometer.getGAccel(accelRaw); // Gets and saves acceleration in G's\n    accelMPS = accelerometer.getMPSAccel(accelG); // Gets and saves acceleration in MPS\n\n    Serial.print(\"MPS, X-Axis: \"); // Prints out 3-axis acceleration (MPS)\n    Serial.println(accelMPS.x, 8);\n    Serial.print(\"MPS, Y-Axis: \");\n    Serial.println(accelMPS.y, 8);\n    Serial.print(\"MPS, Z-Axis: \");\n    Serial.println(accelMPS.z, 8);\n    Serial.println();\n\n    dynamicAcceleration = sqrt(pow(accelMPS.x,2) + pow(accelMPS.y,2) + pow(accelMPS.z,2)); // Adds up magnitude of current acceleration\n\n    accelDif = abs(dynamicAcceleration - staticAcceleration); // Subtracts and saves static acceleration from dynamic acceleration\n\n    Serial.print(F(\"Calculated Difference in Acceleration: \")); Serial.println(accelDif); // Print out difference in acceleration\n\n    if(accelDif >= impactThreshold){ // If the difference in acceleration is greater than or equal to the threshhold set above\n        Serial.println(\"Impact detected\"); // Notify impact has been detected\n\n        digitalWrite(LED, HIGH); // LEDs blink\n        delay(500);\n        digitalWrite(LED, LOW);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n    accelerometer.initialize(); // Set-up for MPU \n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelerometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G\n\n    // Calibration (LunaSat flat on table)\n    sensor_float_vec_t calibrationPoints[calibrationSize];  // Array of vectors for storing calibration points  \n    for(int i = 0; i < calibrationSize; i++){\n        calibrationPoints[i] = accelerometer.getSample();"
        },
        {
          "name": "loop",
          "body": "acc = accelerometer.getSample(); // Gets and saves 3-axis acceleration reading (G)\n\n    accMPS = accelerometer.getMPSAccel(acc); // Converts acceleration measurements from G's to meters per second squared\n\n    // Subtract baseline values from current sample\n\n    accMPS.x = accMPS.x - avgX*9.81; // Multiply by 9.81 to convert G's to m/s^2\n    accMPS.y = accMPS.y - avgY*9.81;\n    \n    // Find the net acceleration for each pair of axes\n    yzAcceleration = sqrt(pow(accMPS.y,2) + pow(accMPS.z,2)); \n    xzAcceleration = sqrt(pow(accMPS.x,2) + pow(accMPS.z,2)); \n    xyAcceleration = sqrt(pow(accMPS.x,2) + pow(accMPS.y,2)); \n\n    // Calculate x angle (roll)\n    xAngle = accMPS.x/yzAcceleration;\n    xAngle = atan(xAngle)*(180/3.141);\n    Serial.print(\"X Angle (Roll): \");\n    Serial.print(xAngle);\n    Serial.println(\"º\");\n\n    // Calculate y angle (pitch)\n    yAngle = accMPS.y/xzAcceleration;\n    yAngle = atan(yAngle)*(180/3.141);\n    Serial.print(\"Y Angle (Pitch): \");\n    Serial.print(yAngle);\n    Serial.println(\"º\");\n\n    // Calculate z angle (yaw)\n    zAngle = accMPS.z/xyAcceleration;\n    zAngle = (atan(zAngle)*(180/3.141));\n    Serial.print(\"Z Angle (Yaw): \");\n    Serial.print(zAngle);\n    Serial.println(\"º\");\n    Serial.println();\n    \n    delay(500); // Waits half a second"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && millis() - dataMillis > 5000)\n  {\n    dataMillis = millis();\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count++) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "SKETCH_DEBUG",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AccessoryShield.h",
        "Mouse.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the Accessory Shield library\n  accessoryShield.begin();\n  // initialize mouse control:\n  Mouse.begin();\n  \n#ifdef SKETCH_DEBUG\n  Serial.begin(9600);\n  while(!Serial) ;\n#endif"
        },
        {
          "name": "loop",
          "body": "// read a new value from th joystick\n  JoystickMode joystickValue = accessoryShield.getJoystickValue();\n  \n  // set the distance offset using the pot trimmer of Accessory Shield\n  unsigned int distanceOffset = accessoryShield.readPot();\n  // calibrate and map the pot value \n  distanceOffset = map(distanceOffset, 0, 1023, minDistanceOffset, maxDistanceOffset);\n  // set the X and Y distance :\n  // xDistance and yDistance are used to set how the mouse sould be moved\n  // in orizontal (X axis) or in vertical (Y axis) \n  xDistance = yDistance = distanceOffset;\n\n  // check if the joystick has been moved\n#if (defined(_VARIANT_ARDUINO_101_X_) || defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAMD))\n  if(joystickValue != JOYSTICK_NONE_OR_DOWN) {\n#else\n  if(joystickValue != JOYSTICK_NONE) {\n#endif\n    // print values of X and Y distance\n#ifdef SKETCH_DEBUG\n    Serial.print(\"X distance offset= \");\n    Serial.println(xDistance);\n    Serial.print(\"Y distance offset= \");\n    Serial.println(yDistance);\n#endif\n    \n    switch(joystickValue) {\n      // if the joystick has been pushed, click with mouse left button\n      case JOYSTICK_PUSH :\n        Mouse.click(MOUSE_LEFT);\n        break;\n      // if the joystick has been moved up, move up the mouse cursor\n      case JOYSTICK_UP :\n        Mouse.move(0, -yDistance, 0);\n        break;\n#if !(defined(_VARIANT_ARDUINO_101_X_) || defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAMD))\n      // if the joystick has been moved down, move down the mouse cursor\n      case JOYSTICK_DOWN :\n        Mouse.move(0, yDistance, 0);\n        break;\n#endif\n      // if the joystick has been moved right, move right the mouse cursor\n      case JOYSTICK_RIGHT :\n        Mouse.move(xDistance, 0, 0);\n        break;\n      // if the joystick has been moved left, move left the mouse cursor\n      case JOYSTICK_LEFT :\n        Mouse.move(-xDistance, 0, 0);\n        break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  BHY2.begin();\n  active.begin();"
        },
        {
          "name": "loop",
          "body": "BHY2.update();\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis >= interval) {\n    previousMillis = currentMillis;\n    Serial.println(String(\"Activity info: \") + active.toString());"
        }
      ]
    },
    {
      "name": "Serial",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "digitalWrite"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "HardwareSerial.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Serial.println(F(\"*** SIMCom Module MQTT Example ***\"));\n\n  #ifdef LED\n    pinMode(LED, OUTPUT);\n    digitalWrite(LED, LOW);\n  #endif\n  \n  pinMode(RST, OUTPUT);\n  digitalWrite(RST, HIGH); // Default state\n\n  modem.powerOn(BOTLETICS_PWRKEY); // Power on the module\n  moduleSetup(); // Establishes first-time serial comm and prints IMEI\n\n  if (!tempsensor.begin()) {\n    Serial.println(\"Couldn't find the MCP9808!\");\n    tempsensor.wake(); // Wake up the MCP9808 if it was sleeping and retry\n    if (!tempsensor.begin()) while (1);"
        },
        {
          "name": "loop",
          "body": "// Connect to cell network and verify connection\n  // If unsuccessful, keep retrying every 2s until a connection is made\n  while (!netStatus()) {\n    Serial.println(F(\"Failed to connect to cell network, retrying...\"));\n    delay(2000); // Retry every 2s"
        },
        {
          "name": "moduleSetup",
          "body": "// SIM7000 takes about 3s to turn on and SIM7500 takes about 15s\n  // Press Arduino reset button if the module is still turning on and the board doesn't find it.\n  // When the module is on it should communicate right after pressing reset\n\n  // Software serial:\n  modemSS.begin(115200); // Default SIM7000 shield baud rate\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modemSS.println(\"AT+IPR=9600\"); // Set baud rate\n  delay(100); // Short pause to let the command run\n  modemSS.begin(9600);\n  if (! modem.begin(modemSS)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while (1); // Don't proceed if it couldn't find the device"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  // Stop if already connected.\n  if (mqtt.connected()) {\n    return;"
        },
        {
          "name": "MQTT_publish_checkSuccess",
          "body": "Serial.println(F(\"Sending data...\"));\n  if (! feed.publish(feedContent)) {\n    Serial.println(F(\"Failed\"));\n    txfailures++;"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleBLEPeripheral.h",
        "BLEPeripheral.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  SerialBLE.setLocalName(\"Blynk\");\n  SerialBLE.setDeviceName(\"Blynk\");\n  SerialBLE.setAppearance(0x0080);\n  SerialBLE.begin();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(SerialBLE, auth);"
        },
        {
          "name": "loop",
          "body": "SerialBLE.poll();\n\n  if (SerialBLE) {    // If BLE is connected...\n    Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleSerialBLE.h",
        "Adafruit_BLE.h",
        "Adafruit_BluefruitLE_SPI.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  ble.begin(BLUEFRUIT_VERBOSE_MODE);\n  ble.factoryReset(); // Optional\n  ble.setMode(BLUEFRUIT_MODE_DATA);\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(auth, ble);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFi101.h",
        "BlynkSimpleWiFiShield101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  WiFi.setPins(8, 7, 4, 2);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(pin, INPUT);"
        },
        {
          "name": "loop",
          "body": "for (int i = 0; i < repetitions; i++) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(500);\n    digitalWrite(LED_BUILTIN, LOW);\n    delay(500);"
        },
        {
          "name": "repetitionsIncrease",
          "body": "// This function will be called once on device wakeup\n  // You can do some little operations here (like changing variables which will be used in the loop)\n  // Remember to avoid calling delay() and long running functions since this functions executes in interrupt context\n  repetitions ++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Checking Connection\");\n  if (WifiConnection::isConnected()) {\n    \n    // add that value to array in the server\n    bool isOk = storage.add(\"times_alive\", millis());\n    \n    // notify if error occurred\n    if(isOk == false) {\n      Serial.println(\"Something went wrong...\");"
        }
      ]
    },
    {
      "name": "INT_FREQ",
      "keywords": [
        "Wire",
        "Serial",
        "attachInterrupt",
        "digitalWrite"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Begin Serial communication\n    Serial.begin(9600);\n    while (!Serial);\n\n    // Set the DS3231 clock mode to 24-hour\n    myRTC.setClockMode(false); // false = not using the alternate, 12-hour mode\n\n    // Set the clock to an arbitrarily chosen time of\n    // 00:00:00 midnight the morning of January 1, 2020\n    // using a suitable Unix-style timestamp\n    myRTC.setEpoch(1640995200);\n\n    // Assign parameter values for Alarm 1\n    alarmDay = myRTC.getDate();\n    alarmHour = myRTC.getHour(alarmH12, alarmPM);\n    alarmMinute = myRTC.getMinute();\n    alarmSecond = INT_FREQ; // initialize to the interval length\n    alarmBits = 0b00001110; // Alarm 1 when seconds match\n    alarmDayIsDay = false; // using date of month\n\n    // Upload initial parameters of Alarm 1\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(\n       alarmDay, alarmHour, alarmMinute, alarmSecond,\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // clear Alarm 1 flag after setting the alarm time\n    myRTC.checkIfAlarm(1);\n    // now it is safe to enable interrupt output\n    myRTC.turnOnAlarm(1);\n\n    // When using interrupt with only one of the DS3231 alarms, as in this example,\n    // it may be possible to prevent the other alarm entirely,\n    // so it will not covertly block the outgoing interrupt signal.\n\n    // Try to prevent Alarm 2 altogether by assigning a \n    // nonsensical alarm minute value that cannot match the clock time,\n    // and an alarmBits value to activate \"when minutes match\".\n    alarmMinute = 0xFF; // a value that will never match the time\n    alarmBits = 0b01100000; // Alarm 2 when minutes match, i.e., never\n    \n    // Upload the parameters to prevent Alarm 2 entirely\n    myRTC.setA2Time(\n        alarmDay, alarmHour, alarmMinute,\n        alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // disable Alarm 2 interrupt\n    myRTC.turnOffAlarm(2);\n    // clear Alarm 2 flag\n    myRTC.checkIfAlarm(2);\n\n    // NOTE: both of the alarm flags must be clear\n    // to enable output of a FALLING interrupt\n\n    // attach clock interrupt\n    pinMode(CLINT, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(CLINT), isr_TickTock, FALLING);\n\n    // Configure the LED for blinking\n    pinMode(LED_BUILTIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // Do when alarm interrupt received:\n    if (tick) {\n        // right away, capture the current time in a DateTime variable\n        // for later processing\n        DateTime alarmDT = RTClib::now();\n\n        // disable Alarm 1 interrupt\n        myRTC.turnOffAlarm(1);\n        \n        // Clear Alarm 1 flag\n        myRTC.checkIfAlarm(1);\n        \n        tick = 0; // reset the local interrupt-received flag\n        state = ~state; // reverse the state of the LED\n        digitalWrite(LED_BUILTIN, state);\n\n        // optional serial output\n        Serial.print(\"Turning LED \");\n        Serial.print((state ? \"ON\" : \"OFF\"));\n        Serial.print(\" at \");\n        Serial.print(alarmDT.hour());\n        Serial.print(\":\");\n        Serial.print(alarmDT.minute());\n        Serial.print(\":\");\n        Serial.println(alarmDT.second());\n\n        // extract the DateTime values as a timestamp \n        uint32_t nextAlarm = alarmDT.unixtime();\n        // add the INT_FREQ number of seconds\n        nextAlarm += INT_FREQ;\n        // update the DateTime with the new timestamp\n        alarmDT = DateTime(nextAlarm);\n\n        // upload the new time to Alarm 1\n       myRTC.setA1Time(\n         alarmDT.day(), alarmDT.hour(), alarmDT.minute(), alarmDT.second(),\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n       \n       // enable Alarm 1 interrupts\n       myRTC.turnOnAlarm(1);\n      // clear Alarm 1 flag again after enabling interrupts\n        myRTC.checkIfAlarm(1);"
        },
        {
          "name": "isr_TickTock",
          "body": "// interrupt signals to loop\n    tick = 1;\n    return;"
        }
      ]
    },
    {
      "name": "TRIGGER_PIN",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP  \n  Serial.begin(115200);\n  Serial.setDebugOutput(true);  \n  delay(3000);\n  Serial.println(\"\\n Starting\");\n\n  pinMode(TRIGGER_PIN, INPUT);\n  \n  // wm.resetSettings(); // wipe settings\n\n  if(wm_nonblocking) wm.setConfigPortalBlocking(false);\n\n  // add a custom input field\n  int customFieldLength = 40;\n\n\n  // new (&custom_field) WiFiManagerParameter(\"customfieldid\", \"Custom Field Label\", \"Custom Field Value\", customFieldLength,\"placeholder=\\\"Custom Field Placeholder\\\"\");\n  \n  // test custom html input type(checkbox)\n  // new (&custom_field) WiFiManagerParameter(\"customfieldid\", \"Custom Field Label\", \"Custom Field Value\", customFieldLength,\"placeholder=\\\"Custom Field Placeholder\\\" type=\\\"checkbox\\\"\"); // custom html type\n  \n  // test custom html(radio)\n  const char* custom_radio_str = \"<br/><label for='customfieldid'>Custom Field Label</label><input type='radio' name='customfieldid' value='1' checked> One<br><input type='radio' name='customfieldid' value='2'> Two<br><input type='radio' name='customfieldid' value='3'> Three\";\n  new (&custom_field) WiFiManagerParameter(custom_radio_str); // custom html input\n  \n  wm.addParameter(&custom_field);\n  wm.setSaveParamsCallback(saveParamCallback);\n\n  // custom menu via array or vector\n  // \n  // menu tokens, \"wifi\",\"wifinoscan\",\"info\",\"param\",\"close\",\"sep\",\"erase\",\"restart\",\"exit\" (sep is seperator) (if param is in menu, params will not show up in wifi page!)\n  // const char* menu[] = {\"wifi\",\"info\",\"param\",\"sep\",\"restart\",\"exit\""
        },
        {
          "name": "checkButton",
          "body": "// check for button press\n  if ( digitalRead(TRIGGER_PIN) == LOW ) {\n    // poor mans debounce/press-hold, code not ideal for production\n    delay(50);\n    if( digitalRead(TRIGGER_PIN) == LOW ){\n      Serial.println(\"Button Pressed\");\n      // still holding button for 3000 ms, reset settings, code not ideaa for production\n      delay(3000); // reset delay hold\n      if( digitalRead(TRIGGER_PIN) == LOW ){\n        Serial.println(\"Button Held\");\n        Serial.println(\"Erasing Config, restarting\");\n        wm.resetSettings();\n        ESP.restart();"
        },
        {
          "name": "saveParamCallback",
          "body": "Serial.println(\"[CALLBACK] saveParamCallback fired\");\n  Serial.println(\"PARAM customfieldid = \" + getParam(\"customfieldid\"));"
        },
        {
          "name": "loop",
          "body": "if(wm_nonblocking) wm.process(); // avoid delays() in loop when non-blocking and other long running code  \n  checkButton();\n  // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the Ethernet device\n  Ethernet.begin(ip, subnet, gateway, myDns);\n  // start listening for clients\n  server.begin();\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// wait for a new client:\n  EthernetClient client = server.available();\n\n  // when the client sends the first byte, say hello:\n  if (client) {\n\n    bool newClient = true;\n    for (byte i = 0; i < 4; i++) {\n      //check whether this client refers to the same socket as one of the existing instances:\n      if (clients[i] == client) {\n        newClient = false;\n        break;"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    WS_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "//out.reserve(ORIGINAL_STR_LEN);\n\n  pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AdvancedWebServer on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if ! (ESP32 || ESP8266)\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_ESP32_SPI2 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ETG_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  Serial.println(\"=========================\");\n  Serial.println(\"Currently Used SPI pinout:\");\n  Serial.print(\"MOSI:\");\n  Serial.println(PIN_MOSI);\n  Serial.print(\"MISO:\");\n  Serial.println(PIN_MISO);\n  Serial.print(\"SCK:\");\n  Serial.println(PIN_SCK);\n  Serial.print(\"SS:\");\n  Serial.println(USE_THIS_SS_PIN);\n  Serial.println(F(\"=========================\"));\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  if (Ethernet.getChip() == w5500)\n  {\n    Serial.print(F(\"Speed: \"));\n    Serial.print(Ethernet.speedReport());\n    Serial.print(F(\", Duplex: \"));\n    Serial.print(Ethernet.duplexReport());\n    Serial.print(F(\", Link status: \"));\n    Serial.println(Ethernet.linkReport());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n\n#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AdvancedWebServer %s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += server.uri();\n  message += \"\\nMethod: \";\n  message += (server.method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += server.args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  \n  delay(2000);\n \n  Serial.println(\"\\nStart AdvancedWebServer_LAN8720 on \" + String(BOARD_NAME) + \", using \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n  \n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  server.on(\"/\", handleRoot);\n  server.on(\"/test.svg\", drawGraph);\n  server.on(\"/inline\", []()\n  {\n    server.send(200, \"text/plain\", \"This works as well\");"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "WEBSERVER_PORT",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server->uri();\n  message += F(\"\\nMethod: \");\n  message += (server->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server->args(); i++)\n  {\n    message += \" \" + server->argName(i) + \": \" + server->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "SerialDebug.begin(115200);\n\n  while (!SerialDebug && millis() < 5000);\n\n  delay(1000);\n\n  SerialDebug.print(\"\\nStarting AdvancedWebServer_Ptr on \");\n  SerialDebug.print(BOARD_NAME);\n  SerialDebug.print(F(\" with \"));\n  SerialDebug.println(SHIELD_TYPE);\n  SerialDebug.println(ETHERNET_WEBSERVER_VERSION);\n\n#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    SerialDebug.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  SerialDebug.print(F(\".\"));\n\n  if (num == 80)\n  {\n    SerialDebug.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server->handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "initEthernet",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    Serial.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_RP2040_SPI1 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "SERIAL_PORT_MONITOR",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n  \n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf_P(temp, BUFFER_SIZE - 1,\n           PSTR(\"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  \n  String message = F(\"File Not Found\\n\\n\");\n  \n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n  \n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    AT_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n  \n  Serial.print(F(\"\\nStarting AdvancedWebServer_STM32 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE); \n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "initEthernet",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    Serial.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_Teensy4x_SPI1 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    WS_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "check_WiFi",
          "body": "#if ( defined(ARDUINO_PORTENTA_H7_M7) || defined(ARDUINO_PORTENTA_H7_M4) )\n\n  // Workaround for bug in https://github.com/arduino/ArduinoCore-mbed/issues/381\n  if ( (WiFi.status() != WL_CONNECTED) || (WiFi.RSSI() == 0) )\n#elif ( defined(ARDUINO_RASPBERRY_PI_PICO_W) )\n  if (!isWiFiConnected())\n#else\n  if ( (WiFi.status() != WL_CONNECTED) )\n#endif\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AdvancedWebServer_WiFiMulti on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFIMULTI_GENERIC_VERSION);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if ! (ESP32 || ESP8266)\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n\n  if (WiFiConnected)\n#else\n  if (WiFi.status() == WL_CONNECTED)\n#endif\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static uint32_t checkstatus_timeout  = 0;\n  static uint32_t checkwifi_timeout    = 0;\n\n  static uint32_t current_millis;\n\n#if ( defined(ARDUINO_RASPBERRY_PI_PICO_W) )\n#define WIFICHECK_INTERVAL    10000L\n#else\n#define WIFICHECK_INTERVAL    1000L\n#endif\n\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Checking Connection\");\n  if (WifiConnection::isConnected()) {\n    \n    float averageTemperture = storage.avg(\"today_temperture_samples\");\n    float highestTemperture = storage.max<float>(\"today_temperture_samples\");\n    float lowestTemperture = storage.min<float>(\"today_temperture_samples\");\n    int numSamples = storage.count(\"today_temperture_samples\");\n\n    Serial.print(\"Today's tempertures ranged from \");\n    Serial.print(lowestTemperture); \n    Serial.print(\" degrees to \");\n    Serial.print(highestTemperture);\n    Serial.println(\" degrees celsius.\");\n\n    Serial.print(\"With the average \");\n    Serial.print(averageTemperture);\n    Serial.println(\" degrees celsius.\");\n\n    Serial.print(\"Total of \");\n    Serial.print(numSamples);\n    Serial.println(\" samples.\");"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setupWiFi",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);"
        },
        {
          "name": "setupSinricPro",
          "body": "// add device to SinricPro\n  SinricProAirQualitySensor& mySinricProAirQualitySensor = SinricPro[DEVICE_ID];\n\n  // set callback function to device\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting AirQualitySensor on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();\n\n  if ((long)(millis() - dispatchTime) >= 0) \n  {\n    SinricProAirQualitySensor &mySinricProAirQualitySensor = SinricPro[DEVICE_ID]; // get sensor device\n\n    int pm1   = 0;\n    int pm2_5 = 0;\n    int pm10  = 0;\n\n    mySinricProAirQualitySensor.sendAirQualityEvent(pm1, pm2_5, pm10, \"PERIODIC_POLL\");\n    dispatchTime += MIN;\n    \n    Serial.println(\"Sending Air Quality event ..\");"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "GP2YDustSensor.h",
        "ESP8266WiFi.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setupWiFi",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);"
        },
        {
          "name": "setupSinricPro",
          "body": "// add device to SinricPro\n  SinricProAirQualitySensor& mySinricProAirQualitySensor = SinricPro[DEVICE_ID];\n\n  // set callback function to device\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setupDustSensor",
          "body": "//dustSensor.setBaseline(0.4); // set no dust voltage according to your own experiments\n  //dustSensor.setCalibrationFactor(1.1); // calibrate against precision instrument\n  dustSensor.begin();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting AirQualitySensor_GP2Y1014AU0F on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();\n\n  if ((long)(millis() - dispatchTime) >= 0) \n  {\n    Serial.print(\"Dust density: \");\n    Serial.print(dustSensor.getDustDensity());\n    Serial.print(\" ug/m3; Running average: \");\n    Serial.print(dustSensor.getRunningAverage());\n    Serial.println(\" ug/m3\");\n\n    SinricProAirQualitySensor &mySinricProAirQualitySensor = SinricPro[DEVICE_ID]; // get air q sensor device\n\n    int pm1 = 0;\n    int pm2_5 = dustSensor.getRunningAverage();\n    int pm10 = 0;\n\n    mySinricProAirQualitySensor.sendAirQualityEvent(pm1, pm2_5, pm10, \"PERIODIC_POLL\");\n    dispatchTime += MIN;\n\n    Serial.println(\"Sending Air Quality event ..\");"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  pinMode(heaterPin, OUTPUT);\n  pinMode(fanPin, OUTPUT);\n  pinMode(soilMoisturePin, INPUT);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  dhtSensor.begin();\n  \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.println(\"Connecting to WiFi...\");"
        },
        {
          "name": "loop",
          "body": "// Baca kelembapan tanah\n  int soilMoistureValue = analogRead(soilMoisturePin);\n  Serial.print(\"Soil Moisture Value: \");\n  Serial.println(soilMoistureValue);\n\n  // Tentukan kondisi kelembapan tanah\n  String soilCondition;\n  float soil_ph = 7.0; // Default nilai pH netral\n  if (soilMoistureValue < 300) {\n    soilCondition = \"Dry\";\n    soil_ph += 0.5; // Menambahkan 0.5 untuk kondisi tanah kering"
        },
        {
          "name": "handAKMMes",
          "body": "for (int i = 0; i < numNewMessages; i++) {\n    String chat_id = String(bot.messages[i].chat_id);\n    String text = bot.messages[i].text;\n\n    if (text == \"/start@AkseleratorHumanisasiKomposBot\") {\n      String welcome_message = \n          \"Selamat datang di grup! Berikut adalah perintah yang tersedia:\\n\"\n          \"/kondisi - Menampilkan kondisi suhu dan pH saat ini\\n\"\n          \"/on - Menyalakan pemanas\\n\";\n      bot.sendMessage(chat_id, welcome_message, \"\");"
        }
      ]
    },
    {
      "name": "CLINT",
      "keywords": [
        "Wire",
        "Serial",
        "attachInterrupt",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Begin Serial communication\n    Serial.begin(9600);\n    while (!Serial);\n    Serial.println();\n    Serial.println(\"Starting Serial\");\n\n    // Assign parameter values for Alarm 1\n    alarmDay = 0;\n    alarmHour = 0;\n    alarmMinute = 0;\n    alarmSecond = 0;\n    alarmBits = 0b00001111; // Alarm 1 every second\n    alarmDayIsDay = false;\n    alarmH12 = false;\n    alarmPM = false;    \n\n    // Set alarm 1 to fire at one-second intervals\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(\n       alarmDay, alarmHour, alarmMinute, alarmSecond,\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // enable Alarm 1 interrupts\n    myRTC.turnOnAlarm(1);\n    // clear Alarm 1 flag\n    myRTC.checkIfAlarm(1);\n\n    // When using interrupt with only one of the DS3231 alarms, as in this example,\n    // it may be advisable to prevent the other alarm entirely,\n    // so it will not covertly block the outgoing interrupt signal.\n\n    // Prevent Alarm 2 altogether by assigning a \n    // nonsensical alarm minute value that cannot match the clock time,\n    // and an alarmBits value to activate \"when minutes match\".\n    alarmMinute = 0xFF; // a value that will never match the time\n    alarmBits = 0b01100000; // Alarm 2 when minutes match, i.e., never\n    \n    // Upload the parameters to prevent Alarm 2 entirely\n    myRTC.setA2Time(\n        alarmDay, alarmHour, alarmMinute,\n        alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // disable Alarm 2 interrupt\n    myRTC.turnOffAlarm(2);\n    // clear Alarm 2 flag\n    myRTC.checkIfAlarm(2);\n\n    // NOTE: both of the alarm flags must be clear\n    // to enable output of a FALLING interrupt\n\n    // attach clock interrupt\n    pinMode(CLINT, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(CLINT), isr_TickTock, FALLING);\n\n    // Use builtin LED to blink\n    pinMode(LED_BUILTIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // if alarm went of, do alarm stuff\n    if (tick) {\n        tick = 0;\n        state = ~state;\n        digitalWrite(LED_BUILTIN, state);\n\n        // optional serial output\n        Serial.print(\"Turning LED \");\n        Serial.println((state ? \"ON\" : \"OFF\"));\n\n        // Clear Alarm 1 flag\n        myRTC.checkIfAlarm(1);"
        },
        {
          "name": "isr_TickTock",
          "body": "// interrupt signals to loop\n    tick = 1;\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Setup alarm one to fire every second\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(0, 0, 0, 0, 0b01111111, false, false, false);\n    myRTC.turnOnAlarm(1);\n    myRTC.checkIfAlarm(1);\n\n    // Use builtin LED to blink\n    pinMode(LED_BUILTIN, OUTPUT);\n    digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "loop",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // if alarm went of, do alarm stuff\n    // first call to checkIFAlarm does not clear alarm flag\n    if (myRTC.checkIfAlarm(1, false)) {\n        state = ~state;\n        digitalWrite(LED_BUILTIN, state);\n        // Clear alarm state\n        myRTC.checkIfAlarm(1, true);"
        }
      ]
    },
    {
      "name": "TINY_GSM_MODEM_SIM800",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h",
        "StreamDebugger.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // !!!!!!!!!!!\n  // Set your reset, enable, power pins here\n  // !!!!!!!!!!!\n\n  DBG(\"Wait...\");\n  delay(6000L);\n\n  // Set GSM module baud rate\n  TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n  // SerialAT.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  DBG(\"Initializing modem...\");\n  if (!modem.restart()) {\n    // if (!modem.init()) {\n    DBG(\"Failed to restart modem, delaying 10s and retrying\");\n    // restart autobaud in case GSM just rebooted\n    // TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // open the serial port to send the information of what you are reading\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// read all the D inputs at the Motor Board as analog\n  //analogReadB_Ds();\n\n  // read all the D inputs at the Motor Board as digital\n  //digitalReadB_Ds();\n\n  // read all the M inputs at the Control Board as analog\n  //analogReadMs();\n\n  // read all the M inputs at the Control Board as digital\n  //digitalReadMs();\n\n  // read all the D inputs at the Control Board as analog\n  analogReadT_Ds();\n\n  // read all the D inputs at the Control Board as digital\n  //digitalReadT_Ds();\n\n  // write all the D outputs at the Motor Board as digital\n  //digitalWriteB_Ds();\n\n  // write all the D outputs at the Control Board as digital\n  //digitalWriteT_Ds();\n  delay(40);"
        },
        {
          "name": "analogReadMs",
          "body": "for (int i = 0; i < 8; i++) {\n    Serial.print(Robot.analogRead(arr[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalReadMs",
          "body": "for (int i = 0; i < 8; i++) {\n    Serial.print(Robot.digitalRead(arr[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "analogReadT_Ds",
          "body": "for (int i = 0; i < 6; i++) {\n    Serial.print(Robot.analogRead(arr2[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalReadT_Ds",
          "body": "for (int i = 0; i < 6; i++) {\n    Serial.print(Robot.digitalRead(arr2[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalWriteT_Ds",
          "body": "// turn all the pins on\n  for (int i = 0; i < 6; i++) {\n    Robot.digitalWrite(arr2[i], HIGH);"
        },
        {
          "name": "digitalWriteB_Ds",
          "body": "// turn all the pins on\n  for (int i = 0; i < 4; i++) {\n    Robot.digitalWrite(arr3[i], HIGH);"
        },
        {
          "name": "analogReadB_Ds",
          "body": "for (int i = 0; i < 4; i++) {\n    Serial.print(Robot.analogRead(arr3[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalReadB_Ds",
          "body": "for (int i = 0; i < 4; i++) {\n    Serial.print(Robot.digitalRead(arr3[i]));\n    Serial.print(\",\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogRead"
      ],
      "libraries": [
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "sendPort",
          "body": "portValue = portValue & portStatus[portNumber];\n  if (previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;"
        },
        {
          "name": "setup",
          "body": "byte i, port, status;\n\n  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n\n  for (pin = 0; pin < TOTAL_PINS; pin++) {\n    if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT);"
        },
        {
          "name": "loop",
          "body": "byte i;\n\n  for (i = 0; i < TOTAL_PORTS; i++) {\n    sendPort(i, readPort(i, 0xff));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  MIDI.begin(4);                    // Launch MIDI and listen to channel 4"
        },
        {
          "name": "loop",
          "body": "if (MIDI.read())                  // If we have received a message\n  {\n    digitalWrite(LED_BUILTIN, HIGH);\n    MIDI.sendNoteOn(42, 127, 1);    // Send a Note (pitch 42, velo 127 on channel 1)\n    delay(1000);                    // Wait for a second\n    MIDI.sendNoteOff(42, 0, 1);     // Stop the note\n    digitalWrite(LED_BUILTIN, LOW);"
        }
      ]
    },
    {
      "name": "HOST",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "QNEthernet.h",
        "lwip/altcp_tcp.h",
        "mbedtls.h",
        "lwip/altcp_tls.h",
        "lwip/apps/altcp_proxyconnect.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial"
        },
        {
          "name": "loop",
          "body": "// Read the response\n  if (client.connected()) {\n    int avail = client.available();\n    if (avail > 0) {\n      dataCount += avail;\n      for (int i = 0; i < avail; i++) {\n        putc(client.read(), stdout);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor.\");"
        },
        {
          "name": "loop",
          "body": "// check if a color reading is available\n  while (! APDS.colorAvailable()) {\n    delay(5);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor!\");"
        },
        {
          "name": "loop",
          "body": "if (APDS.gestureAvailable()) {\n    // a gesture was detected, read and print to Serial Monitor\n    int gesture = APDS.readGesture();\n\n    switch (gesture) {\n      case GESTURE_UP:\n        Serial.println(\"Detected UP gesture\");\n        break;\n\n      case GESTURE_DOWN:\n        Serial.println(\"Detected DOWN gesture\");\n        break;\n\n      case GESTURE_LEFT:\n        Serial.println(\"Detected LEFT gesture\");\n        break;\n\n      case GESTURE_RIGHT:\n        Serial.println(\"Detected RIGHT gesture\");\n        break;\n\n      default:\n        // ignore\n        break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor!\");"
        },
        {
          "name": "loop",
          "body": "// check if a proximity reading is available\n  if (APDS.proximityAvailable()) {\n    // read the proximity\n    // - 0   => close\n    // - 255 => far\n    // - -1  => error\n    int proximity = APDS.readProximity();\n\n    // print value to the Serial Monitor\n    Serial.println(proximity);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoSound.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial communications and wait for port to open:\n  // A baud rate of 115200 is used instead of 9600 for a faster data rate\n  // on non-native USB ports\n  Serial.begin(115200);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// check if a new analysis is available\n  if (amplitudeAnalyzer.available()) {\n    // read the new amplitude\n    int amplitude = amplitudeAnalyzer.read();\n\n    // print out the amplititude to the serial monitor\n    Serial.println(amplitude);"
        }
      ]
    },
    {
      "name": "ROUND_SAMPLE_INTERVAL",
      "keywords": [
        "digitalWrite",
        "delay",
        "Serial",
        "analogRead"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "fatalBlink",
          "body": "while (true) {\n    if (ERROR_LED_PIN >= 0) {\n      digitalWrite(ERROR_LED_PIN, HIGH);\n      delay(200);\n      digitalWrite(ERROR_LED_PIN, LOW);\n      delay(200);"
        },
        {
          "name": "adcInit",
          "body": "uint8_t adps;  // prescaler bits for ADCSRA\n  uint32_t ticks = F_CPU*SAMPLE_INTERVAL + 0.5;  // Sample interval cpu cycles.\n\n  if (ADC_REF & ~((1 << REFS0) | (1 << REFS1))) {\n    error(\"Invalid ADC reference\");"
        },
        {
          "name": "adcStart",
          "body": "// initialize ISR\n  isrBufNeeded = true;\n  isrOver = 0;\n  adcindex = 1;\n\n  // Clear any pending interrupt.\n  ADCSRA |= 1 << ADIF;\n\n  // Setup for first pin.\n  ADMUX = adcmux[0];\n  ADCSRB = adcsrb[0];\n  ADCSRA = adcsra[0];\n\n  // Enable timer1 interrupts.\n  timerError = false;\n  timerFlag = false;\n  TCNT1 = 0;\n  TIFR1 = 1 << OCF1B;\n  TIMSK1 = 1 << OCIE1B;"
        },
        {
          "name": "adcStop",
          "body": "TIMSK1 = 0;\n  ADCSRA = 0;"
        },
        {
          "name": "binaryToCsv",
          "body": "uint8_t lastPct = 0;\n  block_t buf;\n  metadata_t* pm;\n  uint32_t t0 = millis();\n  char csvName[13];\n  StdioStream csvStream;\n\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "checkOverrun",
          "body": "bool headerPrinted = false;\n  block_t buf;\n  uint32_t bgnBlock, endBlock;\n  uint32_t bn = 0;\n\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "dumpData",
          "body": "block_t buf;\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "logData",
          "body": "uint32_t bgnBlock, endBlock;\n\n  // Allocate extra buffer space.\n  block_t block[BUFFER_BLOCK_COUNT];\n\n  Serial.println();\n\n  // Initialize ADC and timer1.\n  adcInit((metadata_t*) &block[0]);\n\n  // Find unused file name.\n  if (BASE_NAME_SIZE > 6) {\n    error(\"FILE_BASE_NAME too long\");"
        },
        {
          "name": "setup",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// Read any Serial data.\n  do {\n    delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogWrite",
        "EEPROM",
        "analogRead"
      ],
      "libraries": [
        "Servo.h",
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "analogWriteCallback",
          "body": "switch (pin) {\n    case 9: servo9.write(value); break;\n    case 10: servo10.write(value); break;\n    case 3:\n    case 5:\n    case 6:\n    case 11: // PWM pins\n      analogWrite(pin, value);\n      break;"
        },
        {
          "name": "reportAnalogCallback",
          "body": "if (value == 0) {\n    analogInputsToReport = analogInputsToReport & ~ (1 << pin);"
        },
        {
          "name": "setup",
          "body": "Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);\n\n  servo9.attach(9);\n  servo10.attach(10);\n  Firmata.begin(57600);"
        },
        {
          "name": "loop",
          "body": "while (Firmata.available())\n    Firmata.processInput();\n  currentMillis = millis();\n  if (currentMillis - previousMillis > 20) {\n    previousMillis += 20;                   // run this every 20ms\n    for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) {\n      if ( analogInputsToReport & (1 << analogPin) )\n        Firmata.sendAnalog(analogPin, analogRead(analogPin));"
        }
      ]
    },
    {
      "name": "SD_CHIP_SELECT",
      "keywords": [
        "delay",
        "Serial",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "SPI.h",
        "Wire.h",
        "RTClib.h"
      ],
      "functions": [
        {
          "name": "dateTime",
          "body": "DateTime now = RTC.now();\n\n  // return date using FAT_DATE macro to format fields\n  *date = FAT_DATE(now.year(), now.month(), now.day());\n\n  // return time using FAT_TIME macro to format fields\n  *time = FAT_TIME(now.hour(), now.minute(), now.second());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial.\n  while (!Serial) {\n    yield();"
        },
        {
          "name": "loop",
          "body": "uint32_t m;\n\n  // wait for time to be a multiple of interval\n  do {\n    m = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//analog_out.period_ms(CHANNEL, PERIOD_MILLISECONDS);\n  analog_out.period_ms(0, 4);\n  analog_out.period_ms(1, 4);\n  analog_out.period_ms(2, 4);\n  analog_out.period_ms(3, 4);\n  \n  Serial.begin(9600);\n  Serial.println(\"Analog out test\");"
        },
        {
          "name": "loop",
          "body": "//analog_out.write(CHANNEL, OUTPUT_VOLTAGE_VALUE);\n  analog_out.write(0, counter);\n  analog_out.write(1, counter);\n  analog_out.write(2, counter);\n  analog_out.write(3, counter);\n  Serial.println(\"All channels set at \"+String(counter)+\"V\");\n  \n  counter = counter + 0.1;\n  //Maximum output value is 10.4V\n  if (counter >= 10.5)\n  {\n    counter = 0;\n    //Additional 100 ms delay introduced to manage 10.5V -> 0V fall time of 150 ms\n    delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.set0_10V();"
        },
        {
          "name": "loop",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH0: \");\n  Serial.print(voltage_ch0, 3);\n  Serial.println(\"V\");\n\n  float raw_voltage_ch1 = analog_in.read(1);\n  float voltage_ch1 = (raw_voltage_ch1 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH1: \");\n  Serial.print(voltage_ch1, 3);\n  Serial.println(\"V\");\n\n  float raw_voltage_ch2 = analog_in.read(2);\n  float voltage_ch2 = (raw_voltage_ch2 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH2: \");\n  Serial.print(voltage_ch2, 3);\n  Serial.println(\"V\");\n  Serial.println();\n  delay(250);"
        }
      ]
    },
    {
      "name": "SENSE_RES",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.set4_20mA();"
        },
        {
          "name": "loop",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535;\n  float current_ch0 = (voltage_ch0 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH0: \");\n  Serial.print(current_ch0);\n  Serial.println(\"mA\");\n\n  float raw_voltage_ch1 = analog_in.read(1);\n  float voltage_ch1 = (raw_voltage_ch1 * reference) / 65535;\n  float current_ch1 = (voltage_ch1 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH1: \");\n  Serial.print(current_ch1);\n  Serial.println(\"mA\");\n  float raw_voltage_ch2 = analog_in.read(2);\n  float voltage_ch2 = (raw_voltage_ch2 * reference) / 65535;\n  float current_ch2 = (voltage_ch2 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH2: \");\n  Serial.print(current_ch2);\n  Serial.println(\"mA\");\n\n  Serial.println();\n  delay(250);"
        }
      ]
    },
    {
      "name": "REFERENCE_RES",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.setNTC();"
        },
        {
          "name": "loop",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535;\n  float resistance_ch0;\n  Serial.print(\"Resistance CH0: \");\n  if (voltage_ch0 < lowest_voltage) {\n    resistance_ch0 = ((-REFERENCE_RES) * voltage_ch0) / (voltage_ch0 - reference);\n    Serial.print(resistance_ch0);\n    Serial.println(\" ohm\");"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    if (app.ready() && (millis() - ms > 30 * 1000 || ms == 0))\n    {\n        cnt++;\n        ms = millis();\n\n        Serial.println(\"App is authenticated as anonymous...\");\n        Firebase.printf(\"User UID: %s\\n\", app.getUid().c_str());\n\n        app.isAuthenticated();\n\n        if (cnt == 3)\n        {\n            Serial.println(\"Deleting anonymous user...\");\n            UserAccount user(API_KEY);\n            deleteUser(aClient, app, getAuth(user.idToken(app.getToken())), aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\tWiFiManager wifiManager;\n\n\t// wifiManager.setAPCallback([this](WiFiManager* wifiManager) {\n\twifiManager.setAPCallback([&](WiFiManager* wifiManager) {\n\t\tSerial.printf(\"Entered config mode:ip=%s, ssid='%s'\\n\", \n                        WiFi.softAPIP().toString().c_str(), \n                        wifiManager->getConfigPortalSSID().c_str());\n\t\t_enteredConfigMode = true;"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && signupOK && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = auth.token.uid.c_str(); //<- user uid\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());\n\n        if (count == 10)\n        {\n            Serial.print(\"Delete user... \");\n            if (Firebase.deleteUser(&config, &auth /* third argument can be the id token of active user to delete or leave it blank to delete current user */))\n            {\n                Serial.println(\"ok\");"
        }
      ]
    },
    {
      "name": "DEBUG",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "#if DEBUG\n  Serial.begin(115200);\n  BHY2.debug(Serial);\n#endif\n\n  BHY2.begin();"
        },
        {
          "name": "loop",
          "body": "// Update and then sleep\n  BHY2.update(100);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 31, 140), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "DEBUG",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "#if DEBUG\n  Serial.begin(115200);\n  BHY2.debug(Serial);\n#endif\n\n  BHY2.begin();"
        },
        {
          "name": "loop",
          "body": "// Update and then sleep only for 1ms\n  BHY2.update(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "QNEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize Serial output\n  Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial"
        },
        {
          "name": "setNetworkReady",
          "body": "networkReadyLatch = hasIP && hasLink && interfaceUp;\n\n  printf(\"Network is%s READY\\r\\n\", networkReadyLatch ? \"\" : \" NOT\");\n\n  // To successfully perform network startup tasks, test the latch\n  // somewhere in the main loop, and, if it is true, perform any\n  // network tasks and then set the latch to false. No network calls\n  // should be done from inside a listener.\n\n  // Similar logic could be applied for when the network is not ready.\n\n  // Servers technically only need the address state because they can\n  // be brought up and active even when there's no link or no active\n  // network interface, unlike clients and connections, which require\n  // all of an address, link, and active network interface."
        },
        {
          "name": "loop",
          "body": "// *** Main program code goes here\n\n  // Perform any network startup:\n  if (networkReadyLatch) {\n    // *** Do any network startup tasks that must run when the network\n    // *** comes up\n    networkReadyLatch = false;"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append array)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document\";\n        String fieldPath = \"appended_data\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // array value to append\n        Values::ArrayValue arrV(Values::IntegerValue((int)rand()));\n        arrV.add(Values::StringValue(\"word don't come easy \" + String(counter)));\n\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue(arrV);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, appendValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        Writes writes(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // Another array value to append\n        Values::ArrayValue arrV2(Values::DoubleValue((int)rand() * 1.234));\n        arrV2.add(Values::StringValue(\"never gonna give you up \" + String(counter)));\n        // Another append array object\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue2(arrV2);\n        // Another field transform\n        FieldTransform::FieldTransform fieldTransforms2(fieldPath, appendValue2);\n        // Another doc transform\n        DocumentTransform transform2(documentPath, fieldTransforms2);\n        // Add another Write object of another transform to the Writes object\n        writes.add(Write(transform2, Precondition()));\n\n        // All Writes, Write, DocumentTransform FieldTransform::xxx, and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append map value in document)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // Map value to append\n        Values::MapValue mapV(\"key\" + String(counter), Values::IntegerValue(counter));\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV));\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */));\n\n        // All Writes, Document and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append array)... \");\n\n        String documentPath = \"test_collection/test_document\";\n        String fieldPath = \"appended_map_array\";\n\n        // map in array value to append\n        Values::MapValue mapV(\"id\", Values::StringValue(\"item\" + String(counter)));\n        mapV.add(\"status\", Values::BooleanValue(counter % 2 == 0));\n\n        Values::ArrayValue arrV(mapV);\n\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue(arrV);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, appendValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        Writes writes(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // All Writes, Write, DocumentTransform FieldTransform::xxx, and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append map value in document)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document_map_value_timestamp\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // Map value to append\n        Values::MapValue mapV(\"name\", Values::StringValue(\"value\" + String(counter)));\n        mapV.add(\"count\", Values::StringValue(String(counter)));\n\n        Values::MapValue mapV2(\"key\" + String(counter), mapV);\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV2));\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */));\n\n        String fieldPath = \"myMap.key\" + String(counter) + \".timestamp\";\n        // See https://firebase.google.com/docs/firestore/reference/rest/v1/Write#servervalue\n        FieldTransform::SetToServerValue setValue(FieldTransform::REQUEST_TIME);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, setValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        writes.add(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // All Writes, DocumentTransform and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); \n\n  EEPROM.begin();                                               \n\n  EEPROM.write(0, test);                              // write data to address 0\n  test_recieve = EEPROM.read(0, test_size);           // read data from address 0, of ul size\n  Serial.println(test_recieve);\n\n  EEPROM.write(0 + test_size, test);                  // repeat, adding size to last address\n  test_recieve = EEPROM.read(0, test_size);\n  Serial.print(test_recieve);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "EE_FILE",
      "keywords": [
        "EEPROM",
        "delay"
      ],
      "libraries": [
        "MicroGamer.h",
        "MicroGamerMemoryCard.h",
        "MicroGamerTones.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "mg.begin();\n  mg.setFrameRate(40);\n  mg.initRandomSeed();"
        },
        {
          "name": "loop",
          "body": "// pause render until it's time for the next frame\n  if (!(mg.nextFrame()))\n    return;\n\n  //Title screen loop switches from title screen\n  //and high scores until FIRE is pressed\n  while (!start)\n  {\n    start = titleScreen();\n    if (!start)\n    {\n      start = displayHighScores(EE_FILE);"
        },
        {
          "name": "movePaddle",
          "body": "//Move right\n  if(xPaddle < WIDTH - 12)\n  {\n    if (mg.pressed(RIGHT_BUTTON))\n    {\n      xPaddle+=2;"
        },
        {
          "name": "moveBall",
          "body": "tick++;\n  if(released)\n  {\n    //Move ball\n    if (abs(dx)==2) {\n      xb += dx/2;\n      // 2x speed is really 1.5 speed\n      if (tick%2==0)\n        xb += dx/2;"
        },
        {
          "name": "drawBall",
          "body": "// mg.setCursor(0,0);\n  // mg.print(mg.cpuLoad());\n  // mg.print(\"  \");\n  mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n\n  moveBall();\n\n  mg.drawPixel(xb,   yb,   1);\n  mg.drawPixel(xb+1, yb,   1);\n  mg.drawPixel(xb,   yb+1, 1);\n  mg.drawPixel(xb+1, yb+1, 1);"
        },
        {
          "name": "drawPaddle",
          "body": "mg.drawRect(xPaddle, 63, 11, 1, 0);\n  movePaddle();\n  mg.drawRect(xPaddle, 63, 11, 1, 1);"
        },
        {
          "name": "drawGameOver",
          "body": "mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n  mg.setCursor(37, 42);\n  mg.print(\"Game Over\");\n  mg.setCursor(31, 56);\n  mg.print(\"Score: \");\n  mg.print(score);\n  mg.display();\n  delay(4000);"
        },
        {
          "name": "pause",
          "body": "paused = true;\n  //Draw pause to the screen\n  mg.setCursor(52, 45);\n  mg.print(\"PAUSE\");\n  mg.display();\n  while (paused)\n  {\n    delay(150);\n    //Unpause if FIRE is pressed\n    pad2 = mg.pressed(Y_BUTTON) || mg.pressed(X_BUTTON);\n    if (pad2 == true && oldpad2 == false && released)\n    {\n        mg.fillRect(52, 45, 30, 11, 0);\n\n        paused=false;"
        },
        {
          "name": "Score",
          "body": "score += (level*10);"
        },
        {
          "name": "newLevel",
          "body": "//Undraw paddle\n  mg.drawRect(xPaddle, 63, 11, 1, 0);\n\n  //Undraw ball\n  mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n\n  //Alter various variables to reset the game\n  xPaddle = 54;\n  yb = 60;\n  brickCount = 0;\n  released = false;\n\n  //Draws new bricks and resets their values\n  for (byte row = 0; row < 4; row++) {\n    for (byte column = 0; column < 13; column++)\n    {\n      isHit[row][column] = false;\n      mg.drawRect(10*column, 2+6*row, 8, 4, 1);"
        },
        {
          "name": "enterInitials",
          "body": "byte index = 0;\n\n  mg.clear();\n\n  initials[0] = ' ';\n  initials[1] = ' ';\n  initials[2] = ' ';\n\n  while (true)\n  {\n    mg.display();\n    mg.clear();\n\n    mg.setCursor(16,0);\n    mg.print(\"HIGH SCORE\");\n    sprintf(text_buffer, \"%u\", score);\n    mg.setCursor(88, 0);\n    mg.print(text_buffer);\n    mg.setCursor(56, 20);\n    mg.print(initials[0]);\n    mg.setCursor(64, 20);\n    mg.print(initials[1]);\n    mg.setCursor(72, 20);\n    mg.print(initials[2]);\n    for(byte i = 0; i < 3; i++)\n    {\n      mg.drawLine(56 + (i*8), 27, 56 + (i*8) + 6, 27, 1);"
        },
        {
          "name": "enterHighScore",
          "body": "// Each block of EEPROM has 7 high scores, and each high score entry\n  // is 5 bytes long:  3 bytes for initials and two bytes for score.\n  int address = file * 7 * 5 + EEPROM_STORAGE_SPACE_START;\n  byte hi, lo;\n  char tmpInitials[3];\n  unsigned int tmpScore = 0;\n\n  mem.load();\n\n  // High score processing\n  for(byte i = 0; i < 7; i++)\n  {\n    hi = mem.read(address + (5 * i));\n    lo = mem.read(address + (5 * i) + 1);\n    if ((hi == 0xFF) && (lo == 0xFF))\n    {\n      // The values are uninitialized, so treat this entry\n      // as a score of 0.\n      tmpScore = 0;"
        },
        {
          "name": "playTone",
          "body": "if (mg.audio.enabled() == true)\n  {\n    audio.tone( frequency, duration);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduTFLite.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize serial communications and wait for Serial Monitor to be opened\n  Serial.begin(9600);\n  while(!Serial);\n\n  Serial.println(\"Sine(x) function inference example.\");\n  Serial.println(\"Initializing TensorFlow Lite Micro Interpreter...\");\n  if (!modelInit(model, tensor_arena, kTensorArenaSize)){\n    Serial.println(\"Model initialization failed!\");\n    while(true);"
        },
        {
          "name": "loop",
          "body": "// Check if a value was sent from Serial Monitor\n  // if so, 'sanitize' the input and perform inference\n  if (Serial.available()){\n    String inputValue = Serial.readString();\n    float x = inputValue.toFloat(); // evaluates to zero if the user input is not a valid number\n    Serial.print(\"Your input value: \");\n    Serial.println(x);\n    // The model was trained in range 0 to 2*Pi\n    // if the value provided by user is not in this range\n    // the value is corrected substituting edge values\n    if (x<0) x = 0;\n    if (x >6.28) x = 6.28;\n    Serial.print(\"Adapted input value: \");\n    Serial.println(x);\n  \n    // Place the value in the model's input tensor\n    modelSetInput(x,0);\n\n    // Run inference, and report if an error occurs\n    if(!modelRunInference()){\n          Serial.println(\"RunInference Failed!\");\n          return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AccessoryShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize Serial comunication\n  Serial.begin(9600);\n  // wait for the serial port to connect, Needed for USB native only\n  while(!Serial) ;\n  // initialize the Accessory Shield library\n  accessoryShield.begin();"
        },
        {
          "name": "loop",
          "body": "// get temperarture in degrees Celsius\n  tempC = accessoryShield.getTemperature(DHT11_TEMP_CELSIUS);\n  // convert temperature from Celsius to Fareneith \n  tempF = accessoryShield.convertTempCtoF(tempC);\n  // convert temperature from Celsius to Kelvin\n  tempK = accessoryShield.convertTempCtoK(tempC);\n  // check if we have got valid values\n  if((tempC != NAN) && (tempF != NAN) && (tempK != NAN)) {\n    // print temperature in degrees Celsius\n    Serial.print(\"Temperature in Celsius degrees : \");\n    Serial.print(tempC);\n    Serial.println(\" C\");\n    // print temperature in degrees Fareneith\n    Serial.print(\"Temperature in Fareneith degrees : \");\n    Serial.print(tempF);\n    Serial.println(\" F\");\n    // print temperature in degrees Kelvin\n    Serial.print(\"Temperature in Kelvin degrees : \");\n    Serial.print(tempK);\n    Serial.println(\" K\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onSwitchButtonChange",
          "body": "if (switchButton)\n  {\n    location = Location(latMov, lonMov);\n    color    = Color(hueRed, satRed, briRed);"
        },
        {
          "name": "onColorChange",
          "body": "Serial.print(\"Hue = \");\n  Serial.println(color.getValue().hue);\n  Serial.print(\"Sat = \");\n  Serial.println(color.getValue().sat);\n  Serial.print(\"Bri = \");\n  Serial.println(color.getValue().bri);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();\n  potentiometer = analogRead(A0);\n  seconds = millis() / 1000;"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "// When OTA is available, stay there until it completes.\n  // The rest of the loop() does not run and the sketch\n  // restarts automatically at the end of the OTA process.\n  while (block_for_ota) {\n    ArduinoCloud.update();\n    if (ota_started) {\n      Serial.print(\"Waiting for OTA to finish...\");\n      ota_started = false;"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "doThisOnConnect",
          "body": "/* add your custom code here */\n  Serial.println(\"Board successfully connected to Arduino IoT Cloud\");"
        },
        {
          "name": "doThisOnSync",
          "body": "/* add your custom code here */\n  Serial.println(\"Thing Properties synchronised\");"
        },
        {
          "name": "doThisOnDisconnect",
          "body": "/* add your custom code here */\n  Serial.println(\"Board disconnected from Arduino IoT Cloud\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "ATTN_PIN",
      "keywords": [
        "Serial",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [
        "Notecard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();\n  potentiometer = analogRead(A0);\n  seconds = millis() / 1000;"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize the serial port and wait up to 5 seconds for a connection */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "setupOneShotSchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = startingFrom + ( DAYS * 1 );\n  ScheduleTimeType activePeriod = MINUTES * 5;\n\n  /* Warning: there is no cross check between until and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createOneShotScheduleConfiguration();\n\n  oneShot = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupMinuteSchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = startingFrom + ( DAYS * 1 );\n  ScheduleTimeType activePeriod = SECONDS * 15;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Minutes, repetitionPeriod);\n\n  minute = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupHourlySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = MINUTES * 20;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Hours, repetitionPeriod);\n\n  hourly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupDailySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = HOURS * 2;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Days, repetitionPeriod);\n\n  daily = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupWeeklySchedule",
          "body": "unsigned int startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  unsigned int until = startingFrom + ( DAYS * 30 );\n  unsigned int executionPeriod = MINUTES * 3;\n\n  ScheduleWeeklyMask WeeklyMask = {\n    ScheduleState::Inactive,   /* Sunday */\n    ScheduleState::Active,     /* Monday */\n    ScheduleState::Inactive,   /* Tuesday */\n    ScheduleState::Active,     /* Wednesday */\n    ScheduleState::Inactive,   /* Thursday */\n    ScheduleState::Active,     /* Friday */\n    ScheduleState::Inactive,   /* Saturday */"
        },
        {
          "name": "setupMonthlySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = DAYS * 1;\n  int dayOfMonth = 3;\n\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createMonthlyScheduleConfiguration(dayOfMonth);\n\n  monthly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupYearlySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 06 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2041 Nov 06 13:00:00\");\n  ScheduleTimeType activePeriod = DAYS * 2;\n  int dayOfMonth = 6;\n\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createYearlyScheduleConfiguration(ScheduleMonth::Nov, dayOfMonth);\n\n  yearly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();\n\n  /* Print a message when the oneShot schedule is active */\n  if(oneShot.isActive()) {\n    Serial.println(\"One shot schedule is active\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  unsigned long serialBeginTime = millis();\n  while (!Serial && (millis() - serialBeginTime <= 5000));\n\n  Serial.println(\"Starting Arduino IoT Cloud Example\");\n\n  initProperties();\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onBoolPropertyChange",
          "body": "Serial.println(\"'onBoolPropertyChange'\");"
        },
        {
          "name": "onIntPropertyChange",
          "body": "Serial.println(\"'onIntPropertyChange'\");"
        },
        {
          "name": "onFloatPropertyChange",
          "body": "Serial.println(\"'onFloatPropertyChange'\");"
        },
        {
          "name": "onStringPropertyChange",
          "body": "Serial.println(\"'onStringPropertyChange'\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Display.begin();\n  \n  Display.beginDraw();\n  Display.background(255, 255, 255);\n  Display.clear();\n  Display.fill(0x008184);\n  Display.circle(Display.width()/2, Display.height()/2, 300);\n  Display.stroke(255, 255, 255);\n  Display.noFill();\n  for (int i=0; i<30; i++) {\n    Display.circle((Display.width()/2)-55+5, Display.height()/2, 110-i);\n    Display.circle((Display.width()/2)+55-5, Display.height()/2, 110-i);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoMqttClient.h",
        "Arduino.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "ESP8266WiFi.h",
        "WiFi.h",
        "FirebaseJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "if (!mqttReady)\n        return;\n\n    mqttClient.poll();\n\n    if (millis() - lastMillis > 1000)\n    {\n        lastMillis = millis();\n\n        Serial.print(\"Sending message to topic: \");\n\n        Serial.println(topic);\n\n        FirebaseJson json;\n        json.add(\"abc\", count);\n        json.add(\"def\", count % 5 == 0);\n\n        json.toString(Serial);\n        Serial.println();\n\n        // send message, the Print interface can be used to set the message contents\n        mqttClient.beginMessage(topic);\n\n        json.toString(mqttClient);\n\n        mqttClient.endMessage();\n        count++;"
        }
      ]
    },
    {
      "name": "PROG_VERSION",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "TFT_eSPI.h",
        "Button2.h",
        "menu.h",
        "menuIO/serialIO.h",
        "menuIO/TFT_eSPIOut.h",
        "menuIO/chainStream.h",
        "menuIO/esp8266Out.h"
      ],
      "functions": [
        {
          "name": "button_init",
          "body": "btnUp.setLongClickHandler([](Button2 & b) {\n        // Select\n        unsigned int time = b.wasPressedFor();\n        if (time >= 1000) {\n          nav.doNav(enterCmd);"
        },
        {
          "name": "button_loop",
          "body": "// Check for button presses\n    btnUp.loop();\n    btnDwn.loop();"
        },
        {
          "name": "setup",
          "body": "//options=&myOptions;//can customize options\n  Serial.begin(115200); // Set Serial baudrate at 115200\n  while(!Serial);\n  Serial.flush();\n  Serial.println();\n  Serial.print(\"ARDUINOMENU DEMO V\");\n  Serial.print(PROG_VERSION);\n  Serial.println(\" FOR LILYGO TTGO T-DISPLAY\");\n\n  nav.idleTask=idle;//point a function to be used when menu is suspended\n  mainMenu[1].disable();\n  //outGfx.usePreview=true;//reserve one panel for preview?\n  //nav.showTitle=false;//show menu title?\n\n  //SPI.begin(); // Leave this commented or else there will be nothing shown on the screen.\n  gfx.init(); // Initialize the screen.\n\n  Serial.print(\"Configuring PWM for TFT backlight... \");\n  ledcSetup(pwmLedChannelTFT, pwmFreq, pwmResolution);\n  ledcAttachPin(TFT_BL, pwmLedChannelTFT);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Setting PWM for TFT backlight to default intensity... \");\n  ledcWrite(pwmLedChannelTFT, ledBacklight);\n  Serial.println(\"DONE\");\n\n  gfx.setRotation(1); // Rotate display a quarter clockwise\n\n  gfx.setTextSize(2);\n  gfx.setTextWrap(false);\n  gfx.fillScreen(Black);\n\n  Serial.print(\"Showing bootlogo... \");\n  gfx.setSwapBytes(true);\n  gfx.pushImage(0, 0,  240, 135, bootlogo);\n  delay(1000);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Initialize buttons... \");\n  button_init();\n  delay(1000);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Initialize external led... \");\n  if(LED_CTRL > 0){\n    pinMode(LED_CTRL,OUTPUT);\n    digitalWrite(LED_CTRL,ledCtrl);\n    delay(500);\n    Serial.println(\"DONE\");"
        },
        {
          "name": "loop",
          "body": "button_loop();\n  nav.poll();//this device only draws when needed\n\n  // External connected led\n  if(LED_CTRL > 0){ // Only set led state when a pinnumber for the external led has been provided.\n    digitalWrite(LED_CTRL,ledCtrl);"
        }
      ]
    },
    {
      "name": "NUM_GESTURES",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino_LSM9DS1.h",
        "Arduino_BMI270_BMM150.h",
        "ArduTFLite.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  // init IMU sensor\n  if (!IMU.begin()) {\n    Serial.println(\"IMU sensor init failed!\");\n    while (true); // stop program here."
        },
        {
          "name": "loop",
          "body": "float aX, aY, aZ, gX, gY, gZ;\n\n  // wait for a significant movement\n  while (true) {\n    if (IMU.accelerationAvailable()) {\n      // read linear acceleration\n      IMU.readAcceleration(aX, aY, aZ);\n\n      // compute absolute value of total acceleration\n      float aSum = fabs(aX) + fabs(aY) + fabs(aZ);\n\n      // if total absolute acceleration is over the threshold a gesture has started\n      if (aSum >= accelerationThreshold) {\n        samplesRead = 0; // init samples counter\n        break; // exit from waiting cycle"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    redkea.begin(ssid, pass, deviceID);"
        },
        {
          "name": "loop",
          "body": "redkea.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    redkea.begin(ssid, pass, deviceID);"
        },
        {
          "name": "loop",
          "body": "redkea.loop();"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "BlynkSimpleCurieBLE.h",
        "CurieBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  delay(1000);\n\n  blePeripheral.setLocalName(\"Blynk\");\n  blePeripheral.setDeviceName(\"Blynk\");\n  blePeripheral.setAppearance(384);\n\n  Blynk.begin(blePeripheral, auth);\n\n  blePeripheral.begin();\n\n  Serial.println(\"Waiting for connections...\");"
        },
        {
          "name": "loop",
          "body": "blePeripheral.poll();\n  Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "mySerial.begin(9600);\n  Debug.setDebugOutputStream(&mySerial);\n  Debug.setDebugLevel(DBG_VERBOSE);\n  Debug.timestampOn();"
        },
        {
          "name": "loop",
          "body": "DEBUG_VERBOSE(\"i = %d\", i);\n  i++;\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Debug.timestampOn();"
        },
        {
          "name": "loop",
          "body": "DEBUG_INFO(\"i = %d\", i);\n  i++;\n  delay(1000);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet2.h",
        "BlynkSimpleEthernet2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, \"blynk-cloud.com\", 80);\n  //Blynk.begin(auth, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, server_ip, 8080, arduino_ip, dns_ip, gateway_ip, subnet_mask, arduino_mac);\n  // Or like this:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80, arduino_ip, dns_ip, gateway_ip, subnet_mask, arduino_mac);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "GSM.h"
      ],
      "functions": [
        {
          "name": "connectNetwork",
          "body": "Serial.println(\"Connecting to GSM...\");\n  bool status = false;\n\n  // After starting the modem with GSM.begin()\n  // attach the shield to the GPRS network with the APN, login and password\n  while (status == false) {\n    if ((gsmAccess.begin(PINNUMBER) == GSM_READY) &\n        (gprs.attachGPRS(GPRS_APN, GPRS_LOGIN, GPRS_PASSWORD) == GPRS_READY)) {\n      status = true;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  delay(10);\n  Serial.println();\n  Serial.println();\n\n  connectNetwork();"
        },
        {
          "name": "loop",
          "body": "String response;\n\n  unsigned long value = millis();\n\n  // Send value to the cloud\n  // similar to Blynk.virtualWrite()\n\n  Serial.print(\"Sending value: \");\n  Serial.println(value);\n\n  if (httpRequest(\"GET\", String(\"/external/api/update?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2&value=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "BlynkSimpleMKR1000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFiNINA.h",
        "BlynkSimpleWiFiNINA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "BlynkMultiClient.h",
        "SPI.h",
        "Ethernet.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "connectEthernet",
          "body": "if (Ethernet.begin(ETH_MAC, 5000L, 500L)) {\n    Serial.print(\"Ethernet IP: \");\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "connectGPRS",
          "body": "bool gsmConnected = false;\n  bool gprsConnected = false;\n\n  const uint32_t tstart = millis();\n  while (millis() - tstart < 20000) {\n    if (gsmAccess.begin(SIM_PIN) == GSM_READY) {\n      gsmConnected = true;\n      break;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n\n  // Deselect the SD card\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH);\n\n  // Initialize Ethernet shield\n  Ethernet.init(MKRETH_CS);\n\n  connectEthernet();\n  connectGPRS();\n\n  // Setup Blynk\n  Blynk.addClient(\"ETH\", blynkEthernetClient, 80);\n  Blynk.addClient(\"GSM\", blynkGsmClient,      80);\n  Blynk.config(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  Ethernet.maintain();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "BlynkMultiClient.h",
        "SPI.h",
        "Ethernet.h",
        "ArduinoECCX08.h",
        "ArduinoBearSSL.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "connectEthernet",
          "body": "if (Ethernet.begin(ETH_MAC, 5000L, 500L)) {\n    Serial.print(\"Ethernet IP: \");\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "connectGPRS",
          "body": "bool gsmConnected = false;\n  bool gprsConnected = false;\n\n  const uint32_t tstart = millis();\n  while (millis() - tstart < 20000) {\n    if (gsmAccess.begin(SIM_PIN) == GSM_READY) {\n      gsmConnected = true;\n      break;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n\n  // Deselect the SD card\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH);\n\n  // Initialize Ethernet shield\n  Ethernet.init(MKRETH_CS);\n\n  // Enable NTP time helper (needed for SSL authentiction)\n  ArduinoBearSSL.onGetTime(ntpGetTime);\n\n  connectEthernet();\n  connectGPRS();\n\n  // Setup Blynk\n  Blynk.addClient(\"ETH\", blynkEthernetClientSSL,  443);\n  Blynk.addClient(\"GSM\", blynkGsmClientSSL,       443);\n\n  Blynk.config(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  Ethernet.maintain();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "MKRGSM.h",
        "BlynkSimpleMKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, gsmAccess, gprs, client, pin, apn, user, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "MKRNB.h",
        "BlynkSimpleMKRNB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n  Blynk.begin(BLYNK_AUTH_TOKEN, nbAccess, gprs, client, pin);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Ethernet.init(MKRETH_CS);      // Init MKR ETH shield\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "ArduinoECCX08.h",
        "ArduinoBearSSL.h",
        "BlynkSimpleEthernetSSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Ethernet.init(MKRETH_CS);      // Init MKR ETH shield\n\n  // Enable NTP time helper (needed for SSL authentiction)\n  ArduinoBearSSL.onGetTime(ntpGetTime);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleStream.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Blynk will work through SoftwareSerial\n  // Do not read or write this serial manually in your sketch\n  SwSerial.begin(9600);\n  Blynk.begin(SwSerial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi.h",
        "BlynkSimpleWifi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "BlynkSimpleWiFiShield101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Bridge.h",
        "BlynkSimpleYun.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  SerialUSB.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiLink.h",
        "BlynkSimpleWiFiLink.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// start serial\n    Serial.begin(9600);\n    while(!Serial); // Wait for the serial port to come online\n\n    // Add some values to the buffer\n    for (int i = 65; i < 65 + 6; i++) {\n        buffer.push(i);"
        },
        {
          "name": "loop",
          "body": "// Nothing to do here"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCaptivePortal on \");  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCaptivePortalAdvanced on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncCaptivePortalAdvanced_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncCaptivePortal_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    Serial.println(\"\\nSending GET Request to \" + String(GET_ServerAddress));\n\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    //request.setReqHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCustomHeader on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    Serial.println(\"\\nSending GET Request to \" + String(GET_ServerAddress));\n\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    //request.setReqHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCustomHeader_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME) + \" using CYW43439 WiFi\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDNSServer on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncDNSServer_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME) + \" using CYW43439 WiFi\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDNSServerFull on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncDNSServerFull_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + dweetName + String(millis() / 1000)).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetGET on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "AsyncHTTPRequest_Impl_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + dweetName + String(millis() / 1000)).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      //Serial.println(request->responseText());\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n\n      request->setDebug(false);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetGET_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    String postData = \"sensorValue=\";\n    postData += analogRead(A0);\n\n    Serial.println(\"\\nMaking new POST request\");\n\n    requestOpenResult = request.open(\"POST\", (POST_ServerAddress + dweetName + postData).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetPOST on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "analogRead",
        "Serial"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    String postData = \"sensorValue=\";\n    postData += analogRead(A0);\n\n    Serial.println(\"\\nMaking new POST request\");\n\n    requestOpenResult = request.open(\"POST\", (POST_ServerAddress + dweetName + postData).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      //Serial.println(request->responseText());\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n\n      request->setDebug(false);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetPOST_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "BOARD_TYPE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n       \n    client->printf(\"Hello Client %lu :)\", client->id());\n    client->ping();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n \n  Serial.printf(\"\\nStarting AsyncFSBrowser_STM32 on %s with %s\\n\", BOARD_NAME, SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n \n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n \n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n    client->printf(\"Hello Client %lu :)\", client->id());\n    client->ping();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart AsyncFSBrowser_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n \n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n \n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\n\t\tclient->printf(\"Hello Client %u :)\", client->id());\n\t\tclient->ping();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(F(\"\\nStart AsyncFSBrowser_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "LittleFS.h",
        "AsyncFSEditor_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\t\tclient->printf(\"Hello Client %ld :)\", client->id());\n\t\tclient->ping();"
        },
        {
          "name": "initFS",
          "body": "// Initialize LittleFS/SPIFFS file-system\n\tif (!LittleFS.begin())\n\t{\n\t\tLittleFS.format();\n\n\t\tif (!LittleFS.begin())\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tSerial.println(F(\"LittleFS failed!\"));\n\n\t\t\t\t// Stay forever here as useless to go further\n\t\t\t\tdelay(5000);"
        },
        {
          "name": "initWebServer",
          "body": "ws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart AsyncFSWebServer on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "LittleFS.h",
        "AsyncFSEditor_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\t\tclient->printf(\"Hello Client %ld :)\", client->id());\n\t\tclient->ping();"
        },
        {
          "name": "initFS",
          "body": "// Initialize LittleFS/SPIFFS file-system\n\tif (!LittleFS.begin())\n\t{\n\t\tLittleFS.format();\n\n\t\tif (!LittleFS.begin())\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tSerial.println(F(\"LittleFS failed!\"));\n\n\t\t\t\t// Stay forever here as useless to go further\n\t\t\t\tdelay(5000);"
        },
        {
          "name": "listDir",
          "body": "Dir dir = LittleFS.openDir(\"/\");\n\tSerial.println(F(\"Opening / directory\"));\n\n\twhile (dir.next())\n\t{\n\t\tString fileName = dir.fileName();\n\t\tsize_t fileSize = dir.fileSize();\n\t\tSerial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());"
        },
        {
          "name": "initWebServer",
          "body": "ws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart AsyncFSWebServer_Complex on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPMultiRequests using \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(F(\"Warning. Must use this example on Version equal or later than : \"));\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_ENC.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_ENC_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_ENC on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W5500.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W5500_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_W5500 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W6100.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_W6100 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WT32_ETH01_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_WT32_ETH01 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n    //requestOpenResult = request.open(\"GET\", \"http://213.188.196.246/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      Serial.println(\"Request sent\");\n\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPRequest_ESP using \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  WiFi.mode(WIFI_STA);\n\n  WiFi.begin(ssid, password);\n\n  Serial.print(F(\"Connecting to WiFi SSID: \"));\n  Serial.println(ssid);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(F(\".\"));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_ENC.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_ENC_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_ENC on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W5500.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W5500_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_W5500 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W6100.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_W6100 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "W5100lwIP.h",
        "ENC28J60lwIP.h",
        "WiFiClient.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (eth.connected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n  eth.setDefault();\n\n  if (!eth.begin())\n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n\n    while (true)\n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP8266_Ethernet on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" using \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  initEthernet();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  reqCount[index]--;\n  readySend[index] = false;\n\n  requestOpenResult = request[index].open(\"GET\", addreses[index][reqCount[index]]);\n\n  if (requestOpenResult)\n  {\n    // Only send() if open() returns true, or crash\n    Serial.print(\"\\nSending request: \");\n    request[index].send();"
        },
        {
          "name": "sendRequest0",
          "body": "sendRequest(0);"
        },
        {
          "name": "sendRequest1",
          "body": "sendRequest(1);"
        },
        {
          "name": "sendRequests",
          "body": "reqCount[0] = NUM_ENTRIES_SITE_0;\n  reqCount[1] = NUM_ENTRIES_SITE_1;"
        },
        {
          "name": "requestCB0",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "requestCB1",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP_Multi on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  WiFi.mode(WIFI_STA);\n\n  WiFi.begin(ssid, password);\n\n  Serial.println(\"Connecting to WiFi SSID: \" + String(ssid));\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(1000);\n    Serial.print(\".\");"
        },
        {
          "name": "loop",
          "body": "for (int index = 0; index < NUM_DIFFERENT_SITES; index++)\n  {\n    if ((reqCount[index] > 0) && readySend[index])\n    {\n      sendRequestCB[index]();\n\n      // Don't send too fast\n      delay(1000);"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "AsyncHTTPRequest_Generic.h",
        "AsyncHTTPRequest_Impl_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn,\n              in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "loadConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset(&WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  //memset(&WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  // New in v1.8.2\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    file.write((uint8_t*) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPRequest_ESP_WiFiManager using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(F(\"Warning. Must use this example on Version later than : \"));\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WT32_ETH01_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_WT32_ETH01 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n  \n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "BOARD_TYPE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(Ethernet.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(Ethernet.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n\trequest->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n\trequest->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(F(\"\\nStart AsyncMultiWebServer_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tSerial.print(\"\\nConnected to network. IP = \");\n\tSerial.println(ETH.localIP());\n\n\tfor (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n\t{\n\t\tmultiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n\t\tif (multiServer[serverIndex])\n\t\t{\n\t\t\tSerial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncSimpleGET on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncSimpleGET_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_ENC\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_W5500\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_W6100\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tSerial.print(F(\"\\nStart AsyncSimpleServer_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tIPAddress localIP = ETH.localIP();\n\n\tSerial.print(F(\"IP address: \"));\n\tSerial.println(localIP);\n\n\tserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_WT32_ETH01\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Stepper.h"
      ],
      "functions": [
        {
          "name": "clockwise",
          "body": "stepCounter++;\n\tif (stepCounter >= numSteps) stepCounter = 0;\n\tsetOutput(stepCounter);"
        },
        {
          "name": "anticlockwise",
          "body": "stepCounter--;\n\tif (stepCounter < 0) stepCounter = numSteps - 1;\n\tsetOutput(stepCounter);"
        },
        {
          "name": "setOutput",
          "body": "digitalWrite(motorPin1, bitRead(stepsLookup[step], 0));\n\tdigitalWrite(motorPin2, bitRead(stepsLookup[step], 1));\n\tdigitalWrite(motorPin3, bitRead(stepsLookup[step], 2));\n\tdigitalWrite(motorPin4, bitRead(stepsLookup[step], 3));"
        },
        {
          "name": "rotateCW",
          "body": "stepper1.Rotate(90, AsyncStepper::CW, rotateCCW);"
        },
        {
          "name": "rotateCCW",
          "body": "stepper1.Rotate(90, AsyncStepper::CCW, rotateCW);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n\tpinMode(motorPin1, OUTPUT);\n\tpinMode(motorPin2, OUTPUT);\n\tpinMode(motorPin3, OUTPUT);\n\tpinMode(motorPin4, OUTPUT);\n\n\tstepper1.SetSpeedRpm(10);\n\tstepper1.RotateContinuos(AsyncStepper::CCW);"
        },
        {
          "name": "loop",
          "body": "stepper1.Update();"
        }
      ]
    },
    {
      "name": "ENABLE_ASYNC_TCP_CLIENT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// The async task handler should run inside the main loop\n    // without blocking delay or bypassing with millis code blocks.\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "asyncCB",
          "body": "// WARNING!\n    // Do not put your codes inside the callback and printResult.\n\n    printResult(aResult);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "AsyncTCPConnectCB",
          "body": ""
        },
        {
          "name": "AsyncTCPStatusCB",
          "body": "// Some asyn TCP client provides the server connected callback, you have to collect the required status from its callback\n    // and set it to status variable."
        },
        {
          "name": "AsyncTCPSendCB",
          "body": ""
        },
        {
          "name": "AsyncTCPReceiveCB",
          "body": "// Some asyn TCP client provides the data available callback, you have to collect the required data and status from its callback\n    // and provide the data here in case of data is ready and available to read.\n\n    // Please don't reallocate the buff, just copy data from async TCP client buffer to buff.\n    // After buff was set, set the filledSize and available."
        },
        {
          "name": "AsyncTCPStop",
          "body": ""
        }
      ]
    },
    {
      "name": "TCP_PORT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AsyncTCP_RP2040W.h"
      ],
      "functions": [
        {
          "name": "replyToServer",
          "body": "(void) arg;\n\n  Serial.println(\"\\n********************\");\n  Serial.println(\"New replyToServer\");\n\n  AsyncClient* client = reinterpret_cast<AsyncClient*>(arg);\n\n  // send reply\n  if (client->space() > REPLY_SIZE && client->canSend())\n  {\n    char message[REPLY_SIZE];\n    sprintf(message, \"This is from AsyncTCPClient @ %s\", WiFi.localIP().toString().c_str());\n    client->add(message, strlen(message));\n    client->send();\n\n    dataReceived = false;"
        },
        {
          "name": "handleData",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nData received from %s \\n\", client->remoteIP().toString().c_str());\n  Serial.write((uint8_t*)data, len);\n\n  lastCheck = millis();\n\n  dataReceived = true;"
        },
        {
          "name": "onConnect",
          "body": "(void) arg;\n\n  clientConnected = true;\n\n  Serial.printf(\"\\nAsyncTCPClient has been connected to Server %s, port %d \\n\", serverIP.toString().c_str(), TCP_PORT);\n\n  replyToServer(client);"
        },
        {
          "name": "onDisconnect",
          "body": "(void) arg;\n  (void) client;\n\n  Serial.printf(\"\\nAsyncTCPClient has been disconnected from Server %s, port %d \\n\", serverIP.toString().c_str(), TCP_PORT);\n\n  clientConnected = false;"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncTCP_Client on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "static unsigned long lastConnectCheck = CHECK_INTERVAL_MS;\n  \n  if (millis() - lastCheck > SEND_INTERVAL_MS)\n  {\n    if (clientConnected && dataReceived)\n    {\n      replyToServer(client);"
        }
      ]
    },
    {
      "name": "TCP_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncTCP_RP2040W.h",
        "vector"
      ],
      "functions": [
        {
          "name": "handleError",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nConnection error %s from client %s \\n\", client->errorToString(error), client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleData",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nData received from client %s \\n\", client->remoteIP().toString().c_str());\n  Serial.write((uint8_t*)data, len);\n\n  // reply to client\n  if (client->space() > REPLY_SIZE && client->canSend())\n  {\n    char reply[REPLY_SIZE];\n    sprintf(reply, \"You've connected to AsyncTCPServer @ %s\", serverIP.toString().c_str());\n    client->add(reply, strlen(reply));\n    client->send();"
        },
        {
          "name": "handleDisconnect",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nClient %s disconnected\\n\", client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleTimeOut",
          "body": "(void) arg;\n  (void) time;\n\n  Serial.printf(\"\\nClient ACK timeout ip: %s\\n\", client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleNewClient",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nNew client has been connected to server, IP: %s\", client->remoteIP().toString().c_str());\n\n  // add to list\n  clients.push_back(client);\n\n  // register events\n  client->onData(&handleData, NULL);\n  client->onError(&handleError, NULL);\n  client->onDisconnect(&handleDisconnect, NULL);\n  client->onTimeout(&handleTimeOut, NULL);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  serverIP = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(serverIP);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncTCP_Server on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "parsePacket",
          "body": "Serial.print(\"UDP Packet Type: \");\n  Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\", From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.print(\", Data: \");\n  Serial.write(packet.data(), packet.length());\n  Serial.println();\n  //reply to the client\n  packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart Async_UDPClient on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"Async_UDPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  if (udp.connect(remoteIPAddress, UDP_REMOTE_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket( packet);"
        },
        {
          "name": "loop",
          "body": "delay(10000);\n  //Send broadcast on port UDP_REMOTE_PORT = 1234\n  udp.broadcastTo(\"Anyone here?\", UDP_REMOTE_PORT);"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "parsePacket",
          "body": "Serial.print(\"UDP Packet Type: \");\n  Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\", From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.print(\", Data: \");\n  Serial.write(packet.data(), packet.length());\n  Serial.println();\n  //reply to the client\n  packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUDPMulticastServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"Async_UDPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n\n  if (udp.listenMulticast(IPAddress(239, 1, 2, 3), 1234))\n  {\n    Serial.print(\"UDP Listening on IP: \");\n    Serial.println(ETH.localIP());\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);"
        },
        {
          "name": "loop",
          "body": "delay(1000);\n  //Send multicast\n  udp.print(\"Anyone here?\");"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart Async_UdpServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUDPServer started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  if (udp.listen(1234))\n  {\n    Serial.print(\"UDP Listening on IP: \");\n    Serial.println(ETH.localIP());\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      Serial.print(\"UDP Packet Type: \");\n      Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n      Serial.print(\", From: \");\n      Serial.print(packet.remoteIP());\n      Serial.print(\":\");\n      Serial.print(packet.remotePort());\n      Serial.print(\", To: \");\n      Serial.print(packet.localIP());\n      Serial.print(\":\");\n      Serial.print(packet.localPort());\n      Serial.print(\", Length: \");\n      Serial.print(packet.length());\n      Serial.print(\", Data: \");\n      Serial.write(packet.data(), packet.length());\n      Serial.println();\n      //reply to the client\n      packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "loop",
          "body": "delay(1000);\n  //Send broadcast\n  udp.broadcast(\"Anyone here?\");"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h",
        "time.h"
      ],
      "functions": [
        {
          "name": "createNTPpacket",
          "body": "Serial.println(\"============= createNTPpacket =============\");\n\n  // set all bytes in the buffer to 0\n  memset(packetBuffer, 0, NTP_PACKET_SIZE);\n  // Initialize values needed to form NTP request\n  // (see URL above for details on the packets)\n\n  packetBuffer[0]   = 0b11100011;   // LI, Version, Mode\n  packetBuffer[1]   = 0;     // Stratum, or type of clock\n  packetBuffer[2]   = 6;     // Polling Interval\n  packetBuffer[3]   = 0xEC;  // Peer Clock Precision\n\n  // 8 bytes of zero for Root Delay & Root Dispersion\n  packetBuffer[12]  = 49;\n  packetBuffer[13]  = 0x4E;\n  packetBuffer[14]  = 49;\n  packetBuffer[15]  = 52;"
        },
        {
          "name": "parsePacket",
          "body": "struct tm  ts;\n  char       buf[80];\n\n  memcpy(packetBuffer, packet.data(), sizeof(packetBuffer));\n\n  Serial.print(\"Received UDP Packet Type: \");\n  Serial.println(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\"From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.println();\n\n  unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);\n  unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);\n\n  // combine the four bytes (two words) into a long integer\n  // this is NTP time (seconds since Jan 1 1900):\n  unsigned long secsSince1900 = highWord << 16 | lowWord;\n\n  Serial.print(F(\"Seconds since Jan 1 1900 = \"));\n  Serial.println(secsSince1900);\n\n  // now convert NTP time into )everyday time:\n  Serial.print(F(\"Epoch/Unix time = \"));\n\n  // Unix time starts on Jan 1 1970. In seconds, that's 2208988800:\n  const unsigned long seventyYears = 2208988800UL;\n\n  // subtract seventy years:\n  unsigned long epoch = secsSince1900 - seventyYears;\n  time_t epoch_t = epoch;   //secsSince1900 - seventyYears;\n\n  // print Unix time:\n  Serial.println(epoch);\n\n  // print the hour, minute and second:\n  Serial.print(F(\"The UTC/GMT time is \"));       // UTC is the time at Greenwich Meridian (GMT)\n\n  ts = *localtime(&epoch_t);\n  strftime(buf, sizeof(buf), \"%a %Y-%m-%d %H:%M:%S %Z\", &ts);\n  Serial.println(buf);"
        },
        {
          "name": "sendNTPPacket",
          "body": "createNTPpacket();\n  //Send unicast\n  Udp.write(packetBuffer, sizeof(packetBuffer));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUdpNTPClient on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUdpNTPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  //NTP requests are to port NTP_REQUEST_PORT = 123\n  if (Udp.connect(timeServerIP, NTP_REQUEST_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    Udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);"
        },
        {
          "name": "loop",
          "body": "sendNTPPacket();\n\n  // wait 60 seconds before asking for the time again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h",
        "time.h"
      ],
      "functions": [
        {
          "name": "sendACKPacket",
          "body": "Serial.println(\"============= sendACKPacket =============\");\n\n  // Send unicast ACK to the same remoteIP and remotePort we received the packet\n  // The AsyncUDP_STM32 library will take care of the correct IP and port based on pcb\n  Udp.write((uint8_t *) ReplyBuffer, sizeof(ReplyBuffer));"
        },
        {
          "name": "createNTPpacket",
          "body": "Serial.println(\"============= createNTPpacket =============\");\n\n  // set all bytes in the buffer to 0\n  memset(packetBuffer, 0, NTP_PACKET_SIZE);\n  // Initialize values needed to form NTP request\n  // (see URL above for details on the packets)\n\n  packetBuffer[0]   = 0b11100011;   // LI, Version, Mode\n  packetBuffer[1]   = 0;     // Stratum, or type of clock\n  packetBuffer[2]   = 6;     // Polling Interval\n  packetBuffer[3]   = 0xEC;  // Peer Clock Precision\n\n  // 8 bytes of zero for Root Delay & Root Dispersion\n  packetBuffer[12]  = 49;\n  packetBuffer[13]  = 0x4E;\n  packetBuffer[14]  = 49;\n  packetBuffer[15]  = 52;"
        },
        {
          "name": "sendNTPPacket",
          "body": "createNTPpacket();\n  //Send unicast\n  Udp.write(packetBuffer, sizeof(packetBuffer));"
        },
        {
          "name": "parsePacket",
          "body": "struct tm  ts;\n  char       buf[80];\n\n  memcpy(packetBuffer, packet.data(), sizeof(packetBuffer));\n\n  Serial.print(\"Received UDP Packet Type: \");\n  Serial.println(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\"From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.println();\n\n  unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);\n  unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);\n\n  // combine the four bytes (two words) into a long integer\n  // this is NTP time (seconds since Jan 1 1900):\n  unsigned long secsSince1900 = highWord << 16 | lowWord;\n\n  Serial.print(F(\"Seconds since Jan 1 1900 = \"));\n  Serial.println(secsSince1900);\n\n  // now convert NTP time into )everyday time:\n  Serial.print(F(\"Epoch/Unix time = \"));\n\n  // Unix time starts on Jan 1 1970. In seconds, that's 2208988800:\n  const unsigned long seventyYears = 2208988800UL;\n\n  // subtract seventy years:\n  unsigned long epoch = secsSince1900 - seventyYears;\n  time_t epoch_t = epoch;   //secsSince1900 - seventyYears;\n\n  // print Unix time:\n  Serial.println(epoch);\n\n  // print the hour, minute and second:\n  Serial.print(F(\"The UTC/GMT time is \"));       // UTC is the time at Greenwich Meridian (GMT)\n\n  ts = *localtime(&epoch_t);\n  strftime(buf, sizeof(buf), \"%a %Y-%m-%d %H:%M:%S %Z\", &ts);\n  Serial.println(buf);\n\n  // send a reply, to the IP address and port that sent us the packet we received\n  sendACKPacket();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUDPSendReceive on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUDPSendReceive started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  Serial.println(F(\"\\nStarting connection to server...\"));\n\n  //NTP requests are to port NTP_REQUEST_PORT = 123\n  if (Udp.connect(timeServerIP, NTP_REQUEST_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    Udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);"
        },
        {
          "name": "loop",
          "body": "sendNTPPacket();\n\n  // wait 60 seconds before asking for the time again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + GET_Location).c_str());\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncWebClientRepeating on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + GET_Location).c_str());\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncWebClientRepeating_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "AsyncMqtt_Generic.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "connectToWifi",
          "body": "Serial.println(\"Connecting to Wi-Fi...\");\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);"
        },
        {
          "name": "connectToMqtt",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "WiFiEvent",
          "body": "switch (event)\n  {\n#if USING_CORE_ESP32_CORE_V200_PLUS\n\n    case ARDUINO_EVENT_WIFI_READY:\n      Serial.println(\"WiFi ready\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_START:\n      Serial.println(\"WiFi STA starting\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_CONNECTED:\n      Serial.println(\"WiFi STA connected\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP6:\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP:\n      Serial.println(\"WiFi connected\");\n      Serial.print(\"IP address: \");\n      Serial.println(WiFi.localIP());\n      connectToMqtt();\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_LOST_IP:\n      Serial.println(\"WiFi lost IP\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:\n      Serial.println(\"WiFi lost connection\");\n      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi\n      xTimerStart(wifiReconnectTimer, 0);\n      break;\n#else\n\n    case SYSTEM_EVENT_STA_GOT_IP:\n      Serial.println(\"WiFi connected\");\n      Serial.println(\"IP address: \");\n      Serial.println(WiFi.localIP());\n      connectToMqtt();\n      break;\n\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n      Serial.println(\"WiFi lost connection\");\n      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi\n      xTimerStart(wifiReconnectTimer, 0);\n      break;\n#endif\n\n    default:\n      break;"
        },
        {
          "name": "connectToMqttLoop",
          "body": "if (WiFi.status() == WL_CONNECTED)\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"ESP32 Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"ESP32 Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"ESP32 Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MQTT on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  mqttReconnectTimer = xTimerCreate(\"mqttTimer\", pdMS_TO_TICKS(2000), pdFALSE, (void*)0,\n                                    reinterpret_cast<TimerCallbackFunction_t>(connectToMqtt));\n  wifiReconnectTimer = xTimerCreate(\"wifiTimer\", pdMS_TO_TICKS(10000), pdFALSE, (void*)0,\n                                    reinterpret_cast<TimerCallbackFunction_t>(connectToWifi));\n\n  WiFi.onEvent(WiFiEvent);\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToWifi();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from ESP32!\");"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) /*|| (checkstatus_timeout == 0)*/)\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCTCP_RP2040W_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "Ticker.h",
        "AsyncMqtt_Generic.h",
        "AsyncWebServer_RP2040W.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"Connected to SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"Signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "connectToMqttLoop",
          "body": "//if ( (WiFi.status() == WL_CONNECTED) && (WiFi.RSSI() != 0) )      // temporary workaround\n  if (isWiFiConnected())\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();"
        },
        {
          "name": "connectToMqtt",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"RP2040W Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"RP2040W Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"RP2040W Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MQTT_RP2040W on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  ///////////////////////////////////\n\n  connectToWifi();\n\n  ///////////////////////////////////\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToMqttTicker.start(); //start the ticker.\n\n  connectToMqtt();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from RP2040W!\");"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) /*|| (checkstatus_timeout == 0)*/)\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "connectToMqttTicker.update(); //update the ticker.\n  check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "createPage",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "handleRoot",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < 500; lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"ESP32_ENC_AsyncWebServer_SendChunked_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart AsyncWebServer_SendChunked on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     400\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(3000);\n  char temp[70];\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_AdvancedWebServer on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCTCP_RP2040W_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n\n\tint sec = millis() / 1000;\n\tint min = sec / 60;\n\tint hr = min / 60;\n\tint day = hr / 24;\n\n\tsnprintf(temp, BUFFER_SIZE - 1,\n\t         \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='60'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n\tString message = \"File Not Found\\n\\n\";\n\n\tmessage += \"URI: \";\n\tmessage += request->url();\n\tmessage += \"\\nMethod: \";\n\tmessage += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n\tmessage += \"\\nArguments: \";\n\tmessage += request->args();\n\tmessage += \"\\n\";\n\n\tfor (uint8_t i = 0; i < request->args(); i++)\n\t{\n\t\tmessage += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n\tout.reserve(4000);\n\tchar temp[70];\n\n\tdigitalWrite(LED_BUILTIN, LED_ON);\n\n\tout += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n\tout += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n\tout += \"<g stroke=\\\"blue\\\">\\n\";\n\tint y = rand() % 130;\n\n\tfor (int x = 10; x < 300; x += 10)\n\t{\n\t\tint y2 = rand() % 130;\n\t\tsprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n\t\tout += temp;\n\t\ty = y2;"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);\n\n\t// print your board's country code\n\t// #define CYW43_COUNTRY(A, B, REV) ((unsigned char)(A) | ((unsigned char)(B) << 8) | ((REV) << 16))\n\tuint32_t myCountryCode = cyw43_arch_get_country_code();\n\n\tcountryCode[0] = myCountryCode & 0xFF;\n\tcountryCode[1] = (myCountryCode >> 8) & 0xFF;\n\n\tSerial.print(\"Country code: \");\n\tSerial.println(countryCode);"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n\tdigitalWrite(LED_BUILTIN, LED_OFF);\n\n\tSerial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart Async_AdvancedWebServer_Country on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n\tSerial.print(F(\".\"));\n\n\tif (num == 80)\n\t{\n\t\tSerial.println();\n\t\tnum = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n\t// Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n\tif ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n\t{\n\t\theartBeatPrint();\n\t\tcheckstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n\n#define BUFFER_SIZE     400\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(3000);\n  char temp[70];\n  \n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='60'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "PrintHeapData",
          "body": "static uint32_t maxFreeHeap = 0xFFFFFFFF;\n  static uint32_t totalHeap = ESP.getHeapSize();\n\n  uint32_t freeHeap  = ESP.getFreeHeap();\n\n  // Print and update only when larger heap\n  if (maxFreeHeap > freeHeap)\n  {\n    maxFreeHeap = freeHeap;\n\n    Serial.print(\"\\nHEAP DATA - \");\n    Serial.print(hIn);\n\n    Serial.print(\"  Max heap: \");\n    Serial.print(totalHeap);\n    Serial.print(\"  Free heap: \");\n    Serial.print(ESP.getFreeHeap());\n    Serial.print(\"  Used heap: \");\n    Serial.println(totalHeap - freeHeap);"
        },
        {
          "name": "PrintStringSize",
          "body": "static uint32_t count = 0;\n\n  // Print only when cStr length too large and corrupting memory or every (20 * 5) s\n  if ( (out.length() >= STRING_SIZE) || (++count > 20) )\n  {\n    Serial.print(\"\\nOut String Length=\");\n    Serial.println(out.length());\n\n    count = 0;"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MemoryIssues_SendArduinoString on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='10'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "PrintHeapData",
          "body": "static uint32_t maxFreeHeap = 0xFFFFFFFF;\n  static uint32_t totalHeap = ESP.getHeapSize();\n\n  uint32_t freeHeap  = ESP.getFreeHeap();\n\n  // Print and update only when larger heap\n  if (maxFreeHeap > freeHeap)\n  {\n    maxFreeHeap = freeHeap;\n\n    Serial.print(\"\\nHEAP DATA - \");\n    Serial.print(hIn);\n\n    Serial.print(\"  Max heap: \");\n    Serial.print(totalHeap);\n    Serial.print(\"  Free heap: \");\n    Serial.print(ESP.getFreeHeap());\n    Serial.print(\"  Used heap: \");\n    Serial.println(totalHeap - freeHeap);"
        },
        {
          "name": "PrintStringSize",
          "body": "Serial.print(\"\\nOut String Length=\");\n  Serial.println(strlen(cStr));"
        },
        {
          "name": "drawGraph",
          "body": "char temp[80];\n\n  cStr[0] = '\\0';\n\n  strcat(cStr, \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\");\n  strcat(cStr,\n         \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\");\n  strcat(cStr, \"<g stroke=\\\"blue\\\">\\n\");\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    strcat(cStr, temp);\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MemoryIssues_Send_CString on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  cStr = (char *) malloc(CSTRING_SIZE);           // make a little larger than required\n\n  if (cStr == NULL)\n  {\n    Serial.println(\"Unable top Allocate RAM\");\n\n    for (;;);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    //Serial.println();\n    PrintStringSize(cStr);\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out = String();\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_SendChunked on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "Ticker.h",
        "AsyncMqtt_Generic.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print your board's country code\n  // #define CYW43_COUNTRY(A, B, REV) ((unsigned char)(A) | ((unsigned char)(B) << 8) | ((REV) << 16))\n  uint32_t myCountryCode = cyw43_arch_get_country_code();\n  char countryCode[3] = { 0, 0, 0"
        },
        {
          "name": "connectToMqttLoop",
          "body": "//if ( (WiFi.status() == WL_CONNECTED) && (WiFi.RSSI() != 0) )      // temporary workaround\n  if (isWiFiConnected())\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();"
        },
        {
          "name": "connectToMqtt",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"RP2040W Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"RP2040W Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"RP2040W Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "handleRoot",
          "body": "static uint32_t pageCount   = 0;\n  static uint32_t maxfreeHeap = 0;\n  static uint32_t minFreeHeap = 0xFFFFFFFF;\n  uint32_t curFreeHeap = rp2040.getFreeHeap();\n\n  if (maxfreeHeap < curFreeHeap)\n    maxfreeHeap = curFreeHeap;\n\n  if (minFreeHeap > curFreeHeap)\n    minFreeHeap = curFreeHeap;\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out = String();\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LED_OFF);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_SendChunked_MQTT on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  ///////////////////////////////////\n\n  connectToWifi();\n\n  ///////////////////////////////////\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToMqttTicker.start(); //start the ticker.\n\n  connectToMqtt();\n  \n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "drawFavicon",
          "body": "AsyncWebServerResponse *response = request->beginResponse(200, \"image/x-icon\", favicon_ico_gz, favicon_ico_gz_len);\n  \n  response->addHeader(\"Content-Encoding\", \"gzip\");\n  request->send(response);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(4000);\n  char temp[80];\n\n  digitalWrite(led, 1);\n  \n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_favicon on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(\"\\nStarting Async_AutoConnectAP using \" + String(FS_Name));\n  Serial.println(\" on \" + String(ARDUINO_BOARD));\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ArduinoJson.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "saveConfigCallback",
          "body": "Serial.println(F(\"Should save config\"));\n  shouldSaveConfig = true;"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(PIN_LED, !digitalRead(PIN_LED));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFSParams using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  \n  static ulong currentMillis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  currentMillis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((currentMillis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = currentMillis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LED_ON);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFSParametersAndCustomIP using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFeedBack using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(PIN_LED, !digitalRead(PIN_LED));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(PIN_LED, OUTPUT);\n  \n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFeedBackLED using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 ) \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnDRD-FS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnDRD-FS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(\"Got stored Credentials. Timeout 120s\");"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "delay",
        "EEPROM",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "map"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  AsyncWebServer webServer(HTTP_PORT);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n  \n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr_Complex using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();\n\n  delay(1);"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n  \n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr_Medium using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset_Multi using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset_TZ using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnStartup using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwitch using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwitch\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwitch\");\n#endif\n\n    ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n    // From v1.0.10 only\n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n    ESPAsync_wifiManager.setConfigPortalChannel(0);\n    //////\n\n    //set custom ip for portal\n    //ESPAsync_wifiManager.setAPStaticIPConfig(IPAddress(192, 168, 100, 1), IPAddress(192, 168, 100, 1), IPAddress(255, 255, 255, 0));\n\n#if !USE_DHCP_IP    \n  #if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n  #endif \n#endif       \n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n   \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwichFS using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    AsyncWebServer webServer(HTTP_PORT);\n    AsyncDNSServer dnsServer;\n    \n    ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwitchFS\");\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n   \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "OneButton.h",
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      60000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "handleClick",
          "body": "Serial.println(F(\"\\nButton clicked!\"));\n  wifi_manager();"
        },
        {
          "name": "handleDoubleClick",
          "body": "Serial.println(F(\"\\nButton double clicked!\"));"
        },
        {
          "name": "handleLongPressStop",
          "body": "Serial.println(F(\"\\nLong Button pressed!\"));\n  newConfigData();"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwichFS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// checking button state all the time\n  btn.tick();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigPortalParamsOnSwitch using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    AsyncWebServer webServer(HTTP_PORT);\n    AsyncDNSServer dnsServer;\n  \n    ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncCP-ParamsOnSW\");\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.print(F(\"Opening configuration portal.\"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n    \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "ESPmDNS.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP32_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "ESPmDNS.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP32_FSWebServer_DRD using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "delay",
        "digitalWrite",
        "Serial",
        "EEPROM"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "ESPAsyncDNSServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "SPIFFSEditor.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n  if ( String(ESP_ASYNC_WIFIMANAGER_VERSION) < ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET )\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "MDNS.update();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "delay",
        "digitalWrite",
        "Serial",
        "EEPROM"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "ESPAsyncDNSServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP_FSWebServer_DRD using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n  \n  MDNS.update();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/plain\", String(\"Hello from Async_HelloServer on \") + ARDUINO_BOARD );"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_HelloServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/plain\", String(\"Hello from Async_HelloServer2 on \") + ARDUINO_BOARD );"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_HelloServer2 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/plain\", String(\"Hello from AsyncWebServer_STM32 on \") + BOARD_NAME );\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HelloServer2_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/plain\", String(\"Hello from AsyncWebServer_STM32_LAN8720 on \") + BOARD_NAME );\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HelloServer_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_HTTPBasicAuth on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    if (!request->authenticate(www_username, www_password))\n    {\n      return request->requestAuthentication();"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HTTPBasicAuth_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  //Ethernet.begin(mac[10]);\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    if (!request->authenticate(www_username, www_password))\n    {\n      return request->requestAuthentication();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/html\", postForms);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handlePlain",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleForm",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);;\n\n  Serial.print(F(\"\\nStart Async_PostServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/html\", postForms);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handlePlain",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleForm",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_PostServer_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_RegexPatterns on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_ENC on \" + String(ARDUINO_BOARD));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_W5500 on \" + String(ARDUINO_BOARD));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_W6100 on \" + String(ARDUINO_BOARD));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart Async_RegexPatterns_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_STM32 on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_RegexPatterns_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_STM32_LAN8720 on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tSerial.print(F(\"\\nStart Async_RegexPatterns_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_WT32_ETH01 on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n  \n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from \" SHIELD_TYPE);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart Async_SimpleWebServer_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from LAN8742A\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_SimpleWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from LAN8720\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/html\", webpageCont);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStarting Async_WebSocketsServer on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  server.on(\"/\", handleRoot);\n  server.begin();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] WSClient connected\\n\", server->url(), client->id());\n\n\t\tglobalClient = client;\n\t\t//client->text(\"Hello from RP2040W Server\");"
        },
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/html\", webpageCont);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStarting Async_WebSocketsServer_Xtreme on \");\n\tSerial.println(BOARD_NAME);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n\tSerial.print(F(\".\"));\n\n\tif (num == 80)\n\t{\n\t\tSerial.println();\n\t\tnum = 1;"
        },
        {
          "name": "sendStatus",
          "body": "static unsigned long sendStatus_timeout  = 1000;\n\tstatic unsigned long checkstatus_timeout = 1000;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n#define SEND_INTERVAL             30L\n\n\t// Send status report every SEND_INTERVAL (30) millis\n\tif (millis() > sendStatus_timeout)\n\t{\n\t\t//if (globalClient != NULL && globalClient->status() == WS_CONNECTED)\n\t\t// Sending only when gessage_queue not full\n\t\tif (globalClient != NULL && globalClient->status() == WS_CONNECTED && globalClient->canSend())\n\t\t{\n\t\t\tString POTvalString = String(rand() % 256);\n\n\t\t\tJSONtxt = \"{\\\"POT\\\":\\\"\" + POTvalString + \"\\\""
        },
        {
          "name": "loop",
          "body": "sendStatus();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "seesaw_spectrum.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  while (!Serial) delay(10);   // wait until serial port is opened\n  Serial.println(\"A\");\n  \n  if (!ss.begin()) {\n    Serial.println(\"seesaw not found!\");\n    while(1) delay(10);"
        },
        {
          "name": "loop",
          "body": "ss.getData(); // Pull audio spectrum data from device\n  // Print contents of each of the 64 spectrum bins...\n  for (uint8_t i=0; i<64; i++) {\n    Serial.print(ss.getLevel(i));\n    Serial.write(' ');"
        }
      ]
    },
    {
      "name": "DEBUG_ETHERNET_WEBSERVER_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting Authorization on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();"
        },
        {
          "name": "loop",
          "body": "if (WT32_ETH01_isConnected())\n  {\n    HTTPClient http;\n\n    Serial.print(\"[HTTP] begin...\\n\");\n\n    http.begin(\"http://user:password@192.168.2.112/test.html\");\n\n    /*\n      // or\n      http.begin(\"http://192.168.2.112/test.html\");\n      http.setAuthorization(\"user\", \"password\");\n      // or\n      http.begin(\"http://192.168.2.112/test.html\");\n      http.setAuthorization(\"dXNlcjpwYXN3b3Jk\");\n    */\n\n    Serial.print(\"[HTTP] GET...\\n\");\n    // start connection and send HTTP header\n    int httpCode = http.GET();\n\n    // httpCode will be negative on error\n    if (httpCode > 0) \n    {\n      // HTTP header has been send and Server response header has been handled\n      Serial.printf(\"[HTTP] GET... code: %d\\n\", httpCode);\n\n      // file found at server\n      if (httpCode == HTTP_CODE_OK) \n      {\n        String payload = http.getString();\n        Serial.println(payload);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n    Serial.begin(115200);\n\n    //WiFiManager\n    //Local intialization. Once its business is done, there is no need to keep it around\n    WiFiManager wifiManager;\n    //reset saved settings\n    //wifiManager.resetSettings();\n    \n    //set custom ip for portal\n    //wifiManager.setAPStaticIPConfig(IPAddress(10,0,1,1), IPAddress(10,0,1,1), IPAddress(255,255,255,0));\n\n    //fetches ssid and pass from eeprom and tries to connect\n    //if it does not connect it starts an access point with the specified name\n    //here  \"AutoConnectAP\"\n    //and goes into a blocking loop awaiting configuration\n    wifiManager.autoConnect(\"AutoConnectAP\");\n    //or use this for auto generated name ESP + ChipID\n    //wifiManager.autoConnect();\n\n    \n    //if you get here you have connected to the WiFi\n    Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP    \n    // put your setup code here, to run once:\n    Serial.begin(115200);\n    \n    //reset settings - wipe credentials for testing\n    //wm.resetSettings();\n\n    wm.setConfigPortalBlocking(false);\n    wm.setConfigPortalTimeout(60);\n    //automatically connect using saved credentials if they exist\n    //If connection fails it starts an access point with the specified name\n    if(wm.autoConnect(\"AutoConnectAP\")){\n        Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "body": "wm.process();\n    // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP    \n    // put your setup code here, to run once:\n    Serial.begin(115200);\n    \n    //reset settings - wipe credentials for testing\n    //wm.resetSettings();\n    wm.addParameter(&custom_mqtt_server);\n    wm.setConfigPortalBlocking(false);\n    wm.setSaveParamsCallback(saveParamsCallback);\n\n    //automatically connect using saved credentials if they exist\n    //If connection fails it starts an access point with the specified name\n    if(wm.autoConnect(\"AutoConnectAP\")){\n        Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "body": "wm.process();\n    // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //clean FS, for testing\n  //SPIFFS.format();\n\n  //read configuration from FS json\n  Serial.println(\"mounting FS...\");\n\n  if (SPIFFS.begin()) {\n    Serial.println(\"mounted file system\");\n    if (SPIFFS.exists(\"/config.json\")) {\n      //file exists, reading and loading\n      Serial.println(\"reading config file\");\n      File configFile = SPIFFS.open(\"/config.json\", \"r\");\n      if (configFile) {\n        Serial.println(\"opened config file\");\n        size_t size = configFile.size();\n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[size]);\n\n        configFile.readBytes(buf.get(), size);\n        DynamicJsonBuffer jsonBuffer;\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        json.printTo(Serial);\n        if (json.success()) {\n          Serial.println(\"\\nparsed json\");\n\n          strcpy(mqtt_server, json[\"mqtt_server\"]);\n          strcpy(mqtt_port, json[\"mqtt_port\"]);\n          strcpy(blynk_token, json[\"blynk_token\"]);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //clean FS, for testing\n  //SPIFFS.format();\n\n  //read configuration from FS json\n  Serial.println(\"mounting FS...\");\n\n  if (SPIFFS.begin()) {\n    Serial.println(\"mounted file system\");\n    if (SPIFFS.exists(\"/config.json\")) {\n      //file exists, reading and loading\n      Serial.println(\"reading config file\");\n      File configFile = SPIFFS.open(\"/config.json\", \"r\");\n      if (configFile) {\n        Serial.println(\"opened config file\");\n        size_t size = configFile.size();\n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[size]);\n\n        configFile.readBytes(buf.get(), size);\n        DynamicJsonBuffer jsonBuffer;\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        json.printTo(Serial);\n        if (json.success()) {\n          Serial.println(\"\\nparsed json\");\n\n          strcpy(mqtt_server, json[\"mqtt_server\"]);\n          strcpy(mqtt_port, json[\"mqtt_port\"]);\n          strcpy(blynk_token, json[\"blynk_token\"]);\n\n          if(json[\"ip\"]) {\n            Serial.println(\"setting custom ip from config\");\n            //static_ip = json[\"ip\"];\n            strcpy(static_ip, json[\"ip\"]);\n            strcpy(static_gw, json[\"gateway\"]);\n            strcpy(static_sn, json[\"subnet\"]);\n            //strcat(static_ip, json[\"ip\"]);\n            //static_gw = json[\"gateway\"];\n            //static_sn = json[\"subnet\"];\n            Serial.println(static_ip);\n/*            Serial.println(\"converting ip\");\n            IPAddress ip = ipFromCharArray(static_ip);\n            Serial.println(ip);*/"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  wifiManager.setAPCallback(configModeCallback);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if(!wifiManager.autoConnect()) {\n    Serial.println(\"failed to connect and hit timeout\");\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "tick",
          "body": "//toggle state\n  int state = digitalRead(BUILTIN_LED);  // get the current state of GPIO1 pin\n  digitalWrite(BUILTIN_LED, !state);     // set pin to the opposite state"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //set led pin as output\n  pinMode(BUILTIN_LED, OUTPUT);\n  // start ticker with 0.5 because we start in AP mode and try to connect\n  ticker.attach(0.6, tick);\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  wifiManager.setAPCallback(configModeCallback);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect()) {\n    Serial.println(\"failed to connect and hit timeout\");\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //exit after config instead of connecting\n  wifiManager.setBreakAfterConfig(true);\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n\n  //tries to connect to last known settings\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\" with password \"password\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect, we should reset as see if it connects\");\n    delay(3000);\n    ESP.reset();\n    delay(5000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set static ip\n  //block1 should be used for ESP8266 core 2.1.0 or newer, otherwise use block2\n\n  //start-block1\n  //IPAddress _ip,_gw,_sn;\n  //_ip.fromString(static_ip);\n  //_gw.fromString(static_gw);\n  //_sn.fromString(static_sn);\n  //end-block1\n\n  //start-block2\n  IPAddress _ip = IPAddress(10, 0, 1, 78);\n  IPAddress _gw = IPAddress(10, 0, 1, 1);\n  IPAddress _sn = IPAddress(255, 255, 255, 0);\n  //end-block2\n  \n  wifiManager.setSTAStaticIPConfig(_ip, _gw, _sn);\n\n\n  //tries to connect to last known settings\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\" with password \"password\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect, we should reset as see if it connects\");\n    delay(3000);\n    ESP.reset();\n    delay(5000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //sets timeout until configuration portal gets turned off\n  //useful to make it all retry or go to sleep\n  //in seconds\n  wifiManager.setTimeout(180);\n  \n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if(!wifiManager.autoConnect(\"AutoConnectAP\")) {\n    Serial.println(\"failed to connect and hit timeout\");\n    delay(3000);\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(5000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "SPI.begin();\n  pinMode(amisStepPin, OUTPUT);\n  delay(1);\n\n  stepper.init(amisSlaveSelect);\n  stepper.resetSettings();\n  stepper.setCurrentMilliamps(132);\n  stepper.enableDriver();"
        },
        {
          "name": "loop",
          "body": "takeSteps();\n  checkDriver();"
        },
        {
          "name": "takeSteps",
          "body": "// Don't take any steps if there is an issue.\n  if (stepperSettingsProblem || stepperNonLatchedFlags || stepperLatchedFlags)\n  {\n    return;"
        },
        {
          "name": "checkDriver",
          "body": "// Every 20 ms, perform some checks.\n  static uint16_t lastCheckTime = 0;\n  if ((uint16_t)(millis() - lastCheckTime) >= 20)\n  {\n    // Read back the configuration of the driver and make sure it\n    // is correct.\n    if (!stepperSettingsProblem && !stepper.verifySettings())\n    {\n      // We have detected the settings on the driver do not match\n      // the desired settings we chose earlier in this sketch.\n      // It is likely that stepper motor power has been lost or\n      // that communication with the driver is not working.\n      stepperSettingsProblem = true;\n      Serial.println(F(\"Could not verify settings; driver power might be off.\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "your_edge_impulse_inferencing.h",
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/car.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___AUTONOMOUS CAR___\");\n\n    // replace with your board\n    camera.pinout.freenove_s3();\n    camera.brownout.disable();\n    camera.resolution.yolo();\n    camera.pixformat.rgb565();\n\n    // how many millis motors will run\n    // to follow given object\n    fomoCar.defaultDuration(100);\n    fomoCar.stop();\n\n    // if you mounted the camera \"backward\"\n    // (see video), you have to reverse the motors\n    // left.reverse();\n    // right.reverse();\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Put object in front of camera\");"
        },
        {
          "name": "loop",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);"
        },
        {
          "name": "loop",
          "body": "// set the cursor to (0,0):\n  lcd.setCursor(0, 0);\n  // print from 0 to 9:\n  for (int thisChar = 0; thisChar < 10; thisChar++) {\n    lcd.print(thisChar);\n    delay(500);"
        }
      ]
    },
    {
      "name": "Serial",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "fatalBlink",
          "body": "while (true) {\n    if (ERROR_LED_PIN >= 0) {\n      digitalWrite(ERROR_LED_PIN, HIGH);\n      delay(200);\n      digitalWrite(ERROR_LED_PIN, LOW);\n      delay(200);"
        },
        {
          "name": "errorHalt",
          "body": "// Print minimal error data.\n  // sd.errorPrint(&Serial);\n  // Print extended error info - uses extra bytes of flash.\n  sd.printSdError(&Serial);\n  // Try to save data.\n  binFile.close();\n  fatalBlink();"
        },
        {
          "name": "printUnusedStack",
          "body": "Serial.print(F(\"\\nUnused stack: \"));\n  Serial.println(UnusedStack());"
        },
        {
          "name": "dateTime",
          "body": "DateTime now = rtc.now();\n\n  // Return date using FS_DATE macro to format fields.\n  *date = FS_DATE(now.year(), now.month(), now.day());\n\n  // Return time using FS_TIME macro to format fields.\n  *time = FS_TIME(now.hour(), now.minute(), now.second());\n\n  // Return low time bits in units of 10 ms.\n  *ms10 = now.second() & 1 ? 100 : 0;"
        },
        {
          "name": "adcInit",
          "body": "uint8_t adps;  // prescaler bits for ADCSRA\n  uint32_t ticks = F_CPU*SAMPLE_INTERVAL + 0.5;  // Sample interval cpu cycles.\n\n  if (ADC_REF & ~((1 << REFS0) | (1 << REFS1))) {\n    error(\"Invalid ADC reference\");"
        },
        {
          "name": "adcStart",
          "body": "// initialize ISR\n  adcindex = 1;\n  isrBuf = nullptr;\n  isrOver = 0;\n  isrStop = false;\n\n  // Clear any pending interrupt.\n  ADCSRA |= 1 << ADIF;\n\n  // Setup for first pin.\n  ADMUX = adcmux[0];\n  ADCSRB = adcsrb[0];\n  ADCSRA = adcsra[0];\n\n  // Enable timer1 interrupts.\n  timerError = false;\n  timerFlag = false;\n  TCNT1 = 0;\n  TIFR1 = 1 << OCF1B;\n  TIMSK1 = 1 << OCIE1B;"
        },
        {
          "name": "adcStop",
          "body": "TIMSK1 = 0;\n  ADCSRA = 0;"
        },
        {
          "name": "binaryToCsv",
          "body": "uint8_t lastPct = 0;\n  block_t* pd;\n  metadata_t* pm;\n  uint32_t t0 = millis();\n  // Use fast buffered print class.\n  BufferedPrint<file_t, 64> bp(&csvFile);\n  block_t binBuffer[FIFO_DIM];\n\n  assert(sizeof(block_t) == sizeof(metadata_t));\n  binFile.rewind();\n  uint32_t tPct = millis();\n  bool doMeta = true;\n  while (!Serial.available()) {\n    pd = binBuffer;\n    int nb = binFile.read(binBuffer, sizeof(binBuffer));\n    if (nb < 0) {\n      error(\"read binFile failed\");"
        },
        {
          "name": "clearSerialInput",
          "body": "uint32_t m = micros();\n  do {\n    if (Serial.read() >= 0) {\n      m = micros();"
        },
        {
          "name": "createBinFile",
          "body": "binFile.close();\n  while (sd.exists(binName)) {\n    char* p = strchr(binName, '.');\n    if (!p) {\n      error(\"no dot in filename\");"
        },
        {
          "name": "logData",
          "body": "uint32_t t0;\n  uint32_t t1;\n  uint32_t overruns =0;\n  uint32_t count = 0;\n  uint32_t maxLatencyUsec = 0;\n  size_t maxFifoUse = 0;\n  block_t fifoBuffer[FIFO_DIM];\n\n  adcInit((metadata_t*)fifoBuffer);\n  // Write metadata.\n  if (sizeof(metadata_t) != binFile.write(fifoBuffer, sizeof(metadata_t))) {\n    error(\"Write metadata failed\");"
        },
        {
          "name": "openBinFile",
          "body": "char name[NAME_DIM];\n  clearSerialInput();\n  Serial.println(F(\"Enter file name\"));\n  if (!serialReadLine(name, sizeof(name))) {\n    return;"
        },
        {
          "name": "printData",
          "body": "block_t buf;\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "setup",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "printUnusedStack();\n  // Read any Serial data.\n  clearSerialInput();\n  Serial.println();\n  Serial.println(F(\"type:\"));\n  Serial.println(F(\"b - open existing bin file\"));\n  Serial.println(F(\"c - convert file to csv\"));\n  Serial.println(F(\"l - list files\"));\n  Serial.println(F(\"p - print data to Serial\"));\n  Serial.println(F(\"r - record ADC data\"));\n\n  while(!Serial.available()) {\n    yield();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "ContinuousStepper.h",
        "ContinuousStepper/Tickers/AnalogWriteFrequency.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "stepper.begin(/*step=*/2, /*dir=*/3); // ⚠️ step pin must support PWM\n\n  stepper.spin(200);"
        },
        {
          "name": "loop",
          "body": "stepper.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (gsmAccess.status() != GSM_READY || gprs.status() != GPRS_READY) {\n    connectGSM();"
        },
        {
          "name": "connectGSM",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((gsmAccess.begin(pinnumber) != GSM_READY) ||\n         (gprs.attachGPRS(gprs_apn, gprs_login, gprs_password) != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "MKRNB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (nbAccess.status() != NB_READY || gprs.status() != GPRS_READY) {\n    connectNB();"
        },
        {
          "name": "connectNB",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((nbAccess.begin(pinnumber) != NB_READY) ||\n         (gprs.attachGPRS() != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "WiFiNINA.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    connectWiFi();"
        },
        {
          "name": "connectWiFi",
          "body": "Serial.print(\"Attempting to connect to SSID: \");\n  Serial.print(ssid);\n  Serial.print(\" \");\n\n  while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleBLEPeripheral.h",
        "BLEPeripheral.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  SerialBLE.setLocalName(\"Blynk\");\n  SerialBLE.setDeviceName(\"Blynk\");\n  SerialBLE.setAppearance(0x0080);\n  SerialBLE.begin();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(SerialBLE, auth);"
        },
        {
          "name": "loop",
          "body": "SerialBLE.poll();\n\n  if (SerialBLE) {    // If BLE is connected...\n    Blynk.run();"
        }
      ]
    },
    {
      "name": "BHY_DFU_FW_PATH",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(3000);\n\n  char crc = 0;\n  for (int i = 0; i < fw_bin_len; i++) {\n    crc = crc ^ fw_bin[i];"
        },
        {
          "name": "loop",
          "body": "delay(100);"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_Blynk on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n  \n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BUTTON_PIN",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "attachInterrupt"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "body": "//isButtonPressed = !digitalRead(BUTTON_PIN); // Invert state, since button is \"Active LOW\"\n\n  if ( !isButtonPressed && !digitalRead(BUTTON_PIN)) // You can write any condition to trigger e-mail sending\n  {\n    isButtonPressed = true;\n    count++;\n    Serial.println(\"Button pressed\");"
        },
        {
          "name": "processButton",
          "body": "// *** WARNING: You are limited to send ONLY ONE E-MAIL PER 5 SECONDS! ***\n  // Let's send an e-mail when you press the button\n  // connected to digital pin BUTTON_PIN (2) on your Arduino\n  static String body;\n\n  if (isButtonPressed) // You can write any condition to trigger e-mail sending\n  {\n    body = String(\"You pushed the button \") + count + \" times.\";\n\n    // This can be seen in the Serial Monitor\n    Serial.println(body);\n\n    Blynk.email(\"your_email@gmail.com\", \"Subject: Button Logger\", body);\n\n    isButtonPressed = false;"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_Blynk_Email on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "DHT_PIN",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_WM_Config on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  dht.begin();\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BMX_CYCLE",
      "keywords": [
        "Wire",
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "everytime.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set LED as output and turn it off\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  // initialize serial pport\n  Serial.begin(SERIAL_BAUD);\n\n  // Wait for serial port to settle\n  while (!Serial) {\n    delay(10);"
        },
        {
          "name": "loop",
          "body": "// get Temperature\n  every(BMX_CYCLE) {\n    climateSensor.takeForcedMeasurement();\n    Serial.println(\" \");\n\n    // // uncomment this block to print temperature - int32_t\n    // g_temperature = climateSensor.getTemperatureCelsius();\n    // Serial.print(\"Temperature: \");\n    // Serial.print(g_temperature/100);\n    // Serial.print(\".\");\n    // Serial.print(g_temperature%100);\n    // Serial.println(\" °C\");\n\n    // uncomment this block to print temperature - float\n    g_temperatureFloat = climateSensor.getTemperatureCelsiusAsFloat(true);\n    Serial.print(\"Temperature: \");\n    Serial.print(g_temperatureFloat);\n    Serial.println(\" °C\");\n\n    // // uncomment this block to print pressure - uint32_t\n    // g_pressure = climateSensor.getPressure();\n    // Serial.print(\"Pressure: \");\n    // Serial.print(g_pressure/100);\n    // Serial.print(\".\");\n    // Serial.print(g_pressure%100);\n    // Serial.println(\" hPa\");\n\n    // uncomment this block to print pressure - float\n    g_pressureFloat = climateSensor.getPressureAsFloat();\n    Serial.print(\"Pressure: \");\n    Serial.print(g_pressureFloat);\n    Serial.println(\" hPa\");\n\n    // // uncomment this block to print humidity - uint32_t\n    // g_humidity = climateSensor.getRelativeHumidity();\n    // Serial.print(\"Humidity: \");\n    // Serial.print(g_humidity/100);\n    // Serial.print(\".\");\n    // Serial.print(g_humidity%100);\n    // Serial.println(\" %rh\");\n\n    // uncomment this block to print humidity - float\n    g_humidityFloat = climateSensor.getRelativeHumidityAsFloat();\n    Serial.print(\"Humidity: \");\n    Serial.print(g_humidityFloat);\n    Serial.println(\" %rh\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_1000MS);     // Set the standby time to 1 second (1000ms)\n  bmp280.startNormalConversion();                 // Start NORMAL continuous conversion\n  \n  xTaskCreatePinnedToCore(                        // Kick-off \"TaskOne\" pinned to core 1\n    taskOne,\n    \"TaskOne\",\n    10000,\n    NULL,\n    1,\n    NULL,\n    1);"
        },
        {
          "name": "taskOne",
          "body": "while(true)\n  {\n    if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n    {\n      Serial.print(temperature);                    // Display the results    \n      Serial.print(F(\"*C   \"));\n      Serial.print(pressure);    \n      Serial.print(F(\"hPa   \"));\n      Serial.print(altitude);\n      Serial.println(F(\"m\"));"
        },
        {
          "name": "loop",
          "body": "delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin(BMP280_I2C_ALT_ADDR);              // Default initialisation with alternative I2C address (0x76), place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4"
        },
        {
          "name": "loop",
          "body": "bmp280.startForcedConversion();                 // Start BMP280 forced conversion (if we're in SLEEP_MODE)\n  if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4"
        },
        {
          "name": "loop",
          "body": "bmp280.startForcedConversion();                 // Start BMP280 forced conversion (if we're in SLEEP_MODE)\n  if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                             // Initialise the serial port\n  bmp280_1.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280_1.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280_1.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE \n  bmp280_2.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280_2.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280_2.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280_1.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(F(\"BMP280_1 \"));                                   // Display the results   \n    Serial.print(temperature);                       \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "SERIAL_BAUD",
      "keywords": [
        "Wire",
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set LED as output and turn it off\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  // initialize serial pport\n  Serial.begin(SERIAL_BAUD);\n\n  // Wait for serial port to settle\n  while (!Serial) {\n    delay(10);"
        },
        {
          "name": "loop",
          "body": "// get Temperature\n  delay(2000);\n  climateSensor.takeForcedMeasurement();\n  g_temperature = climateSensor.getTemperatureCelsius();\n  Serial.println(\" \");\n  Serial.print(\"Temperature: \");\n  Serial.print(g_temperature/100);\n  Serial.print(\".\");\n  Serial.print(g_temperature%100);\n  Serial.println(\" °C\");"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin(D2, D3);\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  \n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);"
        }
      ]
    },
    {
      "name": "PIN_CS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "BMx280SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tSPI.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and chip select pin.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "PIN_CS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "BMx280SPIClass.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tSPI.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and chip select pin.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncDelay.h",
        "SoftWire.h",
        "BMx280MI.h"
      ],
      "functions": [
        {
          "name": "writeRegister",
          "body": "sw.startWait(address_, SoftWire::writeMode);\n\t\t\tsw.llWrite(reg);\n\t\t\tsw.llWrite(data);\n\t\t\tsw.stop();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\t\n\t//SoftWire setup\n\tsw.setDelay_us(5);\n\tsw.setTimeout_ms(100);\n\tsw.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280TwoWire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280MI.h"
      ],
      "functions": [
        {
          "name": "writeRegister",
          "body": "Wire1.beginTransmission(address_);\n\t\t\tWire1.write(reg);\n\t\t\tWire1.write(data);\n\t\t\tWire1.endTransmission();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire1.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// debug port\n  Serial.begin(115200);\n  while(!Serial);\n\n  BHY2Host.begin();\n\n  bsec.begin();"
        },
        {
          "name": "loop",
          "body": "static auto printTime = millis();\n  BHY2Host.update();\n\n  if (millis() - printTime >= 1000) {\n    printTime = millis();\n    Serial.println(bsec.toString());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  BHY2.begin();\n  sensortec.bhy2_bsec2_setConfigString(BSEC2CONFIG, sizeof(BSEC2CONFIG)/sizeof(BSEC2CONFIG[0]));\n  bsec2.begin();"
        },
        {
          "name": "loop",
          "body": "// Update function should be continuously polled\n  BHY2.update(100);\n\n  if (bsec2.getNewDataFlag()) {\n    bsec2.setNewDataFlag(false);\n\n    Serial.println(bsec2.toString());"
        }
      ]
    },
    {
      "name": "CONFIG_BSEC2_USE_DEAULT_HP",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  BHY2.begin();\n  sensortec.bhy2_bsec2_setHP((uint8_t*)BSEC2HP_TEMP, sizeof(BSEC2HP_TEMP), (uint8_t*)BSEC2HP_DUR, sizeof(BSEC2HP_DUR)); \n  \n  bsec2Collector.begin();"
        },
        {
          "name": "loop",
          "body": "static auto last_index = 0;\n\n  // Update function should be continuously polled\n  BHY2.update();\n\n  if (last_index != bsec2Collector.gas_index()) {\n    last_index = bsec2Collector.gas_index();\n    Serial.println(String((uint32_t)bsec2Collector.timestamp()) + \" \" \n              + String(bsec2Collector.temperature()) + \" \" \n              + String(bsec2Collector.pressure()) + \" \" \n              + String(bsec2Collector.humidity()) + \" \" \n              + String(bsec2Collector.gas()) + \" \" \n              + String(bsec2Collector.gas_index()) \n              );"
        }
      ]
    },
    {
      "name": "L_EN",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "BTS7960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);                       //begin the serial monitor for output\n  motor1.begin();                           //This method will set the motor driver pins as output\n  motor1.enable();                          //This method will set the L_EN and R_EN to HIGH or digitalWrite them to +5v/3v depending on your mcu"
        },
        {
          "name": "loop",
          "body": "for(int i=0; i<=255; i=i+10)\n  {\n    motor1.pwm = i;                         //Set the speed, by default the speed is set to 255 you can change it \n    motor1.front();                         //front functions should turn the motor in clockwise direction\n    delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": ""
        },
        {
          "name": "loop",
          "body": "motorController.Enable();\n\n  for(int speed = 0 ; speed < 255; speed+=10)\n  {\n\tmotorController.TurnLeft(speed);\n\tdelay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "INA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(GREEN_LED_PIN, OUTPUT);        // Make the internal LED an output pin\n  digitalWrite(GREEN_LED_PIN, true);     // Turn on the LED\n  pinMode(INA_ALERT_PIN, INPUT_PULLUP);  // Declare pin with internal pull-up resistor\n  *digitalPinToPCMSK(INA_ALERT_PIN) |= bit(digitalPinToPCMSKbit(INA_ALERT_PIN));  // Enable PCMSK\n  PCIFR |= bit(digitalPinToPCICRbit(INA_ALERT_PIN));  // clear any outstanding interrupt\n  PCICR |= bit(digitalPinToPCICRbit(INA_ALERT_PIN));  // enable interrupt for the group\n  Serial.begin(SERIAL_SPEED);\n#ifdef __AVR_ATmega32U4__  // If this is a 32U4 processor, wait 2 seconds for initialization\n  delay(2000);\n#endif\n  Serial.print(F(\"\\n\\nBackground INA Read V1.0.5\\n\"));\n  uint8_t devicesFound = 0;\n  while (deviceNumber == UINT8_MAX)  // Loop until we find the first device\n  {\n    devicesFound = INA.begin(1, 100000);  // +/- 1 Amps maximum for 0.1 Ohm resistor\n    for (uint8_t i = 0; i < devicesFound; i++) {\n      /* Change the \"INA226\" in the following statement to whatever device you have attached\n         and want to measure */\n      if (strcmp(INA.getDeviceName(i), \"INA226\") == 0) {\n        deviceNumber = i;\n        INA.reset(deviceNumber);  // Reset device to default settings\n        break;"
        },
        {
          "name": "loop",
          "body": "/*!\n   @brief    Arduino method for the main program loop\n   @details  This is the main program for the Arduino IDE, it is called in an infinite loop. The\n             INA226 measurements are triggered by the interrupt handler each time a conversion is\n             ready and stored in variables. The main program doesn't call any INA library functions,\n             that is done in the interrupt handler. Each time 10 readings have been collected the\n             program will output the averaged values and measurements resume from that point onwards\n   @return   void\n  */\n  static long lastMillis = millis();  // Store the last time we printed something\n  if (readings >= 10) {\n    Serial.print(F(\"Averaging readings taken over \"));\n    Serial.print((float)(millis() - lastMillis) / 1000, 2);\n    Serial.print(F(\" seconds.\\nBus voltage:   \"));\n    Serial.print((float)sumBusMillVolts / readings / 1000.0, 4);\n    Serial.print(F(\"V\\nBus amperage:  \"));\n    Serial.print((float)sumBusMicroAmps / readings / 1000.0, 4);\n    Serial.print(F(\"mA\\n\\n\"));\n    lastMillis = millis();\n    cli();  // Disable interrupts to reset values\n    readings        = 0;\n    sumBusMillVolts = 0;\n    sumBusMicroAmps = 0;\n    sei();  // Enable interrupts again"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "attachInterrupt",
        "Serial",
        "delay"
      ],
      "libraries": [
        "INA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "/*!\n   @brief    Arduino method called once at startup to initialize the system\n   @details  This is an Arduino IDE method which is called first upon boot or restart. It is only\n             called one time and then control goes to the main \"loop()\" method, from which control\n             never returns\n   @return   void\n  */\n  pinMode(INA_ALERT_PIN, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(INA_ALERT_PIN), InterruptHandler, FALLING);\n  Serial.begin(SERIAL_SPEED);\n  Serial.print(F(\"\\n\\nBackground INA Read V1.0.1\\n\"));\n  uint8_t devicesFound = 0;\n  while (deviceNumber == UINT8_MAX)  // Loop until we find the first device\n  {\n    devicesFound = INA.begin(1, 100000);  // +/- 1 Amps maximum for 0.1 Ohm resistor\n    Serial.println(INA.getDeviceName(devicesFound - 1));\n    for (uint8_t i = 0; i < devicesFound; i++) {\n      /* Change the \"INA226\" in the following statement to whatever device you have attached and\n         want to measure */\n      if (strcmp(INA.getDeviceName(i), \"INA219\") == 0) {\n        deviceNumber = i;\n        INA.reset(deviceNumber);  // Reset device to default settings\n        break;"
        },
        {
          "name": "loop",
          "body": "/*!\n   @brief    Arduino method for the main program loop\n   @details  This is the main program for the Arduino IDE, it is called in an infinite loop. The\n             INA226 measurements are triggered by the interrupt handler each time a conversion is\n             ready and stored in variables. The main program doesn't call any INA library functions,\n             that is done in the interrupt handler. Each time 10 readings have been collected the\n             program will output the averaged values and measurements resume from that point onwards\n   @return   void\n  */\n  static long lastMillis = millis();  // Store the last time we printed something\n  if (readings >= 10) {\n    Serial.print(F(\"Averaging readings taken over \"));\n    Serial.print((float)(millis() - lastMillis) / 1000, 2);\n    Serial.print(F(\" seconds.\\nBus voltage:   \"));\n    Serial.print((float)sumBusMillVolts / readings / 1000.0, 4);\n    Serial.print(F(\"V\\nBus amperage:  \"));\n    Serial.print((float)sumBusMicroAmps / readings / 1000.0, 4);\n    Serial.print(F(\"mA\\n\\n\"));\n    lastMillis = millis();\n    cli();  // Disable interrupts to reset values\n    readings        = 0;\n    sumBusMillVolts = 0;\n    sumBusMicroAmps = 0;\n    sei();  // Enable interrupts again"
        }
      ]
    },
    {
      "name": "USE_SD_H",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// nothing happens after setup"
        }
      ]
    },
    {
      "name": "BUTTON_A_PIN",
      "keywords": [],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "create_maze",
          "body": "sp.clear(0);\n  sp.setColor(1);\n  sp.fillRect(0,                0, sp.width(), 16);\n  sp.fillRect(0, sp.height() - 16, sp.width(), 16);\n  sp.fillRect(            0, 0, 16, sp.height()-16);\n  sp.fillRect(sp.width()-16, 0, 16, sp.height()-16);\n  sp.setColor(3);\n  for (int y = 1; y < sp.height(); y += 2)\n  {\n    for (int x = 1; x < sp.width(); x += 2)\n    {\n      sp.writePixel(x, y);\n      int xx = x;\n      int yy = y;\n      do\n      {\n        xx = x;\n        yy = y;\n        switch (random(4)) {\n        case 0: xx = x + 1; break;\n        case 1: xx = x - 1; break;\n        case 2: yy = y + 1; break;\n        case 3: yy = y - 1; break;"
        },
        {
          "name": "draw",
          "body": "draw_count += draw_cycle;\n  std::uint_fast8_t blink = 127+abs(((int)(draw_count<<1) & 255)-128);\n  sp.setPaletteColor(1, 127, 127, blink);\n  sp.setPaletteColor(2, 127, blink, 127);\n\n  float fx = (cx - ox);\n  float fy = (cy - oy);\n  float len = sqrtf(fx * fx + fy * fy) * zoom;\n  float theta = atan2f(fx, fy) + rad;\n  sp.pushRotateZoom(px - sinf(theta) * len, py - cosf(theta) * len, angle, zoom, zoom);"
        },
        {
          "name": "game_init",
          "body": "px = lcd.width()>>1;\n  py = lcd.height()/3;\n\n  create_maze();\n  ox = sp.getPivotX();\n  oy = sp.getPivotY();\n\n  cx = (sp.width() >>1);\n  cy = (sp.height()>>1);\n  cr = 0.2;\n  zoom = zoom_min;"
        },
        {
          "name": "setup",
          "body": "lgfx::lgfxPinMode(BUTTON_A_PIN, lgfx::pin_mode_t::input);\n  lgfx::lgfxPinMode(BUTTON_B_PIN, lgfx::pin_mode_t::input);\n\n  lcd.init();\n  lcd.startWrite();\n  lcd.setColorDepth(16);\n  sp.setColorDepth(2);\n  sp.createSprite(257, 257);\n  game_init();"
        },
        {
          "name": "loop",
          "body": "if (!game_main())\n  {\n    lcd.fillCircle(px, py, roundf(cr*zoom), 0xFFFF00U);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for Leonardo only"
        },
        {
          "name": "loop",
          "body": "// Get current band\n  String bandName = band.getBand(); // Get and print band name\n  Serial.print(\"Current band:\");\n  Serial.println(bandName);\n  Serial.println(\"Want to change the band you’re on?\");\n  String newBandName;\n  newBandName = askUser();\n  // Tell the user what we are about to do…\n  Serial.print(\"\\nConfiguring band \");\n  Serial.println(newBandName);\n  // Change the band\n  bool operationSuccess;\n  operationSuccess = band.setBand(newBandName);\n  // Tell the user if the operation was OK\n  if (operationSuccess) {\n    Serial.println(\"Success\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "analogRead",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Wire.h",
        "LiquidCrystal_I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  lcd.begin(16, 2);\n  pinMode(btnIncrease, INPUT_PULLUP);\n  pinMode(btnDecrease, INPUT_PULLUP);\n  pinMode(kipas, OUTPUT);\n  pinMode(heater, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "int s = analogRead(A1);\n  float v = (s * 5.0) / 1023.0;\n  float suhu = v * 100.0;\n\n  // Debounce for btnIncrease\n  if (digitalRead(btnIncrease) == LOW && (millis() - lastDebounceTime1) > debounceDelay) {\n    while (digitalRead(btnIncrease) == LOW);\n    sp++;\n    lastDebounceTime1 = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_LPS22HB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!BARO.begin()) {\n    Serial.println(\"Failed to initialize pressure sensor!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// read the sensor value\n  float pressure = BARO.readPressure();\n\n  // print the sensor value\n  Serial.print(\"Pressure = \");\n  Serial.print(pressure);\n  Serial.println(\" kPa\");\n\n  float temperature = BARO.readTemperature();\n\n  // print the sensor value\n  Serial.print(\"Temperature = \");\n  Serial.print(temperature);\n  Serial.println(\" C\");\n\n  // print an empty line\n  Serial.println();\n\n  // wait 1 second to print again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    while (!Serial);\n    myBarometer.init();"
        },
        {
          "name": "loop",
          "body": "temperature = myBarometer.bmp085GetTemperature(\n                      myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n    pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n\n    /*\n        To specify a more accurate altitude, enter the correct mean sea level\n        pressure level.  For example, if the current pressure level is 1019.00 hPa\n        enter 101900 since we include two decimal places in the integer value。\n    */\n    altitude = myBarometer.calcAltitude(101900);\n\n    atm = pressure / 101325;\n\n    Serial.print(\"Temperature: \");\n    Serial.print(temperature, 2); //display 2 decimal places\n    Serial.println(\" Celsius\");\n\n    Serial.print(\"Pressure: \");\n    Serial.print(pressure, 0); //whole number only.\n    Serial.println(\" Pa\");\n\n    Serial.print(\"Ralated Atmosphere: \");\n    Serial.println(atm, 4); //display 4 decimal places\n\n    Serial.print(\"Altitude: \");\n    Serial.print(altitude, 2); //display 2 decimal places\n    Serial.println(\" m\");\n\n    Serial.println();\n\n    delay(1000); //wait a second and get values again."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// start the SPI library:\n  SPI.begin();\n\n  // start the Ethernet connection and the server:\n  Ethernet.begin(ip);\n  server.begin();\n\n  // initialize the  data ready and chip select pins:\n  pinMode(dataReadyPin, INPUT);\n  pinMode(chipSelectPin, OUTPUT);\n\n  Serial.begin(9600);\n\n  //Configure SCP1000 for low noise configuration:\n  writeRegister(0x02, 0x2D);\n  writeRegister(0x01, 0x03);\n  writeRegister(0x03, 0x02);\n\n  // give the sensor and Ethernet shield time to set up:\n  delay(1000);\n\n  //Set the sensor to high resolution mode tp start readings:\n  writeRegister(0x03, 0x0A);"
        },
        {
          "name": "loop",
          "body": "// check for a reading no more than once a second.\n  if (millis() - lastReadingTime > 1000) {\n    // if there's a reading ready, read it:\n    // don't do anything until the data ready pin is high:\n    if (digitalRead(dataReadyPin) == HIGH) {\n      getData();\n      // timestamp the last time you got a reading:\n      lastReadingTime = millis();"
        },
        {
          "name": "getData",
          "body": "Serial.println(\"Getting reading\");\n  //Read the temperature data\n  int tempData = readRegister(0x21, 2);\n\n  // convert the temperature to celsius and display it:\n  temperature = (float)tempData / 20.0;\n\n  //Read the pressure data highest 3 bits:\n  byte  pressureDataHigh = readRegister(0x1F, 1);\n  pressureDataHigh &= 0b00000111; //you only needs bits 2 to 0\n\n  //Read the pressure data lower 16 bits:\n  unsigned int pressureDataLow = readRegister(0x20, 2);\n  //combine the two parts into one 19-bit number:\n  pressure = ((pressureDataHigh << 16) | pressureDataLow) / 4;\n\n  Serial.print(\"Temperature: \");\n  Serial.print(temperature);\n  Serial.println(\" degrees C\");\n  Serial.print(\"Pressure: \" + String(pressure));\n  Serial.println(\" Pa\");"
        },
        {
          "name": "listenForEthernetClients",
          "body": "// listen for incoming clients\n  EthernetClient client = server.available();\n  if (client) {\n    Serial.println(\"Got a client\");\n    // an http request ends with a blank line\n    bool currentLineIsBlank = true;\n    while (client.connected()) {\n      if (client.available()) {\n        char c = client.read();\n        // if you've gotten to the end of the line (received a newline\n        // character) and the line is blank, the http request has ended,\n        // so you can send a reply\n        if (c == '\\n' && currentLineIsBlank) {\n          // send a standard http response header\n          client.println(\"HTTP/1.1 200 OK\");\n          client.println(\"Content-Type: text/html\");\n          client.println();\n          // print the current readings, in HTML format:\n          client.print(\"Temperature: \");\n          client.print(temperature);\n          client.print(\" degrees C\");\n          client.println(\"<br />\");\n          client.print(\"Pressure: \" + String(pressure));\n          client.print(\" Pa\");\n          client.println(\"<br />\");\n          break;"
        },
        {
          "name": "writeRegister",
          "body": "// SCP1000 expects the register name in the upper 6 bits\n  // of the byte:\n  registerName <<= 2;\n  // command (read or write) goes in the lower two bits:\n  registerName |= 0b00000010; //Write command\n\n  // take the chip select low to select the device:\n  digitalWrite(chipSelectPin, LOW);\n\n  SPI.transfer(registerName); //Send register location\n  SPI.transfer(registerValue); //Send value to record into register\n\n  // take the chip select high to de-select:\n  digitalWrite(chipSelectPin, HIGH);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "DATABASE_URL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(100);\n  Serial.println();\n\n  Serial.print(\"Connecting to Wi-Fi\");\n  int status = WL_IDLE_STATUS;\n  while (status != WL_CONNECTED)\n  {\n    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "SSID_MAX_LEN",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite",
        "analogWrite"
      ],
      "libraries": [
        "EEPROM.h",
        "AsyncTCP.h",
        "ESPAsyncWebServer.h",
        "WiFi.h",
        "PubSubClient.h",
        "ArduinoOTA.h",
        "dynaHTML.h"
      ],
      "functions": [
        {
          "name": "dynaCallback",
          "body": "Serial.println(\"YOUR CALLBACK WORKED!!!!!!!!!!\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyconfigData.wifi_pw);\n    Serial.println(MyconfigData.mqtt_server);\n    Serial.println(MyconfigData.sensorname);\n    Serial.println(MyconfigData.sensorstatus);\n    Serial.println(MyconfigData.mqtt_id);\n    Serial.println(MyconfigData.mqtt_key);\n    Serial.println(MyconfigData.usb_power);\n    saveconfigtoEE(MyconfigData);\n    // if we are updating data, force a refresh of the SSID\n    MyAPdata.crc32 = 8675309; // If your CRC based on your bssid and channel happen to be Jennys number, CALL HER!\n    saveAPEE(MyAPdata);\n    delay(1000);\n    ESP.restart();"
        },
        {
          "name": "OTAinit",
          "body": "// Port defaults to 3232\n    // ArduinoOTA.setPort(3232);\n\n    // Hostname defaults to esp3232-[MAC]\n    ArduinoOTA.setHostname(MyconfigData.sensorname);\n\n    // No authentication by default\n    ArduinoOTA.setPassword(OTA_PASSDW);\n\n    // Password can be set with it's md5 value as well\n    // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3\n    // ArduinoOTA.setPasswordHash(\"21232f297a57a5a743894a0e4a801fc3\");\n\n    ArduinoOTA\n        .onStart([]()\n                 {\n      String type;\n      if (ArduinoOTA.getCommand() == U_FLASH)\n        type = \"sketch\";\n      else // U_SPIFFS\n        type = \"filesystem\";\n\n      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()\n      Serial.println(\"Start updating \" + type);"
        },
        {
          "name": "saveconfigtoEE",
          "body": "EEPROM.put(eepromstart, MyconfigData);\n    JumpStart();\n    boolean ok2 = EEPROM.commit();\n    Serial.println(ok2);"
        },
        {
          "name": "saveAPEE",
          "body": "EEPROM.put(eepromapstart, MyAPData);\n    boolean ok2 = EEPROM.commit();"
        },
        {
          "name": "chkColdStart",
          "body": "EEPROM.get(eepromcoldstart, ColdStart);\n    if (ColdStart.One == 0x45 && ColdStart.Two == 0x72)\n    {\n        hasConfig = true;"
        },
        {
          "name": "JumpStart",
          "body": "ColdStart.One = 0x45;\n    ColdStart.Two = 0x72;\n    EEPROM.put(eepromcoldstart, ColdStart);"
        },
        {
          "name": "setup_wifi",
          "body": "// We start by connecting to a WiFi network\n    WiFi.persistent(true);\n    WiFi.mode(WIFI_STA);\n\n    // delay(200);\n    // WiFi.config(staticIP, subnet, gateway, dns);\n    // WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    if (apValid)\n    {\n        Serial.println(\"Using BSSID data\");\n        // The BSSID data was good, make a quick connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw, MyAPdata.channel, MyAPdata.bssid, true);"
        },
        {
          "name": "reconnect",
          "body": "if (WiFi.status() != WL_CONNECTED)\n    {\n        return;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_CONFIG, OUTPUT);  // Initialize the BUILTIN_LED pin as an output\n    pinMode(GPIO4, INPUT_PULLUP); // If this pin is LOW, then REPROGRAM by setting up the Access Point.\n    Serial.begin(115200);\n    EEPROM.begin(EEPROM_SIZE);\n    delay(10);\n    MyconfigData = getConfigData();\n    delay(10);\n    MyAPdata = getAPData();\n    delay(10);\n    chkColdStart();\n    Serial.println(\"Config/ap data\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyAPdata.crc32);\n\n    if (hasConfig == false or digitalRead(GPIO4) == LOW)\n    {\n        configmode = CONFIG;\n\n        WiFi.mode(WIFI_AP_STA);\n        WiFi.softAP(ssidAP, passwordAP);\n        IPAddress IP = WiFi.softAPIP();\n\n        dHTML.setCallback(dynaCallback);\n        uint16_t tot = dHTML.setMenuItems(mallItem, NUM_MENU_ITEMS);\n\n        server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request)\n                  { dHTML.handleRequest(request);"
        },
        {
          "name": "loop",
          "body": "if (configmode == RUN)\n    {\n        if (!client.connected())\n        {\n            reconnect();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting BasicAuthGet on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"making GET request with HTTP basic authentication\");\n  httpClient.beginRequest();\n  httpClient.get(\"/secure\");\n  httpClient.sendBasicAuth(\"username\", \"password\"); // send the username and password for authentication\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStarting BasicAuthGet_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"making GET request with HTTP basic authentication\");\n  httpClient.beginRequest();\n  httpClient.get(\"/secure\");\n  httpClient.sendBasicAuth(\"username\", \"password\"); // send the username and password for authentication\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n  \n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && (millis() - sendDataPrevMillis > 15000 || sendDataPrevMillis == 0))\n  {\n    sendDataPrevMillis = millis();\n\n    Serial.printf(\"Set bool... %s\\n\", Firebase.setBool(fbdo, \"/test/bool\", count % 2 == 0) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get bool... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\") ? fbdo.to<bool>() ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    bool bVal;\n    Serial.printf(\"Get bool ref... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\", &bVal) ? bVal ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get int... %s\\n\", Firebase.getInt(fbdo, \"/test/int\") ? String(fbdo.to<int>()).c_str() : fbdo.errorReason().c_str());\n\n    int iVal = 0;\n    Serial.printf(\"Get int ref... %s\\n\", Firebase.getInt(fbdo, \"/test/int\", &iVal) ? String(iVal).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set float... %s\\n\", Firebase.setFloat(fbdo, \"/test/float\", count + 10.2) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get float... %s\\n\", Firebase.getFloat(fbdo, \"/test/float\") ? String(fbdo.to<float>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set double... %s\\n\", Firebase.setDouble(fbdo, \"/test/double\", count + 35.517549723765) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get double... %s\\n\", Firebase.getDouble(fbdo, \"/test/double\") ? String(fbdo.to<double>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set string... %s\\n\", Firebase.setString(fbdo, \"/test/string\", \"Hello World!\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get string... %s\\n\", Firebase.getString(fbdo, \"/test/string\") ? fbdo.to<const char *>() : fbdo.errorReason().c_str());\n\n    // For the usage of FirebaseJson, see examples/FirebaseJson/BasicUsage/Create_Edit_Parse.ino\n    FirebaseJson json;\n\n    if (count == 0)\n    {\n      json.set(\"value/round/\" + String(count), \"cool!\");\n      json.set(\"vaue/ts/.sv\", \"timestamp\");\n      Serial.printf(\"Set json... %s\\n\", Firebase.set(fbdo, \"/test/json\", json) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "API_KEY",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "WiFiEvent",
          "body": "// Do not run any function here to prevent stack overflow or nested interrupt\n#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)\n\n    switch (event)\n    {\n    case ARDUINO_EVENT_ETH_START:\n        Serial.println(\"ETH Started\");\n        // set eth hostname here\n        ETH.setHostname(\"esp32-ethernet\");\n        break;\n    case ARDUINO_EVENT_ETH_CONNECTED:\n        Serial.println(\"ETH Connected\");\n        break;\n    case ARDUINO_EVENT_ETH_GOT_IP:\n        Serial.print(\"ETH MAC: \");\n        Serial.print(ETH.macAddress());\n        Serial.print(\", IPv4: \");\n        Serial.print(ETH.localIP());\n        if (ETH.fullDuplex())\n        {\n            Serial.print(\", FULL_DUPLEX\");"
        },
        {
          "name": "setupFirebase",
          "body": "if (firebaseConfigReady)\n        return;\n\n    firebaseConfigReady = true;\n\n    // For the following credentials, see examples/Authentications/SignInAsUser/EmailPassword/EmailPassword.ino\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the user sign in credentials */\n    auth.user.email = USER_EMAIL;\n    auth.user.password = USER_PASSWORD;\n\n    /* Assign the RTDB URL (required) */\n    config.database_url = DATABASE_URL;\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    // Or use legacy authenticate method\n    // config.database_url = DATABASE_URL;\n    // config.signer.tokens.legacy_token = \"<database secret>\";\n\n    // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n    Firebase.begin(&config, &auth);"
        },
        {
          "name": "testFirebase",
          "body": "Serial.printf(\"Set bool... %s\\n\", Firebase.setBool(fbdo, \"/test/bool\", count % 2 == 0) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get bool... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\") ? fbdo.to<bool>() ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    bool bVal;\n    Serial.printf(\"Get bool ref... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\", &bVal) ? bVal ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get int... %s\\n\", Firebase.getInt(fbdo, \"/test/int\") ? String(fbdo.to<int>()).c_str() : fbdo.errorReason().c_str());\n\n    int iVal = 0;\n    Serial.printf(\"Get int ref... %s\\n\", Firebase.getInt(fbdo, \"/test/int\", &iVal) ? String(iVal).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set float... %s\\n\", Firebase.setFloat(fbdo, \"/test/float\", count + 10.2) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get float... %s\\n\", Firebase.getFloat(fbdo, \"/test/float\") ? String(fbdo.to<float>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set double... %s\\n\", Firebase.setDouble(fbdo, \"/test/double\", count + 35.517549723765) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get double... %s\\n\", Firebase.getDouble(fbdo, \"/test/double\") ? String(fbdo.to<double>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set string... %s\\n\", Firebase.setString(fbdo, \"/test/string\", \"Hello World!\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get string... %s\\n\", Firebase.getString(fbdo, \"/test/string\") ? fbdo.to<const char *>() : fbdo.errorReason().c_str());\n\n    // For the usage of FirebaseJson, see examples/FirebaseJson/BasicUsage/Create_Edit_Parse.ino\n    FirebaseJson json;\n\n    if (count == 0)\n    {\n        json.set(\"value/round/\" + String(count), \"cool!\");\n        json.set(\"vaue/ts/.sv\", \"timestamp\");\n        Serial.printf(\"Set json... %s\\n\", Firebase.set(fbdo, \"/test/json\", json) ? \"ok\" : fbdo.errorReason().c_str());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n    WiFi.onEvent(WiFiEvent);\n    ETH.begin(ETH_ADDR, ETH_POWER_PIN, ETH_MDC_PIN, ETH_MDIO_PIN, ETH_TYPE, ETH_CLK_MODE);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (eth_connected && (millis() - sendDataPrevMillis > 30000 || sendDataPrevMillis == 0))\n    {\n        sendDataPrevMillis = millis();\n        setupFirebase();\n        if (Firebase.ready())\n            testFirebase();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "ContinuousStepper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// If using a stepper driver, with STEP and DIR pins\n  stepper.begin(/*step=*/2, /*dir=*/3);\n\n  // If using a four-wire stepper:\n  // stepper.begin(8, 10, 9, 11);\n\n  stepper.spin(200);"
        },
        {
          "name": "loop",
          "body": "stepper.loop();"
        }
      ]
    },
    {
      "name": "DEBUG_ETHERNET_WEBSERVER_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting BasicHttpClient on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();"
        },
        {
          "name": "loop",
          "body": "if (WT32_ETH01_isConnected()) \n  {\n    HTTPClient http;\n\n    Serial.print(\"[HTTP] begin...\\n\");\n    // configure traged server and url\n    //http.begin(\"https://www.howsmyssl.com/a/check\", ca); //HTTPS\n    http.begin(\"http://example.com/index.html\"); //HTTP\n\n    Serial.print(\"[HTTP] GET...\\n\");\n    // start connection and send HTTP header\n    int httpCode = http.GET();\n\n    // httpCode will be negative on error\n    if (httpCode > 0) \n    {\n      // HTTP header has been send and Server response header has been handled\n      Serial.printf(\"[HTTP] GET... code: %d\\n\", httpCode);\n\n      // file found at server\n      if (httpCode == HTTP_CODE_OK) \n      {\n        String payload = http.getString();\n        Serial.println(payload);"
        }
      ]
    },
    {
      "name": "DEBUG_ETHERNET_WEBSERVER_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h",
        "WiFiClientSecure.h"
      ],
      "functions": [
        {
          "name": "setClock",
          "body": "configTime(0, 0, \"pool.ntp.org\");\n\n  Serial.print(F(\"Waiting for NTP time sync: \"));\n  time_t nowSecs = time(nullptr);\n\n  while (nowSecs < 8 * 3600 * 2)\n  {\n    delay(500);\n    Serial.print(F(\".\"));\n    yield();\n    nowSecs = time(nullptr);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting BasicHttpsClient on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  setClock();"
        },
        {
          "name": "loop",
          "body": "if (WT32_ETH01_isConnected())\n  {\n    WiFiClientSecure *client = new WiFiClientSecure;\n\n    if (client) \n    {\n      client -> setCACert(rootCACertificate);\n\n      {\n        // Add a scoping block for HTTPClient https to make sure it is destroyed before WiFiClientSecure *client is\n        HTTPClient https;\n\n        Serial.print(\"[HTTPS] begin...\\n\");\n        if (https.begin(*client, \"https://jigsaw.w3.org/HTTP/connection.html\")) \n        {  \n          // HTTPS\n          Serial.print(\"[HTTPS] GET...\\n\");\n          // start connection and send HTTP header\n          int httpCode = https.GET();\n\n          // httpCode will be negative on error\n          if (httpCode > 0) \n          {\n            // HTTP header has been send and Server response header has been handled\n            Serial.printf(\"[HTTPS] GET... code: %d\\n\", httpCode);\n\n            // file found at server\n            if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) \n            {\n              String payload = https.getString();\n              Serial.println(payload);"
        }
      ]
    },
    {
      "name": "SSID_MAX_LEN",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite",
        "analogWrite"
      ],
      "libraries": [
        "ESP_EEPROM.h",
        "ESPAsyncTCP.h",
        "ESPAsyncWebServer.h",
        "ESP8266WiFi.h",
        "PubSubClient.h",
        "ArduinoOTA.h",
        "dynaHTML.h"
      ],
      "functions": [
        {
          "name": "dynaCallback",
          "body": "Serial.println(\"YOUR CALLBACK WORKED!!!!!!!!!!\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyconfigData.wifi_pw);\n    Serial.println(MyconfigData.mqtt_server);\n    Serial.println(MyconfigData.sensorname);\n    Serial.println(MyconfigData.sensorstatus);\n    Serial.println(MyconfigData.mqtt_id);\n    Serial.println(MyconfigData.mqtt_key);\n    Serial.println(MyconfigData.usb_power);\n    saveconfigtoEE(MyconfigData);\n    // if we are updating data, force a refresh of the SSID\n    MyAPdata.crc32 = 8675309; // If your CRC based on your bssid and channel happen to be Jennys number, CALL HER!\n    saveAPEE(MyAPdata);\n    delay(1000);\n    ESP.restart();"
        },
        {
          "name": "OTAinit",
          "body": "// Port defaults to 8266\n    ArduinoOTA.setPort(8266);\n\n    // Hostname defaults to esp8266-[ChipID]\n    // ArduinoOTA.setHostname(\"DOOR-FRONT-ESP\");\n    ArduinoOTA.setHostname(MyconfigData.sensorname);\n    // if (DEBUG == false) {\n    //  Comment to: No authentication by default\n    ArduinoOTA.setPassword(OTA_PASSDW);\n    // Password can be set with it's md5 value as well\n    // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3\n    // ArduinoOTA.setPasswordHash(\"21232f297a57a5a743894a0e4a801fc3\");\n    //"
        },
        {
          "name": "saveconfigtoEE",
          "body": "EEPROM.put(eepromstart, MyconfigData);\n    JumpStart();\n    boolean ok2 = EEPROM.commit();\n    Serial.println(ok2);"
        },
        {
          "name": "saveAPEE",
          "body": "EEPROM.put(eepromapstart, MyAPData);\n    boolean ok2 = EEPROM.commit();"
        },
        {
          "name": "chkColdStart",
          "body": "EEPROM.get(eepromcoldstart, ColdStart);\n    if (ColdStart.One == 0x45 && ColdStart.Two == 0x72)\n    {\n        hasConfig = true;"
        },
        {
          "name": "JumpStart",
          "body": "ColdStart.One = 0x45;\n    ColdStart.Two = 0x72;\n    EEPROM.put(eepromcoldstart, ColdStart);"
        },
        {
          "name": "setup_wifi",
          "body": "// We start by connecting to a WiFi network\n    WiFi.persistent(true);\n    WiFi.mode(WIFI_STA);\n    WiFi.forceSleepWake();\n    // delay(200);\n    // WiFi.config(staticIP, subnet, gateway, dns);\n    // WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    if (apValid)\n    {\n        Serial.println(\"Using BSSID data\");\n        // The BSSID data was good, make a quick connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw, MyAPdata.channel, MyAPdata.bssid, true);"
        },
        {
          "name": "reconnect",
          "body": "if (WiFi.status() != WL_CONNECTED)\n    {\n        return;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT); // Initialize the BUILTIN_LED pin as an output\n    pinMode(GPIO4, INPUT_PULLUP); // If this pin is LOW, then REPROGRAM by setting up the Access Point.\n    Serial.begin(115200);\n    EEPROM.begin(EEPROM_SIZE);\n    delay(10);\n    MyconfigData = getConfigData();\n    delay(10);\n    MyAPdata = getAPData();\n    delay(10);\n    chkColdStart();\n    Serial.println(\"Config/ap data\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyAPdata.crc32);\n\n    if (hasConfig == false or digitalRead(GPIO4) == LOW)\n    {\n        configmode = CONFIG;\n\n        WiFi.mode(WIFI_AP_STA);\n        WiFi.softAP(ssidAP, passwordAP);\n        IPAddress IP = WiFi.softAPIP();\n\n        dHTML.setCallback(dynaCallback);\n        uint16_t tot = dHTML.setMenuItems(mallItem, NUM_MENU_ITEMS);\n\n        server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request)\n                  { dHTML.handleRequest(request);"
        },
        {
          "name": "loop",
          "body": "if (configmode == RUN)\n    {\n        if (!client.connected())\n        {\n            reconnect();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "SPI.begin();\n  stepper.init(amisSlaveSelect);\n\n  // Drive the NXT/STEP and DIR pins low initially.\n  digitalWrite(amisStepPin, LOW);\n  pinMode(amisStepPin, OUTPUT);\n  digitalWrite(amisDirPin, LOW);\n  pinMode(amisDirPin, OUTPUT);\n\n  // Give the driver some time to power up.\n  delay(1);\n\n  // Reset the driver to its default settings.\n  stepper.resetSettings();\n\n  // Set the current limit.  You should change the number here to\n  // an appropriate value for your particular system.\n  stepper.setCurrentMilliamps(132);\n\n  // Set the number of microsteps that correspond to one full step.\n  stepper.setStepMode(32);\n\n  // Enable the motor outputs.\n  stepper.enableDriver();"
        },
        {
          "name": "loop",
          "body": "// Step in the default direction 1000 times.\n  setDirection(0);\n  for (unsigned int x = 0; x < 1000; x++)\n  {\n    step();"
        },
        {
          "name": "step",
          "body": "// The NXT/STEP minimum high pulse width is 2 microseconds.\n  digitalWrite(amisStepPin, HIGH);\n  delayMicroseconds(3);\n  digitalWrite(amisStepPin, LOW);\n  delayMicroseconds(3);\n\n  // The delay here controls the stepper motor's speed.  You can\n  // increase the delay to make the stepper motor go slower.  If\n  // you decrease the delay, the stepper motor will go fast, but\n  // there is a limit to how fast it can go before it starts\n  // missing steps.\n  delayMicroseconds(2000);"
        },
        {
          "name": "setDirection",
          "body": "// The NXT/STEP pin must not change for at least 0.5\n  // microseconds before and after changing the DIR pin.\n  delayMicroseconds(1);\n  digitalWrite(amisDirPin, dir);\n  delayMicroseconds(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_SleepyDog.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial)\n    delay(10);\n  // wait for Arduino Serial Monitor (native USB boards)\n\n  Serial.println(\"Adafruit Watchdog Library Demo!\");\n  Serial.println();\n\n  // First a normal example of using the watchdog timer.\n  // Enable the watchdog by calling Watchdog.enable() as below.\n  // This will turn on the watchdog timer with a ~4 second timeout\n  // before reseting the Arduino. The estimated actual milliseconds\n  // before reset (in milliseconds) is returned.\n  // Make sure to reset the watchdog before the countdown expires or\n  // the Arduino will reset!\n  int countdownMS = Watchdog.enable(4000);\n  Serial.print(\"Enabled the watchdog with max countdown of \");\n  Serial.print(countdownMS, DEC);\n  Serial.println(\" milliseconds!\");\n  Serial.println();\n\n  // Now loop a few times and periodically reset the watchdog.\n  Serial.println(\"Looping ten times while resetting the watchdog...\");\n  for (int i = 1; i <= 10; ++i) {\n    Serial.print(\"Loop #\");\n    Serial.println(i, DEC);\n    delay(1000);\n    // Reset watchdog with every loop to make sure the sketch keeps running.\n    // If you comment out this call watch what happens in about 4 iterations!\n    Watchdog.reset();"
        },
        {
          "name": "loop",
          "body": "// We'll never actually get to the loop because the watchdog will reset in\n  // the setup function.\n  Serial.println(\"You shouldn't see this message.\");\n  delay(1000);"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();\n  \n  //Set counter index to virtual pin V0 \n  DBlynk.virtualWrite(V0, gsCounter_Index);\n\n  gsCounter_Index++;\n  if(gsCounter_Index > 100) //if counter index more than 100, reset to 0\n  {\n    gsCounter_Index = 0;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "MIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n    MIDI.begin(4);                      // Launch MIDI and listen to channel 4"
        },
        {
          "name": "loop",
          "body": "if (MIDI.read())                    // If we have received a message\n    {\n        digitalWrite(LED_BUILTIN, HIGH);\n        MIDI.sendNoteOn(42, 127, 1);    // Send a Note (pitch 42, velo 127 on channel 1)\n        delay(1000);\t\t            // Wait for a second\n        MIDI.sendNoteOff(42, 0, 1);     // Stop the note\n        digitalWrite(LED_BUILTIN, LOW);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        Serial.println(\"Get multiple documents...\");\n\n        BatchGetDocumentOptions options;\n        options.documents(\"info/countries\");\n        options.documents(\"a0/b0\");\n        options.documents(\"test_collection/test_document\");\n        options.mask(DocumentMask(\"Singapore.population,key1\"));\n\n        // You can set the content of options object directly with options.setContent(\"your content\")\n\n        String payload = Docs.batchGet(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), options);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Batch write documents... \");\n\n        String documentPath = \"test_collection/test_document_map_value\";\n\n        Values::MapValue mapV(\"name\", Values::StringValue(\"value\" + String(counter)));\n        mapV.add(\"count\", Values::StringValue(String(counter)));\n\n        Values::MapValue mapV2(\"key\" + String(counter), mapV);\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV2));\n\n        Values::MapValue labels;\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */), Values::MapValue() /* Labels */);\n\n        String documentPath2 = \"test_collection/test_document_timestamp\";\n        String fieldPath = \"myTime\";\n        FieldTransform::SetToServerValue setValue(FieldTransform::REQUEST_TIME);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, setValue);\n        DocumentTransform transform(documentPath2, fieldTransforms);\n\n        writes.add(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // Serial.println(writes);\n\n        // All Writes, DocumentTransform and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.batchWrite(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_PMIC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// Enable the Charger\n  if (!PMIC.enableCharge()) {\n    Serial.println(\"Error enabling Charge mode\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "attachInterrupt",
        "delay"
      ],
      "libraries": [
        "Arduino_PMIC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "if (millis() - time_last_interrupt > 100) {\n    // Enable the Charger\n    if (!PMIC.enableCharge()) {\n      Serial.println(\"Error enabling Charge mode\");"
        },
        {
          "name": "batteryConnected",
          "body": "time_last_interrupt = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite",
        "analogRead"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);    // initialize serial communication\n  while (!Serial);\n\n  pinMode(LED_BUILTIN, OUTPUT); // initialize the built-in LED pin to indicate when a central is connected\n\n  // begin initialization\n  if (!BLE.begin()) {\n    Serial.println(\"starting BLE failed!\");\n\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// wait for a Bluetooth® Low Energy central\n  BLEDevice central = BLE.central();\n\n  // if a central is connected to the peripheral:\n  if (central) {\n    Serial.print(\"Connected to central: \");\n    // print the central's BT address:\n    Serial.println(central.address());\n    // turn on the LED to indicate the connection:\n    digitalWrite(LED_BUILTIN, HIGH);\n\n    // check the battery level every 200ms\n    // while the central is connected:\n    while (central.connected()) {\n      long currentMillis = millis();\n      // if 200ms have passed, check the battery level:\n      if (currentMillis - previousMillis >= 200) {\n        previousMillis = currentMillis;\n        updateBatteryLevel();"
        },
        {
          "name": "updateBatteryLevel",
          "body": "/* Read the current voltage level on the A0 analog input pin.\n     This is used here to simulate the charge level of a battery.\n  */\n  int battery = analogRead(A0);\n  int batteryLevel = map(battery, 0, 1023, 0, 100);\n\n  if (batteryLevel != oldBatteryLevel) {      // if the battery level has changed\n    Serial.print(\"Battery Level % is now: \"); // print it\n    Serial.println(batteryLevel);\n    batteryLevelChar.writeValue(batteryLevel);  // and update the battery level characteristic\n    oldBatteryLevel = batteryLevel;           // save the level for next comparison"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    const uint32_t startNow { millis() + 2500"
        },
        {
          "name": "loop",
          "body": "if (millis() > printNow) {\n        auto vbat = Power.getVBat();\n        Serial.print(\"Battery Voltage: \");\n        Serial.println(vbat);\n\n        auto solarStatus = Power.getSolarChargerStatus();\n        Serial.print(\"Solar Panel Charger Status: \");\n        Serial.println(solarStatus ? \"OK\" : \"Error\");\n\n        auto fiveVoltsStatus = Power.get5VoltStatus();\n        Serial.print(\"5V Power Rail Status: \");\n        Serial.println(fiveVoltsStatus ? \"OK\" : \"Error\");\n\n        printNow = millis() + printInterval;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoMotorCarrier.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  //while (!Serial);\n\n  if (controller.begin())\n  {\n    Serial.print(\"Nano Motor Shield connected, firmware version \");\n    Serial.println(controller.getFWVersion());"
        },
        {
          "name": "loop",
          "body": "batteryVoltage = battery.getRaw()/236.0;\n  Serial.print(\"Battery voltage: \");\n  Serial.print(batteryVoltage,3);\n  //Serial.println(\"V\");\n  Serial.print(\"V, Raw \");\n  Serial.println(battery.getRaw());\n  delay(5000); //wait for a few seconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "delay"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // initialize the sound speaker\n  Robot.beginSpeaker();"
        },
        {
          "name": "loop",
          "body": "Robot.beep(BEEP_SIMPLE);\n  delay(1000);\n  Robot.beep(BEEP_DOUBLE);\n  delay(1000);\n  Robot.beep(BEEP_LONG);\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[Bell 202] Sending data ... \"));\n\n  // send out idle condition for 500 ms\n  bell.idle();\n  delay(500);\n\n  // BellClient supports all methods of the Serial class\n\n  // Arduino String class\n  String aStr = \"Arduino String\";\n  bell.println(aStr);\n\n  // character array (C-String)\n  bell.println(\"C-String\");\n\n  // string saved in flash\n  bell.println(F(\"Flash String\"));\n\n  // character\n  bell.println('c');\n\n  // byte\n  // formatting DEC/HEX/OCT/BIN is supported for\n  // any integer type (byte/int/long)\n  bell.println(255, HEX);\n\n  // integer number\n  int i = 1000;\n  bell.println(i);\n\n  // floating point number\n  float f = -3.1415;\n  bell.println(f, 3);\n\n  // ITA2-encoded string\n  ITA2String str(\"HELLO WORLD!\");\n  bell.print(str);\n\n  // turn the transmitter off\n  bell.standby();\n\n  Serial.println(F(\"done!\"));\n\n  // wait for a second before transmitting again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "handleNoteOn",
          "body": "gTime_stop = micros();\n\n    const unsigned long diff = gTime_stop - gTime_start;\n    gTime_sum += diff;\n\n    if (diff > gTime_max) gTime_max = diff;\n    if (diff < gTime_min) gTime_min = diff;\n\n    if (gCounter++ >= 1000)\n    {\n        const unsigned long average = gTime_sum / (float)gCounter;\n\n        Serial.println(\"Time to receive NoteOn: \");\n\n        Serial.print(\"Average: \");\n        Serial.print(average);\n        Serial.println(\" microsecs\");\n\n        Serial.print(\"Min:     \");\n        Serial.print(gTime_min);\n        Serial.println(\" microsecs\");\n\n        Serial.print(\"Max:     \");\n        Serial.print(gTime_max);\n        Serial.println(\" microsecs\");\n\n        gCounter = 0;\n        gTime_sum = 0;\n        gTime_max = 0;\n        gTime_min = -1;\n\n        midiBench.turnThruOff();"
        },
        {
          "name": "setup",
          "body": "midiBench.setHandleNoteOn(handleNoteOn);\n    midiBench.begin();\n\n    Serial.begin(115200);\n    while(!Serial);\n    Serial.println(\"Arduino Ready\");\n\n    midiBench.sendNoteOn(69,127,1);"
        },
        {
          "name": "loop",
          "body": "gTime_start = micros();\n    midiBench.read();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "ObloqAdafruit.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "mensajeRecibido",
          "body": "if(topic==\"lampara\"){\n      if(mensaje==\"ON\"){\n        digitalWrite(13,1);"
        },
        {
          "name": "setup",
          "body": "softSerial.begin(9600);\n    olq.setMsgHandle(mensajeRecibido);\n    olq.subscribe(\"lampara\");"
        },
        {
          "name": "loop",
          "body": "olq.update();\n\n    // no usar delay!, chequear el tiempo transcurrido con millis()\n    if(millis() - millisAnterior > 5000)\n    {\n        olq.publish(\"temperatura\", analogRead(A0));\n        millisAnterior =  millis();"
        }
      ]
    },
    {
      "name": "BREATH_THRESHOLD",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "playNote",
          "body": "// Check if the slide switch is off or the candles have been blown out\n  // and stop immediately without playing anything.\n  if (!CircuitPlayground.slideSwitch() || lit < 0) {\n    return;"
        },
        {
          "name": "waitBreath",
          "body": "float peakToPeak = measurePeak(milliseconds);\n  // Serial.println(peakToPeak);\n  while (peakToPeak >= BREATH_THRESHOLD) {\n    // Decrement the number of lit candles and keep it from going below\n    // the value -1 (a sentinel that indicates all the candles are blown out\n    // and no music playback, etc. should occur anymore).\n    lit = max(lit-1, -1);\n    // For the simple solid color animation (i.e. no flickering) only update\n    // the pixels when the lit pixel count changes.  This allows the tone\n    // playback to sound better because the pixels don't need to be updated\n    // during delays and music note playback (the pixel writing messes with\n    // interrupts that drive tone playback and cause scratchier sounding tones).\n    if (animation == SOLID) {\n      showLitSolid();"
        },
        {
          "name": "celebrateSong",
          "body": "// Play a little charge melody, from:\n  //  https://en.wikipedia.org/wiki/Charge_(fanfare)\n  // Note the explicit boolean parameters in particular the measure=false\n  // at the end.  This means the notes will play without any breath measurement\n  // logic.  Without this false value playNote will try to keep waiting for candles\n  // to blow out during the celebration song!\n  playNote(NOTE_G4, EIGHTH_TRIPLE, true, false);\n  playNote(NOTE_C5, EIGHTH_TRIPLE, true, false);\n  playNote(NOTE_E5, EIGHTH_TRIPLE, false, false);\n  playNote(NOTE_G5, EIGHTH, true, false);\n  playNote(NOTE_E5, SIXTEENTH, false);\n  playNote(NOTE_G5, HALF, false);"
        },
        {
          "name": "animatePixels",
          "body": "switch (animation) {\n    case FLICKER:\n      showLitFlicker(current);\n      break;\n    case RAINBOW:\n      showLitRainbow(current);\n      break;\n    // Ignore the SOLID case as it has no animation.\n    // This makes the audio smoother since it doesn't get interrupted by\n    // NeoPixel writing like the other animations.  The pixels are instead\n    // changed only once when the number of lit candles changes (see the\n    // waitBreath function's loop).\n    default: break;"
        },
        {
          "name": "setPixelHSV",
          "body": "// Convert HSV to RGB\n  float r, g, b = 0.0;\n  HSVtoRGB(&r, &g, &b, h, s, v);\n  // Lookup gamma correct RGB colors (also convert from 0...1.0 RGB range to 0...255 byte range).\n  uint8_t r1 = pgm_read_byte(&gamma8[int(r*255.0)]);\n  uint8_t g1 = pgm_read_byte(&gamma8[int(g*255.0)]);\n  uint8_t b1 = pgm_read_byte(&gamma8[int(b*255.0)]);\n  // Set the color of the pixel.\n  CircuitPlayground.strip.setPixelColor(i, r1, g1, b1);"
        },
        {
          "name": "showLitRainbow",
          "body": "// Convert time from milliseconds to seconds.\n  float t = current/1000.0;\n  // Loop through each pixel and compute its color.\n  for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit, so compute its hue from the sine wave\n      // equation and set the color accordingly.  Notice the frequency\n      // is scaled down by 10 to 'slow down' the rainbow flicker animation.\n      // This lets the same random frequencies be shared between fast candle\n      // flame effects and this slower rainbow flicker effect.\n      float x  = sin(2.0*PI*frequencies[i]/10.0*t + phases[i]);\n      // Interpolate the sine wave between all 360 degree hue values.\n      float h = lerp(x, -1.0, 1.0, 0.0, 360.0);\n      setPixelHSV(i, h, 1.0, 1.0);"
        },
        {
          "name": "showLitFlicker",
          "body": "// First determine the low and high bounds of the flicker hues.\n  // These are +/- 10 degrees of the specified target hue and will\n  // wrap around to the start/end as appropriate.\n  float lowHue = fmod(FLAME_HUE - 10.0, 360.0);\n  float highHue = fmod(FLAME_HUE + 10.0, 360.0);\n  // Convert time from milliseconds to seconds.\n  float t = current/1000.0;\n  // Loop through each pixel and compute its color.\n  for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit, so compute its hue by composing\n      // a low frequency / slowly changing sine wave with a high\n      // frequency / fast changing cosine wave.  This means the candle will\n      // pulse and jump around in an organice but random looking way.\n      // The frequencies and phases of the waves are randomly generated at\n      // startup in the setup function.\n      // Low frequency wave is a sine wave with random freuqency between 1 and 4,\n      // and offset by a random phase to keep pixels from all starting at the same\n      // color:\n      float lowFreq  = sin(2.0*PI*frequencies[i]*t + phases[i]);\n      // High frequency is a faster changing cosine wave that uses a different\n      // pixel's random frequency.\n      float highFreq = cos(3.0*PI*frequencies[(i+5)%10]*t);\n      // Add the low and high frequency waves together, then interpolate their value\n      // to a hue that's +/-20% of the configured target hue.\n      float h = lerp(lowFreq+highFreq, -2.0, 2.0, lowHue, highHue);\n      setPixelHSV(i, h, 1.0, 1.0);"
        },
        {
          "name": "showLitSolid",
          "body": "for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit.\n      setPixelHSV(i, FLAME_HUE, 1.0, 1.0);"
        },
        {
          "name": "HSVtoRGB",
          "body": "int i;\n  float f, p, q, t;\n  if( s == 0 ) {\n    // achromatic (grey)\n    *r = *g = *b = v;\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize serial output and Circuit Playground library.\n  Serial.begin(115200);\n  CircuitPlayground.begin();\n  // Check if a button is being pressed at startup and change the\n  // animation mode accordingly.\n  if (CircuitPlayground.leftButton()) {\n    // Rainbow animation on left button press at startup.\n    animation = RAINBOW;"
        },
        {
          "name": "loop",
          "body": "// Play happy birthday tune, from:\n  //  http://www.irish-folk-songs.com/happy-birthday-tin-whistle-sheet-music.html#.WXFJMtPytBw\n  // Inside each playNote call it will play a note and drive the NeoPixel animation\n  // and check for a breath against the sound sensor.  Once all the candles are blown out\n  // the playNote calls will stop playing music.\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_E4, QUARTER);       // Bar 1\n  playNote(NOTE_D4, QUARTER);\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_FS4, HALF);         // Bar 2\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_E4, QUARTER);       // Bar 3\n  playNote(NOTE_D4, QUARTER);\n  playNote(NOTE_A4, QUARTER);\n  playNote(NOTE_G4, HALF);          // Bar 4\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_D5, QUARTER);       // Bar 5\n  playNote(NOTE_B4, QUARTER);\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_FS4, QUARTER);      // Bar 6\n  playNote(NOTE_E4, QUARTER);\n  playNote(NOTE_C5, EIGHTH, true);\n  playNote(NOTE_C5, EIGHTH);\n  playNote(NOTE_B4, QUARTER);       // Bar 7\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_A4, QUARTER);\n  playNote(NOTE_G4, HALF);          // Bar 8\n  // One second pause before repeating the loop and playing\n  // the tune again.  Use waitBreath instead of delay so the\n  // pixel animation and breath check continues to happen.\n  waitBreath(1000);"
        }
      ]
    },
    {
      "name": "FLASH_TYPE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Audio.h",
        "Adafruit_Keypad.h",
        "Adafruit_SPIFlash_FatFs.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // open the serial\n\n  customKeypad.begin();\n\n  // Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(40); //this is WAY more tha nwe need\n  // Initialize flash library and check its chip ID.\n  if (!flash.begin()) {\n    while(1){\n      Serial.println(\"Error, failed to initialize flash chip!\");\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "customKeypad.tick();\n  \n  while(customKeypad.available())\n  {\n    keypadEvent e = customKeypad.read();\n    if(e.bit.EVENT == KEY_JUST_PRESSED){\n        if(e.bit.KEY == 1){\n          //Bitcrusher BitDepth\n          if (current_CrushBits >= 2) { //eachtime you press it, deduct 1 bit from the settings.\n              current_CrushBits--;"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "setupETH",
          "body": "Serial.print(\"[ETH]: Connecting\");\n  \n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n  \n  Serial.print(\"[ETH]: IP-Address is \");\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "setupSinricPro",
          "body": "// get a new Blinds device from SinricPro\n  SinricProBlinds &myBlinds = SinricPro[BLINDS_ID];\n  myBlinds.onPowerState(onPowerState);\n  myBlinds.onSetPosition(onSetPosition);\n  myBlinds.onAdjustPosition(onAdjustPosition);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.print(F(\"\\nStart Blinds on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(SINRICPRO_VERSION_STR);\n  \n  setupETH();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//nothing here"
        },
        {
          "name": "loop",
          "body": "led.on();       // set the LED on\n  delay(1000);    // wait for a second\n  led.off();      // set the LED off\n  delay(1000);    // wait for a second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogRead",
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  randomSeed(analogRead(0));\n\n#ifdef CORE_CM7\n  bootM4();\n  myLED = LEDB; // built-in blue LED\n#endif\n#ifdef CORE_CM4\n  myLED = LEDG; // built-in greeen LED\n#endif\n  pinMode(myLED, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  digitalWrite(myLED, LOW); // turn the LED on\n  delay(200);\n  digitalWrite(myLED, HIGH); // turn the LED off\n  delay( rand() % 2000 + 1000); // wait for a random amount of time between 1 and 3 seconds."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "loopTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  for (int i = 10; i > 0; i--) {\n    Serial.println(i);\n    delay(500);"
        },
        {
          "name": "blinkLed13",
          "body": "digitalWrite(led, HIGH);   // turn the led on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(led, LOW);    // turn the led off by making the voltage LOW\n  delay(1000);                       // wait for a second"
        },
        {
          "name": "loop",
          "body": "loopTimer.check(Serial);\n  blinkLed13(); // call the method to blink the led"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n    pinMode(LEDG, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(LEDG, LOW); // turn the LED on (LOW is the voltage level)\n    delay(500); // wait for half a second\n    digitalWrite(LEDG, HIGH); // turn the LED off by making the voltage HIGH\n    delay(500); // wait for half a second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial1.begin(9600);\n      pinMode(LED_BUILTIN, OUTPUT);\n      digitalWrite(LED_BUILTIN, LOW);\n\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "if (Serial1.available()) {\n        auto c = Serial1.read();\n        digitalWrite(LED_BUILTIN, c);"
        },
        {
          "name": "setup",
          "body": "EdgeControl.begin();\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_MKR2);\n\n    // Wait for MKR to power on\n    delay(5000);\n\n    SerialMKR2.begin(115200);\n    while (!SerialMKR2) {\n        delay(500);"
        },
        {
          "name": "loop",
          "body": "SerialMKR2.write(led);\n    led = !led;\n    delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n  bootM4();\n  pinMode(LEDR, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(LEDR, LOW); // turn the red LED on (LOW is the voltage level)\n  delay(200); // wait for 200 milliseconds\n  digitalWrite(LEDR, HIGH); // turn the LED off by setting the voltage HIGH\n  delay(200); // wait for 200 milliseconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n  pinMode(LEDR, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(LEDR, HIGH); // turn the LED off (HIGH is the voltage level)\n  delay(200); // wait for 200 milliseconds\n  digitalWrite(LEDR, LOW); // turn the LED on by making the voltage LOW\n  delay(200); // wait for 200 milliseconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite"
      ],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n\n  t.setInterval([]() { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "loop",
          "body": "t.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LEDpin, OUTPUT);\n  LEDtime.start();"
        },
        {
          "name": "loop",
          "body": "if(LEDtime.update())//Checks to see if set time has past\n  {\n    // if the LED is off turn it on and vice-versa:\n    if (ledState == LOW)\n      ledState = HIGH;\n    else\n      ledState = LOW;\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(LEDpin, ledState);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LEDpin, OUTPUT);\n  LEDtime.start();"
        },
        {
          "name": "loop",
          "body": "LEDtime.update();//will check if set time has past and if so will run set function"
        },
        {
          "name": "ledBlink",
          "body": "// if the LED is off turn it on and vice-versa:\n    if (ledState == LOW)\n      ledState = HIGH;\n    else\n      ledState = LOW;\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(LEDpin, ledState);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LEDpin, OUTPUT);\n  LEDtime.start();"
        },
        {
          "name": "loop",
          "body": "LEDtime.update();//will check if set time has past and if so will run set function"
        },
        {
          "name": "ledBlink",
          "body": "// if the LED is off turn it on and vice-versa:\n    if (ledState == LOW)\n      ledState = HIGH;\n    else\n      ledState = LOW;\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(LEDpin, ledState);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "myDelay",
          "body": "delay(milli);"
        },
        {
          "name": "myWrite",
          "body": "digitalWrite(pin, val);"
        },
        {
          "name": "myMode",
          "body": "pinMode(pin, mode);"
        },
        {
          "name": "setup",
          "body": "struct js *js = js_create(buf, sizeof(buf));\n  jsval_t global = js_glob(js), gpio = js_mkobj(js);    // Equivalent to:\n  js_set(js, global, \"gpio\", gpio);                     // let gpio = {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && (millis() - sendDataPrevMillis > 15000 || sendDataPrevMillis == 0))\n  {\n    sendDataPrevMillis = millis();\n\n    // Create demo data\n    uint8_t data[256];\n    for (int i = 0; i < 256; i++)\n      data[i] = count;\n\n    Serial.printf(\"Set BLOB... %s\\n\", Firebase.setBlob(fbdo, \"/test/blob\", data, sizeof(data)) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get BLOB... %s\\n\", Firebase.getBlob(fbdo, \"/test/blob\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK) // 200\n      printResult(fbdo);                                // see addons/RTDBHelper.h\n\n    Serial.println();\n\n    (count < 255) ? count++ : count = 0;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "millisDelay.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the digital pin as an output.\n  Serial.begin(9600);\n  // wait a few sec to let user open the monitor\n  for (int i = 5; i > 0; i--) {\n    delay(1000);\n    Serial.print(i); Serial.print(' ');"
        },
        {
          "name": "loop",
          "body": "ledBlockOnDelay.justFinished(); // check for timeout and set isRunning() false when timed out\n\n  if (ledOnDelay.justFinished()) { // don't combine this test with any other condition\n    // on delay timed out\n    digitalWrite(led, LOW); // turn led off\n    Serial.println(\"ledOnDelay finished, LED turned off.\");\n    ledBlockOnDelay.start(BLOCKING_DELAY_TIME);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial1.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogRead",
        "analogWrite",
        "delay"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Ciao.begin();  //Start the serial connection with the computer\n                       //to view the result open the serial monitor\n  pinMode(9,OUTPUT);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  pinMode(BuiltIn_LED, OUTPUT);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n\n  // Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready())\n  {\n    if (!Firebase.readStream(stream))\n      Serial.printf(\"sream read error, %s\\n\\n\", stream.errorReason().c_str());\n\n    if (stream.streamTimeout())\n      Serial.println(\"stream timeout, resuming...\\n\");\n\n    if (stream.streamAvailable())\n    {\n\n      Serial.printf(\"sream path, %s\\nevent path, %s\\ndata type, %s\\nevent type, %s\\nvalue, %d\\n\\n\",\n                    stream.streamPath().c_str(),\n                    stream.dataPath().c_str(),\n                    stream.dataType().c_str(),\n                    stream.eventType().c_str(),\n                    stream.intData());\n\n      if (stream.dataType() == \"int\")\n      {\n        if (stream.intData() == 1)\n        {\n          digitalWrite(BuiltIn_LED, HIGH);\n          led.on();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// See the connection status in Serial Monitor\n  Serial.begin(9600);\n\n  // Here your Arduino connects to the Blynk Cloud.\n  Blynk.begin(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "body": "// All the Blynk Magic happens here...\n  Blynk.run();\n\n  // You can inject your own code or combine it with other sketches.\n  // Check other examples on how to communicate with Blynk. Remember\n  // to avoid delay() function!"
        }
      ]
    },
    {
      "name": "BLYNK_NO_INFO",
      "keywords": [],
      "libraries": [
        "BlynkSimpleUserDefined.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Blynk.begin(auth);\n  Blynk.connect();"
        },
        {
          "name": "loop",
          "body": "bool hasIncomingData = (test > 0);\n\n  if (!Blynk.run(hasIncomingData)) {"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "TinyGsmClient.h",
        "BlynkSimpleTinyGSM.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n  delay(6000);\n\n  // Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  SerialMon.println(\"Initializing modem...\");\n  modem.restart();\n\n  String modemInfo = modem.getModemInfo();\n  SerialMon.print(\"Modem Info: \");\n  SerialMon.println(modemInfo);\n\n  // Unlock your SIM card with a PIN\n  // modem.simUnlock(\"1234\");\n\n  Blynk.begin(auth, modem, apn, user, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "ENABLE_MINIMIZATION",
      "keywords": [],
      "libraries": [
        "BlynkSimpleUserDefined.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Blynk.begin(auth);\n  Blynk.connect();"
        },
        {
          "name": "loop",
          "body": "bool hasIncomingData = (test > 0);\n\n  if (!Blynk.run(hasIncomingData)) {"
        }
      ]
    },
    {
      "name": "BLYNK_HEARTBEAT",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "TinyGsmClient.h",
        "BlynkSimpleSIM800.h",
        "BlynkSimpleTinyGSM.h",
        "StreamDebugger.h",
        "ArduinoHttpClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(200);\n\n#if ( BLYNK_HTTP_CLIENT_USING_ETHERNET )  \n  Serial.print(F(\"\\nStart BlynkHTTPClient on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  #if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n    // Deselect the SD card\n    pinMode(SDCARD_CS, OUTPUT);\n    digitalWrite(SDCARD_CS, HIGH);\n  #endif\n\n#else\n  Serial.print(F(\"\\nStart BlynkHTTPClient on \")); Serial.print(BOARD_NAME);\n  Serial.println(F(\" using GSM/GPRS Modem\");\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n  delay(3000);\n\n  // Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  SerialMon.println(F(\"Initializing modem...\"));\n  modem.restart();\n\n  String modemInfo = modem.getModemInfo();\n  SerialMon.print(F(\"Modem: \"));\n  SerialMon.println(modemInfo);\n\n  // Unlock your SIM card with a PIN\n  //modem.simUnlock(\"1234\");\n#endif\n\n#if ( BLYNK_HTTP_CLIENT_USING_ETHERNET )\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(blynk_auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(blynk_auth);\n#endif\n#endif\n#else\n  Blynk.begin(blynk_gsm_auth, modem, apn, user, pass);\n#endif\n\n  if (Blynk.connected())\n    SerialMon.println(F(\"Blynk connected\"));"
        },
        {
          "name": "HTTPClientHandle",
          "body": "#if !( BLYNK_HTTP_CLIENT_USING_ETHERNET )\n\n  SerialMon.print(F(\"Waiting for network...\"));\n  if (!modem.waitForNetwork())\n  {\n    SerialMon.println(F(\" fail\"));\n    return;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    HTTPClientHandle();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "WiFi.h",
        "BlynkSimpleEsp32.h",
        "IRremoteESP8266.h",
        "IRsend.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "#if defined(BLYNK_PRINT)\n  // Debug console\n  Serial.begin(115200);\n#endif  // BLYNK_PRINT\n\n  Blynk.begin(auth, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "SerialDbg.begin(115200);\n  waitSerialConsole(SerialDbg);\n\n  // Power-up NCP (if needed)\n#if defined(ARDUINO_NANO_RP2040_CONNECT)\n  pinMode(NINA_RESETN, OUTPUT);\n  digitalWrite(NINA_RESETN, HIGH);\n#endif\n\n  if (!ncpSetupSerial()) {\n    return;"
        },
        {
          "name": "sendPeriodicMessage",
          "body": "static uint32_t last_change = millis();\n  if (millis() - last_change > 10000) {\n    last_change += 10000;\n\n    // Send a value to Blynk Virtual Pin 1\n    virtualWrite(1, millis());"
        },
        {
          "name": "loop",
          "body": "rpc_run();\n\n  sendPeriodicMessage();"
        },
        {
          "name": "rpc_client_blynkVPinChange_impl",
          "body": "// NOTE: we could copy the buffer, but we use 0-copy instead\n    // But we need to 0-terminate it, overwriting the CRC8\n    param.data[param.length] = '\\0';\n\n    SerialDbg.print(F(\"Got data on Virtual Pin \"));\n    SerialDbg.println(vpin);\n\n    // Param format. Most values will be plain strings: \"Hello world\", \"1234\", \"123.456\", etc.\n    // However, sometimes the value contains multiple items (an array). In this case, the values are separated using a 0x00 byte, i.e:\n    // \"First\\0Second\\0Third\""
        },
        {
          "name": "rpc_client_blynkStateChange_impl",
          "body": "SerialDbg.print(F(\"NCP state: \"));\n  SerialDbg.println(ncpGetStateString(state));\n  if ((RpcBlynkState)state == BLYNK_STATE_CONNECTED) {\n    // Send a value to Virtual Pin 1\n    virtualWrite(1, \"hello world!\");"
        },
        {
          "name": "rpc_client_processEvent_impl",
          "body": "switch ((RpcEvent)event) {\n    /*\n     * System events\n     */\n    case RPC_EVENT_NCP_REBOOTING:\n      SerialDbg.println(F(\"NCP is rebooting. TODO: reinitialize NCP\"));\n      break;\n    case RPC_EVENT_BLYNK_PROVISIONED:\n      SerialDbg.println(F(\"NCP finished provisioning\"));\n      break;\n    case RPC_EVENT_BLYNK_TIME_SYNC:\n      SerialDbg.println(F(\"NCP requests time sync from external time source\"));\n      break;\n    case RPC_EVENT_BLYNK_TIME_CHANGED: break;\n      SerialDbg.println(F(\"NCP local time changed\"));\n      break;\n    /*\n     * User button events (see rpc_hw_initUserButton)\n     */\n    case RPC_EVENT_HW_USER_CLICK:\n      SerialDbg.println(F(\"NCP: user button click\"));\n      break;\n    case RPC_EVENT_HW_USER_DBLCLICK:\n      SerialDbg.println(F(\"NCP: user button double click\"));\n      break;\n    case RPC_EVENT_HW_USER_LONGPRESS:\n      SerialDbg.println(F(\"NCP: user button long press start\"));\n      break;\n    case RPC_EVENT_HW_USER_LONGRELEASE:\n      SerialDbg.println(F(\"NCP: user button long press stop\"));\n      break;\n    case RPC_EVENT_HW_USER_RESET_START:\n      SerialDbg.println(F(\"NCP: Button is pressed for 10 seconds => release to clear configuration\"));\n      break;\n    case RPC_EVENT_HW_USER_RESET_CANCEL:\n      SerialDbg.println(F(\"NCP: Button is pressed for 15 seconds => cancel config reset operation\"));\n      break;\n    case RPC_EVENT_HW_USER_RESET_DONE:\n      SerialDbg.println(F(\"NCP: Button was released => configuration is reset\"));\n      break;\n    default: break;"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);\n\n  //set Output pin to output\n  for(short i=0; i<4; i++)\n  {\n    pinMode(gsOut_PinArray[i], OUTPUT);\n    digitalWrite(gsOut_PinArray[i], LOW);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();\n\n  //checking virtual pin V0 to V4, if high turn on the output pin. Otherwise, turn off\n  for(short i=V0; i<V4; i++)\n  {\n    if(DBlynk.read_asInt(i) == 1)\n    {\n      digitalWrite(gsOut_PinArray[i], HIGH);"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();"
        }
      ]
    },
    {
      "name": "BOARD_TYPE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "BlynkSimpleEsp8266_WM.h",
        "BlynkSimpleEsp32_WFM.h",
        "BlynkSimpleEsp8266_SSL_WM.h",
        "BlynkSimpleEsp32_SSL_WM.h",
        "BlynkSimpleEsp8266_WM.h",
        "BlynkSimpleEsp32_WM.h",
        "BlynkSimpleEsp8266_SSL.h",
        "BlynkSimpleEsp32_SSL.h",
        "BlynkSimpleEsp8266.h",
        "BlynkSimpleEsp32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// HELP DEBUG THIS SKETCH WITH GOOD PRINTOUTS\n  Serial.begin ( SERIAL_SPEED );\n  delay ( 500 );  \n  Serial.println ( F(\"\\n\\n=======================================\") );\n  Serial.print ( SKETCH_NAME );\n\n#if (USE_LITTLEFS)\n  Serial.print( F(\" ** Using LITTLEFS **\") );\n#elif (USE_SPIFFS)\n  Serial.print( F(\" ** Using SPIFFS **\") );  \n#else\n  Serial.print( F(\" ** Using EEPROM **\") );\n#endif\n  \n#if USE_SSL\n  Serial.print ( F(\" ** Using SSL **\") );  \n#endif\nSerial.println();\n\n#if USE_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  connectToWLANandBlynk();  // Connect to WiFi, then to Blynk server\n\n  setupBlynkTimers();  // Establish Blynk timers after Blynk is connected\n\n  // Initialize Onboard LED \n  pinMode ( LED_BUILTIN, OUTPUT );  \n  digitalWrite ( LED_BUILTIN, LED_BUILTIN_LOW ); \n    \n  // Set Blynk Virtual Heartbeat LED OFF\n  Blynk.virtualWrite ( heartbeatVpin, 000 );  \n  heartbeatLEDblink(); // start first heartbeat \n  \n  Serial.println ( F(\"\\nSetup complete \\n\") );"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  myTimer.run();"
        },
        {
          "name": "connectToWLANandBlynk",
          "body": "// Setup WLAN and Blynk\n  Serial.print ( F(\"\\nSetting up WLAN and Blynk \") );  \n  #if USE_WM\n    Serial.println ( F(\"WITH WiFiManager\") ); \n  #else\n    Serial.println ( F(\"WITHOUT WiFiManager\") );  \n  #endif\n  \n  #if USE_WM\n    Serial.println ( F(\"Starting Blynk.begin (with WM)\") );  \n\n    // SET UP THE CONFIG PORTAL CREDENTIALS AND CONNECTION INFO\n    Blynk.setConfigPortalChannel ( 0 );  // 0 -> Use a random WiFi 2.4GHz channel for the Config Portal\n    Blynk.setConfigPortal ( CONFIG_PORTAL_SSID, CONFIG_PORTAL_PASSWORD ); // Set up Config Portal SSID & Password\n    Blynk.setConfigPortalIP ( IPAddress ( CONFIG_PORTAL_IPADDRESS ) ); // Set up IP address for COnfig Portal once connected to WiFi\n\n    Serial.print ( F(\"Blynk.setConfigPortal(\") ); \n    Serial.print ( CONFIG_PORTAL_SSID ); Serial.print ( F(\",\") );  \n    Serial.print ( CONFIG_PORTAL_PASSWORD ); Serial.println ( F(\")\") );   \n    Serial.print ( F(\"  Config Portal will be found at IP: \") ); Serial.print ( IPAddress ( CONFIG_PORTAL_IPADDRESS ) );  \n    Serial.println ( F(\"\\n\") );  \n    \n    //Blynk.config ( blynkAuth );  // not needed with WM \n    Blynk.begin ( DEVICE_HOST_NAME ); // DHCP (router) device name\n  \n  #else//NOT using WM\n    Serial.println ( F(\"Starting WiFi.begin (no WM)\") );  \n    WiFi.begin ( WiFiSSID, WiFiPass );\n    Serial.println ( F(\"... waiting a few seconds for WiFi ...\") );    \n    #if ESP8266\n      delay ( 7500 );  // For esp8266, it needs a delay to realize it has connected\n    #endif\n      \n    // REBOOT if we do not have a good WiFi connection\n    if ( WiFi.status() != WL_CONNECTED )\n    {\n      Serial.println ( F(\"Resetting in a few seconds...\\n\\n\\n\\n\\n\") );\n      delay ( 3000 );  \n      ESP.restart();"
        },
        {
          "name": "setupBlynkTimers",
          "body": "Serial.println ( F(\"Setting up Blynk timers\") );  \n  // Interval timer for heartbeatLED (Blynk LED and onboard LED\n  heartbeatLEDtimerID = myTimer.setInterval ( heartbeatLEDinterval, heartbeatLEDblink );  \n\n  Serial.println ( F(\"... Blynk timers set up.\") );"
        },
        {
          "name": "updateDynamicParameters",
          "body": "Serial.print ( F(\"\\nupdateDynamicParameters has: \") ); \n  Serial.print ( F(\"\\n   controlVpinC/label = \"\"\") );   Serial.print ( controlVpinC );   Serial.print ( F(\"\"\"/\") ); Serial.print ( controlLabel ); \n  Serial.print ( F(\"\\n   heartbeatVpinC/label = \"\"\") ); Serial.print ( heartbeatVpinC ); Serial.print ( F(\"\"\"/\") ); Serial.print ( heartbeatLabel ); \n  Serial.print ( F(\"\\n   displayVpinC/label = \"\"\") );   Serial.print ( displayVpinC );   Serial.print ( F(\"\"\"/\") ); Serial.print ( displayLabel ); \n  Serial.println ( F(\"\\n\") );  \n    \n  // Convert char Virtual Pin numbers to int in preperation for Blynk connect\n  controlVpin = atoi ( controlVpinC );\n  if ( controlVpin < 0 || controlVpin > 255 )\n  {\n    controlVpin = atoi ( CONTROL_DEFAULT_VPIN );\n    Serial.print ( F(\"**** Bad controlVpin input value of \") );\n    Serial.println ( controlVpinC );"
        }
      ]
    },
    {
      "name": "ARGS_SEP_CODE",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//init Ciao\n\tCiao.begin();\n\tSerial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "if(ArduinoBoard == \"\"){\n\t\t//Run commands in Linino OS to get the board model\n\t\tCiaoData data = Ciao.write(\"shell\",\"awk\",\"'/machine/ {print $4"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "event_handler",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_CLICKED)\n  {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was pressed\\n\", txt);\n    if (Serial) Serial.println(txt);\n\n    if (strcmp(txt, \"Move\") == 0)\n      move_joint = !move_joint;"
        },
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_add_event_cb(btnm1, event_handler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  for (auto const start = millis(); !Serial && ((millis() - start) < 5000); delay(10)) {"
        },
        {
          "name": "loop",
          "body": "if (move_joint)\n  {\n    Braccio.move(4).to((SmartServoClass::MAX_ANGLE / 2.0f) - 45.0f);\n    delay(2000);\n    Braccio.move(4).to((SmartServoClass::MAX_ANGLE / 2.0f) + 45.0f);\n    delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin(custom_main_menu))\n  {\n    app.enableButtons();\n    /* Allow greater angular velocity than the default one. */\n    Braccio.setAngularVelocity(45.0f);"
        },
        {
          "name": "loop",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);"
        }
      ]
    },
    {
      "name": "BUTTON_SELECT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin())\n  {\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(TIME_DELAY);"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n  {\n    // Pinch movement\n    gripper.move().to(230.0f);         delay(TIME_DELAY);\n    gripper.move().to(HOME_POS[0]);    delay(TIME_DELAY);\n\n    // // Wrist Roll movement\n    wristRoll.move().to(0.0f);          delay(TIME_DELAY);\n    wristRoll.move().to(HOME_POS[1]);   delay(TIME_DELAY);\n    wristRoll.move().to(315.0f);        delay(TIME_DELAY);\n    wristRoll.move().to(HOME_POS[1]);   delay(TIME_DELAY);\n\n    // // Wrist Pitch movement\n    wristPitch.move().to(70.0f);       delay(TIME_DELAY);\n    wristPitch.move().to(HOME_POS[2]); delay(TIME_DELAY);\n    wristPitch.move().to(260.0f);      delay(TIME_DELAY);\n    wristPitch.move().to(HOME_POS[2]); delay(TIME_DELAY);\n\n    // Elbow movement\n    for(float i=HOME_POS[3]; i >= 70.0; i-=5)\n        { elbow.move().to(i);          delay(TIME_DELAY/2000);"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_SSD1331.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.begin(); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_SSD1351.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.begin(); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7735.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.initR(INITR_144GREENTAB); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7735.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.initR(INITR_BLACKTAB); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7735.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.initR(INITR_MINI160x80); // Initialize screen\n  Serial.println(F(\"TFT initialized.\"));\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'rgbwheel.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/rgbwheel.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(170, 320);           // Init ST7789 170x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(172, 320);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(135, 240);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(240, 240);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(240, 280);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.init(240, 320);           // Init ST7789 320x240\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "analogWrite",
        "analogRead",
        "delay"
      ],
      "libraries": [
        "Bridge.h",
        "BridgeServer.h",
        "BridgeClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Bridge startup\n  pinMode(13, OUTPUT);\n  digitalWrite(13, LOW);\n  Bridge.begin();\n  digitalWrite(13, HIGH);\n\n  // Listen for incoming connection only from localhost\n  // (no one from the external network could connect)\n  server.listenOnLocalhost();\n  server.begin();"
        },
        {
          "name": "loop",
          "body": "// Get clients coming from server\n  BridgeClient client = server.accept();\n\n  // There is a new client?\n  if (client) {\n    // Process request\n    process(client);\n\n    // Close connection and free resources.\n    client.stop();"
        },
        {
          "name": "process",
          "body": "// read the command\n  String command = client.readStringUntil('/');\n\n  // is \"digital\" command?\n  if (command == \"digital\") {\n    digitalCommand(client);"
        },
        {
          "name": "digitalCommand",
          "body": "int pin, value;\n\n  // Read pin number\n  pin = client.parseInt();\n\n  // If the next character is a '/' it means we have an URL\n  // with a value like: \"/digital/13/1\"\n  if (client.read() == '/') {\n    value = client.parseInt();\n    digitalWrite(pin, value);"
        },
        {
          "name": "analogCommand",
          "body": "int pin, value;\n\n  // Read pin number\n  pin = client.parseInt();\n\n  // If the next character is a '/' it means we have an URL\n  // with a value like: \"/analog/5/120\"\n  if (client.read() == '/') {\n    // Read value and execute command\n    value = client.parseInt();\n    analogWrite(pin, value);\n\n    // Send feedback to client\n    client.print(F(\"Pin D\"));\n    client.print(pin);\n    client.print(F(\" set to analog \"));\n    client.println(value);\n\n    // Update datastore key with the current pin value\n    String key = \"D\";\n    key += pin;\n    Bridge.put(key, String(value));"
        },
        {
          "name": "modeCommand",
          "body": "int pin;\n\n  // Read pin number\n  pin = client.parseInt();\n\n  // If the next character is not a '/' we have a malformed URL\n  if (client.read() != '/') {\n    client.println(F(\"error\"));\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "QNEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial"
        },
        {
          "name": "loop",
          "body": "receivePacket();\n  sendLine();"
        },
        {
          "name": "receivePacket",
          "body": "int size = udp.parsePacket();\n  if (size < 0) {\n    return;"
        },
        {
          "name": "printPrompt",
          "body": "printf(\"chat> \");\n  fflush(stdout);  // printf may be line-buffered, so ensure there's output"
        },
        {
          "name": "sendLine",
          "body": "static String line;\n\n  // Read from the console and send lines\n  if (readLine(line)) {\n    if (!udp.send(Ethernet.broadcastIP(), kPort,\n                  reinterpret_cast<const uint8_t *>(line.c_str()),\n                  line.length())) {\n      printf(\"[Error sending]\\r\\n\");"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif"
        },
        {
          "name": "loop",
          "body": "if (millis() - lastTime > 60 * 1000)\n    {\n        lastTime = millis();\n\n        sendMessage();"
        },
        {
          "name": "sendMessage",
          "body": "Serial.print(\"Send Firebase Cloud Messaging... \");\n\n    // Read more details about legacy HTTP API here https://firebase.google.com/docs/cloud-messaging/http-server-ref\n    FCM_Legacy_HTTP_Message msg;\n\n    FirebaseJsonArray arr;\n    arr.add(DEVICE_REGISTRATION_ID_TOKEN_1);\n    arr.add(DEVICE_REGISTRATION_ID_TOKEN_2);\n    arr.add(DEVICE_REGISTRATION_ID_TOKEN_3);\n\n    msg.targets.registration_ids = arr.raw();\n\n    msg.options.time_to_live = \"1000\";\n    msg.options.priority = \"high\";\n\n    msg.payloads.notification.title = \"Notification title\";\n    msg.payloads.notification.body = \"Notification body\";\n    msg.payloads.notification.icon = \"myicon\";\n    msg.payloads.notification.click_action = \"OPEN_ACTIVITY_1\";\n\n    FirebaseJson payload;\n\n    // all data key-values should be string\n    payload.add(\"temp\", \"28\");\n    payload.add(\"unit\", \"celsius\");\n    payload.add(\"timestamp\", \"1609815454\");\n    msg.payloads.data = payload.raw();\n\n    if (Firebase.FCM.send(&fbdo, &msg)) // send message to recipient\n        Serial.printf(\"ok\\n%s\\n\\n\", Firebase.FCM.payload(&fbdo).c_str());\n    else\n        Serial.println(fbdo.errorReason());\n\n    count++;"
        }
      ]
    },
    {
      "name": "SD_FAT_TYPE",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "benchmark",
          "body": "file_t file;\n  BufferedPrint<file_t, 64> bp;\n  // do write test\n  Serial.println();\n  for (int test = 0; test < 6; test++) {\n    char fileName[13] = \"bench0.txt\";\n    fileName[5] = '0' + test;\n    // open or create file - truncate existing file.\n    if (!file.open(fileName, O_RDWR | O_CREAT | O_TRUNC)) {\n      sd.errorHalt(&Serial, F(\"open failed\"));"
        },
        {
          "name": "testMemberFunctions",
          "body": "BufferedPrint<Print, 32> bp(&Serial);\n  char c = 'c';    // char\n//#define BASIC_TYPES\n#ifdef BASIC_TYPES\n  signed char sc = -1;   // signed 8-bit\n  unsigned char uc = 1;  // unsiged 8-bit\n  signed short ss = -2;  // signed 16-bit\n  unsigned short us = 2; // unsigned 16-bit\n  signed long sl = -4;   // signed 32-bit\n  unsigned long ul = 4;  // unsigned 32-bit\n#else  // BASIC_TYPES\n  int8_t sc = -1;  // signed 8-bit\n  uint8_t uc = 1;  // unsiged 8-bit\n  int16_t ss = -2; // signed 16-bit\n  uint16_t us = 2; // unsigned 16-bit\n  int32_t sl = -4; // signed 32-bit\n  uint32_t ul = 4; // unsigned 32-bit\n#endif  // BASIC_TYPES\n  float f = -1.234;\n  double d = -5.678;\n  bp.println();\n  bp.println(\"Test print()\");\n  bp.print(c);\n  bp.println();\n  bp.print(\"string\");\n  bp.println();\n  bp.print(F(\"flash\"));\n  bp.println();\n  bp.print(sc);\n  bp.println();\n  bp.print(uc);\n  bp.println();\n  bp.print(ss);\n  bp.println();\n  bp.print(us);\n  bp.println();\n  bp.print(sl);\n  bp.println();\n  bp.print(ul);\n  bp.println();\n  bp.print(f);\n  bp.println();\n  bp.print(d);\n  bp.println();\n  bp.println();\n\n  bp.println(\"Test println()\");\n  bp.println(c);\n  bp.println(\"string\");\n  bp.println(F(\"flash\"));\n  bp.println(sc);\n  bp.println(uc);\n  bp.println(ss);\n  bp.println(us);\n  bp.println(sl);\n  bp.println(ul);\n  bp.println(f);\n  bp.println(d);\n  bp.println();\n\n  bp.println(\"Test printField()\");\n  bp.printField(c, ',');\n  bp.printField(\"string\", ',');\n  bp.printField(F(\"flash\"), ',');\n  bp.printField(sc, ',');\n  bp.printField(uc, ',');\n  bp.printField(ss, ',');\n  bp.printField(us, ',');\n  bp.printField(sl, ',');\n  bp.printField(ul, ',');\n  bp.printField(f, ',');\n  bp.printField(d, '\\n');\n\n  bp.sync();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "loopTimer.h",
        "BufferedOutput.h",
        "millisDelay.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  for (int i = 10; i > 0; i--) {\n    Serial.println(i);\n    delay(500);"
        },
        {
          "name": "blinkLed13",
          "body": "if (ledDelay.justFinished()) {   // check if delay has timed out\n    ledDelay.repeat(); // start delay again without drift\n    ledOn = !ledOn;     // toggle the led\n    bufferedOut.print(\"The built-in board led, pin 13, is being turned \"); bufferedOut.println(ledOn?\"ON\":\"OFF\");\n    digitalWrite(led, ledOn?HIGH:LOW); // turn led on/off"
        },
        {
          "name": "print_ms",
          "body": "if (printDelay.justFinished()) {\n    printDelay.repeat(); // start delay again without drift\n    bufferedOut.println(millis());   // print the current ms"
        },
        {
          "name": "loop",
          "body": "bufferedOut.nextByteOut(); // call at least once per loop to release chars\n  loopTimer.check(bufferedOut); // send loop timer output to the bufferedOut\n  blinkLed13(); // call the method to blink the led\n  print_ms(); // print the time"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "ArduinoJson.h",
        "LittleFS.h"
      ],
      "functions": [
        {
          "name": "sendMessageToAllSubscribedUsers",
          "body": "JsonObject users = getSubscribedUsers();\n  unsigned int users_processed = 0;\n\n  for (JsonObject::iterator it = users.begin(); it != users.end(); ++it)\n  {\n    users_processed++;\n    if (users_processed < MESSAGES_LIMIT_PER_SECOND)\n    {\n      const char *chat_id = it->key().c_str();\n      bot.sendMessage(chat_id, message, \"\");"
        },
        {
          "name": "handleNewMessages",
          "body": "Serial.print(\"handleNewMessages: \");\n  Serial.println(numNewMessages);\n\n  for (int i = 0; i < numNewMessages; i++)\n  {\n    String chat_id = bot.messages[i].chat_id;\n    String text = bot.messages[i].text;\n    String from_name = bot.messages[i].from_name;\n    if (from_name == \"\")\n      from_name = \"Guest\";\n\n    if (text == \"/start\")\n    {\n      if (addSubscribedUser(chat_id, from_name))\n      {\n        String welcome = \"Welcome to Universal Arduino Telegram Bot library.\\n\";\n        welcome += \"This is Bulk Messages example.\\n\\n\";\n        welcome += \"You, \" + from_name + \", have been subscribed.\\n\";\n        welcome += \"/showallusers : show all subscribed users\\n\";\n        welcome += \"/testbulkmessage : send test message to subscribed users\\n\";\n        welcome += \"/removeallusers : remove all subscribed users\\n\";\n        welcome += \"/stop : unsubscribe from bot\\n\";\n        bot.sendMessage(chat_id, welcome, \"Markdown\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  if (!LittleFS.begin())\n  {\n    Serial.println(\"Failed to mount file system\");\n    return;"
        },
        {
          "name": "loop",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//nothing here"
        },
        {
          "name": "loop",
          "body": "// check the switchState of the button\n  // each time it is pressed, it toggles the LED\n  // when LOW, light should go on\n  if (button.readSwitch() == LOW) {\n    led.on();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "attachInterrupt"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "checkPin",
          "body": "// Invert state, since button is \"Active LOW\"\n  pinValue = !digitalRead(2);\n\n  // Mark pin value changed\n  pinChanged = true;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n\n  // Make pin 2 HIGH by default\n  pinMode(2, INPUT_PULLUP);\n  // Attach INT to our handler\n  attachInterrupt(digitalPinToInterrupt(2), checkPin, CHANGE);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n\n  if (pinChanged) {\n\n    // Process the value\n    if (pinValue) {\n      led1.on();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  pinMode(ledPin, OUTPUT); // use the LED as an output\n  pinMode(buttonPin, INPUT); // use button pin as an input\n\n  // begin initialization\n  if (!BLE.begin()) {\n    Serial.println(\"starting Bluetooth® Low Energy module failed!\");\n\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// poll for Bluetooth® Low Energy events\n  BLE.poll();\n\n  // read the current button pin state\n  char buttonValue = digitalRead(buttonPin);\n\n  // has the value changed since the last read\n  bool buttonChanged = (buttonCharacteristic.value() != buttonValue);\n\n  if (buttonChanged) {\n    // button state changed, update characteristics\n    ledCharacteristic.writeValue(buttonValue);\n    buttonCharacteristic.writeValue(buttonValue);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "checkPin",
          "body": "// Invert state, since button is \"Active LOW\"\n  int state = !digitalRead(2);\n\n  // Debounce mechanism\n  long t = millis();\n  if (state != prevState) {\n    lastChangeTime = t;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n\n  // Make pin 2 default HIGH, and attach INT to our handler\n  pinMode(2, INPUT_PULLUP);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  checkPin();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// we are going to use the serial communication as a\n  // way to see on the PC what is happening on the Arduino\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "if(btn.pressed())\n    Serial.println(\"pressed\");\n  if(btn.held())\n    Serial.println(\"held\");\n  if(btn.released()) {\n    Serial.println(\"released\");\n    Serial.print(\"switch: \");\n    Serial.println(btn.readSwitch());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "EduIntro.h",
        "Keyboard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// we are going to use the serial communication as a\n  // way to see on the PC what is happening on the Arduino\n  Serial.begin(9600);\n\n  // initialize the keyboard controller\n  Keyboard.begin();"
        },
        {
          "name": "loop",
          "body": "for (int i; i < 4; i ++) {\n    if (btn[i].pressed()) {\n      Serial.print(\"pressed pin: \"); Serial.println(btnPins[i]);\n      Keyboard.press(key[i]);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "analogWrite",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "menu.h",
        "menuIO/SSD1306AsciiOut.h",
        "menuIO/keyIn.h",
        "menuIO/chainStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "joystickBtns.begin();\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(LED_BUILTIN, OUTPUT);\n  Wire.begin();\n  oled.begin(&Adafruit128x64, OLED_I2C_ADDRESS); //check config\n  oled.setFont(menuFont);\n  oled.clear();\n  nav.idleTask = idle; //point a function to be used when menu is suspended"
        },
        {
          "name": "loop",
          "body": "nav.poll();\n  delay(1);//simulate a delay when other tasks are done"
        }
      ]
    },
    {
      "name": "CHAR_WIDTH",
      "keywords": [],
      "libraries": [
        "MicroGamer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//initiate mg instance\n  mg.begin();\n\n  // here we set the framerate to 30, we do not need to run at default 60 and\n  // it saves us battery life.\n  mg.setFrameRate(30);\n\n  // set x and y to the middle of the screen\n  x = (WIDTH / 2) - (NUM_CHARS * CHAR_WIDTH / 2);\n  y = (HEIGHT / 2) - (CHAR_HEIGHT / 2);"
        },
        {
          "name": "loop",
          "body": "// pause render until it's time for the next frame\n  if (!(mg.nextFrame()))\n    return;\n\n  // the next couple of lines will deal with checking if the D-pad buttons\n  // are pressed and move our text accordingly.\n  // We check to make sure that x and y stay within a range that keeps the\n  // text on the screen.\n\n  // if the right button is pressed move 1 pixel to the right every frame\n  if(mg.pressed(RIGHT_BUTTON) && (x < X_MAX)) {\n    x++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "digitalWrite",
        "delay",
        "Serial"
      ],
      "libraries": [
        "Arduino_PF1550.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "periodic_cbk",
          "body": "digitalWrite(LEDR, !digitalRead(LEDR));"
        },
        {
          "name": "alarm_cbk",
          "body": "digitalWrite(LED_BUILTIN, LOW);\n  delay(500);\n  digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "/* Enter low power mode. Note: The JLink looses connection here. */\n  R_LPM_LowPowerModeEnter(&p_api_ctrl);\n\n  if (RTC.isRunning())\n  {\n    /* GET CURRENT TIME FROM RTC */\n    RTCTime current_time;\n    RTC.getTime(current_time);\n\n    /* PRINT CURRENT TIME on Serial */\n    Serial.print(\"Current time: \");\n    /* DATE */\n    Serial.print(current_time.getDayOfMonth());\n    Serial.print(\"/\");\n    Serial.print(Month2int(current_time.getMonth()));\n    Serial.print(\"/\");\n    Serial.print(current_time.getYear());\n    Serial.print(\" - \");\n    Serial.print(current_time.getUnixTime());\n    Serial.print(\" - \");\n\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    Serial.print(tv.tv_sec);\n    Serial.print(\" - \");\n\n    /* HOUR:MINUTES:SECONDS */\n    Serial.print(current_time.getHour());\n    Serial.print(\":\");\n    Serial.print(current_time.getMinutes());\n    Serial.print(\":\");\n    Serial.println(current_time.getSeconds());\n\n    delay(1000);"
        }
      ]
    },
    {
      "name": "NO_CANCOMMANDER",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Commanders.h",
        "Accessories.h"
      ],
      "functions": [
        {
          "name": "ReceiveEvent",
          "body": "Accessories::ReceiveEvent(inId, (ACCESSORIES_EVENT_TYPE) inEventType, inEventData);\n\t\n\t#ifdef ACCESSORIES_DEBUG_MODE\n    COMMANDERS_PRINT_EVENT(inId, inEventType, inEventData);\n    #endif"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\t//while (!Serial);\t\t// For Leonardo only. No effect on other Arduino.\n\n\tCommanders::begin(ReceiveEvent, LED_BUILTIN);\n\tAccessories::begin();\n\n\t// Commanders setup\n\n\tDccCommander.begin(0x00, 0x00, digitalPinToInterrupt(2));\n\tSerialCommander.begin();\n\n\tCANCommander.begin(10, CAN_125KBPS, digitalPinToInterrupt(3), 100);\n\n\t// Ports setups\n\n\tPort0.begin(6);\n\tPort1.begin(7);\n\tPort2.begin(8);\n\tPort3.begin(9);\n\tPort4.begin(A0);\n\tPort5.begin(A1);\n\tPort6.begin(A2);\n\tPort7.begin(A3);\n\n\t// Accessories setups\n\n\tspeed = 19;\t// starting speed state : fast.\n\n\tservo0.begin(&Port0, speed, 0, 10, 2);\n\tservo1.begin(&Port1, speed, 0, 10, 2);\n\tservo2.begin(&Port2, speed, 0, 10, 2);\n\tservo3.begin(&Port3, speed, 0, 10, 2);\n\tservo4.begin(&Port4, speed, 0, 10, 2);\n\tservo5.begin(&Port5, speed, 0, 10, 2);\n\tservo6.begin(&Port6, speed, 0, 10, 2);\n\tservo7.begin(&Port7, speed, 0, 10, 2);\n\n\tservo0.AddMinMaxMovingPositions(SERVO0_MIN, SERVO0_MAX);\n\tservo1.AddMinMaxMovingPositions(SERVO1_MIN, SERVO1_MAX);\n\tservo2.AddMinMaxMovingPositions(SERVO2_MIN, SERVO2_MAX);\n\tservo3.AddMinMaxMovingPositions(SERVO3_MIN, SERVO3_MAX);\n\tservo4.AddMinMaxMovingPositions(SERVO4_MIN, SERVO4_MAX);\n\tservo5.AddMinMaxMovingPositions(SERVO5_MIN, SERVO5_MAX);\n\tservo6.AddMinMaxMovingPositions(SERVO6_MIN, SERVO6_MAX);\n\tservo7.AddMinMaxMovingPositions(SERVO7_MIN, SERVO7_MAX);"
        },
        {
          "name": "loop",
          "body": "Commanders::loop();\n\tAccessories::loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "mcp2515.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n \n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_125KBPS);\n  mcp2515.setNormalMode();\n \n  Serial.println(\"------- CAN Speedtest ----------\");"
        },
        {
          "name": "loop",
          "body": "if (mcp2515.readMessage(&canMsg) == MCP2515::ERROR_OK) {\n    cntr++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "mcp2515.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_125KBPS);\n  mcp2515.setNormalMode();\n  \n  Serial.println(\"------- CAN Read ----------\");\n  Serial.println(\"ID  DLC   DATA\");"
        },
        {
          "name": "loop",
          "body": "if (mcp2515.readMessage(&canMsg) == MCP2515::ERROR_OK) {\n    Serial.print(canMsg.can_id, HEX); // print ID\n    Serial.print(\" \"); \n    Serial.print(canMsg.can_dlc, HEX); // print DLC\n    Serial.print(\" \");\n    \n    for (int i = 0; i<canMsg.can_dlc; i++)  {  // print the data\n      Serial.print(canMsg.data[i],HEX);\n      Serial.print(\" \");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "mcp2515.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "canMsg1.can_id  = 0x0F6;\n  canMsg1.can_dlc = 8;\n  canMsg1.data[0] = 0x8E;\n  canMsg1.data[1] = 0x87;\n  canMsg1.data[2] = 0x32;\n  canMsg1.data[3] = 0xFA;\n  canMsg1.data[4] = 0x26;\n  canMsg1.data[5] = 0x8E;\n  canMsg1.data[6] = 0xBE;\n  canMsg1.data[7] = 0x86;\n\n  canMsg2.can_id  = 0x036;\n  canMsg2.can_dlc = 8;\n  canMsg2.data[0] = 0x0E;\n  canMsg2.data[1] = 0x00;\n  canMsg2.data[2] = 0x00;\n  canMsg2.data[3] = 0x08;\n  canMsg2.data[4] = 0x01;\n  canMsg2.data[5] = 0x00;\n  canMsg2.data[6] = 0x00;\n  canMsg2.data[7] = 0xA0;\n  \n  while (!Serial);\n  Serial.begin(115200);\n  \n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_125KBPS);\n  mcp2515.setNormalMode();\n  \n  Serial.println(\"Example: Write to CAN\");"
        },
        {
          "name": "loop",
          "body": "mcp2515.sendMessage(&canMsg1);\n  mcp2515.sendMessage(&canMsg2);\n\n  Serial.println(\"Messages sent\");\n  \n  delay(100);"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[CC1101] Waiting for incoming transmission ... \"));\n\n  // you can receive data as an Arduino String\n  String str;\n  int state = radio.receive(str);\n\n  // you can also receive data as byte array\n  /*\n    byte byteArr[8];\n    int state = radio.receive(byteArr, 8);\n  */\n\n  if (state == RADIOLIB_ERR_NONE) {\n    // packet was successfully received\n    Serial.println(F(\"success!\"));\n\n    // print the data of the packet\n    Serial.print(F(\"[CC1101] Data:\\t\\t\"));\n    Serial.println(str);\n\n    // print RSSI (Received Signal Strength Indicator)\n    // of the last received packet\n    Serial.print(F(\"[CC1101] RSSI:\\t\\t\"));\n    Serial.print(radio.getRSSI());\n    Serial.println(F(\" dBm\"));\n\n    // print LQI (Link Quality Indicator)\n    // of the last received packet, lower is better\n    Serial.print(F(\"[CC1101] LQI:\\t\\t\"));\n    Serial.println(radio.getLQI());"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[CC1101] Waiting for incoming transmission ... \"));\n\n  // you can receive data as an Arduino String\n  String str;\n  int state = radio.receive(str);\n\n  // you can also receive data as byte array\n  /*\n    byte byteArr[8];\n    int state = radio.receive(byteArr, 8);\n  */\n\n  if (state == RADIOLIB_ERR_NONE) {\n    // packet was successfully received\n    Serial.println(F(\"success!\"));\n\n    // print the data of the packet\n    Serial.print(F(\"[CC1101] Data:\\t\\t\"));\n    Serial.println(str);\n\n    // print RSSI (Received Signal Strength Indicator)\n    // of the last received packet\n    Serial.print(F(\"[CC1101] RSSI:\\t\\t\"));\n    Serial.print(radio.getRSSI());\n    Serial.println(F(\" dBm\"));\n\n    // print LQI (Link Quality Indicator)\n    // of the last received packet, lower is better\n    Serial.print(F(\"[CC1101] LQI:\\t\\t\"));\n    Serial.println(radio.getLQI());"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "setFlag",
          "body": "// we got a packet, set the flag\n  receivedFlag = true;"
        },
        {
          "name": "loop",
          "body": "// check if the flag is set\n  if(receivedFlag) {\n    // reset flag\n    receivedFlag = false;\n\n    // you can read received data as an Arduino String\n    String str;\n    int state = radio.readData(str);\n\n    // you can also read received data as byte array\n    /*\n      byte byteArr[8];\n      int numBytes = radio.getPacketLength();\n      int state = radio.readData(byteArr, numBytes);\n    */\n\n    if (state == RADIOLIB_ERR_NONE) {\n      // packet was successfully received\n      Serial.println(F(\"[CC1101] Received packet!\"));\n\n      // print data of the packet\n      Serial.print(F(\"[CC1101] Data:\\t\\t\"));\n      Serial.println(str);\n\n      // print RSSI (Received Signal Strength Indicator)\n      // of the last received packet\n      Serial.print(F(\"[CC1101] RSSI:\\t\\t\"));\n      Serial.print(radio.getRSSI());\n      Serial.println(F(\" dBm\"));\n\n      // print LQI (Link Quality Indicator)\n      // of the last received packet, lower is better\n      Serial.print(F(\"[CC1101] LQI:\\t\\t\"));\n      Serial.println(radio.getLQI());"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio1.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// nothing here"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[CC1101] Transmitting packet ... \"));\n\n  // you can transmit C-string or Arduino string up to 63 characters long\n  int state = radio.transmit(\"Hello World!\");\n\n  // you can also transmit byte array up to 63 bytes long\n  /*\n    byte byteArr[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[CC1101] Transmitting packet ... \"));\n\n  // you can transmit C-string or Arduino string up to 63 characters long\n  String str = \"Hello World! #\" + String(count++);\n  int state = radio.transmit(str);\n\n  // you can also transmit byte array up to 63 bytes long\n  /*\n    byte byteArr[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "setFlag",
          "body": "// we sent a packet, set the flag\n  transmittedFlag = true;"
        },
        {
          "name": "loop",
          "body": "// check if the previous transmission finished\n  if(transmittedFlag) {\n    // reset flag\n    transmittedFlag = false;\n\n    if (transmissionState == RADIOLIB_ERR_NONE) {\n      // packet was successfully sent\n      Serial.println(F(\"transmission finished!\"));\n\n      // NOTE: when using interrupt-driven transmit method,\n      //       it is not possible to automatically measure\n      //       transmission data rate using getDataRate()"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Adafruit_CC3000.h",
        "BlynkSimpleCC3000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass, wifi_sec);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Wire.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "MQ7.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.println(\"Connecting to WiFi...\");"
        },
        {
          "name": "loop",
          "body": "int coLevel = mq7.getPPM();\n  Serial.print(\"Nilai Sensor CO: \");\n  Serial.println(coLevel);\n\n  float prediction = predictFNN(coLevel);\n\n  String message;\n  if (prediction == 0) {\n    message = \"Tingkat polutan CO: \" + String(coLevel) + \" ppm, Status: Aman.\";"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "MQ7.h",
        "MQ3.h",
        "Wire.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "Fuzzy.h",
        "MQ7.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Koneksi ke WiFi\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": "int coLevel = mq7.getPPM();\n  Serial.print(\"Nilai Sensor CO: \");\n  Serial.println(coLevel);\n  delay(5000);\n\n  fuzzy->setInput(1, coLevel);\n\n  fuzzy->fuzzify();\n\n  float alertLevel = fuzzy->defuzzify(1);\n  if (alertLevel == 0.0) {\n    // Replace the output message with an error message\n    String message = \"Error: Sensor not sensing\";\n    bot.sendMessage(CHAT_ID, message, \"\");\n    delay(1000);"
        }
      ]
    },
    {
      "name": "rx",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "CS5490.h",
        "EEPROM.h"
      ],
      "functions": [
        {
          "name": "CS5490_SendConfiguration",
          "body": "uint32_t IgainCalibrated;\n  uint8_t calibrationData[7];\n\n  // Look for calibration data stored in EEPROM\n  uint8_t CRC = 0;\n  for(uint8_t i=0; i<7;i++)\n  {\n    calibrationData[i] = EEPROM.read(i);\n    //Serial.println(calibrationData[i], HEX);\n    CRC ^=calibrationData[i];"
        },
        {
          "name": "setup",
          "body": "//Initializing communication with CS5490\n  //600 is the default baud rate velocity.\n   line.begin(baudRate_default);\n\n  line.hardwareReset();\n  resetRequired = false;\n  \n  //Initializing communication arduino/PC to show results in Monitor Serial\n  Serial.begin(115200);\n  // wait for serial port to connect. Needed for Leonardo only\n  while (!Serial);\n\n#ifndef TUNING_MODE_ACTIVE\n  CS5490_SendConfiguration();\n#endif"
        },
        {
          "name": "loop",
          "body": "#ifdef TUNING_MODE_ACTIVE\n\n  // The application is AC (mains voltage) with shunt resistor used to measure the current.\n  // Perform the Igain calibration with a reference instruments (a calibrated digital power meter) in the condition of more less HALF LOAD \n  // Implementation based on \"CIRRUS LOGIC AN366REV2\" pag. 15 \"Main Calibration Flow\" https://statics.cirrus.com/pubs/appNote/AN366REV2.pdf\n  // Calibration should be performed with PF=1 --> pure resistive load\n  \n  #define I_CAL_RMS_A  1.3126 // Moreless 1/2 max load\n  #define SCALE_REGISTER_FRACTION  (0.6 * SYS_GAIN * (I_CAL_RMS_A / I_MAX_RMS_A)) // For not full load calibration\n  #define SCALE_REGISTER_VALUE ((uint32_t)(SCALE_REGISTER_FRACTION * 0x800000)) \n\n  // Verify that reset is ok: HW RESET --> START SINGLE CONVERSION --> CHECK RESET CHECKSUM\n  while(!CS5490_testReset())\n  {\n    Serial.println( \"RESET issue... retry\" );\n    line.resolve();"
        }
      ]
    },
    {
      "name": "rx",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "//Initializing communication with CS5490\n  //600 is the default baud rate velocity.\n  line.begin(baudRate_default);\n  //Initializing communication arduino/PC to show results in Monitor Serial\n  Serial.begin(115200);\n  // wait for serial port to connect. Needed for Leonardo only\n  while (!Serial);\n  //Set to continous conversion\n  line.contConv();"
        },
        {
          "name": "loop",
          "body": "double foo = line.getFreq();\n  double bar = line.getTime();\n\n  Serial.print(\"The Line to Sample Frequency Ratio is: \");\n  Serial.println( foo , 5 ); //5 is the number of decimal places\n\n  Serial.print(\"The System Time is: \");\n  Serial.println( bar );\n\n  Serial.println(\"\");\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "Audio.h",
        "Wire.h",
        "SPI.h",
        "SD.h",
        "SerialFlash.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(4);\n  // Enable the audio shield, select the input and set the output volume.\n  audioShield.enable();\n  audioShield.inputSelect(myInput);\n  audioShield.volume(0.5);\n  audioShield.audioPostProcessorEnable(); // enable the DAP block in SGTL5000\n  // audioShield.eqSelect(1); // using PEQ Biquad filters\n  // audioShield.eqFilterCount(2); // enable filter 0 & filter 1\n  calcBiquad(FILTER_PARAEQ,110,0,0.2,524288,44100,updateFilter); // automation negates the need\n  audioShield.eqFilter(0,updateFilter); // for the three lines commented out above.\n  calcBiquad(FILTER_PARAEQ,4400,0,0.167,524288,44100,updateFilter);\n  audioShield.eqFilter(1,updateFilter);"
        },
        {
          "name": "loop",
          "body": "// every 10 ms, check for adjustment\n  if (chgMsec > 10) {\n    \n    float tone2=analogRead(15);\n    tone2=floor(((tone2-512)/512)*70)/10;\n    if(tone2!=tone1)\n    {\n      // calcBiquad(FilterType,FrequencyC,dBgain,Q,QuantizationUnit,SampleRate,int*);\n      calcBiquad(FILTER_PARAEQ,110,-tone2,0.2,524288,44100,updateFilter);\n      audioShield.eqFilter(0,updateFilter);\n      calcBiquad(FILTER_PARAEQ,4400,tone2,0.167,524288,44100,updateFilter);\n      audioShield.eqFilter(1,updateFilter);\n      tone1=tone2;"
        }
      ]
    },
    {
      "name": "LeftMinSpeed",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "CalibratedSpeed.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\n  // include your motors initialization here\n\n  Serial.begin(9600); // only because this example outputs values\n  // on serial interface instead of the actual motors\n\n// Accelerate form 0 to maximum speed\n  for (int spd = 0; spd < 256; spd++)\n  {\n    // call getSpeed method of your calibration objects\n    // getSpeed accepts the desired speed and retuns the calibrated speed value\n    // Here the \"calibrated\" speed is sent to the serial interface  instead of the actual motors\n    Serial.print(csl.getSpeed(spd));\n    Serial.print(\" \");\n    Serial.println(csr.getSpeed(spd));\n    delay(10);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    cfunctions.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        Serial.println(\"Call a function...\");\n\n        String payload = cfunctions.call(aClient, GoogleCloudFunctions::Parent(FIREBASE_PROJECT_ID, PROJECT_LOCATION), \"helloWorld\" /* function name */, \"test\" /* data to pass to function */);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "streamCallback",
          "body": "Serial.printf(\"sream path, %s\\nevent path, %s\\ndata type, %s\\nevent type, %s\\n\\n\",\n                data.streamPath().c_str(),\n                data.dataPath().c_str(),\n                data.dataType().c_str(),\n                data.eventType().c_str());\n  printResult(data); // see addons/RTDBHelper.h\n  Serial.println();\n\n  // This is the size of stream payload received (current and max value)\n  // Max payload size is the payload size under the stream path since the stream connected\n  // and read once and will not update until stream reconnection takes place.\n  // This max value will be zero as no payload received in case of ESP8266 which\n  // BearSSL reserved Rx buffer size is less than the actual stream payload.\n  Serial.printf(\"Received stream payload size: %d (Max. %d)\\n\\n\", data.payloadLength(), data.maxPayloadLength());"
        },
        {
          "name": "streamTimeoutCallback",
          "body": "if (timeout)\n    Serial.println(\"stream timed out, resuming...\\n\");\n\n  if (!stream.httpConnected())\n    Serial.printf(\"error code: %d, reason: %s\\n\\n\", stream.httpCode(), stream.errorReason().c_str());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && (millis() - sendDataPrevMillis > 15000 || sendDataPrevMillis == 0))\n  {\n    sendDataPrevMillis = millis();\n    count++;\n    FirebaseJson json;\n    json.add(\"data\", \"hello\");\n    json.add(\"num\", count);\n    Serial.printf(\"Set json... %s\\n\\n\", Firebase.setJSON(fbdo, \"/test/stream/data/json\", json) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n  \n  pinMode(ledPin, OUTPUT); // use the LED pin as an output\n\n  // begin initialization\n  if (!BLE.begin()) {\n    Serial.println(\"starting Bluetooth® Low Energy module failed!\");\n\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// poll for Bluetooth® Low Energy events\n  BLE.poll();"
        },
        {
          "name": "blePeripheralConnectHandler",
          "body": "// central connected event handler\n  Serial.print(\"Connected event, central: \");\n  Serial.println(central.address());"
        },
        {
          "name": "blePeripheralDisconnectHandler",
          "body": "// central disconnected event handler\n  Serial.print(\"Disconnected event, central: \");\n  Serial.println(central.address());"
        },
        {
          "name": "switchCharacteristicWritten",
          "body": "// central wrote new value to characteristic, update LED\n  Serial.print(\"Characteristic event, written: \");\n\n  if (switchCharacteristic.value()) {\n    Serial.println(\"LED on\");\n    digitalWrite(ledPin, HIGH);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "MIDI.h"
      ],
      "functions": [
        {
          "name": "handleNoteOn",
          "body": "// Do whatever you want when a note is pressed.\n\n    // Try to keep your callbacks short (no delays ect)\n    // otherwise it would slow down the loop() and have a bad impact\n    // on real-time performance."
        },
        {
          "name": "handleNoteOff",
          "body": "// Do something when the note is released.\n    // Note that NoteOn messages with 0 velocity are interpreted as NoteOffs."
        },
        {
          "name": "setup",
          "body": "// Connect the handleNoteOn function to the library,\n    // so it is called upon reception of a NoteOn.\n    MIDI.setHandleNoteOn(handleNoteOn);  // Put only the name of the function\n\n    // Do the same for NoteOffs\n    MIDI.setHandleNoteOff(handleNoteOff);\n\n    // Initiate MIDI communications, listen to all channels\n    MIDI.begin(MIDI_CHANNEL_OMNI);"
        },
        {
          "name": "loop",
          "body": "// Call MIDI.read the fastest you can for real-time performance.\n    MIDI.read();\n\n    // There is no need to check if there are messages incoming\n    // if they are bound to a Callback function.\n    // The attached method will be called automatically\n    // when the corresponding message has been received."
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WebServer.h",
        "WiFiClient.h"
      ],
      "functions": [
        {
          "name": "setupSinricPro",
          "body": "// add device to SinricPro\n  SinricProCamera& mySwitch = SinricPro[CAMERA_ID];\n\n  // set callback function to device\n  mySwitch.onPowerState(onPowerState);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setupWiFi",
          "body": "IPAddress ip;\n\n  // Configures static IP address\n  if (!WiFi.config(local_IP, gateway, subnet, primaryDNS, secondaryDNS))\n  {\n    Serial.println(\"Failed to configure IP\");"
        },
        {
          "name": "setupCamera",
          "body": "camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer   = LEDC_TIMER_0;\n  \n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  \n  config.pin_xclk     = XCLK_GPIO_NUM;\n  config.pin_pclk     = PCLK_GPIO_NUM;\n  config.pin_vsync    = VSYNC_GPIO_NUM;\n  config.pin_href     = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn     = PWDN_GPIO_NUM;\n  config.pin_reset    = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.pixel_format = PIXFORMAT_JPEG; //PIXFORMAT_YUV422 PIXFORMAT_GRAYSCALE PIXFORMAT_RGB565 PIXFORMAT_JPEG\n\n  /*\n    FRAMESIZE_UXGA (1600 x 1200)\n    FRAMESIZE_QVGA (320 x 240)\n    FRAMESIZE_CIF (352 x 288)\n    FRAMESIZE_VGA (640 x 480)\n    FRAMESIZE_SVGA (800 x 600)\n    FRAMESIZE_XGA (1024 x 768)\n    FRAMESIZE_SXGA (1280 x 1024)\n  */\n\n  if (psramFound())\n  {\n    Serial.println(\"psram found\");\n    \n    config.frame_size = FRAMESIZE_UXGA;\n    config.jpeg_quality = 40; //10-63 lower number means higher quality\n    config.fb_count = 2;"
        },
        {
          "name": "setupStreaming",
          "body": "rtspServer.begin();\n  //streamer = new SimStreamer(true);             // our streamer for UDP/TCP based RTP transport\n  streamer = new OV2640Streamer(cam);             // our streamer for UDP/TCP based RTP transport"
        },
        {
          "name": "handleStreaming",
          "body": "uint32_t msecPerFrame = 100;\n  static uint32_t lastimage = millis();\n\n  // If we have an active client connection, just service that until gone\n  streamer->handleRequests(0); // we don't use a timeout here,\n\n  // instead we send only if we have new enough frames\n  uint32_t now = millis();\n\n  if (streamer->anySessions())\n  {\n    if (now > lastimage + msecPerFrame || now < lastimage)\n    {\n      // handle clock rollover\n      streamer->streamImage(now);\n      lastimage = now;\n\n      // check if we are overrunning our max frame rate\n      now = millis();\n\n      if (now > lastimage + msecPerFrame)\n      {\n        printf(\"Warning exceeding max frame rate of %d ms\\n\", now - lastimage);\n        Serial.printf(\"Warning exceeding max frame rate of %d ms\\n\", now - lastimage);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE);\n  while (!Serial);            //wait for serial connection.\n\n  Serial.println(\"\\nStarting Camera on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n\n  setupCamera();\n  setupWiFi();\n  setupSinricPro();\n  setupStreaming();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();\n  handleStreaming();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  Serial.println(\"OV767X Camera Capture\");\n  Serial.println();\n\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (Serial.read() == 'c') {\n    Serial.println(\"Reading frame\");\n    Serial.println();\n    Camera.readFrame(pixels);\n\n    int numPixels = Camera.width() * Camera.height();\n\n    for (int i = 0; i < numPixels; i++) {\n      unsigned short p = pixels[i];\n\n      if (p < 0x1000) {\n        Serial.print('0');"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "Camera.readFrame(data);\n\n  Serial.write(data, bytesPerFrame);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  Serial.println(\"OV767X Test Pattern\");\n  Serial.println();\n\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize the Serial \n  Serial.begin(9600);\n  while (!Serial);\n\n  // initialize the Shield\n  initializeShield();\n\n  // Initialize the OV7675 camera\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675))\n  {\n    Serial.println(\"Failed to initialize camera\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "int i = 0;\n\n  bool clicked = readShieldButton();\n  if (clicked)\n  {\n    Serial.println(\"\\nImage data will be printed out!\");\n    delay(1000);\n    Camera.readFrame(image);\n    for (int i = 0; i < bytesPerFrame; i += 2)\n    {\n      Serial.print(\"0x\");\n      Serial.print(image[i + 1], HEX);\n      Serial.print(image[i], HEX);\n      if (i != bytesPerFrame - 2) Serial.print(\", \");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite"
      ],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n\n  unsigned short intervalId = t.setInterval(\n      []() { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "loop",
          "body": "t.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  unsigned short timeoutId = t.setTimeout(\n      []() { Serial.println(\"Message after 10 seconds from booting\");"
        },
        {
          "name": "loop",
          "body": "t.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Open serial port, set the baud rate to 9600 bits per second\n\tcap.begin(); // Call begin method of cap library for secondary initialization"
        },
        {
          "name": "loop",
          "body": "int rawData = cap.getRawData(); // Retrieve raw analog cap sensor reading and store in initialized variable\n\tSerial.println(rawData); // Print raw data\n\tdelay(100); // Wait 100ms between samples (no offset adjustment)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "CAP.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Begin serial communication at 9600 baud rate\n  cap.begin(); // Call the begin method for the Capacitive Sensor (initialization method)\n  \n  // CHANGE THESE POINTS TO YOUR CALIBRATION POINTS (ADC READING, KNOWN DIELECTRIC CONST)\n  cap.addCalibrationPoint(17,94); // Add Calibration Point 1\n  cap.addCalibrationPoint(13,73); // Add Calibration Point 2\n  cap.addCalibrationPoint(12,59); // Add Calibration Point 3\n  \n  coefs = cap.getLinearRegression(); // Preform Linear Regression on entered Calibration Points \n\n  // Print Calibration Coefficents\n  Serial.print(\"First Coefficent: \"); Serial.println(*coefs);\n  Serial.print(\"Second Coefficent: \"); Serial.println(*(coefs + 1));"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "CAP.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Begin serial communication with 9600 baud rate\n\n  cap.begin(); // Begin Capacitive Sensor (initialization method)\n  \n  cap.setCal(c1,c2); // Set calibration using user defined calibration coefficients"
        },
        {
          "name": "loop",
          "body": "dielectricConst = cap.getDielectric(); // Sample dielectric constant (using set calibration coefficents)\n\n  Serial.print(\"Dielectric Const: \"); Serial.println(dielectricConst);\n\n  delay(1000); // Wait 1s between samples"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "DNSServer.h",
        "WiFi.h",
        "AsyncTCP.h",
        "ESP8266WiFi.h",
        "ESPAsyncTCP.h"
      ],
      "functions": [
        {
          "name": "handleRequest",
          "body": "AsyncResponseStream *response = request->beginResponseStream(\"text/html\");\n    response->print(\"<!DOCTYPE html><html><head><title>Captive Portal</title></head><body>\");\n    response->print(\"<p>This is out captive portal front page.</p>\");\n    response->printf(\"<p>You were trying to reach: http://%s%s</p>\", request->host().c_str(), request->url().c_str());\n    response->printf(\"<p>Try opening <a href='http://%s'>this link</a> instead</p>\", WiFi.softAPIP().toString().c_str());\n    response->print(\"</body></html>\");\n    request->send(response);"
        },
        {
          "name": "setup",
          "body": "//your other setup stuff...\n  WiFi.softAP(\"esp-captive\");\n  dnsServer.start(53, \"*\", WiFi.softAPIP());\n  server.addHandler(new CaptiveRequestHandler()).setFilter(ON_AP_FILTER);//only when requested from AP\n  //more handlers...\n  server.begin();"
        },
        {
          "name": "loop",
          "body": "dnsServer.processNextRequest();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "your_edge_impulse_inferencing.h",
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/car.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n  Serial.begin(115200);\n  Serial.println(\"___AUTONOMOUS CAR___\");\n\n  camera.pinout.freenove_s3();\n  camera.brownout.disable();\n  camera.resolution.yolo();\n  camera.pixformat.rgb565();\n\n  fomoCar.defaultDuration(100);\n  fomoCar.stop();\n\n  while (!camera.begin().isOk())\n      Serial.println(camera.exception.toString());\n\n  Serial.println(\"Camera OK\");\n  Serial.println(\"Put object in front of camera\");"
        },
        {
          "name": "loop",
          "body": "// capture picture\n  if (!camera.capture().isOk()) {\n      Serial.println(camera.exception.toString());\n      return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/car/two_wheels_car.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___CAR TEST___\");\n\n    // how many millis motors will run\n    testCar.defaultDuration(200);\n    testCar.stop();\n\n    Serial.println(\"Enter one of f (forward), b (backward), l (left), r (right)\");"
        },
        {
          "name": "loop",
          "body": "if (!Serial.available())\n        return;\n\n    String cmd = Serial.readStringUntil('\\n');\n\n    if (cmd.startsWith(\"f\")) testCar.forward();\n    else if (cmd.startsWith(\"b\")) testCar.backward();\n    else if (cmd.startsWith(\"l\")) testCar.left();\n    else if (cmd.startsWith(\"r\")) testCar.right();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino_EdgeControl.h",
        "SD.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial communications and wait for port to open:\n    Serial.begin(115200);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "AT_BAUD_RATE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFiEspAT.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(OLD_BAUD_RATE);\n\n  Serial.println(\"Sending baud rate change...\");\n  Serial1.print(\"AT+UART_DEF=\");\n  Serial1.print(NEW_BAUD_RATE);\n  Serial1.println(\",8,1,0,0\");\n  delay(100);\n  // we can't expect a readable answer over SoftwareSerial at 115200\n\n  Serial1.begin(NEW_BAUD_RATE);\n  WiFi.init(Serial1);\n  const char* ver = WiFi.firmwareVersion();\n  if (ver[0] != 0) {\n    Serial.print(\"Baud rate \");\n    Serial.print(NEW_BAUD_RATE);\n    Serial.println(\" baud is working.\");\n    Serial.print(\"Firmware version is \");\n    Serial.println(ver);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "motor.i2cSlaveAddress(0x30); // Change I2C Address from 0x20 to 0x30\n  motor.saveAllRegisters();\n  delay(2000);\n  motor.reboot();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "task1",
          "body": "static unsigned long last = 0;\n    Serial.print(millis());\n    Serial.print(F(\": task1 called after \"));\n    Serial.println(millis() - last);\n    last = millis();"
        },
        {
          "name": "task2",
          "body": "Serial.print(millis());\n    Serial.print(F(\": reset and change the interval of task1 to \"));\n    unsigned r = random(1000, 3000);\n    Serial.println(r);\n    tasker.setInterval(task1, r);"
        },
        {
          "name": "task3",
          "body": "Serial.print(millis());\n    Serial.println(\": STOP\");\n    tasker.cancel(task1);\n    tasker.cancel(task2);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println(\"Tasker: Demo of changing scheduled task setup at runtime\");\n\n    // set task1 to be called every 2 seconds\n    tasker.setInterval(task1, 2000);\n    \n    // every 8 seconds call task2 that changes the settings of task1\n    tasker.setInterval(task2, 8000);\n    \n    // after 60 seconds stop both tasks\n    tasker.setTimeout(task3, 60000);"
        },
        {
          "name": "loop",
          "body": "tasker.loop();\n    // your code can be here"
        }
      ]
    },
    {
      "name": "rx",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "//Initializing communication with CS5490\n  //600 is the default baud rate velocity.\n  line.begin(600);\n  //Initializing communication arduino/PC to show results in Monitor Serial\n  Serial.begin(115200);\n  //Changing BaudRate of CS5490 to 115200\n  /*\n    WARNING: Everytime that you reset the software from board you also need to reset\n    the CS5490!!! If you don't, it will not work properly\n  */\n  line.setBaudRate(115200);\n  //Set to continous conversion\n  line.contConv();"
        },
        {
          "name": "loop",
          "body": "double foo = line.getFreq();\n  double bar = line.getTime();\n\n  Serial.print(\"The Line to Sample Frequency Ratio is: \");\n  Serial.println( foo , 5 ); //5 is the number of decimal places\n\n  Serial.print(\"The System Time is: \");\n  Serial.println( bar );\n\n  Serial.println(\"\");\n  delay(1000);"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();\n\n  //set LED widget to Green\n  DBlynk.setProperty(V0, \"color\", BLYNK_GREEN);\n  \n  //turn on LED widget with maximum brightness \n  DBlynk.virtualWrite(V0, 255);\n\n  delay(1000);\n\n  //set LED widget to Blue\n  DBlynk.setProperty(V0, \"color\", BLYNK_BLUE);\n  \n  //turn on LED widget with maximum brightness \n  DBlynk.virtualWrite(V0, 255);\n\n  delay(1000);\n\n  //set LED widget to Yellow\n  DBlynk.setProperty(V0, \"color\", BLYNK_YELLOW);\n  \n  //turn on LED widget with maximum brightness \n  DBlynk.virtualWrite(V0, 255);\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "body": "for (int i = 0; i < numNewMessages; i++)\n  {\n    if (bot.messages[i].type == \"channel_post\")\n    {\n      bot.sendMessage(bot.messages[i].chat_id, bot.messages[i].chat_title + \" \" + bot.messages[i].text, \"\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  // attempt to connect to Wifi network:\n  configTime(0, 0, \"pool.ntp.org\");      // get UTC time via NTP\n  secured_client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org\n  Serial.print(\"Connecting to Wifi SSID \");\n  Serial.print(WIFI_SSID);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "body": "Serial.println(\"handleNewMessages\");\n  Serial.println(String(numNewMessages));\n\n  for (int i = 0; i < numNewMessages; i++)\n  {\n    String chat_id = bot.messages[i].chat_id;\n    String text = bot.messages[i].text;\n\n    String from_name = bot.messages[i].from_name;\n    if (from_name == \"\")\n      from_name = \"Guest\";\n\n    if (text == \"/send_test_action\")\n    {\n      bot.sendChatAction(chat_id, \"typing\");\n      delay(4000);\n      bot.sendMessage(chat_id, \"Did you see the action message?\");\n\n      // You can't use own message, just choose from one of bellow\n\n      //typing for text messages\n      //upload_photo for photos\n      //record_video or upload_video for videos\n      //record_audio or upload_audio for audio files\n      //upload_document for general files\n      //find_location for location data\n\n      //more info here - https://core.telegram.org/bots/api#sendchataction"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  // Set WiFi to station mode and disconnect from an AP if it was Previously\n  // connected\n  WiFi.mode(WIFI_STA);\n  WiFi.disconnect();\n  delay(100);\n\n  // attempt to connect to Wifi network:\n  Serial.print(\"Connecting to Wifi SSID \");\n  Serial.print(WIFI_SSID);\n  Serial.print(\" \");\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  secured_client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);"
        }
      ]
    },
    {
      "name": "ADAFRUIT_CC3000_IRQ",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_CC3000.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(F(\"Hello, CC3000!\\n\")); \n\n  Serial.print(\"Free RAM: \"); Serial.println(getFreeRam(), DEC);\n  \n  /* Initialise the module */\n  Serial.println(F(\"\\nInitializing...\"));\n  if (!cc3000.begin())\n  {\n    Serial.println(F(\"Couldn't begin()! Check your wiring?\"));\n    while(1);"
        },
        {
          "name": "loop",
          "body": "// Try to get a client which is connected.\n  Adafruit_CC3000_ClientRef client = chatServer.available();\n  if (client) {\n     // Check if there is data available to read.\n     if (client.available() > 0) {\n       // Read a byte and write it to all clients.\n       uint8_t ch = client.read();\n       chatServer.write(ch);"
        }
      ]
    },
    {
      "name": "AT_BAUD_RATE",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiEspAT.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(AT_BAUD_RATE);\n  WiFi.init(Serial1);\n\n  if (WiFi.status() == WL_NO_MODULE) {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_FIRMWARE_LATEST_VERSION",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFiNINA_Generic.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  // Print a welcome message\n  Serial.print(F(\"\\nStart WiFiNINA CheckFirmwareVersion on \"));\n  Serial.println(BOARD_NAME);\n  Serial.println(WIFININA_GENERIC_VERSION);\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"Communication with WiFi module failed!\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiLink.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize serial\n  Serial.begin(115200);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "driver/source/nmasic.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize serial\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  MODEM.begin();\n  while (!MODEM.noop());\n\n  for (int i = 0; i < 80; i++) Serial.print(\"*\");\n  Serial.println();\n  Serial.println(\"This sketch allows you to select your preferred\");\n  Serial.println(\"GSM Radio Access Technology (RAT).\");\n  Serial.println();\n  Serial.println(\"You can choose among 2G, 3G/UMTS or a combination of both.\");\n  Serial.println();\n  Serial.println(\"The chosen configuration will be saved to modem's internal memory\");\n  Serial.println(\"and will be preserved through MKR GSM 1400 sketch uploads.\");\n  Serial.println();\n  Serial.println(\"In order to change the RAT, you will need to run this sketch again.\");\n  for (int i = 0; i < 80; i++) Serial.print(\"*\");\n\n  Serial.println();\n  Serial.println();\n  Serial.println(\"Please choose your Radio Access Technology:\");\n  Serial.println();\n  Serial.println(\"    0 - 2G only\");\n  Serial.println(\"    1 - 3G/UMTS only\");\n  Serial.println(\"    2 - 2G preferred, 3G/UMTS as failover\");\n  Serial.println(\"    3 - 3G/UMTS preferred, 2G as failover (default)\");\n  Serial.println();"
        },
        {
          "name": "loop",
          "body": "String uratChoice;\n\n  Serial.print(\"> \");\n\n  Serial.setTimeout(-1);\n  while (Serial.available() == 0);\n  String uratInput = Serial.readStringUntil('\\n');\n  uratInput.trim();\n  int urat = uratInput.toInt();\n  Serial.println(urat);\n\n  switch (urat) {\n    case 0:\n      uratChoice = \"0\";\n      break;\n    case 1:\n      uratChoice = \"2\";\n      break;\n    case 2:\n      uratChoice = \"1,0\";\n      break;\n    case 3:\n      uratChoice = \"1,2\";\n      break;\n    default:\n      Serial.println(\"Invalid input. Please, retry.\");\n      return;"
        }
      ]
    },
    {
      "name": "NEO_PIN",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Audio.h",
        "Adafruit_Keypad.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) ;\n  delay(3000);\n\n  customKeypad.begin();\n\n  // Maximum memory usage was reported as 4\n  // Proc = 9 (9),  Mem = 4 (4)\n  AudioMemory(4);\n\n  // Initialize the effect - left channel\n  // address of delayline\n  // total number of samples in the delay line\n  // number of voices in the chorus INCLUDING the original voice\n  if(!l_myEffect.begin(l_delayline,CHORUS_DELAY_LENGTH,n_chorus)) {\n    Serial.println(\"AudioEffectChorus - left channel begin failed\");\n    while(1);"
        },
        {
          "name": "loop",
          "body": "customKeypad.tick();\n  \n  while(customKeypad.available())\n  {\n    keypadEvent e = customKeypad.read();\n    if(e.bit.KEY == PASSTHRU_KEY){\n      if(e.bit.EVENT == KEY_JUST_PRESSED){\n        // switch on the chorus when the button is pressed\n        l_myEffect.voices(n_chorus);\n        r_myEffect.voices(n_chorus);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266HTTPClient.h",
        "ESP8266WiFi.h",
        "HTTPClient.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "StreamUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize Serial Port\n  Serial.begin(115200);\n  while (!Serial)\n    continue;\n\n  // Connect to the WLAN\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.println(F(\"Connecting to Wifi...\"));\n    delay(500);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "DATA_SIZE",
      "keywords": [],
      "libraries": [
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "CircuitPlayground.begin();"
        },
        {
          "name": "loop",
          "body": "CircuitPlayground.mic.capture(inputData, DATA_SIZE);\n\n  /*******************************\n   *   REMOVE DC OFFSET\n   ******************************/\n  int32_t avg = 0;\n  int16_t *ptr = inputData;\n  for(int i=0; i<DATA_SIZE; i++) avg += *ptr++;\n  avg = avg/DATA_SIZE;\n\n  ptr = inputData;\n  for(int i=0; i<DATA_SIZE; i++){\n    *ptr -= avg;\n    *ptr++ = *ptr*SCALE_FACTOR;"
        }
      ]
    },
    {
      "name": "DEBUG_MODE",
      "keywords": [
        "Wire",
        "delay",
        "Serial",
        "digitalWrite",
        "analogWrite",
        "EEPROM",
        "analogRead"
      ],
      "libraries": [
        "SPI.h",
        "Servo.h",
        "Wire.h",
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "wireWrite",
          "body": "#if ARDUINO >= 100\n  Wire.write((byte)data);\n#else\n  Wire.send(data);\n#endif"
        },
        {
          "name": "attachServo",
          "body": "if (servoCount < MAX_SERVOS) {\n    // reuse indexes of detached servos until all have been reallocated\n    if (detachedServoCount > 0) {\n      servoPinMap[pin] = detachedServos[detachedServoCount - 1];\n      if (detachedServoCount > 0) detachedServoCount--;"
        },
        {
          "name": "detachServo",
          "body": "servos[servoPinMap[pin]].detach();\n  // if we're detaching the last servo, decrement the count\n  // otherwise store the index of the detached servo\n  if (servoPinMap[pin] == servoCount && servoCount > 0) {\n    servoCount--;"
        },
        {
          "name": "readAndReportData",
          "body": "// allow I2C requests that don't require a register read\n  // for example, some devices using an interrupt pin to signify new data available\n  // do not always require the register read so upon interrupt you call Wire.requestFrom()\n  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {\n    Wire.beginTransmission(address);\n    wireWrite((byte)theRegister);\n    Wire.endTransmission();\n    // do not set a value of 0\n    if (i2cReadDelayTime > 0) {\n      // delay is necessary for some devices such as WiiNunchuck\n      delayMicroseconds(i2cReadDelayTime);"
        },
        {
          "name": "outputPort",
          "body": "// pins not configured as INPUT are cleared to zeros\n  portValue = portValue & portConfigInputs[portNumber];\n  // only send if the value is different than previously sent\n  if (forceSend || previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;"
        },
        {
          "name": "checkDigitalInputs",
          "body": "/* Using non-looping code allows constants to be given to readPort().\n   * The compiler will apply substantial optimizations if the inputs\n   * to readPort() are compile-time constants. */\n  if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);\n  if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);\n  if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);\n  if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);\n  if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);\n  if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);\n  if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);\n  if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);\n  if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);\n  if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);\n  if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);\n  if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);\n  if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);\n  if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);\n  if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);\n  if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);"
        },
        {
          "name": "setPinModeCallback",
          "body": "if (pinConfig[pin] == PIN_MODE_IGNORE)\n    return;\n\n  if (pinConfig[pin] == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) {\n    // disable i2c so pins can be used for other functions\n    // the following if statements should reconfigure the pins properly\n    disableI2CPins();"
        },
        {
          "name": "setPinValueCallback",
          "body": "if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) {\n    if (pinConfig[pin] == OUTPUT) {\n      pinState[pin] = value;\n      digitalWrite(PIN_TO_DIGITAL(pin), value);"
        },
        {
          "name": "analogWriteCallback",
          "body": "if (pin < TOTAL_PINS) {\n    switch (pinConfig[pin]) {\n      case PIN_MODE_SERVO:\n        if (IS_PIN_DIGITAL(pin))\n          servos[servoPinMap[pin]].write(value);\n        pinState[pin] = value;\n        break;\n      case PIN_MODE_PWM:\n        if (IS_PIN_PWM(pin))\n          analogWrite(PIN_TO_PWM(pin), value);\n        pinState[pin] = value;\n        break;"
        },
        {
          "name": "digitalWriteCallback",
          "body": "byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;\n\n  if (port < TOTAL_PORTS) {\n    // create a mask of the pins on this port that are writable.\n    lastPin = port * 8 + 8;\n    if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS;\n    for (pin = port * 8; pin < lastPin; pin++) {\n      // do not disturb non-digital pins (eg, Rx & Tx)\n      if (IS_PIN_DIGITAL(pin)) {\n        // do not touch pins in PWM, ANALOG, SERVO or other modes\n        if (pinConfig[pin] == OUTPUT || pinConfig[pin] == INPUT) {\n          pinValue = ((byte)value & mask) ? 1 : 0;\n          if (pinConfig[pin] == OUTPUT) {\n            pinWriteMask |= mask;"
        },
        {
          "name": "reportAnalogCallback",
          "body": "if (analogPin < TOTAL_ANALOG_PINS) {\n    if (value == 0) {\n      analogInputsToReport = analogInputsToReport & ~ (1 << analogPin);"
        },
        {
          "name": "reportDigitalCallback",
          "body": "if (port < TOTAL_PORTS) {\n    reportPINs[port] = (byte)value;\n    // Send port value immediately. This is helpful when connected via\n    // ethernet, wi-fi or bluetooth so pin states can be known upon\n    // reconnecting.\n    if (value) outputPort(port, readPort(port, portConfigInputs[port]), true);"
        },
        {
          "name": "circuitPlaygroundCommand",
          "body": "switch (command) {\n    case CP_PIXEL_SET:\n      // Set a NeoPixel to the specified RGB color.\n      // Expect: 1 byte pixel number, 4 bytes pixel RGB value (as 7-bit bytes)\n      if (argc >= 5) {\n        // Parse out the pixel number and R, G, B bytes.\n        uint8_t pixel = argv[0] & 0x7F;\n        uint8_t r = (argv[1] << 1) | ((argv[2] & 0x7F) >> 6);  // Red = 7 bits from byte 4 and 1 bit from byte 5\n        uint8_t g = ((argv[2] & 0x3F) << 2) | (((argv[3]) & 0x7F) >> 5);  // Green = 6 bits from byte 5 and 2 bits from byte 6\n        uint8_t b = ((argv[3] & 0x1F) << 3) | (((argv[4]) & 0x7F) >> 4);  // Blue = 5 bits from byte 6 and 3 bits from byte 7\n        CircuitPlayground.strip.setPixelColor(pixel, r, g, b);"
        },
        {
          "name": "sendColorSenseResponse",
          "body": "// Perform a color sense with NeoPixel #1 and the light sensor.\n  uint8_t red, green, blue;\n  CircuitPlayground.senseColor(red, green, blue);\n  // Construct a response data packet and send it.\n  uint8_t data[4] = {0"
        },
        {
          "name": "sendAccelResponse",
          "body": "// Get an accelerometer X, Y, Z reading.\n  sensors_event_t event;\n  CircuitPlayground.lis.getEvent(&event);\n  // Construct a response data packet.\n  uint8_t data[13] = {0"
        },
        {
          "name": "sendTapResponse",
          "body": "// Get the accelerometer tap detection state.\n  uint8_t click = CircuitPlayground.lis.getClick();\n  // Construct a response data packet and send it.\n  uint8_t data[2] = {0"
        },
        {
          "name": "sendCapResponse",
          "body": "// Get the cap sense value for the provided input pin.\n  int32_t value = CircuitPlayground.readCap(pin, CAP_SAMPLES);\n  // Build a response data packet and send it.  The response includes:\n  // - uint8_t: CP_CAP_REPLY value\n  // - uint8_t: pin number of the read input\n  // - int32_t: cap sensor value, large values mean the input was touched\n  union {\n    struct {\n      uint8_t type;\n      uint8_t pin;\n      int32_t value;"
        },
        {
          "name": "sysexCallback",
          "body": "byte mode;\n  byte slaveAddress;\n  byte data;\n  int slaveRegister;\n  unsigned int delayTime;\n\n  switch (command) {\n    // Circuit playground command processing:\n    case CP_COMMAND:\n      if (argc < 1) return;\n      circuitPlaygroundCommand(argv[0], argc-1, argv+1);\n      break;\n    case I2C_REQUEST:\n      mode = argv[1] & I2C_READ_WRITE_MODE_MASK;\n      if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) {\n        Firmata.sendString(\"10-bit addressing not supported\");\n        return;"
        },
        {
          "name": "enableI2CPins",
          "body": "byte i;\n  // is there a faster way to do this? would probaby require importing\n  // Arduino.h to get SCL and SDA pins\n  for (i = 0; i < TOTAL_PINS; i++) {\n    if (IS_PIN_I2C(i)) {\n      // mark pins as i2c so they are ignore in non i2c data requests\n      setPinModeCallback(i, PIN_MODE_I2C);"
        },
        {
          "name": "disableI2CPins",
          "body": "isI2CEnabled = false;\n  // disable read continuous mode for all devices\n  queryIndex = -1;"
        },
        {
          "name": "systemResetCallback",
          "body": "isResetting = true;\n\n  // initialize a defalt state\n  // TODO: option to load config from EEPROM instead of default\n\n  // Reset circuit playground components to a default state with nothing running.\n  // (i.e. no pixels lit, no sound, no data streaming back)\n  circuitPlaygroundReset();\n\n  if (isI2CEnabled) {\n    disableI2CPins();"
        },
        {
          "name": "circuitPlaygroundReset",
          "body": "// Reset the circuit playground components into a default state\n  // with none of the pixels lit, no tones playing, and no cap touch\n  // or accelerometer data streaming back.\n\n  // Turn off all the NeoPixels.\n  CircuitPlayground.strip.clear();\n  CircuitPlayground.strip.show();\n\n  // Reset the accelerometer to a default range.\n  CircuitPlayground.lis.setRange(LIS3DH_RANGE_2_G);\n  delay(100);\n  CircuitPlayground.lis.setClick(2, 80);\n  delay(100);\n\n  // Turn off streaming of tap, accel, and cap touch data.\n  streamTap = false;\n  streamAccel = false;\n  for (int i=0; i<CAP_COUNT; ++i) {\n    cap_state[i].streaming = false;"
        },
        {
          "name": "setup",
          "body": "// Circuit playground debug setup\n  #ifdef DEBUG_MODE\n    DEBUG_OUTPUT.begin(DEBUG_BAUD);\n    DEBUG_PRINTLN(\"Circuit Playground Firmata starting up!\");\n  #endif\n\n  // Circuit playground setup:\n  if (!CircuitPlayground.begin()) {\n    // Failed to initialize circuit playground, fast blink the red LED on the board.\n    DEBUG_PRINTLN(\"Failed to initialize circuit playground!\");\n    pinMode(13, OUTPUT);\n    while (1) {\n      digitalWrite(13, LOW);\n      delay(100);\n      digitalWrite(13, HIGH);\n      delay(100);"
        },
        {
          "name": "loop",
          "body": "byte pin, analogPin;\n\n  /* DIGITALREAD - as fast as possible, check for changes and output them to the\n   * FTDI buffer using Serial.print()  */\n  checkDigitalInputs();\n\n  /* STREAMREAD - processing incoming messagse as soon as possible, while still\n   * checking digital inputs.  */\n  while (Firmata.available())\n    Firmata.processInput();\n\n  // TODO - ensure that Stream buffer doesn't go over 60 bytes\n\n  currentMillis = millis();\n  if (currentMillis - previousMillis > samplingInterval) {\n    previousMillis += samplingInterval;\n    /* ANALOGREAD - do all analogReads() at the configured sampling interval */\n    for (pin = 0; pin < TOTAL_PINS; pin++) {\n      if (IS_PIN_ANALOG(pin) && pinConfig[pin] == PIN_MODE_ANALOG) {\n        analogPin = PIN_TO_ANALOG(pin);\n        if (analogInputsToReport & (1 << analogPin)) {\n          Firmata.sendAnalog(analogPin, analogRead(analogPin));"
        },
        {
          "name": "runDemo",
          "body": "// test Red #13 LED\n  CircuitPlayground.redLED(pixeln % 1);\n\n  /************* TEST SLIDE SWITCH */\n  if (CircuitPlayground.slideSwitch()) {\n    pixeln++;\n    if (pixeln == 11) {\n      pixeln = 0;\n      CircuitPlayground.clearPixels();"
        }
      ]
    },
    {
      "name": "DEBUG_MODE",
      "keywords": [
        "Wire",
        "delay",
        "digitalWrite",
        "analogRead",
        "analogWrite",
        "Serial",
        "EEPROM"
      ],
      "libraries": [
        "SPI.h",
        "Servo.h",
        "Wire.h",
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "wireWrite",
          "body": "#if ARDUINO >= 100\n  Wire.write((byte)data);\n#else\n  Wire.send(data);\n#endif"
        },
        {
          "name": "shimPinMode",
          "body": "// Ignore pins above 13 as they are internal to classic/express (but not 19 or 21 as those are classic buttons).\n  if ((pin != 19) && (pin != 21) && (pin > 13)) {\n    return;"
        },
        {
          "name": "shimDigitalWrite",
          "body": "// Only write to pins below 13 as other pins are internal like chip selects, etc.\n  if (pin > 13) {\n    return;"
        },
        {
          "name": "shimAnalogWrite",
          "body": "// Only write to pins below 13 as other pins are internal like chip selects, etc.\n  if (pin > 13) {\n    return;"
        },
        {
          "name": "attachServo",
          "body": "if (servoCount < MAX_SERVOS) {\n    // reuse indexes of detached servos until all have been reallocated\n    if (detachedServoCount > 0) {\n      servoPinMap[pin] = detachedServos[detachedServoCount - 1];\n      if (detachedServoCount > 0) detachedServoCount--;"
        },
        {
          "name": "detachServo",
          "body": "servos[servoPinMap[pin]].detach();\n  // if we're detaching the last servo, decrement the count\n  // otherwise store the index of the detached servo\n  if (servoPinMap[pin] == servoCount && servoCount > 0) {\n    servoCount--;"
        },
        {
          "name": "readAndReportData",
          "body": "// allow I2C requests that don't require a register read\n  // for example, some devices using an interrupt pin to signify new data available\n  // do not always require the register read so upon interrupt you call Wire.requestFrom()\n  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {\n    Wire.beginTransmission(address);\n    wireWrite((byte)theRegister);\n    Wire.endTransmission();\n    // do not set a value of 0\n    if (i2cReadDelayTime > 0) {\n      // delay is necessary for some devices such as WiiNunchuck\n      delayMicroseconds(i2cReadDelayTime);"
        },
        {
          "name": "outputPort",
          "body": "// pins not configured as INPUT are cleared to zeros\n  portValue = portValue & portConfigInputs[portNumber];\n  // only send if the value is different than previously sent\n  if (forceSend || previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;"
        },
        {
          "name": "checkDigitalInputs",
          "body": "/* Using non-looping code allows constants to be given to readPort().\n   * The compiler will apply substantial optimizations if the inputs\n   * to readPort() are compile-time constants. */\n  if (classic_TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, shimReadPort(0, portConfigInputs[0]), false);\n  if (classic_TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, shimReadPort(1, portConfigInputs[1]), false);\n  if (classic_TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, shimReadPort(2, portConfigInputs[2]), false);\n  if (classic_TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, shimReadPort(3, portConfigInputs[3]), false);\n  if (classic_TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, shimReadPort(4, portConfigInputs[4]), false);\n  if (classic_TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, shimReadPort(5, portConfigInputs[5]), false);\n  if (classic_TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, shimReadPort(6, portConfigInputs[6]), false);\n  if (classic_TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, shimReadPort(7, portConfigInputs[7]), false);\n  if (classic_TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, shimReadPort(8, portConfigInputs[8]), false);\n  if (classic_TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, shimReadPort(9, portConfigInputs[9]), false);\n  if (classic_TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, shimReadPort(10, portConfigInputs[10]), false);\n  if (classic_TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, shimReadPort(11, portConfigInputs[11]), false);\n  if (classic_TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, shimReadPort(12, portConfigInputs[12]), false);\n  if (classic_TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, shimReadPort(13, portConfigInputs[13]), false);\n  if (classic_TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, shimReadPort(14, portConfigInputs[14]), false);\n  if (classic_TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, shimReadPort(15, portConfigInputs[15]), false);"
        },
        {
          "name": "setPinModeCallback",
          "body": "if (pinConfig[pin] == PIN_MODE_IGNORE)\n    return;\n\n  if (pinConfig[pin] == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) {\n    // disable i2c so pins can be used for other functions\n    // the following if statements should reconfigure the pins properly\n    disableI2CPins();"
        },
        {
          "name": "setPinValueCallback",
          "body": "if (pin < classic_TOTAL_PINS && classic_IS_PIN_DIGITAL(pin)) {\n    if (pinConfig[pin] == OUTPUT) {\n      pinState[pin] = value;\n      shimDigitalWrite(classic_PIN_TO_DIGITAL(pin), value);"
        },
        {
          "name": "analogWriteCallback",
          "body": "if (pin < classic_TOTAL_PINS) {\n    switch (pinConfig[pin]) {\n      case PIN_MODE_SERVO:\n        if (classic_IS_PIN_DIGITAL(pin))\n          servos[servoPinMap[pin]].write(value);\n        pinState[pin] = value;\n        break;\n      case PIN_MODE_PWM:\n        if (classic_IS_PIN_PWM(pin))\n          shimAnalogWrite(classic_PIN_TO_PWM(pin), value);\n        pinState[pin] = value;\n        break;"
        },
        {
          "name": "digitalWriteCallback",
          "body": "byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;\n\n  if (port < classic_TOTAL_PORTS) {\n    // create a mask of the pins on this port that are writable.\n    lastPin = port * 8 + 8;\n    if (lastPin > classic_TOTAL_PINS) lastPin = classic_TOTAL_PINS;\n    for (pin = port * 8; pin < lastPin; pin++) {\n      // do not disturb non-digital pins (eg, Rx & Tx)\n      if (classic_IS_PIN_DIGITAL(pin)) {\n        // do not touch pins in PWM, ANALOG, SERVO or other modes\n        if (pinConfig[pin] == OUTPUT || pinConfig[pin] == INPUT) {\n          pinValue = ((byte)value & mask) ? 1 : 0;\n          if (pinConfig[pin] == OUTPUT) {\n            pinWriteMask |= mask;"
        },
        {
          "name": "reportAnalogCallback",
          "body": "if (analogPin < classic_TOTAL_ANALOG_PINS) {\n    if (value == 0) {\n      analogInputsToReport = analogInputsToReport & ~ (1 << analogPin);"
        },
        {
          "name": "reportDigitalCallback",
          "body": "if (port < classic_TOTAL_PORTS) {\n    reportPINs[port] = (byte)value;\n    // Send port value immediately. This is helpful when connected via\n    // ethernet, wi-fi or bluetooth so pin states can be known upon\n    // reconnecting.\n    if (value) outputPort(port, shimReadPort(port, portConfigInputs[port]), true);"
        },
        {
          "name": "circuitPlaygroundCommand",
          "body": "switch (command) {\n    case CP_PIXEL_SET:\n      // Set a NeoPixel to the specified RGB color.\n      // Expect: 1 byte pixel number, 4 bytes pixel RGB value (as 7-bit bytes)\n      if (argc >= 5) {\n        // Parse out the pixel number and R, G, B bytes.\n        uint8_t pixel = argv[0] & 0x7F;\n        uint8_t r = (argv[1] << 1) | ((argv[2] & 0x7F) >> 6);  // Red = 7 bits from byte 4 and 1 bit from byte 5\n        uint8_t g = ((argv[2] & 0x3F) << 2) | (((argv[3]) & 0x7F) >> 5);  // Green = 6 bits from byte 5 and 2 bits from byte 6\n        uint8_t b = ((argv[3] & 0x1F) << 3) | (((argv[4]) & 0x7F) >> 4);  // Blue = 5 bits from byte 6 and 3 bits from byte 7\n        CircuitPlayground.strip.setPixelColor(pixel, r, g, b);"
        },
        {
          "name": "sendColorSenseResponse",
          "body": "// Perform a color sense with NeoPixel #1 and the light sensor.\n  uint8_t red, green, blue;\n  CircuitPlayground.senseColor(red, green, blue);\n  // Construct a response data packet and send it.\n  uint8_t data[4] = {0"
        },
        {
          "name": "sendAccelResponse",
          "body": "// Get an accelerometer X, Y, Z reading.\n  sensors_event_t event;\n  CircuitPlayground.lis.getEvent(&event);\n  // Construct a response data packet.\n  uint8_t data[13] = {0"
        },
        {
          "name": "sendTapResponse",
          "body": "// Get the accelerometer tap detection state.\n  uint8_t click = CircuitPlayground.lis.getClick();\n  // Construct a response data packet and send it.\n  uint8_t data[2] = {0"
        },
        {
          "name": "sendCapResponse",
          "body": "// Get the cap sense value for the provided input pin.\n  int32_t value = CircuitPlayground.readCap(pin, CAP_SAMPLES);\n  // Build a response data packet and send it.  The response includes:\n  // - uint8_t: CP_CAP_REPLY value\n  // - uint8_t: pin number of the read input\n  // - int32_t: cap sensor value, large values mean the input was touched\n  union {\n    struct {\n      uint8_t type;\n      uint8_t pin;\n      int32_t value;"
        },
        {
          "name": "sysexCallback",
          "body": "byte mode;\n  byte slaveAddress;\n  byte data;\n  int slaveRegister;\n  unsigned int delayTime;\n\n  switch (command) {\n    // Circuit playground command processing:\n    case CP_COMMAND:\n      if (argc < 1) return;\n      circuitPlaygroundCommand(argv[0], argc-1, argv+1);\n      break;\n    case I2C_REQUEST:\n      mode = argv[1] & I2C_READ_WRITE_MODE_MASK;\n      if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) {\n        Firmata.sendString(\"10-bit addressing not supported\");\n        return;"
        },
        {
          "name": "enableI2CPins",
          "body": "byte i;\n  // is there a faster way to do this? would probaby require importing\n  // Arduino.h to get SCL and SDA pins\n  for (i = 0; i < classic_TOTAL_PINS; i++) {\n    if (classic_IS_PIN_I2C(i)) {\n      // mark pins as i2c so they are ignore in non i2c data requests\n      setPinModeCallback(i, PIN_MODE_I2C);"
        },
        {
          "name": "disableI2CPins",
          "body": "isI2CEnabled = false;\n  // disable read continuous mode for all devices\n  queryIndex = -1;"
        },
        {
          "name": "systemResetCallback",
          "body": "isResetting = true;\n\n  // initialize a defalt state\n  // TODO: option to load config from EEPROM instead of default\n\n  // Reset circuit playground components to a default state with nothing running.\n  // (i.e. no pixels lit, no sound, no data streaming back)\n  circuitPlaygroundReset();\n\n  if (isI2CEnabled) {\n    disableI2CPins();"
        },
        {
          "name": "circuitPlaygroundReset",
          "body": "// Reset the circuit playground components into a default state\n  // with none of the pixels lit, no tones playing, and no cap touch\n  // or accelerometer data streaming back.\n\n  // Make speaker shutdown an output and turn off the speaker.\n  pinMode(CPLAY_SPEAKER_SHUTDOWN, OUTPUT);\n  digitalWrite(CPLAY_SPEAKER_SHUTDOWN, LOW);\n  //noTone(CPLAY_SPEAKER); //TODO: NOTONE BROKEN! LOCKS\n\n  // Turn off all the NeoPixels.\n  CircuitPlayground.strip.clear();\n  CircuitPlayground.strip.show();\n\n  // Reset the accelerometer to a default range.\n  CircuitPlayground.lis.setRange(LIS3DH_RANGE_2_G);\n  delay(100);\n  CircuitPlayground.lis.setClick(2, 80);\n  delay(100);\n\n  // Turn off streaming of tap, accel, and cap touch data.\n  streamTap = false;\n  streamAccel = false;\n  for (int i=0; i<CAP_COUNT; ++i) {\n    cap_state[i].streaming = false;"
        },
        {
          "name": "setup",
          "body": "// Circuit playground setup:\n  if (!CircuitPlayground.begin()) {\n    // Failed to initialize circuit playground, fast blink the red LED on the board.\n    pinMode(13, OUTPUT);\n    while (1) {\n      digitalWrite(13, LOW);\n      delay(100);\n      digitalWrite(13, HIGH);\n      delay(100);"
        },
        {
          "name": "loop",
          "body": "byte pin, analogPin;\n\n  /* DIGITALREAD - as fast as possible, check for changes and output them to the\n   * FTDI buffer using Serial.print()  */\n  checkDigitalInputs();\n\n  /* STREAMREAD - processing incoming messagse as soon as possible, while still\n   * checking digital inputs.  */\n  while (Firmata.available()) {\n    Firmata.processInput();"
        },
        {
          "name": "runDemo",
          "body": "// test Red #13 LED\n  CircuitPlayground.redLED(pixeln % 1);\n\n  /************* TEST SLIDE SWITCH */\n  if (CircuitPlayground.slideSwitch()) {\n    pixeln++;\n    if (pixeln == 11) {\n      pixeln = 0;\n      CircuitPlayground.clearPixels();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "ArduinoSound.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// setup the serial\n  Serial.begin(9600);\n\n  // configure the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n\n  // setup the I2S audio input for 44.1 kHz with 32-bits per sample\n  if (!AudioInI2S.begin(44100, 32)) {\n    Serial.println(\"Failed to initialize I2S input!\");\n    while (1); // do nothing"
        },
        {
          "name": "loop",
          "body": "// check if a new analysis is available\n  if (amplitudeAnalyzer.available()) {\n    // read the new amplitude\n    int amplitude = amplitudeAnalyzer.read();\n\n    // find the difference between the new amplitude and the last\n    int delta = amplitude - lastAmplitude;\n  \n    // check if the difference is larger than the threshold\n    if (delta > amplitudeDeltaThreshold) {\n      // a clap was detected\n      Serial.println(\"clap detected\");\n  \n      // toggle the LED\n      digitalWrite(ledPin, !digitalRead(ledPin));\n  \n      // delay a bit to debounce\n      delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Wire"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // write empty strings for the different fields\n  Robot.userNameWrite(\"\");\n  Robot.robotNameWrite(\"\");\n  Robot.cityNameWrite(\"\");\n  Robot.countryNameWrite(\"\");"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "ESP_Google_Sheet_Client.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32) || defined(ESP8266)\n    WiFi.setAutoReconnect(true);\n#endif\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif"
        },
        {
          "name": "loop",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\n    bool ready = GSheet.ready();\n\n    if (ready && !taskComplete)\n    {\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\n\n        // If you assign the spreadsheet id from your own spreadsheet,\n        // you need to set share access to the Service Account's CLIENT_EMAIL\n\n        FirebaseJson response;\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\n\n        Serial.println(\"\\nWrite spreadsheet values in range...\");\n        Serial.println(\"--------------------------------------------------------------\");\n\n        FirebaseJson valueRange;\n\n        valueRange.add(\"range\", \"Sheet1!A1:H10\");\n        valueRange.add(\"majorDimension\", \"ROWS\");\n\n        String path;\n        for (size_t i = 0; i < 8; i++)\n        {\n            for (size_t j = 0; j < 10; j++)\n            {\n                path = \"values/[\";\n                path += String(j);\n                path += \"]/[\";\n                path += String(i);\n                path += \"]\";\n                valueRange.set(path, \"x\");"
        },
        {
          "name": "tokenStatusCallback",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());"
        }
      ]
    },
    {
      "name": "encA",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "TFT_eSPI.h",
        "menu.h",
        "menuIO/TFT_eSPIOut.h",
        "streamFlow.h",
        "ClickEncoder.h",
        "menuIO/clickEncoderIn.h",
        "menuIO/keyIn.h",
        "menuIO/chainStream.h",
        "menuIO/serialIO.h",
        "menuIO/serialOut.h",
        "menuIO/serialIn.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(3000);\n\n  clickEncoder.setAccelerationEnabled(true);\n  clickEncoder.setDoubleClickEnabled(false); // Disable doubleclicks makes the response faster.  See: https://github.com/soligen2010/encoder/issues/6\n\n  // // ESP32 timer\n  timer = timerBegin(0, 80, true);\n  timerAttachInterrupt(timer, &onTimer, true);\n  timerAlarmWrite(timer, 1000, true);\n  timerAlarmEnable(timer);\n\n  // Use this initializer if you're using a 1.8\" TFT\n  // SPI.begin();\n  gfx.init(); // Initialize a ST7735S chip\n  gfx.setRotation(0); // Set the rotation (0-3) to vertical\n  Serial.println(\"Initialized ST7735S TFT\");\n  gfx.fillScreen(TFT_BLACK);\n  Serial.println(\"done\");\n\n\n  nav.showTitle = true; // Show titles in the menus and submenus\n  //  nav.timeOut = 60;  // Timeout after 60 seconds of inactivity\n  //  nav.idleOn(); // Start with the main screen and not the menu"
        },
        {
          "name": "loop",
          "body": "// Slow down the menu redraw rate\n  constexpr int menuFPS = 1000 / 30;\n  static unsigned long lastMenuFrame = -menuFPS;\n  unsigned long now = millis();\n  //... other stuff on loop, will keep executing\n  switch (exitMenuOptions)\n  {\n  case 1:\n  {\n    delay(500); // Pause to allow the button to come up\n    runCuts();\n    break;"
        },
        {
          "name": "runCuts",
          "body": "exitMenuOptions = 0;   // Return to the menu\n  delay(500);\n  mainMenu.dirty = true; // Force the main menu to redraw itself"
        },
        {
          "name": "feedInOut",
          "body": "exitMenuOptions = 0;   // Return to the menu\n  delay(500);\n  mainMenu.dirty = true; // Force the main menu to redraw itself"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESPAsyncTCP.h",
        "osapi.h",
        "os_type.h"
      ],
      "functions": [
        {
          "name": "replyToServer",
          "body": "AsyncClient* client = reinterpret_cast<AsyncClient*>(arg);\n\n\t// send reply\n\tif (client->space() > 32 && client->canSend()) {\n\t\tchar message[32];\n\t\tsprintf(message, \"this is from %s\", WiFi.localIP().toString().c_str());\n\t\tclient->add(message, strlen(message));\n\t\tclient->send();"
        },
        {
          "name": "handleData",
          "body": "Serial.printf(\"\\n data received from %s \\n\", client->remoteIP().toString().c_str());\n\tSerial.write((uint8_t*)data, len);\n\n\tos_timer_arm(&intervalTimer, 2000, true); // schedule for reply to server at next 2s"
        },
        {
          "name": "onConnect",
          "body": "Serial.printf(\"\\n client has been connected to %s on port %d \\n\", SERVER_HOST_NAME, TCP_PORT);\n\treplyToServer(client);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\tdelay(20);\n\n\t// connects to access point\n\tWiFi.mode(WIFI_STA);\n\tWiFi.begin(SSID, PASSWORD);\n\twhile (WiFi.status() != WL_CONNECTED) {\n\t\tSerial.print('.');\n\t\tdelay(500);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "LGFX_USE_V1",
      "keywords": [],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "lcd.init();\n\n  zoom = (float)(std::min(lcd.width(), lcd.height())) / width; // 表示が画面にフィットするよう倍率を調整\n\n  lcd.setPivot(lcd.width() >> 1, lcd.height() >> 1); // 時計描画時の中心を画面中心に合わせる\n\n  canvas.setColorDepth(lgfx::palette_4bit);  // 各部品を４ビットパレットモードで準備する\n  clockbase.setColorDepth(lgfx::palette_4bit);\n  needle1.setColorDepth(lgfx::palette_4bit);\n  shadow1.setColorDepth(lgfx::palette_4bit);\n  needle2.setColorDepth(lgfx::palette_4bit);\n  shadow2.setColorDepth(lgfx::palette_4bit);\n// パレットの初期色はグレースケールのグラデーションとなっており、\n// 0番が黒(0,0,0)、15番が白(255,255,255)\n// 1番～14番は黒から白へ段階的に明るさが変化している\n//\n// パレットを使う場合、描画関数は色の代わりに0～15のパレット番号を指定する\n\n  canvas.createSprite(width, width); // メモリ確保\n  clockbase.createSprite(width, width);\n  needle1.createSprite(9, 119);\n  shadow1.createSprite(9, 119);\n  needle2.createSprite(3, 119);\n  shadow2.createSprite(3, 119);\n\n  canvas.fillScreen(transpalette); // 透過色で背景を塗り潰す (create直後は0埋めされているので省略可能)\n  clockbase.fillScreen(transpalette);\n  needle1.fillScreen(transpalette);\n  shadow1.fillScreen(transpalette);\n\n  clockbase.setTextFont(4);           // フォント種類を変更(時計盤の文字用)\n  clockbase.setTextDatum(lgfx::middle_center);\n  clockbase.fillCircle(halfwidth, halfwidth, halfwidth    ,  6); // 時計盤の背景の円を塗る\n  clockbase.drawCircle(halfwidth, halfwidth, halfwidth - 1, 15);\n  for (int i = 1; i <= 60; ++i) {\n    float rad = i * 6 * - 0.0174532925;              // 時計盤外周の目盛り座標を求める\n    float cosy = - cos(rad) * (halfwidth * 10 / 11);\n    float sinx = - sin(rad) * (halfwidth * 10 / 11);\n    bool flg = 0 == (i % 5);      // ５目盛り毎フラグ\n    clockbase.fillCircle(halfwidth + sinx + 1, halfwidth + cosy + 1, flg * 3 + 1,  4); // 目盛りを描画\n    clockbase.fillCircle(halfwidth + sinx    , halfwidth + cosy    , flg * 3 + 1, 12);\n    if (flg) {                    // 文字描画\n      cosy = - cos(rad) * (halfwidth * 10 / 13);\n      sinx = - sin(rad) * (halfwidth * 10 / 13);\n      clockbase.setTextColor(1);\n      clockbase.drawNumber(i/5, halfwidth + sinx + 1, halfwidth + cosy + 4);\n      clockbase.setTextColor(15);\n      clockbase.drawNumber(i/5, halfwidth + sinx    , halfwidth + cosy + 3);"
        },
        {
          "name": "update7Seg",
          "body": "// 時計盤のデジタル表示部の描画\n  int x = clockbase.getPivotX() - 69;\n  int y = clockbase.getPivotY();\n  clockbase.setCursor(x, y);\n  clockbase.setTextColor(5);  // 消去色で 88:88 を描画する\n  clockbase.print(\"88:88\");\n  clockbase.setCursor(x, y);\n  clockbase.setTextColor(12); // 表示色で時:分を描画する\n  clockbase.printf(\"%02d:%02d\", hour, min);"
        },
        {
          "name": "drawDot",
          "body": "bool flg = 0 == (pos % 5);      // ５目盛り毎フラグ\n  float rad = pos * 6 * - 0.0174532925;              // 時計盤外周の目盛り座標を求める\n  float cosy = - cos(rad) * (halfwidth * 10 / 11);\n  float sinx = - sin(rad) * (halfwidth * 10 / 11);\n  canvas.fillCircle(halfwidth + sinx, halfwidth + cosy, flg * 3 + 1, palette);"
        },
        {
          "name": "drawClock",
          "body": "// 時計の描画\n  static int32_t p_min = -1;\n  int32_t sec = time / 1000;\n  int32_t min = sec / 60;\n  if (p_min != min) { // 分の値が変化していれば時計盤のデジタル表示部分を更新\n    p_min = min;\n    update7Seg(min / 60, min % 60);"
        },
        {
          "name": "loop",
          "body": "static uint32_t p_milli = 0;\n  uint32_t milli = lgfx::millis() % 1000;\n  if (p_milli > milli) count += 1000 + (milli - p_milli);\n  else                 count +=        (milli - p_milli);\n  p_milli = milli;\n\n  int32_t tmp = (count % 1000) >> 3;\n  canvas.setPaletteColor(8, 255 - (tmp>>1), 255 - (tmp>>1), 200 - tmp); // 秒針の描画色を変化させる\n//count += 60000;\n  if ( count > oneday ) { count -= oneday;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "Approximate.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    pinMode(LED_PIN, OUTPUT);\n\n    if (approx.init(\"MyHomeWiFi\", \"password\")) {\n        approx.setProximateDeviceHandler(onProximateDevice, APPROXIMATE_PERSONAL_RSSI);\n        approx.begin();"
        },
        {
          "name": "loop",
          "body": "approx.loop();"
        },
        {
          "name": "onProximateDevice",
          "body": "switch(event) {\n        case Approximate::ARRIVE:\n            digitalWrite(LED_PIN, HIGH);\n            Serial.println(\"ARRIVE\\t\" + device->getMacAddressAsString());\n            break;\n        case Approximate::DEPART:\n            digitalWrite(LED_PIN, LOW);\n            Serial.println(\"DEPART\\t\" + device->getMacAddressAsString());\n            break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Approximate.h",
        "PubSubClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n\n  if (approx.init(\"MyHomeWiFi\", \"password\")) {\n    approx.setProximateDeviceHandler(onProximateDevice);\n    approx.begin([]() {\n      mqttClient.setServer(\"192.168.XXX.XXX\", 1883);"
        },
        {
          "name": "loop",
          "body": "approx.loop();\n  mqttClient.loop();"
        },
        {
          "name": "onProximateDevice",
          "body": "if(event == Approximate::ARRIVE || event == Approximate::DEPART) {\n    digitalWrite(LED_PIN, event == Approximate::ARRIVE);\n\n    String json = \"{\\\"\" + device->getMacAddressAsString() + \"\\\":\\\"\" + Approximate::toString(event) + \"\\\""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Approximate.h",
        "ESP8266HTTPClient.h",
        "HTTPClient.h",
        "AceButton.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  pinMode(LED_PIN, OUTPUT);\n  digitalWrite(LED_PIN, false);\n\n  ButtonConfig* buttonConfig = button.getButtonConfig();\n  buttonConfig->setEventHandler(onButtonEvent);\n\n  if (approx.init(\"MyHomeWiFi\", \"password\", true)) {\n    approx.setProximateDeviceHandler(onProximateDevice, APPROXIMATE_SOCIAL_RSSI, 10000);\n    approx.begin();"
        },
        {
          "name": "loop",
          "body": "approx.loop();\n  button.check();"
        },
        {
          "name": "onProximateDevice",
          "body": "switch (device->getOUI()) {\n    //D8F15B Sonoff (Expressif Inc) - see: http://standards-oui.ieee.org/oui.txt\n    case 0xD8F15B:\n      onCloseBySonoff(device, event);\n      break;\n    default:\n      Serial.printf(\"Unknown OUI:\\t0x%06X\\n\", device->getOUI());\n      break;"
        },
        {
          "name": "onCloseBySonoff",
          "body": "switch (event) {\n    case Approximate::ARRIVE:\n      closeBySonoff = device;\n      digitalWrite(LED_PIN, HIGH);\n      Serial.printf(\"SONOFF\\t%s\\t(%s)\\tARRIVE\\n\", device -> getMacAddressAsString().c_str(), device -> getIPAddressAsString().c_str());\n      break;\n    case Approximate::DEPART:\n      if(*device == *closeBySonoff) {\n        closeBySonoff = NULL;\n        digitalWrite(LED_PIN, LOW);\n        Serial.printf(\"SONOFF\\t%s\\tDEPART\\n\", device -> getMacAddressAsString().c_str());"
        },
        {
          "name": "onButtonEvent",
          "body": "if(closeBySonoff) {  \n    switch (eventType) {\n      case AceButton::kEventPressed:\n        Serial.println(\"AceButton::kEventPressed\");\n        switchCloseBySonoff(true);\n        break;\n      case AceButton::kEventReleased:\n        Serial.println(\"AceButton::kEventReleased\");\n        switchCloseBySonoff(false);\n        break;"
        },
        {
          "name": "switchCloseBySonoff",
          "body": "if(closeBySonoff) {\n    approx.onceWifiStatus(WL_CONNECTED, [](bool switchState) {\n      if(closeBySonoff) {\n        WiFiClient client;\n        HTTPClient http;\n        String url = \"http://\" + closeBySonoff->getIPAddressAsString() + \":8081/zeroconf/switch\";\n        http.begin(client, url);\n        http.addHeader(\"Content-Type\", \"application/json\");\n      \n        String switchValue = switchState?\"on\":\"off\";\n        String httpRequestData = \"{\\\"deviceid\\\": \\\"\\\",\\\"data\\\": {\\\"switch\\\": \\\"\" + switchValue + \"\\\""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/extra/esp32/wifi/sta.h",
        "eloquent_esp32cam/viz/image_collection.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___IMAGE COLLECTION SERVER___\");\n\n    // camera settings\n    // replace with your own model!\n    camera.pinout.wroom_s3();\n    camera.brownout.disable();\n    // Edge Impulse models work on square images\n    // face resolution is 240x240\n    camera.resolution.face();\n    camera.quality.high();\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    // connect to WiFi\n    while (!wifi.connect().isOk())\n      Serial.println(wifi.exception.toString());\n\n    // init face detection http server\n    while (!collectionServer.begin().isOk())\n        Serial.println(collectionServer.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"WiFi OK\");\n    Serial.println(\"Image Collection Server OK\");\n    Serial.println(collectionServer.address());"
        },
        {
          "name": "loop",
          "body": "// server runs in a separate thread, no need to do anything here"
        }
      ]
    },
    {
      "name": "LGFX_USE_V1",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "diffDraw",
          "body": "union\n  {\n    std::uint32_t* s32;\n    std::uint8_t* s;"
        },
        {
          "name": "drawfunc",
          "body": "ball_info_t *balls;\n  ball_info_t *a;\n  LGFX_Sprite *sprite;\n\n  auto width  = _sprites[0].width();\n  auto height = _sprites[0].height();\n\n  std::size_t flip = _draw_count & 1;\n  balls = &_balls[flip][0];\n\n  sprite = &(_sprites[flip]);\n  sprite->clear();\n\n  for (int32_t i = 8; i < width; i += 16) {\n    sprite->drawFastVLine(i, 0, height, 0x1F);"
        },
        {
          "name": "mainfunc",
          "body": "static constexpr float e = 0.999; // Coefficient of friction\n\n  sec = lgfx::millis() / 1000;\n  if (psec != sec) {\n    psec = sec;\n    fps = frame_count;\n    frame_count = 0;\n\n    if (++ball_count >= BALL_MAX) { ball_count = 1;"
        },
        {
          "name": "taskDraw",
          "body": "while ( _is_running )\n  {\n    while (_loop_count == _draw_count) { taskYIELD();"
        },
        {
          "name": "setup",
          "body": "lcd.begin();\n  lcd.startWrite();\n  lcd.setColorDepth(8);\n  if (lcd.width() < lcd.height()) lcd.setRotation(lcd.getRotation() ^ 1);\n\n  auto lcd_width = lcd.width();\n  auto lcd_height = lcd.height();\n\n  for (std::uint32_t i = 0; i < 2; ++i)\n  {\n    _sprites[i].setTextSize(2);\n    _sprites[i].setColorDepth(8);"
        },
        {
          "name": "loop",
          "body": "mainfunc();\n#if defined (CONFIG_IDF_TARGET_ESP32)\n  while (_loop_count != _draw_count) { taskYIELD();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor.\");"
        },
        {
          "name": "loop",
          "body": "// check if a color reading is available\n  while (! APDS.colorAvailable()) {\n    delay(5);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n  Wire.begin();\n  if (!digital_inputs.init()){\n    Serial.println(\"GPIO expander initialization fail!!\");"
        },
        {
          "name": "loop",
          "body": "// Write the status value to On to Pin 3\n  digital_programmables.set(IO_WRITE_CH_PIN_03, SWITCH_ON);\n  delay(1000);\n\n  // Read from PROGRAMMABLE DIGITAL I/O Pin 3\n  Serial.println(\"Read IO Pin 03: \" + String(digital_programmables.read(IO_READ_CH_PIN_03)));\n  delay(1000);\n\n  // Read from DIGITAL INPUT Expander Pin 3 \n  Serial.println(\"Read DIN Pin 03: \" + String(digital_inputs.read(DIN_READ_CH_PIN_03)));\n  delay(1000);\n\n  // Write the status value to Off to Pin 3\n  digital_programmables.set(IO_WRITE_CH_PIN_03, SWITCH_OFF);\n  delay(1000);\n\n  Serial.println();\n  // Write the status value to On to all the Output Pins\n  digital_programmables.writeAll(SWITCH_ON_ALL);\n\n  // Reads from all Input Pins\n  readAll();\n  delay(1000);\n\n  // Write the status value to Off all to all the Output Pins\n  digital_programmables.writeAll(SWITCH_OFF_ALL);\n\n  // Reads from all Input Pins\n  readAll();\n  Serial.println();\n  delay(1000);"
        },
        {
          "name": "readAll",
          "body": "uint32_t inputs = digital_programmables.readAll();\n  Serial.println(\"CH00: \" + String((inputs & (1 << IO_READ_CH_PIN_00)) >> IO_READ_CH_PIN_00));\n  Serial.println(\"CH01: \" + String((inputs & (1 << IO_READ_CH_PIN_01)) >> IO_READ_CH_PIN_01));\n  Serial.println(\"CH02: \" + String((inputs & (1 << IO_READ_CH_PIN_02)) >> IO_READ_CH_PIN_02));\n  Serial.println(\"CH03: \" + String((inputs & (1 << IO_READ_CH_PIN_03)) >> IO_READ_CH_PIN_03));\n  Serial.println(\"CH04: \" + String((inputs & (1 << IO_READ_CH_PIN_04)) >> IO_READ_CH_PIN_04));\n  Serial.println(\"CH05: \" + String((inputs & (1 << IO_READ_CH_PIN_05)) >> IO_READ_CH_PIN_05));\n  Serial.println(\"CH06: \" + String((inputs & (1 << IO_READ_CH_PIN_06)) >> IO_READ_CH_PIN_06));\n  Serial.println(\"CH07: \" + String((inputs & (1 << IO_READ_CH_PIN_07)) >> IO_READ_CH_PIN_07));\n  Serial.println(\"CH08: \" + String((inputs & (1 << IO_READ_CH_PIN_08)) >> IO_READ_CH_PIN_08));\n  Serial.println(\"CH09: \" + String((inputs & (1 << IO_READ_CH_PIN_09)) >> IO_READ_CH_PIN_09));\n  Serial.println(\"CH10: \" + String((inputs & (1 << IO_READ_CH_PIN_10)) >> IO_READ_CH_PIN_10));\n  Serial.println(\"CH11: \" + String((inputs & (1 << IO_READ_CH_PIN_11)) >> IO_READ_CH_PIN_11));\n  Serial.println();\n  inputs = digital_inputs.readAll();\n  Serial.println(\"CH00: \" + String((inputs & (1 << DIN_READ_CH_PIN_00)) >> DIN_READ_CH_PIN_00));\n  Serial.println(\"CH01: \" + String((inputs & (1 << DIN_READ_CH_PIN_01)) >> DIN_READ_CH_PIN_01));\n  Serial.println(\"CH02: \" + String((inputs & (1 << DIN_READ_CH_PIN_02)) >> DIN_READ_CH_PIN_02));\n  Serial.println(\"CH03: \" + String((inputs & (1 << DIN_READ_CH_PIN_03)) >> DIN_READ_CH_PIN_03));\n  Serial.println(\"CH04: \" + String((inputs & (1 << DIN_READ_CH_PIN_04)) >> DIN_READ_CH_PIN_04));\n  Serial.println(\"CH05: \" + String((inputs & (1 << DIN_READ_CH_PIN_05)) >> DIN_READ_CH_PIN_05));\n  Serial.println(\"CH06: \" + String((inputs & (1 << DIN_READ_CH_PIN_06)) >> DIN_READ_CH_PIN_06));\n  Serial.println(\"CH07: \" + String((inputs & (1 << DIN_READ_CH_PIN_07)) >> DIN_READ_CH_PIN_07));\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Environment",
      "keywords": [
        "Serial",
        "digitalWrite",
        "analogRead",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  pinMode(MIC , INPUT);\n  pinMode(LIGHT , INPUT);\n  pinMode(BUTTON , INPUT);\n  \n  pinMode(LED, OUTPUT);\n  digitalWrite(LED, LOW);\n  pinMode(BUZZER, OUTPUT);\n  \n  Environment.begin();\n\n  Oled.begin();\n  Oled.setFlipMode(true);\n\n  Accelerometer.begin();\n  Pressure.begin();"
        },
        {
          "name": "loop",
          "body": "Oled.setFont(u8x8_font_amstrad_cpc_extended_r); \n\n  //cursor values are in characters, not pixels\n  Oled.setCursor(0, 4);\n  \n  // If accelerometer and altimeter are queried too close to one another\n  // this causes a hang, so we read this first.\n  Oled.print(\"x:\"); \n  Oled.print(Accelerometer.readX()); \n  Oled.print(\" y:\"); \n  Oled.print(Accelerometer.readY());        \n  Oled.setCursor(0, 5);\n  Oled.print(\"z:\"); \n  Oled.print(Accelerometer.readZ());\n  Oled.print(\" T:\");\n  Oled.print(Environment.readTemperature());\n  Oled.print(\"C\");\n\n  Oled.setCursor(0, 0);\n  Oled.print(\"But:\"); \n\n  pot_value = analogRead(POT);\n  \n  button_state = digitalRead(BUTTON);\n  Oled.print(button_state); \n  \n  if (button_state == true) {\n    digitalWrite(LED, HIGH);\n    tone(BUZZER, pot_value);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "HardwareBLESerial.h",
        "CommandParser.h"
      ],
      "functions": [
        {
          "name": "cmd_move",
          "body": "positionX = args[0].asInt64;\n  positionY = args[1].asInt64;\n  Serial.print(\"MOVING \"); Serial.print(args[0].asInt64); Serial.print(\" \"); Serial.println(args[1].asInt64);\n  snprintf(response, MyCommandParser::MAX_RESPONSE_SIZE, \"moved to %d, %d\", positionX, positionY);"
        },
        {
          "name": "cmd_jump",
          "body": "Serial.println(\"JUMPING!\");\n  snprintf(response, MyCommandParser::MAX_RESPONSE_SIZE, \"jumped at %d, %d\", positionX, positionY);"
        },
        {
          "name": "cmd_say",
          "body": "Serial.print(\"SAYING \"); Serial.println(args[0].asString);\n  snprintf(response, MyCommandParser::MAX_RESPONSE_SIZE, \"said %s at %d, %d\", args[0].asString, positionX, positionY);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!bleSerial.beginAndSetupBLE(\"CommandLine\")) {\n    while (true) {\n      Serial.println(\"failed to initialize HardwareBLESerial!\");\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// this must be called regularly to perform BLE updates\n  bleSerial.poll();\n\n  // read and process incoming commands\n  while (bleSerial.availableLines() > 0) {\n    // read line\n    char line[128];\n    bleSerial.readLine(line, 128);\n\n    // process line with CommandParser\n    char response[MyCommandParser::MAX_RESPONSE_SIZE]; parser.processCommand(line, response);\n    bleSerial.println(response);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "IRremoteESP8266.h",
        "IRac.h",
        "IRutils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(200);\n\n  // Set up what we want to send.\n  // See state_t, opmode_t, fanspeed_t, swingv_t, & swingh_t in IRsend.h for\n  // all the various options.\n  ac.next.protocol = decode_type_t::DAIKIN;  // Set a protocol to use.\n  ac.next.model = 1;  // Some A/Cs have different models. Try just the first.\n  ac.next.mode = stdAc::opmode_t::kCool;  // Run in cool mode initially.\n  ac.next.celsius = true;  // Use Celsius for temp units. False = Fahrenheit\n  ac.next.degrees = 25;  // 25 degrees.\n  ac.next.fanspeed = stdAc::fanspeed_t::kMedium;  // Start the fan at medium.\n  ac.next.swingv = stdAc::swingv_t::kOff;  // Don't swing the fan up or down.\n  ac.next.swingh = stdAc::swingh_t::kOff;  // Don't swing the fan left or right.\n  ac.next.light = false;  // Turn off any LED/Lights/Display that we can.\n  ac.next.beep = false;  // Turn off any beep from the A/C if we can.\n  ac.next.econo = false;  // Turn off any economy modes if we can.\n  ac.next.filter = false;  // Turn off any Ion/Mold/Health filters if we can.\n  ac.next.turbo = false;  // Don't use any turbo/powerful/etc modes.\n  ac.next.quiet = false;  // Don't use any quiet/silent/etc modes.\n  ac.next.sleep = -1;  // Don't set any sleep time or modes.\n  ac.next.clean = false;  // Turn off any Cleaning options if we can.\n  ac.next.clock = -1;  // Don't set any current time if we can avoid it.\n  ac.next.power = false;  // Initially start with the unit off.\n\n  Serial.println(\"Try to turn on & off every supported A/C type ...\");"
        },
        {
          "name": "loop",
          "body": "// For every protocol the library has ...\n  for (int i = 1; i < kLastDecodeType; i++) {\n    decode_type_t protocol = (decode_type_t)i;\n    // If the protocol is supported by the IRac class ...\n    if (ac.isProtocolSupported(protocol)) {\n      Serial.println(\"Protocol \" + String(protocol) + \" / \" +\n                     typeToString(protocol) + \" is supported.\");\n      ac.next.protocol = protocol;  // Change the protocol used.\n      ac.next.power = true;  // We want to turn on the A/C unit.\n      Serial.println(\"Sending a message to turn ON the A/C unit.\");\n      ac.sendAc();  // Have the IRac class create and send a message.\n      delay(5000);  // Wait 5 seconds.\n      ac.next.power = false;  // Now we want to turn the A/C off.\n      Serial.println(\"Send a message to turn OFF the A/C unit.\");\n      ac.sendAc();  // Send the message.\n      delay(1000);  // Wait 1 second."
        }
      ]
    },
    {
      "name": "FPSTR",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h",
        "aunit/string_util.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "#ifndef EPOXY_DUINO\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro"
        },
        {
          "name": "loop",
          "body": "TestRunner::run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // initialize the robot's screen\n  Robot.beginTFT();\n\n  // initialize the serial port\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// read the compass\n  int compass = Robot.compassRead();\n\n  // print out the sensor's value\n  Serial.println(compass);\n\n  // show the value on the robot's screen\n  Robot.drawCompass(compass);"
        }
      ]
    },
    {
      "name": "USE_SPIFFS",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_DoubleResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_minimal on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION); \n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n  if (drd->detectDoubleReset()) { Serial.println(F(\"DRD\")); initialConfig = true;"
        },
        {
          "name": "loop",
          "body": "drd->loop();"
        }
      ]
    },
    {
      "name": "USE_LITTLEFS",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_DoubleResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_minimal on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION); \n  if (WiFi.SSID() == \"\") { Serial.println(F(\"No AP credentials\")); initialConfig = true;"
        },
        {
          "name": "loop",
          "body": "drd->loop();"
        }
      ]
    },
    {
      "name": "ESP_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "OneButton.h",
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnDRD_FS-MQTT\");;\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDRD_FS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h",
        "map"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnSwichFS-MQTT\");\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDRD_FS_MQTT_Ptr_Complex using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnSwichFS-MQTT\");\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n  \n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDRD_FS_MQTT_Ptr_Medium using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "_WIFIMGR_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay",
        "EEPROM",
        "digitalWrite"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti_Generic.h",
        "LittleFS.h",
        "DoubleResetDetector_Generic.h",
        "WiFiManager_RP2040W.h",
        "WiFiManager_RP2040W.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3((\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1((\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR1((\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(\"\\nWiFi lost. Call connectMultiWiFi in loop\");\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = LittleFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR((\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {   \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n\n    file.close();\n    LOGERROR((\"OK\"));"
        },
        {
          "name": "processDataFromCP",
          "body": "// Stored  for later usage, from v1.1.0, but clear first\n  memset(&WM_config, 0, sizeof(WM_config));\n\n  for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n  {\n    String tempSSID = RP2040W_WiFiManager.getSSID(i);\n    String tempPW   = RP2040W_WiFiManager.getPW(i);\n\n    if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n    if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStarting ConfigOnDoubleReset with DoubleResetDetect on \"); Serial.println(BOARD_NAME);\n  Serial.println(WIFI_MANAGER_RP2040W_VERSION);\n\n  drd = new DoubleResetDetector_Generic(DRD_TIMEOUT, DRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager_RP2040W RP2040W_WiFiManager;\n\n  RP2040W_WiFiManager.setDebugOutput(true);\n\n  // Use only to erase stored WiFi Credentials\n  //RP2040W_WiFiManager.resetSettings();\n\n  RP2040W_WiFiManager.setMinimumSignalQuality(-1);\n\n#if USING_CORS_FEATURE\n  RP2040W_WiFiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    RP2040W_WiFiManager.setConfigPortalTimeout(0);\n\n    LOGERROR(\"Open Config Portal without Timeout: Double Reset Detected\");\n    initialConfig = true;"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "ESPAsync_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_Multi with DoubleResetDetect using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "_ESP32_ETH_MGR_LOGLEVEL_",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP32_W6100_Manager.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "printLocalTime",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "beginEthernet",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_TZ using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "USE_SPIFFS",
      "keywords": [
        "Serial",
        "delay",
        "EEPROM",
        "digitalWrite"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_MultiResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnMRD_ESP32_minimal on \")); Serial.print(ARDUINO_BOARD);\n#if ESP_MRD_USE_LITTLEFS\n  Serial.println(F(\" using LittleFS\"));\n#elif ESP_MRD_USE_SPIFFS\n  Serial.println(F(\" using SPIFFS\"));\n#else\n  Serial.println(F(\" using EEPROM\"));\n#endif  \n  Serial.println(ESP_WIFIMANAGER_VERSION); Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  mrd = new MultiResetDetector(MRD_TIMEOUT, MRD_ADDRESS);\n  if (mrd->detectMultiReset()) { Serial.println(F(\"MRD\")); initialConfig = true;"
        },
        {
          "name": "loop",
          "body": "mrd->loop();"
        }
      ]
    },
    {
      "name": "USE_LITTLEFS",
      "keywords": [
        "Serial",
        "delay",
        "EEPROM",
        "digitalWrite"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_MultiResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnMRD_ES8266_minimal on \")); Serial.print(ARDUINO_BOARD);\n#if ESP_MRD_USE_LITTLEFS\n  Serial.println(F(\" using LittleFS\"));\n#elif ESP_MRD_USE_SPIFFS\n  Serial.println(F(\" using SPIFFS\"));\n#else\n  Serial.println(F(\" using EEPROM\"));\n#endif    \n  Serial.println(ESP_WIFIMANAGER_VERSION); Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  if (WiFi.SSID() == \"\") { Serial.println(F(\"No AP credentials\")); initialConfig = true;"
        },
        {
          "name": "loop",
          "body": "mrd->loop();"
        }
      ]
    },
    {
      "name": "_WIFIMGR_LOGLEVEL_",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_MultiResetDetector.h",
        "ESP_MultiResetDetector.h",
        "ESP_MultiResetDetector.h",
        "ESP_MultiResetDetector.h",
        "ESP_MultiResetDetector.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(\"\\nWiFi lost. Call connectMultiWiFi in loop\");\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "loadConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset(&WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset(&WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n    \n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n    \n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    file.write((uint8_t*) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n    \n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ConfigOnMultiReset with MultiResetDetect using \" + String(FS_Name));\n  Serial.println(\" on \" + String(ARDUINO_BOARD));\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n    Serial.print(FS_Name);\n    Serial.println(F(\" failed! AutoFormatting.\"));\n\n#ifdef ESP8266\n    FileFS.format();\n#endif"
        },
        {
          "name": "loop",
          "body": "// Call the mlti reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call mrd.stop() when you wish to no longer\n  // consider the next reset as a mlti reset.\n  mrd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "_WIFIMGR_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "EEPROM"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti_Generic.h",
        "LittleFS.h",
        "WiFiManager_RP2040W.h",
        "WiFiManager_RP2040W.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(\"\\nWiFi lost. Call connectMultiWiFi in loop\");\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = LittleFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR((\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {   \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n    //file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n\n    file.close();\n    LOGERROR((\"OK\"));"
        },
        {
          "name": "processDataFromCP",
          "body": "// Stored  for later usage, from v1.1.0, but clear first\n  memset(&WM_config, 0, sizeof(WM_config));\n\n  for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n  {\n    String tempSSID = RP2040W_WiFiManager.getSSID(i);\n    String tempPW   = RP2040W_WiFiManager.getPW(i);\n\n    if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n    if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n  \n  Serial.print(\"\\nStarting ConfigOnStartup on \"); Serial.println(BOARD_NAME);\n  Serial.println(WIFI_MANAGER_RP2040W_VERSION);\n\n  digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  unsigned long startedAt = millis();\n\n  bool beginOK = LittleFS.begin();\n\n  if (!beginOK)\n  {\n    Serial.println(\"\\nLittleFS error\");"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "_ESP32_ETH_MGR_LOGLEVEL_",
      "keywords": [
        "EEPROM",
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "esp_wifi.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP32_W6100_Manager.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "beginEthernet",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnSwitch using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP32-XXXXXX\n    //ESP32_W6100_Manager ESP32_W6100_manager;\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    ESP32_W6100_Manager ESP32_W6100_manager(\"ConfigOnSwitch\");\n\n#if !USE_DHCP_IP\n#if USE_CONFIGURABLE_DNS\n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n#else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n#endif\n#endif\n\n#if USING_CORS_FEATURE\n    ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n    //Check if there is stored credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n\n    if (loadConfigData())\n    {\n      //If no access point name has been previously entered disable timeout.\n      ESP32_W6100_manager.setConfigPortalTimeout(120);\n      \n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "_ESP32_ETH_MGR_LOGLEVEL_",
      "keywords": [
        "EEPROM",
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP32_W6100_Manager.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "beginEthernet",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnSwichFS using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  // Initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP32-XXXXXX\n    //ESP32_W6100_Manager ESP32_W6100_manager;\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    ESP32_W6100_Manager ESP32_W6100_manager(\"ConfigOnSwitchFS\");\n\n    //Check if there is stored credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n\n    if (loadConfigData())\n    {\n      //If no access point name has been previously entered disable timeout.\n      ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "ESP_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "OneButton.h",
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n  // For debug only\n  //Serial.print(F(\"Published Temp = \"));\n  //Serial.println(some_number);\n    \n  MQTT_connect();\n  \n  if (Temperature->publish(some_number)) \n  {\n    //Serial.println(F(\"Failed to send value to Temperature feed!\"));\n    Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "handleClick",
          "body": "Serial.println(F(\"Button clicked!\"));\n  wifi_manager();"
        },
        {
          "name": "handleDoubleClick",
          "body": "Serial.println(F(\"Button double clicked!\"));"
        },
        {
          "name": "handleLongPressStop",
          "body": "Serial.println(F(\"Button pressed for long time and then released!\"));\n  newConfigData();"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnSwitchFS-MQTT\");\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n\n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnSwichFS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// checking button state all the time\n  btn.tick();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "_ESP32_ETH_MGR_LOGLEVEL_",
      "keywords": [
        "EEPROM",
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP32_W6100_Manager.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "beginEthernet",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigPortalParamsOnSwitch using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP32-XXXXXX\n    //ESP32_W6100_Manager ESP32_W6100_manager;\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    ESP32_W6100_Manager ESP32_W6100_manager(\"CP-ParamsOnSW\");\n\n    //Check if there is stored credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal\"));\n\n    if (loadConfigData())\n    {\n      //If no access point name has been previously entered disable timeout.\n      ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "CS_USE_SPIFFS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoJson.h",
        "ConfigStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    while (!Serial)\n        ;\n\n    delay(200);\n\n    // change parameters\n    exampleInt = configDoc[\"ParaInt\"] + 10;\n    exampleFloat = configDoc[\"ParaFloat\"] + 0.314;\n    exampleText = configDoc[\"ParaText\"] + \" and hello again\";\n\n    // set parameters\n    configDoc[\"ParaInt\"] = exampleInt;\n    configDoc[\"ParaFloat\"] = exampleFloat;\n    configDoc[\"ParaText\"] = exampleText;\n\n    // save configuration as file\n    CS.set(configDoc);\n    CS.save();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "ArduinoJson.h",
        "ConfigStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": ""
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "AT_BAUD_RATE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFiEspAT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(AT_BAUD_RATE);\n  WiFi.init(Serial1);\n\n  if (WiFi.status() == WL_NO_MODULE) {\n    Serial.println();\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": ""
        },
        {
          "name": "configAP",
          "body": "WiFiServer server(80);\n\n  WiFi.beginAP(); // starts the default AP (factory default or setup as persistent)\n\n  char ssid[33];\n  WiFi.apSSID(ssid);\n  Serial.print(\"Connect your computer to the WiFi network \");\n  Serial.print(ssid);\n  Serial.println();\n  IPAddress ip = WiFi.apIP();\n  Serial.print(\"and enter http://\");\n  Serial.print(ip);\n  Serial.println(\" in a Web browser\");\n\n  server.begin();\n\n  while (true) {\n\n    WiFiClient client = server.available();\n    if (client && client.available()) { // if !available yet, we return to this client in next loop\n      char line[64];\n      int l = client.readBytesUntil('\\n', line, sizeof(line));\n      line[l] = 0;\n      client.find((char*) \"\\r\\n\\r\\n\");\n\n      if (strncmp_P(line, PSTR(\"POST\"), strlen(\"POST\")) == 0) {\n        l = client.readBytes(line, sizeof(line));\n        line[l] = 0;\n\n        // parse the parameters sent by the html form\n        const char* delims = \"=&\";\n        strtok(line, delims);\n        const char* ssid = strtok(NULL, delims);\n        strtok(NULL, delims);\n        const char* pass = strtok(NULL, delims);\n\n        // send a response before attemting to connect to the WiFi network\n        // because it will reset the SoftAP and disconnect the client station\n        client.println(F(\"HTTP/1.1 200 OK\"));\n        client.println(F(\"Connection: close\"));\n        client.println(F(\"Refresh: 10\"));\n        client.println();\n        client.println(F(\"<html><body><h3>Configuration AP</h3><br>connecting...</body></html>\"));\n        client.flush();\n        delay(1000);\n        client.stop();\n\n        Serial.println();\n        Serial.print(\"Attempting to connect to WPA SSID: \");\n        Serial.println(ssid);\n        // WiFi.setPersistent(); // to make a successful connection persistent\n        WiFi.begin(ssid, pass);\n\n        // configuration continues with the next request"
        }
      ]
    },
    {
      "name": "MAX_DEPTH",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "menu.h",
        "menuIO/serialOut.h",
        "menuIO/serialIn.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"menu 4.x custom sub-menu prompt example\");Serial.flush();"
        },
        {
          "name": "loop",
          "body": "if (running) nav.poll();\n  delay(100);//simulate a delay when other tasks are done"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWiFiData",
          "body": "// print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(\"MAC address: \");\n  printMacAddress(mac);\n\n  // print your subnet mask:\n  IPAddress subnet = WiFi.subnetMask();\n  Serial.print(\"NetMask: \");\n  Serial.println(subnet);\n\n  // print your gateway address:\n  IPAddress gateway = WiFi.gatewayIP();\n  Serial.print(\"Gateway: \");\n  Serial.println(gateway);"
        },
        {
          "name": "printCurrentNet",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(\"BSSID: \");\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(\"Encryption Type:\");\n  Serial.println(encryption, HEX);"
        },
        {
          "name": "printMacAddress",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "SERIAL_PORT_MONITOR",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "printWifiData",
          "body": "// print your WiFi shield's IP address\n  IPAddress ip = WiFi.localIP();\n  \n  Serial.print(F(\"IP Address: \"));\n  Serial.println(ip);\n\n  // print your MAC address\n  byte mac[6];\n  WiFi.macAddress(mac);\n  \n  char buf[20];\n  \n  sprintf_P(buf, PSTR(\"%02X:%02X:%02X:%02X:%02X:%02X\"), mac[5], mac[4], mac[3], mac[2], mac[1], mac[0]);\n  \n  Serial.print(F(\"MAC address: \"));\n  Serial.println(buf);"
        },
        {
          "name": "printCurrentNet",
          "body": "// print the SSID of the network you're attached to\n  Serial.print(F(\"SSID: \"));\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  \n  char buf[20];\n  \n  sprintf_P(buf, PSTR(\"%02X:%02X:%02X:%02X:%02X:%02X\"), bssid[5], bssid[4], bssid[3], bssid[2], bssid[1], bssid[0]);\n  \n  Serial.print(F(\"BSSID: \"));\n  Serial.println(buf);\n\n  // print the received signal strength\n  long rssi = WiFi.RSSI();\n  Serial.print(F(\"Signal strength (RSSI): \"));\n  Serial.println(rssi);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting ConnectWPA on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE); \n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// print the network connection information every 10 seconds\n  Serial.println();\n  printCurrentNet();\n  printWifiData();\n\n  delay(10000);"
        }
      ]
    },
    {
      "name": "ESP_AT_BAUD",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(1000);\n\n#if defined(BOARD_NAME)\n  Serial.println(\"\\nStart ConnectWiFi on \" + String(BOARD_NAME));\n#else\n  Serial.println(\"\\nStart ConnectWiFi\");\n#endif\n\n  Serial.println(ESP_AT_LIB_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(ESP_AT_BAUD);\n\n  Serial.print(\"FW Version: \");\n  Serial.println(wifi.getVersion().c_str());\n\n\n  if (wifi.setOprToStation())\n  {\n    Serial.println(\"Set STA Mode OK\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWiFiData",
          "body": "// print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(\"MAC address: \");\n  printMacAddress(mac);"
        },
        {
          "name": "printCurrentNet",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(\"BSSID: \");\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(\"Encryption Type:\");\n  Serial.println(encryption, HEX);\n  Serial.println();"
        },
        {
          "name": "printMacAddress",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWiFiData",
          "body": "// print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(\"MAC address: \");\n  printMacAddress(mac);"
        },
        {
          "name": "printCurrentNet",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(\"BSSID: \");\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(\"Encryption Type:\");\n  Serial.println(encryption, HEX);\n  Serial.println();"
        },
        {
          "name": "printMacAddress",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "WIFI_FIRMWARE_LATEST_VERSION",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "WiFiNINA_Generic.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStart ConnectWithWPA2Enterprise on \"));\n  Serial.println(BOARD_NAME);\n  Serial.println(WIFININA_GENERIC_VERSION);\n  \n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"Communication with WiFi module failed!\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWifiData",
          "body": "// print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(F(\"IP Address: \"));\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(F(\"MAC address: \"));\n  printMacAddress(mac);"
        },
        {
          "name": "printCurrentNet",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(F(\"SSID: \"));\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(F(\"BSSID: \"));\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(F(\"signal strength (RSSI):\"));\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(F(\"Encryption Type:\"));\n  Serial.println(encryption, HEX);"
        },
        {
          "name": "printMacAddress",
          "body": "for (int i = 5; i >= 0; i--)\n  {\n    if (mac[i] < 16)\n    {\n      Serial.print(F(\"0\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFi.h",
        "Arduino_MultiWiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Wait until the serial port is connected\n    Serial.begin(9600);\n    while (!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiNINA.h",
        "Arduino_MultiWiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Wait until the serial port is connected\n    Serial.begin(9600);\n    while (!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USE_NOTE_LORA",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Notecard.h",
        "Arduino_ConnectionHandler.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial debug port and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "/* Toggle the connection every `CONN_TOGGLE_MS` milliseconds */\n  if ((millis() - lastConnToggleMs) > CONN_TOGGLE_MS) {\n    Serial.println(\"Toggling connection...\");\n    if (attemptConnect) {\n      displayCachedDeviceId();\n      conMan.connect();"
        },
        {
          "name": "displayCachedDeviceId",
          "body": "Serial.print(\"Cached Arduino IoT Cloud Device ID: \");\n  Serial.println(conMan.getDeviceId());"
        },
        {
          "name": "onNetworkConnect",
          "body": "Serial.println(\">>>> CONNECTED to network\");"
        },
        {
          "name": "onNetworkDisconnect",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "body": "Serial.println(\">>>> ERROR\");"
        }
      ]
    },
    {
      "name": "CONN_TOGGLE_MS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_ConnectionHandler.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial debug port and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "/* Toggle the connection every `CONN_TOGGLE_MS` milliseconds */\n  if ((millis() - lastConnToggleMs) > CONN_TOGGLE_MS) {\n    Serial.println(\"Toggling connection...\");\n    if (attemptConnect) {\n      conMan.connect();"
        },
        {
          "name": "onNetworkConnect",
          "body": "Serial.println(\">>>> CONNECTED to network\");"
        },
        {
          "name": "onNetworkDisconnect",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "body": "Serial.println(\">>>> ERROR\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "TinyMLShield.h",
        "Arduino_CRC32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!Camera.begin(QCIF, RGB565, 5, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// sliding delay window to try different start times wrt camera VSYNC\n  if (delayTime>0) {delayTime=delayTime-10;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Console.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize Console and wait for port to open:\n  Bridge.begin();\n  Console.begin();\n\n  // Uncomment the following line to enable buffering:\n  // - better transmission speed and efficiency\n  // - needs to call Console.flush() to ensure that all\n  //   transmitted data is sent\n\n  //Console.buffer(64);\n\n  while (!Console) {\n    ; // wait for Console port to connect."
        },
        {
          "name": "loop",
          "body": "// prints value unaltered, i.e. the raw binary version of the\n  // byte. The Console monitor interprets all bytes as\n  // ASCII, so 33, the first number,  will show up as '!'\n  Console.write(thisByte);\n\n  Console.print(\", dec: \");\n  // prints value as string as an ASCII-encoded decimal (base 10).\n  // Decimal is the  default format for Console.print() and Console.println(),\n  // so no modifier is needed:\n  Console.print(thisByte);\n  // But you can declare the modifier for decimal if you want to.\n  //this also works if you uncomment it:\n\n  // Console.print(thisByte, DEC);\n\n  Console.print(\", hex: \");\n  // prints value as string in hexadecimal (base 16):\n  Console.print(thisByte, HEX);\n\n  Console.print(\", oct: \");\n  // prints value as string in octal (base 8);\n  Console.print(thisByte, OCT);\n\n  Console.print(\", bin: \");\n  // prints value as string in binary (base 2)\n  // also prints ending line break:\n  Console.println(thisByte, BIN);\n\n  // if printed last visible character '~' or 126, stop:\n  if (thisByte == 126) {    // you could also use if (thisByte == '~') {\n    // ensure the latest bit of data is sent\n    Console.flush();\n\n    // This loop loops forever and does nothing\n    while (true) {\n      continue;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite"
      ],
      "libraries": [
        "Console.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Bridge.begin();   // Initialize Bridge\n  Console.begin();  // Initialize Console\n\n  // Wait for the Console port to connect\n  while (!Console);\n\n  Console.println(\"type H or L to turn pin 13 on or off\");\n\n  // initialize the LED pin as an output:\n  pinMode(ledPin, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// see if there's incoming Console data:\n  if (Console.available() > 0) {\n    // read the oldest byte in the Console buffer:\n    incomingByte = Console.read();\n    Console.println(incomingByte);\n    // if it's a capital H (ASCII 72), turn on the LED:\n    if (incomingByte == 'H') {\n      digitalWrite(ledPin, HIGH);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Console.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize Console and wait for port to open:\n  Bridge.begin();\n  Console.begin();\n\n  // Wait for Console port to connect\n  while (!Console);\n\n  Console.println(\"Hi, what's your name?\");"
        },
        {
          "name": "loop",
          "body": "if (Console.available() > 0) {\n    char c = Console.read(); // read the next char received\n    // look for the newline character, this is the last character in the string\n    if (c == '\\n') {\n      //print text with the name received\n      Console.print(\"Hi \");\n      Console.print(name);\n      Console.println(\"! Nice to meet you!\");\n      Console.println();\n      // Ask again for name and clear the old name\n      Console.println(\"Hi, what's your name?\");\n      name = \"\";  // clear the name string"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "handleContactsensor",
          "body": "if (!myPowerState) return;                            // if device switched off...do nothing\n\n  unsigned long actualMillis = millis();\n  \n  if (actualMillis - lastChange < 250) \n    return;          // debounce contact state transitions (same as debouncing a pushbutton)\n\n  bool actualContactState = digitalRead(CONTACT_PIN);   // read actual state of contactsensor\n\n  if (actualContactState != lastContactState) \n  {         \n    // if state has changed\n    Serial.printf(\"Contactsensor is %s now\\r\\n\", actualContactState ? \"open\" : \"closed\");\n    \n    lastContactState = actualContactState;              // update last known state\n    lastChange = actualMillis;                          // update debounce time\n    SinricProContactsensor &myContact = SinricPro[CONTACT_ID]; // get contact sensor device\n    myContact.sendContactEvent(actualContactState);      // send event with actual state"
        },
        {
          "name": "setupWiFi",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);"
        },
        {
          "name": "setupSinricPro",
          "body": "// add device to SinricPro\n  SinricProContactsensor& myContact = SinricPro[CONTACT_ID];\n\n  // set callback function to device\n  myContact.onPowerState(onPowerState);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting ContactSensor on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n\n  pinMode(CONTACT_PIN, INPUT);\n\n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "handleContactsensor();\n  SinricPro.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite"
      ],
      "libraries": [
        "LCD_ST7032.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(contrastButtonPin, INPUT);\n  digitalWrite(contrastButtonPin, HIGH);\n  lcd.begin();\n  lcd.setcontrast(24); //contrast value range is 0-63, try 25@5V or 50@3.3V as a starting value"
        },
        {
          "name": "loop",
          "body": "boolean a = digitalRead(contrastButtonPin);\n  if (a != lastButtonState) {\n    if (!a) {\n      lcd.adjcontrast(1); //increase contrast (-1 to decrease)"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "analogRead",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "initAdcadcPins",
          "body": "for (byte i = 0; i < sizeof(adcPins) / sizeof(int); i++) {\n    LOG_I(\"Init pin no: %i\\n\", adcPins[i]);\n    pinMode(adcPins[i], INPUT);\n    ctrl.bind( (\"adc_\" + String(adcPins[i])).c_str() );"
        },
        {
          "name": "readAdcadcPins",
          "body": "for (byte i = 0; i < sizeof(adcPins) / sizeof(int); i++) {\n    uint16_t v = analogRead( adcPins[i]);\n    ctrl.set(ctrlsNdx[i], v);\n    LOG_N(\"Read pin no: %i = %u\\n\", adcPins[i], v);"
        },
        {
          "name": "speedChange",
          "body": "LOG_V(\"speedChange  %s\\n\", ctrl[\"speed\"].c_str());\n speed = ctrl[\"speed\"].toInt();"
        },
        {
          "name": "changeOnOff",
          "body": "LOG_V(\"changeOnOff  %li\\n\", ctrl[\"on-off\"].toInt());\n isPlaying = ctrl[\"on-off\"].toInt();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "if (millis() - pingMillis >= speed){\n    if(isPlaying) readAdcadcPins();\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "debugMemory",
          "body": "#if defined(ESP32)\n    LOG_D(\"%s > Free: heap %u, block: %u, pSRAM %u\\n\", caller, ESP.getFreeHeap(), heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL), ESP.getFreePsram());\n  #else\n    LOG_D(\"%s > Free: heap %u\\n\", caller, ESP.getFreeHeap());\n  #endif"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n\n  // Setup the remote web debugger in order to store log lines, url \"/log\"\n  // When no connection is present store log lines in a buffer until connection\n  remoteLogView.setup();\n\n  LOG_I(\"Starting..\\n\");\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_D(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "if (millis() - pingMillis >= 2000){\n    debugMemory(\"Loop\");\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "disconnect",
          "body": "LOG_D(\"Disconnect WiFi for %s seconds\\n\", String(disconTime / 1000L).c_str());\n  ctrl.put(\"wifi_rssi\",  -120 );\n  ctrl.loop();\n  ctrl.sendSystemMsg(\"C\");\n  time_t s = millis();\n  while(millis() - s < 100 )\n    ctrl.loop();\n  WiFi.disconnect();\n  disconnMillis = millis();"
        },
        {
          "name": "changeHandler",
          "body": "String key = ctrl[ndx].key;\n  if(key == \"sleep_time\" )\n    disconTime = ctrl[key].toInt() * 1000;\n  else if(key == \"disconnect_button\")\n    disconnect();\n\n  LOG_D(\"changeHandler: ndx: %02i, key: %s = %s\\n\",ndx, key.c_str(), ctrl[key].c_str());"
        },
        {
          "name": "connect",
          "body": "if(WiFi.status() == WL_CONNECTED ) return;\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n  // Connect WiFi\n  connect();\n\n  // Control assist setup\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.bind(\"mac_address\", WiFi.macAddress().c_str() );\n  ctrl.bind(\"wifi_rssi\");\n  ctrl.bind(\"sleep_time\", disconTime / 1000);\n  ctrl.bind(\"disconnect_button\");\n  ctrl.setAutoSendOnCon(true);\n  // Every time a variable changed changeHandler will be called\n  ctrl.setGlobalCallback(changeHandler);\n\n  // Start web sockets\n  ctrl.begin();\n  //ctrl.put(\"sleep_time\", disconTime / 1000,true);\n  LOG_V(\"ControlAssist started.\\n\");\n\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);"
        },
        {
          "name": "loop",
          "body": "// Change html control values\n  if (millis() - pingMillis >= 3000){\n    // Update control assist variables\n    ctrl.put(\"wifi_rssi\", WiFi.RSSI() );\n\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "STORAGE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266WebServer.h",
        "LittleFS.h",
        "ESP8266mDNS.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "setLed",
          "body": "if( ledState ){\n    digitalWrite(LED_BUILTIN, LOW); // Turn LED ON\n    LOG_D(\"Led on\\n\");"
        },
        {
          "name": "globalChangeHandler",
          "body": "LOG_N(\"globalChangeHandler ndx: %02u, key: '%s', val: %s\\n\", ndx, ctrl[ndx].key.c_str(), ctrl[ndx].val.c_str());\n  if(ctrl[ndx].key == \"led\"){ // Led clicked in web page\n    // Incoming message, Toggle led and dont send update\n    setLed(ctrl[ndx].val.toInt());\n    LOG_I(\"Setting led to %i\\n\",(int)ctrl[ndx].val.toInt());\n    // Set the connected led pin\n    String ledKey = String(LED_BUILTIN);\n    if(LED_BUILTIN<10) ledKey = \"0\" + ledKey;\n    ctrl.put(ledKey.c_str(), !ctrl[ndx].val.toInt() );"
        },
        {
          "name": "readAllGpio",
          "body": "for(uint i=0; i<TOTAL_PINS; i++){\n    int state = readGPIO(i);\n    String pin = String(i);\n    if (i<10) pin = \"0\" + pin;\n    ctrl.put(pin.c_str(), state, true);\n\n    /* Click on build in led pin\n    if(pin.toInt() == LED_BUILTIN){\n      setLed(!state);\n      ctrl.put(\"led\", !state);"
        },
        {
          "name": "listAllFilesInDir",
          "body": "Dir dir = LittleFS.openDir(dir_path);\n\twhile(dir.next()) {\n\t\tif (dir.isFile()) {\n\t\t\t// print file names\n\t\t\tSerial.print(\"File: \");\n\t\t\tSerial.println(dir_path + dir.fileName() + \" : \" + dir.fileSize());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  if (!STORAGE.begin()) {\n    Serial.println(\"An Error has occurred while mounting SPIFFS\");\n    return;"
        },
        {
          "name": "loop",
          "body": "if (millis() - pingMillis >= 5000){\n    // Toggle led\n    setLed(!ctrl[\"led\"].toInt());\n    // Update config assist variable and send ws message\n    ctrl.put(\"led\", !ctrl[\"led\"].toInt() );\n    // Read the state of all gpio\n    readAllGpio();\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "analogWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "lampLevel",
          "body": "ledLevel = ctrl[\"lampLevel\"].toInt();\n  LOG_D(\"lampLevel: %i\\n\", ledLevel);\n  analogWrite(LED_BUILTIN, 255 - ledLevel);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();;"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "changeHandler",
          "body": "String key = ctrl[ndx].key;\n  if(key == \"check_ctrl\" )\n    buttonState = ctrl[\"check_ctrl\"].toInt();\n  LOG_D(\"changeHandler: ndx: %02i, key: %s = %s\\n\",ndx, key.c_str(), ctrl[key].c_str());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n   // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "// Update html control values\n  if (millis() - pingMillis >= DELAY_MS){\n    ctrl.put(\"rssi\", String( WiFi.RSSI() ) );\n    ctrl.put(\"mem\", String( getMemPerc() ) );\n    #if defined(ESP32)\n    ctrl.put(\"temp\", String( ((temprature_sens_read() - 32) / 1.8), 1 ));\n    ctrl.put(\"hall\", String( hallRead() ) );\n    #else\n    ctrl.put(\"vcc\", String( ESP.getVcc() ));\n    #endif\n    buttonState = !buttonState;\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "xChange",
          "body": "LOG_I(\"X pos: %lu\\n\", ctrl[\"x_coordinate\"].toInt());"
        },
        {
          "name": "yChange",
          "body": "LOG_I(\"Y pos: %lu\\n\", ctrl[\"y_coordinate\"].toInt());"
        },
        {
          "name": "speedChange",
          "body": "LOG_I(\"Speed: %lu %%\\n\", ctrl[\"speed\"].toInt());"
        },
        {
          "name": "angleChange",
          "body": "LOG_I(\"Angle: %lu °\\n\", ctrl[\"angle\"].toInt());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "delay",
        "Serial",
        "analogRead"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n  String res = \"\";\n  res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n  while( ctrl.getHtmlChunk(res)){\n    server.sendContent(res);"
        },
        {
          "name": "changeOnOff",
          "body": "LOG_V(\"changeOnOff  %li\\n\", ctrl[\"on-off\"].toInt());\n isPlaying = ctrl[\"on-off\"].toInt();"
        },
        {
          "name": "speedChange",
          "body": "LOG_V(\"speedChange  %s\\n\", ctrl[\"speed\"].c_str());\n speed = ctrl[\"speed\"].toInt();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "// Run repeatedly\n\n  if (millis() - pingMillis >= speed){\n    // Set control at position to value\n    if(isPlaying)\n      ctrl.set(adc_pos, analogRead(ADC_PIN), true);\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "changeHandler",
          "body": "String key = ctrl[ndx].key;\n  if(key == \"check_ctrl\" )\n    buttonState = ctrl[\"check_ctrl\"].toInt();\n  LOG_D(\"changeHandler: ndx: %02i, key: %s = %s\\n\",ndx, key.c_str(), ctrl[key].c_str());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n   // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "// Change html control values\n  if (millis() - pingMillis >= 3000){\n    // Update control assist variables\n    ctrl.put(\"span_ctrl\", analogRead(ADC_PIN) );\n    ctrl.put(\"input_ctrl\", String(ESP.getCycleCount()));\n    ctrl.put(\"text_ctrl\",  chBuff);\n    ctrl.put(\"check_ctrl\", buttonState );\n    ctrl.put(\"range_ctrl\", WiFi.RSSI() );\n    ctrl.put(\"button_ctrl\", buttonState );\n#if defined(ESP32)\n    //ctrl.put(\"input_ctrl\", String((temprature_sens_read() - 32) / 1.8 ) + \" °C\");\n    sprintf(chBuff, \"Memory Free: heap %u, block: %u, pSRAM %u\", ESP.getFreeHeap(), heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL), ESP.getFreePsram());\n#else\n    sprintf(chBuff,\"Memory free heap: %u, stack: %u ,block: %u\", ESP.getFreeHeap(), ESP.getFreeContStack(), ESP.getMaxFreeBlockSize());\n#endif\n    buttonState = !buttonState;\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "WEB_SERVER",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "ledChangeHandler",
          "body": "ledState = ctrl[\"toggleLed\"].toInt();\n  LOG_D(\"ledChangeHandler state: %i\\n\", ledState);\n  toggleLed(ledState);"
        },
        {
          "name": "toggleLed",
          "body": "if( ledState ){\n    digitalWrite(LED_BUILTIN, LOW); // Turn LED ON\n    LOG_D(\"Led on\\n\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();"
        },
        {
          "name": "loop",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();\n\n  if (millis() - pingMillis >= 5000){\n    ledState = !ledState;\n    toggleLed(ledState);\n    // Set the ledState and send a websocket update\n    ctrl.put(\"toggleLed\", ledState );\n    pingMillis = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "L298NX2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Used to display information\n  Serial.begin(9600);\n\n  // Wait for Serial Monitor to be opened\n  while (!Serial)\n  {\n    //do nothing"
        },
        {
          "name": "loop",
          "body": "// Tell both motors to go forward (may depend by your wiring)\n  motors.forward();\n\n  // Alternative method:\n  // motors.run(L298N::FORWARD);\n\n  //print the motor status in the serial monitor\n  printSomeInfo();\n\n  delay(3000);\n\n  // Stop\n  motors.stop();\n\n  // Alternative method:\n  // motors.run(L298N::STOP);\n\n  printSomeInfo();\n\n  delay(3000);\n\n  // Change individual speeds\n  motors.setSpeedA(255);\n  motors.setSpeedB(90);\n\n  // Tell motor A to go back (may depend by your wiring)\n  motors.backwardA();\n\n  // Alternative method:\n  // motors.runA(L298N::BACKWARD);\n\n  // Tell motor B to go forward (may depend by your wiring)\n  motors.backwardB();\n\n  // Alternative method:\n  // motors.runB(L298N::FORWARD);\n\n  printSomeInfo();\n\n  delay(3000);\n\n  // Stop\n  motors.stop();\n\n  printSomeInfo();\n\n  // Change individual speeds\n  motors.setSpeedA(90);\n  motors.setSpeedB(255);\n\n  delay(3000);"
        },
        {
          "name": "printSomeInfo",
          "body": "Serial.print(\"Motor A is moving = \");\n  Serial.print(motors.isMovingA() ? \"YES\" : \"NO\");\n  Serial.print(\" at speed = \");\n  Serial.println(motors.getSpeedA());\n  Serial.print(\"Motor B is moving = \");\n  Serial.print(motors.isMovingB() ? \"YES\" : \"NO\");\n  Serial.print(\" at speed = \");\n  Serial.println(motors.getSpeedB());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                 // Baud rate: 115200, but you can define any baud rate you want\n  pinMode(ledPin, OUTPUT);              // Set the pin of our LED to OUTPUT\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.setActuationCallback(asset, actuation);  // \"asset\" - Variable we defined above, \"actuation\" - Name of the function below that does the work\n  device.createAsset(\"led-example\", \"LED (SDK Example)\", \"actuator\", \"boolean\"); // Create asset \"led-example\" on your AllThingsTalk to control the LED\n  device.init();                        // Initialize AllThingsTalk"
        },
        {
          "name": "loop",
          "body": "device.loop();                        // Keep AllThingsTalk & WiFi alive"
        },
        {
          "name": "actuation",
          "body": "// Function called when message arrives to your specified asset. \"value\" is the actual value received.\n  if (value == true) {\n    digitalWrite(ledPin, HIGH);         // Set pin \"ledPin\" to HIGH (ON)\n    Serial.println(\"LED Turned ON\");    // Prints to serial port"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                 // Baud rate: 115200, but you can define any baud rate you want\n  pinMode(ledPin, OUTPUT);              // Set the pin of our LED to OUTPUT\n  digitalWrite(ledPin, HIGH);           // Because the built-in LED is inverted, it's turned on at boot. We'll turn it off here.\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.connectionLed(false);          // Disable the Connection LED feature because we're going to control that exact LED\n  device.setActuationCallback(asset, actuation);  // \"asset\" - Variable we defined above, \"actuation\" - Name of the function below that does the work\n  device.createAsset(\"builtin-led-example\", \"Built-In LED (SDK Example)\", \"actuator\", \"boolean\"); // Create asset on your AllThingsTalk to control the LED\n  device.init();                        // Initialize AllThingsTalk"
        },
        {
          "name": "loop",
          "body": "device.loop();                        // Keep AllThingsTalk & WiFi alive"
        },
        {
          "name": "actuation",
          "body": "// Function called when message arrives to your specified asset. \"value\" is the actual value received.\n  if (value == true) {\n    digitalWrite(ledPin, LOW);          // Set pin \"ledPin\" to LOW (ON, because it's inverted)\n    Serial.println(\"LED Turned ON\");    // Prints to serial port"
        }
      ]
    },
    {
      "name": "RS485_DE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "BLVD20KM_asukiaaa.h",
        "rs485_asukiaaa.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  BLVD20KM_asukiaaa::beginModbus(&modbus, RS485_BAUDRATE);\n  motorA.beginWithoutModbus();\n  motorB.beginWithoutModbus();"
        },
        {
          "name": "readAndPrintSpeed",
          "body": "uint16_t speed;\n  auto result = motor->readSpeed(&speed);\n  Serial.print(motorLabel);\n  Serial.print(\" \");\n  if (result == 0) {\n    Serial.println(\"Speed is \" + String(speed));"
        },
        {
          "name": "readAndPrintAlarm",
          "body": "uint16_t alarmState;\n  auto result = motor->readAlarm(&alarmState);\n  Serial.print(motorLabel);\n  Serial.print(\" \");\n  if (result == 0) {\n    Serial.println(\"Current alarm:0x\" + String(alarmState, HEX) + \" \" +\n                   BLVD20KM_asukiaaa::getStrOfAlarm(alarmState));"
        },
        {
          "name": "loop",
          "body": "motorA.writeSpeed(500);\n  motorA.writeForward();\n  readAndPrintSpeed(\"motorA\", &motorA);\n  delay(2000);\n\n  motorB.writeSpeed(500);\n  motorB.writeForward();\n  readAndPrintSpeed(\"motorB\", &motorB);\n  delay(2000);\n\n  motorA.writeStop();\n  Serial.println(\"motorA stop\");\n  delay(2000);\n\n  motorB.writeStop();\n  Serial.println(\"motorB stop\");\n  delay(2000);\n\n  motorA.writeSpeed(200);\n  motorA.writeReverse();\n  readAndPrintSpeed(\"motorA\", &motorA);\n  delay(2000);\n\n  motorB.writeSpeed(200);\n  motorB.writeReverse();\n  readAndPrintSpeed(\"motorB\", &motorB);\n  delay(2000);\n\n  motorA.writeStop();\n  Serial.println(\"motorA stop\");\n  delay(2000);\n\n  motorB.writeStop();\n  Serial.println(\"motorB stop\");\n  delay(2000);\n\n  readAndPrintAlarm(\"motorA\", &motorA);\n  readAndPrintAlarm(\"motorB\", &motorB);\n  delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");"
        },
        {
          "name": "loop",
          "body": "/*Read control panel status (Switch and Slider)*/\n  String control_panel_status = myiot.ReadControlPanel(userid,key);\n\n  /*Print out result: Output is JSON format*/\n  Serial.println(control_panel_status);\n\n  /*Delay interval time for read control status*/\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "IoTtweetESP32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");"
        },
        {
          "name": "loop",
          "body": "/*Read control panel status (Switch and Slider)*/\n  String control_panel_status = myiot.ReadControlPanel(userid,key);\n\n  /*Print out result: Output is JSON format*/\n  Serial.println(control_panel_status);\n\n  /*Delay interval time for read control status*/\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");"
        },
        {
          "name": "loop",
          "body": "/*Example : Read status slider no.1 on dashboard.\n   * This command will return data type as float to you \n   * command parameter : ReadAnalogSlider(userid,key,slider number);\n   */\n  float slider1_read = myiot.ReadAnalogSlider(userid,key,1);\n\n  /*Print output to serial monitor*/\n  Serial.println();\n  Serial.print(\"Analog Slider 1 value is \");\n  Serial.print(slider1_read);\n\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  /*Set output pin of LED (Built-in LED of NodeMCU is IO no. 16)*/\n  pinMode(LED_BUILTIN,OUTPUT);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");"
        },
        {
          "name": "loop",
          "body": "/*Example : Read status switch no.1 on dashboard.\n   * This command will return \"ON\" or \"OFF\" string to you    \n   * command parameter : ReadDigitalSwitch(userid,ket,switch number);\n   */\n  String sw1_read = myiot.ReadDigitalSwitch(userid,key,1);\n\n  delay(10);\n\n  /*Drive to built-in LED*/\n  if(sw1_read == \"ON\")\n  {\n      digitalWrite(LED_BUILTIN,LOW);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "analogWrite"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h",
        "WiFiNINA.h",
        "utility/wifi_drv.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                 // Baud rate for Serial output (debug), but you can define any baud rate you want\n  WiFiDrv::pinMode(25, OUTPUT);         // Initialize the Green LED pin on the MKR1010 board\n  WiFiDrv::pinMode(26, OUTPUT);         // Initialize the Red LED pin on the MKR1010 board\n  WiFiDrv::pinMode(27, OUTPUT);         // Initialize the Blue LED pin on the MKR1010 board\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.setActuationCallback(actuator, rgb); // Add an actuation callback for asset defined above and run function \"rgb\" once command is received\n  device.init();                        // Initialize WiFi and AllThingsTalk"
        },
        {
          "name": "rgb",
          "body": "// Function that will be called when you pick a color on AllThingsTalk\n  Serial.println(\"RGB Color Changed!\"); // Outputs to Serial\n  // Parses the received RGB information into three separate variables (R, G, B)\n  long hexColor = (long) strtol(&value[1], NULL, 16);\n  r = hexColor >> 16;\n  g = hexColor >> 8 & 0xFF;\n  b = hexColor & 0xFF;\n  WiFiDrv::analogWrite(25, g);          // Set the Green LED to received value\n  WiFiDrv::analogWrite(26, r);          // Set the Red LED to received value\n  WiFiDrv::analogWrite(27, b);          // Set the Blue LED to received value"
        },
        {
          "name": "loop",
          "body": "// Runs as long as the device in on\n  device.loop();                        // Keep AllThingsTalk & WiFi connection alive"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "IRremoteESP8266.h",
        "IRsend.h",
        "ir_Samsung.h"
      ],
      "functions": [
        {
          "name": "printState",
          "body": "// Display the settings.\n  Serial.println(\"Samsung A/C remote is in the following state:\");\n  Serial.printf(\"  %s\\n\", ac.toString().c_str());"
        },
        {
          "name": "setup",
          "body": "ac.begin();\n  Serial.begin(115200);\n  delay(200);\n\n  // Set up what we want to send. See ir_Samsung.cpp for all the options.\n  Serial.println(\"Default state of the remote.\");\n  printState();\n  Serial.println(\"Setting initial state for A/C.\");\n  ac.off();\n  ac.setFan(kSamsungAcFanLow);\n  ac.setMode(kSamsungAcCool);\n  ac.setTemp(25);\n  ac.setSwing(false);\n  printState();"
        },
        {
          "name": "loop",
          "body": "// Turn the A/C unit on\n  Serial.println(\"Turn on the A/C ...\");\n  ac.on();\n  ac.send();\n  printState();\n  delay(15000);  // wait 15 seconds\n  // and set to cooling mode.\n  Serial.println(\"Set the A/C mode to cooling ...\");\n  ac.setMode(kSamsungAcCool);\n  ac.send();\n  printState();\n  delay(15000);  // wait 15 seconds\n\n  // Increase the fan speed.\n  Serial.println(\"Set the fan to high and the swing on ...\");\n  ac.setFan(kSamsungAcFanHigh);\n  ac.setSwing(true);\n  ac.send();\n  printState();\n  delay(15000);\n\n  // Change to Fan mode, lower the speed, and stop the swing.\n  Serial.println(\"Set the A/C to fan only with a low speed, & no swing ...\");\n  ac.setSwing(false);\n  ac.setMode(kSamsungAcFan);\n  ac.setFan(kSamsungAcFanLow);\n  ac.send();\n  printState();\n  delay(15000);\n\n  // Turn the A/C unit off.\n  Serial.println(\"Turn off the A/C ...\");\n  ac.off();\n  ac.send();\n  printState();\n  delay(15000);  // wait 15 seconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h",
        "Servo.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                 // Baud rate: 115200, but you can define any baud rate you want\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.wifiSignalReporting(true);     // Enables WiFi Signal Strength reporting to your AllThingsTalk\n  device.setActuationCallback(asset, controlServo);  // \"asset\" - Variable we defined above, \"controlServo\" - Name of the function below that does the work\n  device.createAsset(asset, \"Servo (SDK Example)\", \"actuator\", \"integer\"); // Create asset on your AllThingsTalk to control the Servo\n  device.init();                        // Initialize AllThingsTalk"
        },
        {
          "name": "loop",
          "body": "device.loop();                        // Keep AllThingsTalk & WiFi alive"
        },
        {
          "name": "controlServo",
          "body": "// Function called when message arrives to your specified asset. \"value\" is the actual value received.\n  servo.attach(servoPin);               // Activates the servo motor\n  Serial.println(\"Changing Servo Motor Position to: \");\n  Serial.println(value);                // Print current value of servo to serial monitor\n  servo.write(value);                   // Send the value to which the servo motor should move to\n  delay(700);                           // Give the servo motor some time to finish its movement\n  servo.detach();                       // Disactivate servo motor"
        }
      ]
    },
    {
      "name": "COLOR_TEAL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();"
        },
        {
          "name": "loop",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();"
        },
        {
          "name": "directionScreen",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SerialFlash.h",
        "SD.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//uncomment these if using Teensy audio shield\n  //SPI.setSCK(14);  // Audio shield has SCK on pin 14\n  //SPI.setMOSI(7);  // Audio shield has MOSI on pin 7\n\n  //uncomment these if you have other SPI chips connected\n  //to keep them disabled while using only SerialFlash\n  //pinMode(4, INPUT_PULLUP);\n  //pinMode(10, INPUT_PULLUP);\n\n  Serial.begin(9600);\n\n  // wait up to 10 seconds for Arduino Serial Monitor\n  unsigned long startMillis = millis();\n  while (!Serial && (millis() - startMillis < 10000)) ;\n  delay(100);\n  Serial.println(\"Copy all files from SD Card to SPI Flash\");\n\n  if (!SD.begin(SDchipSelect)) {\n    error(\"Unable to access SD card\");"
        },
        {
          "name": "loop",
          "body": ""
        },
        {
          "name": "error",
          "body": "while (1) {\n    Serial.println(message);\n    delay(2500);"
        }
      ]
    },
    {
      "name": "USB_BUFFER_SIZE",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SerialFlash.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);  //Teensy serial is always at full USB speed and buffered... the baud rate here is required but ignored\n\n  pinMode(13, OUTPUT);\n  \n  //Set up SPI\n  SPI.setMOSI(MOSI);\n  SPI.setMISO(MISO);\n  SPI.setSCK(SCK);\n  SerialFlash.begin(CSPIN);\n\n  //We start by formatting the flash...\n  uint8_t id[5];\n  SerialFlash.readID(id);\n  SerialFlash.eraseAll();\n  \n  //Flash LED at 1Hz while formatting\n  while (!SerialFlash.ready()) {\n    delay(500);\n    digitalWrite(13, HIGH);\n    delay(500);\n    digitalWrite(13, LOW);"
        },
        {
          "name": "loop",
          "body": "//Do nothing."
        },
        {
          "name": "flushError",
          "body": "uint32_t lastReceiveTime = millis();\n  char usbBuffer[USB_BUFFER_SIZE];\n  //We assume the serial receive part is finished when we have not received something for 3 seconds\n  while(Serial.available() || lastReceiveTime + 3000 > millis()){\n    if (Serial.readBytes(usbBuffer, USB_BUFFER_SIZE)){\n      lastReceiveTime = millis();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "ESP_Google_Sheet_Client.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32) || defined(ESP8266)\n    WiFi.setAutoReconnect(true);\n#endif\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif"
        },
        {
          "name": "loop",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\n    bool ready = GSheet.ready();\n\n    if (ready && !taskComplete)\n    {\n\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\n\n        // If you assign the spreadsheet id from your own spreadsheet,\n        // you need to set share access to the Service Account's CLIENT_EMAIL\n\n        FirebaseJson response;\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\n\n        Serial.println(\"\\nCopy sheet of spreadsheet to another spreadsheet...\");\n        Serial.println(\"---------------------------------------------------\");\n\n        // The sheet id is the integer number which you can get it from gid parameter of spreadsheet URL when select the sheet tab\n        // For example, https://docs.google.com/spreadsheets/d/xxxxxxx/edit#gid=1180731163\n        // The sheet id of above case is 1180731163\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.sheets/copyTo\n\n        bool success = GSheet.sheets.copyTo(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to copy */, 0 /* sheet id */, \"<destination_spreadsheetId>\" /* destination spreadsheet id */);\n        if (success)\n            response.toString(Serial, true);\n        else\n            Serial.println(GSheet.errorReason());\n        Serial.println();\n\n#if defined(ESP32) || defined(ESP8266)\n        Serial.println(ESP.getFreeHeap());\n#elif defined(PICO_RP2040)\n        Serial.println(rp2040.getFreeHeap());\n#endif\n\n        taskComplete = true;"
        },
        {
          "name": "tokenStatusCallback",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());"
        }
      ]
    },
    {
      "name": "ARGS_SEP_CODE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//init Ciao\n\tCiao.begin();\n\tSerial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "//Run commands in Linino OS to get the CPU Usage\n\tCiaoData data = Ciao.write(\"shell\",ShellCommand, ShellArguments);\n\n\tif(!data.isEmpty()){\n\t\t//Get data back\n\t\tString usage = data.get(2);\n\t\tSerial.println(usage);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "FirebaseJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\r\n    Serial.println();\r\n    Serial.println();\r\n\r\n    //Create, parsing and modify JSON object and JSON array\r\n    //FirebaseJSON supports Arduino String, PROGMEM, flash string, std::string, char array, string literal, and sum of arduino String.\r\n\r\n    //All functions supported FPSTR, String, std::string, const char* and char array as parameters.\r\n\r\n    FirebaseJson json;       // or constructor with contents e.g. FirebaseJson json(\"{\\\"a\\\":true"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        // Note: If new document created under non-existent ancestor documents, that document will not appear in queries and snapshot\n        // https://cloud.google.com/firestore/docs/using-console#non-existent_ancestor_documents.\n\n        // We will create the document in the parent path \"a0/b?\n        // a0 is the collection id, b? is the document id in collection a0.\n\n        String documentPath = \"a0/b\" + String(cnt);\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // double\n        Values::DoubleValue dblV(random(1, 500) / 100.0);\n\n        // boolean\n        Values::BooleanValue bolV(true);\n\n        // integer\n        Values::IntegerValue intV(random(500, 1000));\n\n        // null\n        Values::NullValue nullV;\n\n        String doc_path = \"projects/\";\n        doc_path += FIREBASE_PROJECT_ID;\n        doc_path += \"/databases/(default)/documents/coll_id/doc_id\"; // coll_id and doc_id are your collection id and document id\n\n        // reference\n        Values::ReferenceValue refV(doc_path);\n\n        // timestamp\n        Values::TimestampValue tsV(getTimestampString(1712674441, 999999999));\n\n        // bytes\n        Values::BytesValue bytesV(\"aGVsbG8=\");\n\n        // string\n        Values::StringValue strV(\"hello\");\n\n        // array\n        Values::ArrayValue arrV(Values::StringValue(\"test\"));\n        arrV.add(Values::IntegerValue(20)).add(Values::BooleanValue(true));\n\n        // map\n        Values::MapValue mapV(\"name\", Values::StringValue(\"wrench\"));\n        mapV.add(\"mass\", Values::StringValue(\"1.3kg\")).add(\"count\", Values::IntegerValue(3));\n\n        // lat long\n        Values::GeoPointValue geoV(1.486284, 23.678198);\n\n        Document<Values::Value> doc(\"myDouble\", Values::Value(dblV));\n        doc.add(\"myBool\", Values::Value(bolV)).add(\"myInt\", Values::Value(intV)).add(\"myNull\", Values::Value(nullV));\n        doc.add(\"myRef\", Values::Value(refV)).add(\"myTimestamp\", Values::Value(tsV)).add(\"myBytes\", Values::Value(bytesV));\n        doc.add(\"myString\", Values::Value(strV)).add(\"myArr\", Values::Value(arrV)).add(\"myMap\", Values::Value(mapV));\n        doc.add(\"myGeo\", Values::Value(geoV));\n\n        // The value of Values::xxxValue, Values::Value and Document can be printed on Serial.\n\n        Serial.println(\"Create document... \");\n\n        String payload = Docs.createDocument(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), documentPath, DocumentMask(), doc);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "FirebaseJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    // Create, parsing and modify JSON object and JSON array\n    // FirebaseJSON supports Arduino String, PROGMEM, flash string, std::string, char array, string literal, and sum of arduino String.\n\n    // All functions supported FPSTR, String, std::string, const char* and char array as parameters.\n\n    FirebaseJson json;       // or constructor with contents e.g. FirebaseJson json(\"{\\\"a\\\":true"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "ESP_Google_Sheet_Client.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32) || defined(ESP8266)\n    WiFi.setAutoReconnect(true);\n#endif\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif"
        },
        {
          "name": "loop",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\n    bool ready = GSheet.ready();\n\n    if (ready && !taskComplete)\n    {\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\n\n        FirebaseJson response;\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\n\n        Serial.println(\"\\nCreate spreadsheet...\");\n        Serial.println(\"------------------------\");\n\n        FirebaseJson spreadsheet;\n        spreadsheet.set(\"properties/title\", \"Test - Create Update and Read\");\n\n        String spreadsheetId, spreadsheetURL;\n        bool success = false;\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/create\n\n        success = GSheet.create(&response /* returned response */, &spreadsheet /* spreadsheet object */, USER_EMAIL /* your email that this spreadsheet shared to */);\n        response.toString(Serial, true);\n        Serial.println();\n\n        if (success)\n        {\n\n            // Get the spreadsheet id from already created file.\n            FirebaseJsonData result;\n            response.get(result, FPSTR(\"spreadsheetId\")); // parse or deserialize the JSON response\n            if (result.success)\n                spreadsheetId = result.to<const char *>();\n\n            // Get the spreadsheet URL.\n            result.clear();\n            response.get(result, FPSTR(\"spreadsheetUrl\")); // parse or deserialize the JSON response\n            if (result.success)\n            {\n                spreadsheetURL = result.to<const char *>();\n                Serial.println(\"\\nThe spreadsheet URL\");\n                Serial.println(spreadsheetURL);"
        },
        {
          "name": "tokenStatusCallback",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n  // Print a message to the LCD.\n  lcd.print(\"hello, world!\");"
        },
        {
          "name": "loop",
          "body": "// Turn off the cursor:\n  lcd.noCursor();\n  delay(500);\n  // Turn on the cursor:\n  lcd.cursor();\n  delay(500);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "MY_FS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FS.h",
        "SPIFFS.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "fileCallback",
          "body": "// FILE_OPEN_MODE_READ, FILE_OPEN_MODE_WRITE and FILE_OPEN_MODE_APPEND are defined in this library\n    // MY_FS is defined in this example\n    switch (mode)\n    {\n    case file_mode_open_read:\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_READ);\n        break;\n    case file_mode_open_write:\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_WRITE);\n        break;\n    case file_mode_open_append:\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_APPEND);\n        break;\n    case file_mode_remove:\n        MY_FS.remove(filename);\n        break;\n    default:\n        break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogRead",
        "delay"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize LCD and set up the number of columns and rows:\n  lcd.begin(16, 2);\n\n  // create a new character\n  lcd.createChar(0, heart);\n  // create a new character\n  lcd.createChar(1, smiley);\n  // create a new character\n  lcd.createChar(2, frownie);\n  // create a new character\n  lcd.createChar(3, armsDown);\n  // create a new character\n  lcd.createChar(4, armsUp);\n\n  // set the cursor to the top left\n  lcd.setCursor(0, 0);\n\n  // Print a message to the lcd.\n  lcd.print(\"I \");\n  lcd.write(byte(0)); // when calling lcd.write() '0' must be cast as a byte\n  lcd.print(\" Arduino! \");\n  lcd.write((byte)1);"
        },
        {
          "name": "loop",
          "body": "// read the potentiometer on A0:\n  int sensorReading = analogRead(A0);\n  // map the result to 200 - 1000:\n  int delayTime = map(sensorReading, 0, 1023, 200, 1000);\n  // set the cursor to the bottom row, 5th position:\n  lcd.setCursor(4, 1);\n  // draw the little man, arms down:\n  lcd.write(3);\n  delay(delayTime);\n  lcd.setCursor(4, 1);\n  // draw him arms up:\n  lcd.write(4);\n  delay(delayTime);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "delay"
      ],
      "libraries": [
        "Wire.h",
        "LCD03.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialise a 20x4 LCD\n  lcd.begin(20, 4);\n  \n  // create a new character\n  lcd.createChar(0, smiley);"
        },
        {
          "name": "loop",
          "body": "// Write the first custom char to the LCD\n  lcd.write(0);\n\n  // Wait for 1 second\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting CustomHeader on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Making GET request\");\n  httpClient.beginRequest();\n\n  httpClient.get(\"/\");\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"GET Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"GET Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);\n\n  Serial.println(\"Making POST request\");\n  String postData = \"name=Alice&age=12\";\n  httpClient.beginRequest();\n  httpClient.post(\"/\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_LENGTH, postData.length());\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n  httpClient.write((const byte*)postData.c_str(), postData.length());\n  // note: the above line can also be achieved with the simpler line below:\n  //httpClient.print(postData);\n\n  // read the status code and body of the response\n  statusCode = httpClient.responseStatusCode();\n  response = httpClient.responseBody();\n\n  Serial.print(\"POST Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"POST Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStarting BasicAuthGet_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Making GET request\");\n  httpClient.beginRequest();\n  \n  httpClient.get(\"/\");\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"GET Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"GET Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);\n\n  Serial.println(\"Making POST request\");\n  String postData = \"name=Alice&age=12\";\n  httpClient.beginRequest();\n  httpClient.post(\"/\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_LENGTH, postData.length());\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n  httpClient.write((const byte*)postData.c_str(), postData.length());\n  // note: the above line can also be achieved with the simpler line below:\n  //httpClient.print(postData);\n\n  // read the status code and body of the response\n  statusCode = httpClient.responseStatusCode();\n  response = httpClient.responseBody();\n\n  Serial.print(\"POST Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"POST Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Keypad.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "char customKey = customKeypad.getKey();\n  \n  if (customKey){\n    Serial.println(customKey);"
        }
      ]
    },
    {
      "name": "LEDPIN",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "menu.h",
        "menuIO/serialOut.h",
        "menuIO/serialIn.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LEDPIN,OUTPUT);\n  digitalWrite(LEDPIN,HIGH);\n  Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"menu 4.x test\");Serial.flush();\n  nav.idleTask=idle;//point a function to be used when menu is suspended\n  // nav.idleOn(idle);//enter idle mode, this menu will start on idle state, press select  to enter menu\n  // nav.doInput(\"4\");//we can also provide input from string, this will enter idle mode by exiting the menu\n\n  //this is an example of driving the menu string input\n  //this however requires a known menu state and therefor is not recomended for complicated menus\n  // see async calls instead\n  // for(int c=0;c<3;c++) {//using the menu to blink the led\n  //   nav.doInput(\"2\");//led on\n  //   delay(1000);\n  //   nav.doInput(\"3\");//led off\n  //   delay(1000);\n  //"
        },
        {
          "name": "loop",
          "body": "nav.poll();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Database.loop();\n\n    if (app.ready() && (ms == 0 || millis() - ms > 60000))\n    {\n        ms = millis();\n\n        String path = \"/test/int2/\" + genUUID();\n\n        // Push int\n        Serial.print(\"Push int... \");\n        String name = Database.push<int>(aClient, \"/test/int\", 12345);\n\n        if (aClient.lastError().code() == 0)\n            Firebase.printf(\"ok, name: %s\\n\", name.c_str());\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n\n        // Set int with custom UUID.\n        Serial.print(\"Set int with custom UUID... \");\n        bool status = Database.set<int>(aClient, path, 12345);\n\n        if (status)\n            Serial.println(\"ok\");\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiNINA.h",
        "ArduinoOTA.h",
        "SFU.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial:\n  Serial.begin(9600);\n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\");\n    // don't continue:\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// check for WiFi OTA updates\n  ArduinoOTA.poll();\n\n  // add your normal loop code below ..."
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = \"/UsersData/\";\n        path += auth.token.uid.c_str(); //<- user uid or \"Node1\"\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = \"/UsersData/\";\n        path += auth.token.uid.c_str(); //<- user uid is \"Node1\"\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "requestEvent",
          "body": "Wire.write(dest_addr);"
        },
        {
          "name": "receiveEvent",
          "body": "command = Wire.read();\n  if (command == 'r') {\n    stay_in_bootloader = true;\n    while (Wire.available()) {\n      Wire.read();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Wire.begin(I2C_ADDRESS);\n  Wire.onRequest(requestEvent);\n  Wire.onReceive(receiveEvent);\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(3, INPUT_PULLUP);\n\n  setup_ptrs();\n  sodaq_wdt_enable(WDT_PERIOD_2X);\n\n  int start = millis();\n\n  if (system_get_reset_cause() == SYSTEM_RESET_CAUSE_WDT) {\n    stay_in_bootloader = true;"
        },
        {
          "name": "loop",
          "body": "if ((millis() % 1000 > 500) && ((millis() / 1000) % 2 != status)) {\n    digitalWrite(LED_BUILTIN, status);\n    status = (millis() / 1000) % 2;"
        }
      ]
    },
    {
      "name": "Fix16",
      "keywords": [
        "Wire",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "led_on",
          "body": "digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "setup",
          "body": "WDT->CTRL.reg &= ~WDT_CTRL_ENABLE;\n  while (WDT->STATUS.reg & WDT_STATUS_SYNCBUSY);\n\n  //temp_init();\n  battery = new Battery(ADC_BATTERY);\n\n  dcmotors[0] = new DCMotor(MOTOR_1_COUNTER, MOTOR_1_PIN_A, MOTOR_1_PIN_B);\n  dcmotors[1] = new DCMotor(MOTOR_2_COUNTER, MOTOR_2_PIN_A, MOTOR_2_PIN_B),\n\n  servos[0] = new ServoMotor(PWM_PIN_SERVO_1);\n  servos[1] = new ServoMotor(PWM_PIN_SERVO_2);\n  servos[2] = new ServoMotor(PWM_PIN_SERVO_3);\n  servos[3] = new ServoMotor(PWM_PIN_SERVO_4);\n\n  encoders[0] = new EncoderWrapper(ENCODER_2_PIN_A, ENCODER_2_PIN_B, 1);\n  encoders[1] = new EncoderWrapper(ENCODER_1_PIN_A, ENCODER_1_PIN_B, 0);\n\n  pid_control[0] = new PIDWrapper(encoders[0]->position, encoders[0]->velocity, dcmotors[0], 0, 10, 100); //10ms period velo, 100ms period pos\n  pid_control[1] = new PIDWrapper(encoders[1]->position, encoders[1]->velocity, dcmotors[1], 1, 10, 100),\n\n  Wire.begin(I2C_ADDRESS);\n  Wire.onRequest(requestEvent);\n  Wire.onReceive(receiveEvent);\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(IRQ_PIN, OUTPUT);\n  analogWriteResolution(8);"
        },
        {
          "name": "loop",
          "body": "if (command == RESET || ((lastMessageReceived != 0) && (millis() - lastMessageReceived > 10000))) {\n    reboot();"
        },
        {
          "name": "receiveEvent",
          "body": "noInterrupts();\n  command = Wire.read();\n\n  if (command < GET_VERSION) {\n    // empty buffer\n    while (Wire.available()) {\n      Wire.read();"
        },
        {
          "name": "requestEvent",
          "body": "noInterrupts();\n  //deassert IRQ\n  if (irq_enabled) {\n    digitalWrite(IRQ_PIN, HIGH);"
        },
        {
          "name": "requestAttention",
          "body": "irq_status |= (1 << cause);\n  if (irq_enabled) {\n    digitalWrite(IRQ_PIN, LOW);"
        },
        {
          "name": "getFWVersion",
          "body": "Wire.write(FW_VERSION);"
        },
        {
          "name": "getInternalTemperature",
          "body": "//Wire.write(temp_raw_to_mdeg(temp_read_raw()));"
        },
        {
          "name": "reboot",
          "body": "NVIC_SystemReset();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Basic Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);"
        },
        {
          "name": "receivedTrackPower",
          "body": "Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");"
        },
        {
          "name": "receivedLocoUpdate",
          "body": "Serial.print(\"Received Loco update for DCC address: \");\n    Serial.println(loco->getAddress());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Loco Control Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  if (!consist) {\n    consist = new Consist();\n\n    // create a loco with DCC address 11 - LocoSourceEntry means it's not from the roster\n    Loco *loco1 = new Loco(11, LocoSource::LocoSourceEntry);\n    Serial.print(\"Created loco: \");\n    Serial.println(loco1->getAddress());\n\n    // add this loco to the consist\n    consist->addLoco(loco1, Facing::FacingForward);\n\n    // create a second loco with DCC address 12 - LocoSourceEntry means it's not from the roster\n    Loco *loco2 = new Loco(12, LocoSource::LocoSourceEntry);\n    Serial.print(\"Created loco: \");\n    Serial.println(loco2->getAddress());\n\n    // add this loco to the consist, and it will be running in reverse direction\n    consist->addLoco(loco2, Facing::FacingReversed);\n\n    // turn track power on or the loco won't move\n    dccexProtocol.powerOn();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Delegate Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);"
        },
        {
          "name": "receivedTrackPower",
          "body": "Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");"
        },
        {
          "name": "receivedLocoUpdate",
          "body": "Serial.print(\"Received Loco update for DCC address: \");\n    Serial.println(loco->getAddress());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Loco Control Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  if (!loco) {\n    // add a loco with DCC address 11 - LocoSourceEntry means it's not from the roster\n    loco = new Loco(11, LocoSource::LocoSourceEntry);\n    Serial.print(\"Added loco: \");\n    Serial.println(loco->getAddress());\n\n    // turn track power on or the loco won't move\n    dccexProtocol.powerOn();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);"
        },
        {
          "name": "receivedTrackPower",
          "body": "Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");"
        },
        {
          "name": "receivedLocoUpdate",
          "body": "Serial.print(\"Received Loco update for DCC address: \");\n    Serial.println(loco->getAddress());"
        },
        {
          "name": "setLoco",
          "body": "_loco = loco;"
        },
        {
          "name": "setSpeed",
          "body": "if (!_loco)\n      return;\n    _dccexProtocol->setThrottle(_loco, speed, _loco->getDirection());"
        },
        {
          "name": "setDirection",
          "body": "if (!_loco)\n      return;\n    _dccexProtocol->setThrottle(_loco, _loco->getSpeed(), direction);"
        },
        {
          "name": "process",
          "body": "// Routine calls here included in the loop to read encoder or other inputs"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Loco Control Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // throttle processing example\n  for (int i = 0; i < numThrottles; i++) {\n    throttles[i]->process();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);"
        },
        {
          "name": "receivedTrackPower",
          "body": "Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");"
        },
        {
          "name": "receivedRosterList",
          "body": "Serial.println(\"\\n\\nReceived Roster\");\n    printRoster();"
        },
        {
          "name": "receivedTurnoutList",
          "body": "Serial.print(\"\\n\\nReceived Turnouts/Points list\");\n    printTurnouts();\n    Serial.println(\"\\n\\n\");"
        },
        {
          "name": "receivedRouteList",
          "body": "Serial.print(\"\\n\\nReceived Routes List\");\n    printRoutes();\n    Serial.println(\"\\n\\n\");"
        },
        {
          "name": "receivedTurntableList",
          "body": "Serial.print(\"\\n\\nReceived Turntables list\");\n    printTurntables();\n    Serial.println(\"\\n\\n\");"
        },
        {
          "name": "printRoster",
          "body": "for (Loco *loco = dccexProtocol.roster->getFirst(); loco; loco = loco->getNext()) {\n    int id = loco->getAddress();\n    char *name = loco->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");\n    for (int i = 0; i < 32; i++) {\n      char *fName = loco->getFunctionName(i);\n      if (fName != nullptr) {\n        Serial.print(\"loadFunctionLabels() \");\n        Serial.print(fName);\n        if (loco->isFunctionMomentary(i)) {\n          Serial.print(\" - Momentary\");"
        },
        {
          "name": "printTurnouts",
          "body": "for (Turnout *turnout = dccexProtocol.turnouts->getFirst(); turnout; turnout = turnout->getNext()) {\n    int id = turnout->getId();\n    char *name = turnout->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");"
        },
        {
          "name": "printRoutes",
          "body": "for (Route *route = dccexProtocol.routes->getFirst(); route; route = route->getNext()) {\n    int id = route->getId();\n    char *name = route->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");"
        },
        {
          "name": "printTurntables",
          "body": "for (Turntable *turntable = dccexProtocol.turntables->getFirst(); turntable; turntable = turntable->getNext()) {\n    int id = turntable->getId();\n    char *name = turntable->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");\n\n    int j = 0;\n    for (TurntableIndex *turntableIndex = turntable->getFirstIndex(); turntableIndex;\n         turntableIndex = turntableIndex->getNextIndex()) {\n      char *indexName = turntableIndex->getName();\n      Serial.print(\"  index\");\n      Serial.print(j);\n      Serial.print(\" ~\");\n      Serial.print(indexName);\n      Serial.println(\"~\");\n      j++;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Roster and Objects Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // sequentially request and get the required lists. To avoid overloading the buffer\n  // getLists(bool rosterRequired, bool turnoutListRequired, bool routeListRequired, bool turntableListRequired)\n  dccexProtocol.getLists(true, true, true, true);"
        }
      ]
    },
    {
      "name": "MAX_SSIDS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "printSsids",
          "body": "Serial.println(\"\");\n  Serial.println(\"Browsing for SSIDs \");\n\n  double startTime = millis();\n  double nowTime = startTime;\n\n  int numSsids = WiFi.scanNetworks();\n  while ((numSsids == -1) && ((nowTime - startTime) <= 10000)) { // try for 10 seconds\n    delay(250);\n    Serial.print(\".\");\n    nowTime = millis();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol SSID example\");\n  Serial.println();\n\n  // browse for SSIDs\n  printSsids();"
        },
        {
          "name": "loop",
          "body": "delay(20000);\n  // Redo every 20 seconds - For demonstration purposes only!\n  // Normally this will only be required once.\n  printSsids();"
        }
      ]
    },
    {
      "name": "CONSOLE",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "DCCEXProtocol.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "body": "CONSOLE.print(\"\\n\\nReceived version: \");\n    CONSOLE.print(major);\n    CONSOLE.print(\".\");\n    CONSOLE.print(minor);\n    CONSOLE.print(\".\");\n    CONSOLE.println(patch);"
        },
        {
          "name": "receivedTrackPower",
          "body": "CONSOLE.print(\"\\n\\nReceived Track Power: \");\n    CONSOLE.println(state);\n    CONSOLE.println(\"\\n\\n\");"
        },
        {
          "name": "receivedRosterList",
          "body": "CONSOLE.println(\"\\n\\nReceived Roster\");\n    printRoster();"
        },
        {
          "name": "receivedTurnoutList",
          "body": "CONSOLE.print(\"\\n\\nReceived Turnouts/Points list\");\n    printTurnouts();\n    CONSOLE.println(\"\\n\\n\");"
        },
        {
          "name": "receivedRouteList",
          "body": "CONSOLE.print(\"\\n\\nReceived Routes List\");\n    printRoutes();\n    CONSOLE.println(\"\\n\\n\");"
        },
        {
          "name": "receivedTurntableList",
          "body": "CONSOLE.print(\"\\n\\nReceived Turntables list\");\n    printTurntables();\n    CONSOLE.println(\"\\n\\n\");"
        },
        {
          "name": "receivedScreenUpdate",
          "body": "CONSOLE.println(\"\\n\\nReceived screen|row|message\");\n    CONSOLE.print(screen);\n    CONSOLE.print(\"|\");\n    CONSOLE.print(row);\n    CONSOLE.print(\"|\");\n    CONSOLE.println(message);"
        },
        {
          "name": "printRoster",
          "body": "for (Loco *loco = dccexProtocol.roster->getFirst(); loco; loco = loco->getNext()) {\n    int id = loco->getAddress();\n    char *name = loco->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");\n    for (int i = 0; i < 32; i++) {\n      char *fName = loco->getFunctionName(i);\n      if (fName != nullptr) {\n        CONSOLE.print(\"loadFunctionLabels() \");\n        CONSOLE.print(fName);\n        if (loco->isFunctionMomentary(i)) {\n          CONSOLE.print(\" - Momentary\");"
        },
        {
          "name": "printTurnouts",
          "body": "for (Turnout *turnout = dccexProtocol.turnouts->getFirst(); turnout; turnout = turnout->getNext()) {\n    int id = turnout->getId();\n    char *name = turnout->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");"
        },
        {
          "name": "printRoutes",
          "body": "for (Route *route = dccexProtocol.routes->getFirst(); route; route = route->getNext()) {\n    int id = route->getId();\n    char *name = route->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");"
        },
        {
          "name": "printTurntables",
          "body": "for (Turntable *turntable = dccexProtocol.turntables->getFirst(); turntable; turntable = turntable->getNext()) {\n    int id = turntable->getId();\n    char *name = turntable->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");\n\n    int j = 0;\n    for (TurntableIndex *turntableIndex = turntable->getFirstIndex(); turntableIndex;\n         turntableIndex = turntableIndex->getNextIndex()) {\n      char *indexName = turntableIndex->getName();\n      CONSOLE.print(\"  index\");\n      CONSOLE.print(j);\n      CONSOLE.print(\" ~\");\n      CONSOLE.print(indexName);\n      CONSOLE.println(\"~\");\n      j++;"
        },
        {
          "name": "setup",
          "body": "CONSOLE.begin(115200);\n  CLIENT.begin(115200);\n  CONSOLE.println(F(\"DCCEXProtocol Serial Connection Demo\"));\n  CONSOLE.println(F(\"\"));\n\n  // Direct logs to CONSOLE\n  dccexProtocol.setLogStream(&CONSOLE);\n\n  // Set the delegate for broadcasts/responses\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Connect to the CS via CLIENT\n  dccexProtocol.connect(&CLIENT);\n  CONSOLE.println(F(\"DCC-EX connected\"));\n\n  dccexProtocol.requestServerVersion();"
        },
        {
          "name": "loop",
          "body": "// Parse incoming messages\n  dccexProtocol.check();\n\n  dccexProtocol.getLists(true, true, true, true);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "receivedTrackType",
          "body": "Serial.print(\"\\n\\nReceived TrackType: \");\n    Serial.print(track);\n    Serial.print(\" : \");\n    Serial.print(type);\n    Serial.print(\" : \");\n    Serial.println(address);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Track Type Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // every 10 seconds change speed and set a random function on or off\n  if ((millis() - lastTime) >= 10000) {\n\n    lastTrackType++;\n    if (lastTrackType > 4)\n      lastTrackType = 0;\n\n    if (lastTrackType == 0) {\n      Serial.println(\"Set A:MAIN  B:PROG\");\n      dccexProtocol.setTrackType('A', MAIN, 0);\n      // dccexProtocol.setTrackType('B',PROG,0);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "body": "Serial.print(\"Received version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);"
        },
        {
          "name": "receivedTurnoutList",
          "body": "Serial.print(\"Received turnout list:\");\n    printTurnouts();"
        },
        {
          "name": "receivedTurnoutAction",
          "body": "Serial.print(\"Received turnout action ID|thrown: \");\n    Serial.print(turnoutId);\n    Serial.print(\"|\");\n    Serial.println(thrown);"
        },
        {
          "name": "printTurnouts",
          "body": "for (Turnout *turnout = dccexProtocol.turnouts->getFirst(); turnout; turnout = turnout->getNext()) {\n    int id = turnout->getId();\n    char *name = turnout->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Turnout/Point Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // sequentially request and get the required lists. To avoid overloading the buffer\n  dccexProtocol.getLists(false, true, false, false);\n\n  if (dccexProtocol.receivedLists() && !doneTurnouts) {\n    if (dccexProtocol.getTurnoutCount() >= 2) {\n      turnout1 = dccexProtocol.turnouts->getFirst();\n      Serial.print(\"Turnout 1 id: \");\n      Serial.println(turnout1->getId());\n      turnout2 = turnout1->getNext();\n      Serial.print(\"Turnout 2 id: \");\n      Serial.println(turnout2->getId());"
        }
      ]
    },
    {
      "name": "MAX_SERVERS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "printMdnsServers",
          "body": "Serial.println(\"\");\n\n  double startTime = millis();\n  double nowTime = startTime;\n\n  const char *service = \"withrottle\";\n  const char *proto = \"tcp\";\n\n  Serial.print(\"Browsing for service \");\n  Serial.print(service);\n  Serial.print(\".\");\n  Serial.print(proto);\n  Serial.print(\".local. on \");\n  Serial.print(ssid);\n  Serial.println(\" ... \");\n\n  int noOfWitServices = 0;\n  while ((noOfWitServices == 0) && ((nowTime - startTime) <= 5000)) { // try for 5 seconds\n    noOfWitServices = MDNS.queryService(service, proto);\n    if (noOfWitServices == 0) {\n      delay(500);\n      Serial.print(\".\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol mDNS example\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  // setup the mDNS listner\n  mdnsListenerStarted = setupMdnsListner();\n\n  // browse for services\n  if (mdnsListenerStarted) {\n    printMdnsServers();"
        },
        {
          "name": "loop",
          "body": "delay(20000);\n  // Redo every 20 seconds - For demonstration purposes only!\n  // Normally this will only be required once, immediately after you connect to the ssid.\n  if (mdnsListenerStarted) {\n    printMdnsServers();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n  Serial.println(\"Adafruit Motorshield v2 - DC Motor test!\");\n\n  if (!AFMS.begin()) {         // create with the default frequency 1.6KHz\n  // if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz\n    Serial.println(\"Could not find Motor Shield. Check wiring.\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "uint8_t i;\n\n  Serial.print(\"tick\");\n\n  myMotor->run(FORWARD);\n  for (i=0; i<255; i++) {\n    myMotor->setSpeed(i);\n    delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "EasyDDNS.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");"
        },
        {
          "name": "loop",
          "body": "// Check for new public IP every 10 seconds\n  EasyDDNS.update(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoBearSSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"Key: \");\n  printHex(key, 8);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(enc_iv, 8);\n  Serial.println(\" \");\n  Serial.print(\"DES Encryption of '\");\n  printHex(input, 8);\n  Serial.print(\"' is 0x\");\n  DES.runEnc(key, 8, input, 8, enc_iv);   // expect 0x3C21EB6A62D372DB\n  printHex(input, 8);\n  Serial.println(\" \");\n  Serial.println(\" \");\n  Serial.print(\"Key: \");\n  printHex(key, 8);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(dec_iv, 8);\n  Serial.println(\" \");\n  Serial.print(\"DES Decryption of '\");\n  printHex(input, 8);\n  Serial.print(\"' is 0x\");\n  DES.runDec(key, 8, input, 8, dec_iv);\n  printHex(input, 8);\n  Serial.println(\" \");\n  while (1);"
        },
        {
          "name": "printHex",
          "body": "for (byte i = 0; i < size; i = i + 1) {\n    if (text[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleSerialBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  DebugSerial.println(\"Waiting for connections...\");\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(115200);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize serial communications at 9600 bps\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "dht11.update();\n\n  C = dht11.readCelsius();     \t// Reading the temperature in Celsius degrees and store in the C variable\n  F = dht11.readFahrenheit();  \t// Reading the temperature in Fahrenheit degrees and store in the F variable\n  H = dht11.readHumidity();     // Reading the humidity index\n\n  // Print the collected data in a row on the Serial Monitor\n  Serial.print(\"H: \");\n  Serial.print(H);\n  Serial.print(\"\\tC: \");\n  Serial.print(C);\n  Serial.print(\"\\tF: \");\n  Serial.println(F);\n\n  delay(1000);                // Wait one second before get another temperature reading"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n\n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32 using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32 using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting DHT11ESP32 using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n\n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32_SSL using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32_SSL using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting DHT11ESP32_SSL using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(\"B\");"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);;\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP8266 using \")); \n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(\"\\nStarting DHT11ESP8266 using EEPROM\");\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n  \n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  \n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(\"B\");"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP8266_Debug using \"));  \n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting DHT11ESP8266_Debug using EEPROM\");\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n    \n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n  #if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP8266_SSL using \"));\n  Serial.print(CurrentFileFS);  \n#else\n  Serial.print(F(\"\\nStarting DHT11ESP8266_SSL using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "Wire"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "DHT.h",
        "Arduino.h",
        "U8g2lib.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 31, 249), 8080);//自建服务器ip模式\n  dht.begin();\n  timer.setInterval(1000L, sendSensor);\n  u8g2.begin();"
        },
        {
          "name": "sendSensor",
          "body": "float h = dht.readHumidity();\n  float t = dht.readTemperature(); //摄氏度\n  //float t = dht.readTemperature(true); //华氏度\n  Blynk.virtualWrite(V0, t);//将湿度发送给V0\n  Blynk.virtualWrite(V1, h);//将湿度发送给V1\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_ncenB08_tr); \n  u8g2.setFontPosTop();\n  u8g2.drawStr(0,0,\"WENDU:\");\n  u8g2.setCursor(60, 0);\n  u8g2.print(t);\n  u8g2.drawStr(0,20,\"SHIDU:\");\n  u8g2.setCursor(60, 20);\n  u8g2.print(h);\n  u8g2.sendBuffer();"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "DHT_PIN",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart DHT11_W5100 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  dht.begin();\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = 25.5;\n  float humidity    = 50.0;\n \n  if (Blynk.connected())\n  {   \n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart DHT11_W5500 using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart DHT11_W5500 on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  #if USE_ETHERNET_WRAPPER\n\n    EthernetInit();\n\n  #else\n\n    #if USE_ETHERNET\n      Serial.println(F(\"=========== USE_ETHERNET ===========\"));\n    #elif USE_ETHERNET2\n      Serial.println(F(\"=========== USE_ETHERNET2 ===========\"));\n    #elif USE_ETHERNET3\n      Serial.println(F(\"=========== USE_ETHERNET3 ===========\"));\n    #elif USE_ETHERNET_LARGE\n      Serial.println(F(\"=========== USE_ETHERNET_LARGE ===========\"));\n    #elif USE_ETHERNET_ESP8266\n      Serial.println(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n    #else\n      Serial.println(F(\"=========================\"));\n    #endif\n   \n      Serial.println(F(\"Default SPI pinout:\"));\n      Serial.print(F(\"MOSI:\")); Serial.println(MOSI);\n      Serial.print(F(\"MISO:\")); Serial.println(MISO);\n      Serial.print(F(\"SCK:\"));  Serial.println(SCK);\n      Serial.print(F(\"SS:\"));   Serial.println(SS);\n      Serial.println(F(\"=========================\"));\n       \n    #if defined(ESP8266)\n      // For ESP8266, change for other boards if necessary\n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   D2    // For ESP8266\n      #endif\n      \n      Serial.print(F(\"ESP8266 setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n      \n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // For ESP8266\n        // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n        // Ethernet           0                 X            X            X            X        0\n        // Ethernet2          X                 X            X            X            X        0\n        // Ethernet3          X                 X            X            X            X        0\n        // EthernetLarge      X                 X            X            X            X        0\n        // Ethernet_ESP8266   0                 0            0            0            0        0\n        // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n        // Must use library patch for Ethernet, EthernetLarge libraries\n        //Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n        \n    #elif defined(ESP32)\n  \n      // You can use Ethernet.init(pin) to configure the CS pin\n      //Ethernet.init(10);  // Most Arduino shields\n      //Ethernet.init(5);   // MKR ETH shield\n      //Ethernet.init(0);   // Teensy 2.0\n      //Ethernet.init(20);  // Teensy++ 2.0\n      //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n      //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n      \n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   22    // For ESP32\n      #endif\n      \n      Serial.print(F(\"ESP32 setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n      \n      // For other boards, to change if necessary\n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // Must use library patch for Ethernet, EthernetLarge libraries\n        // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n        // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n           \n        //Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n              \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n  \n    #else   //defined(ESP8266)\n      // unknown board, do nothing, use default SS = 10\n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   10    // For other boards\n      #endif\n           \n      Serial.print(BOARD_NAME); Serial.print(F(\" setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n  \n      // For other boards, to change if necessary\n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n  \n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n                        \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n      \n    #endif    //defined(ESP8266)\n  \n  \n  #endif  //USE_ETHERNET_WRAPPER\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n  #if USE_LOCAL_SERVER\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #else\n    //Blynk.begin(auth);\n    // You can also specify server:\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(BlynkServer);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT12 LIBRARY VERSION: \");\n  Serial.println(DHT12_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  DHT.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "body": "if (millis() - DHT.lastRead() >= 2000)\n  {\n    //  READ DATA\n    Serial.print(\"DHT12, \\t\");\n    int status = DHT.read();\n    switch (status)\n    {\n    case DHT12_OK:\n      Serial.print(\"OK,\\t\");\n      break;\n    case DHT12_ERROR_CHECKSUM:\n      Serial.print(\"Checksum error,\\t\");\n      break;\n    case DHT12_ERROR_CONNECT:\n      Serial.print(\"Connect error,\\t\");\n      break;\n    case DHT12_MISSING_BYTES:\n      Serial.print(\"Missing bytes,\\t\");\n      break;\n    default:\n      Serial.print(\"Unknown error,\\t\");\n      break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Wire.begin();\n  DHT.begin();\n\n  Serial.begin(115200);\n  Serial.println(\"Humidity, Temperature\");"
        },
        {
          "name": "loop",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    // note no error checking\n    DHT.read();\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\", \");\n    Serial.println(DHT.getTemperature(), 1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT12 LIBRARY VERSION: \");\n  Serial.println(DHT12_LIB_VERSION);\n  Serial.println();\n\n  Wire.setSDA(12);\n  Wire.setSCL(13);\n  Wire.begin();\n\n  DHT.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "body": "//  READ DATA\n  Serial.print(\"DHT12, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT12_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT12_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT12_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT12_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT12 LIBRARY VERSION: \");\n  Serial.println(DHT12_LIB_VERSION);\n  Serial.println();\n\n  Wire1.begin(12, 13);\n  DHT.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "body": "// READ DATA\n  Serial.print(\"DHT12, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT12_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT12_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT12_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT12_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  DHT.begin();    //  ESP32 default pins 21 22\n\n\n  delay(1000);"
        },
        {
          "name": "loop",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    //  READ DATA\n    uint32_t start = micros();\n    int status = DHT.read();\n    uint32_t stop = micros();\n\n    if ((count % 10) == 0)\n    {\n      count = 0;\n      Serial.println();\n      Serial.println(\"Type\\tHumidity (%)\\tTemp (°C)\\tTime (µs)\\tStatus\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Serial.println(\"\\nNOTE: datasheet states 400 KHz as maximum.\\n\");\n\n  Wire.begin();\n  DHT.begin();  //  ESP32 default pins 21, 22\n  delay(2000);\n\n  for (uint32_t speed = 50000; speed < 850000; speed += 50000)\n  {\n    Wire.setClock(speed);\n    Serial.print(speed);\n    Serial.print(\"\\t\");\n    Serial.print(DHT.read());  // status\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.println();\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  Wire.setClock(400000);\n\n  DHT.begin();  //  ESP32 default 21, 22\n\n  delay(2000);\n\n  //  start with initial request\n  Serial.println(DHT.requestData());"
        },
        {
          "name": "loop",
          "body": "uint32_t now = millis();\n\n  if (now - DHT.lastRead() > 1000)\n  {\n    DHT.readData();\n    DHT.convert();\n\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\" %RH \\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.print(\" °C\\t\");\n    Serial.print(counter);\n    Serial.print(\"\\n\");\n    //  new request\n    counter = 0;\n    DHT.requestData();"
        }
      ]
    },
    {
      "name": "BACKLIGHT_PIN",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Wire.h",
        "LCD.h",
        "LiquidCrystal_I2C.h"
      ],
      "functions": [
        {
          "name": "setupDisplay",
          "body": "lcd = LiquidCrystal_I2C(displayAddress, En_pin, Rw_pin, Rs_pin, D4_pin, D5_pin, D6_pin, D7_pin);\n  lcd.begin(20, 4);\n  //  lcd.setBacklightPin(BACKLIGHT_PIN, NEGATIVE);\n  lcd.setBacklightPin(BACKLIGHT_PIN, POSITIVE);\n  lcd.setBacklight(BL_ON);"
        },
        {
          "name": "display",
          "body": "lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"TEMP:\");\n  lcd.setCursor(6, 0);\n  lcd.print(DHT.getTemperature());\n\n  lcd.setCursor(0, 1);\n  lcd.print(\"HUM:\");\n  lcd.setCursor(6, 1);\n  lcd.print(DHT.getHumidity());\n\n  lcd.setCursor(0, 3);\n  lcd.print(\"TIME:\");\n  lcd.setCursor(6, 3);\n  lcd.print(stop - start);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  DHT.begin();    //  ESP32 default pins 21 22\n\n  setupDisplay();\n\n  delay(1000);"
        },
        {
          "name": "loop",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    //  READ DATA\n    start = micros();\n    int status = DHT.read();\n    stop = micros();\n\n    display();\n\n    if ((count % 10) == 0)\n    {\n      count = 0;\n      Serial.println();\n      Serial.println(\"Type\\tHumidity (%)\\tTemp (°C)\\tTime (µs)\\tStatus\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  Wire.setClock(400000);\n\n  DHT.begin();    //  ESP32 default pins 21 22\n\n  delay(1000);"
        },
        {
          "name": "loop",
          "body": "//  set an offset after 10 seconds.\n  if (millis() > 10000)\n  {\n    DHT.setTempOffset(1.7);\n    DHT.setHumOffset(-2.3);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Wire.begin();\n  DHT.begin();  //  ESP32 default pins 21 22\n\n  Serial.begin(115200);\n  Serial.println(\"Humidity, Temperature\");"
        },
        {
          "name": "loop",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    //  note no error checking\n    DHT.read();\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\", \");\n    Serial.println(DHT.getTemperature(), 1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  Wire.setClock(400000);\n\n  DHT.begin();    //  ESP32 default pins 21 22\n\n  delay(2000);"
        },
        {
          "name": "loop",
          "body": "int status = DHT.readStatus();\n  Serial.println(status);\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire1.begin(12, 13);  //  select your pin numbers here\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "body": "//  READ DATA\n  Serial.print(\"DHT20, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT20_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT20_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT20_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT20_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  case DHT20_ERROR_BYTES_ALL_ZERO:\n    Serial.print(\"All bytes read zero\");\n    break;\n  case DHT20_ERROR_READ_TIMEOUT:\n    Serial.print(\"Read time out\");\n    break;\n  case DHT20_ERROR_LASTREAD:\n    Serial.print(\"Error read too fast\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire1.setSDA(12);  //  select your pin numbers here\n  Wire1.setSCL(13);  //  select your pin numbers here\n  Wire1.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "body": "//  READ DATA\n  Serial.print(\"DHT20, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT20_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT20_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT20_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT20_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  case DHT20_ERROR_BYTES_ALL_ZERO:\n    Serial.print(\"All bytes read zero\");\n    break;\n  case DHT20_ERROR_READ_TIMEOUT:\n    Serial.print(\"Read time out\");\n    break;\n  case DHT20_ERROR_LASTREAD:\n    Serial.print(\"Error read too fast\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "triggerGetTemp",
          "body": "if (tempTaskHandle != NULL) {\n\t   xTaskResumeFromISR(tempTaskHandle);"
        },
        {
          "name": "tempTask",
          "body": "Serial.println(\"tempTask loop started\");\n\twhile (1) // tempTask loop\n  {\n    if (tasksEnabled) {\n      // Get temperature values\n\t\t\tgetTemperature();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println(\"DHT ESP32 example with tasks\");\n  initTemp();\n  // Signal end of setup() to tasks\n  tasksEnabled = true;"
        },
        {
          "name": "loop",
          "body": "if (!tasksEnabled) {\n    // Wait 2 seconds to let system settle down\n    delay(2000);\n    // Enable task that will read values from the DHT sensor\n    tasksEnabled = true;\n    if (tempTaskHandle != NULL) {\n\t\t\tvTaskResume(tempTaskHandle);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println(\"Status\\tHumidity (%)\\tTemperature (C)\\t(F)\\tHeatIndex (C)\\t(F)\");\n  String thisBoard= ARDUINO_BOARD;\n  Serial.println(thisBoard);\n\n  // Autodetect is not working reliable, don't use the following line\n  // dht.setup(17);\n  // use this instead: \n  dht.setup(17, DHTesp::DHT22); // Connect DHT sensor to GPIO 17"
        },
        {
          "name": "loop",
          "body": "delay(dht.getMinimumSamplingPeriod());\n\n  float humidity = dht.getHumidity();\n  float temperature = dht.getTemperature();\n\n  Serial.print(dht.getStatusString());\n  Serial.print(\"\\t\");\n  Serial.print(humidity, 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(temperature, 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(dht.toFahrenheit(temperature), 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(dht.computeHeatIndex(temperature, humidity, false), 1);\n  Serial.print(\"\\t\\t\");\n  Serial.println(dht.computeHeatIndex(dht.toFahrenheit(temperature), humidity, true), 1);\n  delay(2000);"
        }
      ]
    },
    {
      "name": "DHTPIN",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  dht.begin();\n\n  //Get IoTtweet Library version\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  //Connect WiFi\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");"
        },
        {
          "name": "loop",
          "body": "/* - DHT sensor reading - */\n  t = dht.readTemperature();\n  h = dht.readHumidity();\n\n  if (isnan(t) || isnan(h)) {\n    Serial.println(\"Failed to read from DHT sensor!\");\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "tempTask",
          "body": "Serial.println(\"tempTask loop started\");\n\twhile (1) // tempTask loop\n\t{\n\t\tif (tasksEnabled && !gotNewTemperature) { // Read temperature only if old data was processed already\n\t\t\t// Reading temperature for humidity takes about 250 milliseconds!\n\t\t\t// Sensor readings may also be up to 2 seconds 'old' (it's a very slow sensor)\n\t\t\tsensor1Data = dhtSensor1.getTempAndHumidity();\t// Read values from sensor 1\n\t\t\tsensor2Data = dhtSensor2.getTempAndHumidity();\t// Read values from sensor 1\n\t\t\tsensor3Data = dhtSensor3.getTempAndHumidity();\t// Read values from sensor 1\n\t\t\tgotNewTemperature = true;"
        },
        {
          "name": "triggerGetTemp",
          "body": "if (tempTaskHandle != NULL) {\n\t\t xTaskResumeFromISR(tempTaskHandle);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\tSerial.println(\"Example for 3 DHT11/22 sensors\");\n\n\t// Initialize temperature sensor 1\n\tdhtSensor1.setup(dhtPin1, DHTesp::DHT11);\n\t// Initialize temperature sensor 2\n\tdhtSensor2.setup(dhtPin2, DHTesp::DHT11);\n\t// Initialize temperature sensor 3\n\tdhtSensor3.setup(dhtPin3, DHTesp::DHT11);\n\n\t// Start task to get temperature\n\txTaskCreatePinnedToCore(\n\t\t\ttempTask,\t\t\t\t\t\t\t\t\t\t\t /* Function to implement the task */\n\t\t\t\"tempTask \",\t\t\t\t\t\t\t\t\t\t/* Name of the task */\n\t\t\t4000,\t\t\t\t\t\t\t\t\t\t\t\t\t /* Stack size in words */\n\t\t\tNULL,\t\t\t\t\t\t\t\t\t\t\t\t\t /* Task input parameter */\n\t\t\t5,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Priority of the task */\n\t\t\t&tempTaskHandle,\t\t\t\t\t\t\t\t/* Task handle. */\n\t\t\t1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t /* Core where the task should run */\n\n\tif (tempTaskHandle == NULL) {\n\t\tSerial.println(\"[ERROR] Failed to start task for temperature update\");"
        },
        {
          "name": "loop",
          "body": "if (gotNewTemperature) {\n\t\tSerial.println(\"Sensor 1 data:\");\n\t\tSerial.println(\"Temp: \" + String(sensor1Data.temperature,2) + \"'C Humidity: \" + String(sensor1Data.humidity,1) + \"%\");\n\t\tSerial.println(\"Sensor 2 data:\");\n\t\tSerial.println(\"Temp: \" + String(sensor2Data.temperature,2) + \"'C Humidity: \" + String(sensor2Data.humidity,1) + \"%\");\n\t\tSerial.println(\"Sensor 3 data:\");\n\t\tSerial.println(\"Temp: \" + String(sensor3Data.temperature,2) + \"'C Humidity: \" + String(sensor3Data.humidity,1) + \"%\");\n\t\tgotNewTemperature = false;"
        }
      ]
    },
    {
      "name": "DHTPIN",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_Sensor.h",
        "DHT.h",
        "DHT_U.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Initialize device.\n  dht.begin();\n  Serial.println(F(\"DHTxx Unified Sensor Example\"));\n  // Print temperature sensor details.\n  sensor_t sensor;\n  dht.temperature().getSensor(&sensor);\n  Serial.println(F(\"------------------------------------\"));\n  Serial.println(F(\"Temperature Sensor\"));\n  Serial.print  (F(\"Sensor Type: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"Unique ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Max Value:   \")); Serial.print(sensor.max_value); Serial.println(F(\"°C\"));\n  Serial.print  (F(\"Min Value:   \")); Serial.print(sensor.min_value); Serial.println(F(\"°C\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"°C\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Print humidity sensor details.\n  dht.humidity().getSensor(&sensor);\n  Serial.println(F(\"Humidity Sensor\"));\n  Serial.print  (F(\"Sensor Type: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"Unique ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Max Value:   \")); Serial.print(sensor.max_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Min Value:   \")); Serial.print(sensor.min_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"%\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Set delay between sensor readings based on sensor details.\n  delayMS = sensor.min_delay / 1000;"
        },
        {
          "name": "loop",
          "body": "// Delay between measurements.\n  delay(delayMS);\n  // Get temperature event and print its value.\n  sensors_event_t event;\n  dht.temperature().getEvent(&event);\n  if (isnan(event.temperature)) {\n    Serial.println(F(\"Error reading temperature!\"));"
        }
      ]
    },
    {
      "name": "DHTPIN",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Serial.println(F(\"DHTxx test!\"));\n\n  dht.begin();"
        },
        {
          "name": "loop",
          "body": "// Wait a few seconds between measurements.\n  delay(2000);\n\n  // Reading temperature or humidity takes about 250 milliseconds!\n  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)\n  float h = dht.readHumidity();\n  // Read temperature as Celsius (the default)\n  float t = dht.readTemperature();\n  // Read temperature as Fahrenheit (isFahrenheit = true)\n  float f = dht.readTemperature(true);\n\n  // Check if any reads failed and exit early (to try again).\n  if (isnan(h) || isnan(t) || isnan(f)) {\n    Serial.println(F(\"Failed to read from DHT sensor!\"));\n    return;"
        }
      ]
    },
    {
      "name": "USE_OD_MODE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "printId",
          "body": "Serial.print(id[0], HEX);\n    for (size_t i = 1; i < sizeof(OneWireNg::Id); i++) {\n        Serial.print(':');\n        Serial.print(id[i], HEX);"
        },
        {
          "name": "printMem",
          "body": "static const char HEX_DIGS[] = \"0123456789ABCDEF\";\n    uint8_t cmd[DS2431_MEM_SIZE + 3];\n\n    cmd[0] = CMD_READ_MEMORY;\n    /* start reading from 0x0000 */\n    cmd[1] = 0x00; /* TA1 (LSB) */\n    cmd[2] = 0x00; /* TA2 (MSB) */\n\n    /* read memory will be placed here */\n    uint8_t *mem = &cmd[3];\n    memset(mem, 0xff, DS2431_MEM_SIZE);\n\n    if (id) {\n        ow->addressSingle(*id);"
        },
        {
          "name": "setup",
          "body": "OneWireNg::Id id;\n\n    /* id of a DS2431 device for write demo;\n       if not set 1st available DS2431 device will be chosen */\n    OneWireNg::Id dev = {"
        },
        {
          "name": "loop",
          "body": "delay(1000);"
        }
      ]
    },
    {
      "name": "CLOCK_INTERRUPT_PIN",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "attachInterrupt"
      ],
      "libraries": [
        "RTClib.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n    // initializing the rtc\n    if(!rtc.begin()) {\n        Serial.println(\"Couldn't find RTC!\");\n        Serial.flush();\n        while (1) delay(10);"
        },
        {
          "name": "loop",
          "body": "// print current time\n    char date[10] = \"hh:mm:ss\";\n    rtc.now().toString(date);\n    Serial.print(date);\n\n    // the stored alarm value + mode\n    DateTime alarm1 = rtc.getAlarm1();\n    Ds3231Alarm1Mode alarm1mode = rtc.getAlarm1Mode();\n    char alarm1Date[12] = \"DD hh:mm:ss\";\n    alarm1.toString(alarm1Date);\n    Serial.print(\" [Alarm1: \");\n    Serial.print(alarm1Date);\n    Serial.print(\", Mode: \");\n    switch (alarm1mode) {\n      case DS3231_A1_PerSecond: Serial.print(\"PerSecond\"); break;\n      case DS3231_A1_Second: Serial.print(\"Second\"); break;\n      case DS3231_A1_Minute: Serial.print(\"Minute\"); break;\n      case DS3231_A1_Hour: Serial.print(\"Hour\"); break;\n      case DS3231_A1_Date: Serial.print(\"Date\"); break;\n      case DS3231_A1_Day: Serial.print(\"Day\"); break;"
        },
        {
          "name": "onAlarm",
          "body": "Serial.println(\"Alarm occured!\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Start the I2C interface\n\tWire.begin();\n\t// Start the serial interface\n\tSerial.begin(57600);"
        },
        {
          "name": "loop",
          "body": "for (j=0;j<4;j++) {\n\t\t// invert state of 32kHz oscillator.\n\t\ton = !on;\n\t\tmyRTC.enable32kHz(on);\n\t\t// Turn on oscillator pin, frequency j\n\t\tmyRTC.enableOscillator(true, false, j);\n\t\tdelay(4000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Start the serial port\n    Serial.begin(57600);\n    \n    // Start the I2C interface\n    Wire.begin();"
        },
        {
          "name": "loop",
          "body": "// If something is coming in on the serial line, it's\n    // a time correction so set the clock accordingly.\n    if (Serial.available()) {\n        getDateStuff(year, month, date, dOW, hour, minute, second);\n        \n        myRTC.setClockMode(false);  // set to 24h\n        //setClockMode(true); // set to 12h\n        \n        myRTC.setYear(year);\n        myRTC.setMonth(month);\n        myRTC.setDate(date);\n        myRTC.setDoW(dOW);\n        myRTC.setHour(hour);\n        myRTC.setMinute(minute);\n        myRTC.setSecond(second);\n        \n        // Test of alarm functions\n        // set A1 to one minute past the time we just set the clock\n        // on current day of week.\n        myRTC.setA1Time(dOW, hour, minute+1, second, 0x0, true,\n                        false, false);\n        // set A2 to two minutes past, on current day of month.\n        myRTC.setA2Time(date, hour, minute+2, 0x0, false, false,\n                        false);\n        // Turn on both alarms, with external interrupt\n        myRTC.turnOnAlarm(1);\n        myRTC.turnOnAlarm(2);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Start the I2C interface\n\tWire.begin();\n \n\t// Start the serial interface\n\tSerial.begin(57600);"
        },
        {
          "name": "loop",
          "body": "// send what's going on to the serial monitor.\n\t\n\t// Start with the year\n\tSerial.print(\"2\");\n\tif (century) {\t\t\t// Won't need this for 89 years.\n\t\tSerial.print(\"1\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "readSensor",
          "body": "// read the actual temperature after it's been converted\n    float temperature = sensor.getTempC(0);\n    // do what you need with the temperature here"
        },
        {
          "name": "startConversion",
          "body": "// start temperature conversion (does not block)\n    sensor.requestTemperatures();\n    // schedule reading the actual temperature in 750 milliseconds\n    tasker.setTimeout(readSensor, 750);"
        },
        {
          "name": "setup",
          "body": "sensor.begin();\n    // do not block during temperature conversion\n    sensor.setWaitForConversion(false);\n    // read temperature every 5 seconds\n    tasker.setInterval(startConversion, 5000);"
        },
        {
          "name": "loop",
          "body": "tasker.loop();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && !taskCompleted)\n  {\n\n    taskCompleted = true;\n\n    FirebaseJson json;\n\n    for (uint8_t i = 0; i < 30; i++)\n    {\n      json.set(\"Data1\", i + 1);\n      json.set(\"Data2\", i + 100);\n      Serial.printf(\"Push json... %s\\n\", Firebase.pushAsync(fbdo, \"/test/push\", json) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Nicla_System.h",
        "Arduino_BHY2.h",
        "PacketSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "nicla::begin();\n    nicla::leds.begin();\n    BHY2.begin();\n    accel.begin();\n\n    // Init the PacketSerial communication\n    myPacketSerial.begin(115200);\n    // Set the function for handling commands from the companion app\n    myPacketSerial.setPacketHandler(&onPacketReceived);\n\n    pinMode(LED_BUILTIN, OUTPUT);\n    for (auto i = 0u; i < 10; i++) {\n        nicla::leds.setColor(green);\n        delay(25);\n        nicla::leds.setColor(off);\n        delay(25);"
        },
        {
          "name": "loop",
          "body": "// Update communication-channel and sensors\n    myPacketSerial.update();\n    BHY2.update();\n\n    // Check for a receive buffer overflow (optional).\n    if (myPacketSerial.overflow()) {\n        for (auto i = 0u; i < 5; i++) {\n            nicla::leds.setColor(green);\n            delay(25);\n            nicla::leds.setColor(off);\n            delay(25);"
        },
        {
          "name": "onPacketReceived",
          "body": "uint8_t tempBuffer[size];\n\n    for (auto i = 0u; i < 2; i++) {\n        nicla::leds.setColor(green);\n        delay(25);\n        nicla::leds.setColor(off);\n        delay(25);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (Firebase.ready())\n    {\n        if (!indexing)\n        {\n            indexing = true;\n            Serial.print(\"Set query index in database rules... \");\n\n            // If sign in with OAuth2.0 token, the database secret pass to this function can be empty string\n            if (Firebase.setQueryIndex(fbdo, \"test/log\", \"ts\", DATABASE_SECRET))\n                Serial.println(\"ok\");\n            else\n                Serial.println(fbdo.errorReason());"
        }
      ]
    },
    {
      "name": "DATABASE_URL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(100);\n  Serial.println();\n\n  Serial.print(\"Connecting to Wi-Fi\");\n  int status = WL_IDLE_STATUS;\n  while (status != WL_CONNECTED)\n  {\n    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && !taskCompleted)\n  {\n    taskCompleted = true;\n\n    String rules;\n\n    Serial.printf(\"Get RTDB rules... %s\\n\", Firebase.getRules(fbdo) ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK)\n    {\n      FirebaseJson *json = fbdo.to<FirebaseJson *>();\n      json->toString(rules, true);\n      Serial.println(rules);\n      Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//init Ciao\n\tCiao.begin();\n\tSerial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "//Run commands in Linino OS to get date\n\tCiaoData data = Ciao.write(\"shell\",\"date\");\n\n\tif(!data.isEmpty()){\n\t\t//Get data back\n\t\tString usage = data.get(2);\n\t\tSerial.println(usage);"
        }
      ]
    },
    {
      "name": "INPUT_PIN_NUMBER",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  pinMode(INPUT_PIN_NUMBER, INPUT);\n  lastSwitchState = digitalRead(INPUT_PIN_NUMBER);\n\n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "body": "bool newSwitchState = digitalRead(INPUT_PIN_NUMBER);\n  \n  // if input state has changed\n  if(newSwitchState != lastSwitchState && WifiConnection::isConnected()) {\n    \n    // store the new state in the server\n    bool isOk = storage.put<bool>(\"switch_state\", newSwitchState);\n    \n    // Make sure `put` was successful\n    if(isOk) {\n      // save current time in the server in the key \"last_update_time\"\n      // `datetime` also returns the newly stored value \n      String time = storage.datetime(\"last_update_time\");\n      Serial.println(\"Last Update Time in the server now equals to: \");\n      Serial.println(time);"
        }
      ]
    },
    {
      "name": "BUTTON_PIN",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  pinMode(BUTTON_PIN, INPUT);"
        },
        {
          "name": "loop",
          "body": "t.handle();\n\n  if (digitalRead(BUTTON_PIN) == HIGH) {\n    if (timeoutId != 0)\n      t.reset(timeoutId);\n    else\n      timeoutId = t.setTimeout(\n          []() {\n            Serial.println(\"Button pressed!\");\n            timeoutId = 0;"
        }
      ]
    },
    {
      "name": "BUTTON_PIN_1",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  pinMode(BUTTON_PIN_1, INPUT_PULLUP);\n  pinMode(BUTTON_PIN_2, INPUT_PULLUP);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(5 * 1000);\n\n  score = storage.get<int>(\"counter\");"
        },
        {
          "name": "loop",
          "body": "if(WifiConnection::isConnected() == false) {\n    Serial.println(\"No Connection\");\n    return;"
        }
      ]
    },
    {
      "name": "AT_BAUD_RATE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFiEspAT.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(AT_BAUD_RATE);\n  WiFi.init(Serial1, ESP_RESET_PIN);\n\n  if (WiFi.status() == WL_NO_MODULE) {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Waiting for connection to WiFi\");\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print('.');"
        },
        {
          "name": "doSomething",
          "body": "Serial.println();\n  Serial.println(\"Starting connection to server...\");\n  if (client.connect(server, 80)) {\n    Serial.println(\"connected to server\");\n\n    client.println(\"GET /asciilogo.txt HTTP/1.1\");\n    client.print(\"Host: \");\n    client.println(server);\n    client.println(\"Connection: close\");\n    client.println();\n    client.flush();\n    while (client.connected()) {\n      while (client.available()) {\n        char c = client.read();\n        Serial.write(c);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    printResult(aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "WIFI_SSID1",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    wifimulti.addAP(WIFI_SSID1, WIFI_PASSWORD1);\n    wifimulti.addAP(WIFI_SSID2, WIFI_PASSWORD2);\n    wifimulti.addAP(WIFI_SSID3, WIFI_PASSWORD3);\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    printResult(aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Audio.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// allocate enough memory for the delay\n  AudioMemory(120);\n  \n  // configure a sine wave for the chirp\n  // the original is turned on/off by an envelope effect\n  // and output directly on the left channel\n  sine1.frequency(1000);\n  sine1.amplitude(0.5);\n\n  // create 3 delay taps, which connect through a\n  // mixer to the right channel output\n  delay1.delay(0, 110);\n  delay1.delay(1, 220);\n  delay1.delay(2, 330);"
        },
        {
          "name": "loop",
          "body": "envelope1.noteOn();\n  delay(36);\n  envelope1.noteOff();\n  delay(4000);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\r\n    Serial.println();\r\n    Serial.println();\r\n\r\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\r\n\r\n#if defined(ESP32) || defined(ESP8266)\r\n    WiFi.setAutoReconnect(true);\r\n#endif\r\n\r\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\r\n    GSheet.clearAP();\r\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\r\n    multi.run();\r\n#else\r\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\r\n#endif\r\n\r\n    Serial.print(\"Connecting to Wi-Fi\");\r\n    unsigned long ms = millis();\r\n    while (WiFi.status() != WL_CONNECTED)\r\n    {\r\n        Serial.print(\".\");\r\n        delay(300);\r\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\r\n        if (millis() - ms > 10000)\r\n            break;\r\n#endif"
        },
        {
          "name": "loop",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\r\n    bool ready = GSheet.ready();\r\n\r\n    if (ready && !taskComplete)\r\n    {\r\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\r\n\r\n        FirebaseJson response;\r\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\r\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\r\n\r\n        Serial.println(\"\\nDelete spreadsheet from Google Drive...\");\r\n        Serial.println(\"------------------------------------------------\");\r\n\r\n        bool success = GSheet.deleteFile(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to delete */);\r\n        response.toString(Serial, true);\r\n        Serial.println();\r\n\r\n        Serial.println(\"\\nDelete last 5 spreadsheets from Google Drive...\");\r\n        Serial.println(\"------------------------------------------------\");\r\n\r\n        success = GSheet.deleteFiles(&response /* returned response */);\r\n\r\n        if (success)\r\n            Serial.println(\"ok\");\r\n\r\n        taskComplete = true;"
        },
        {
          "name": "tokenStatusCallback",
          "body": "if (info.status == token_status_error)\r\n    {\r\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\r\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    app.loop();"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "IDLEFT",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "ReceiveEvent",
          "body": "Accessories::ReceiveEvent(inId, (ACCESSORIES_EVENT_TYPE)inEventType, inEventData);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\t//while (!Serial);\t\t// For Leonardo only. No effect on other Arduino.\n\n\tCommanders::begin(ReceiveEvent, LED_BUILTIN);\n\tAccessories::begin();\n\n\t// Commanders setup\n\n\tSerialCommander.begin();\n\tDccCommander.begin(0x00, 0x00, digitalPinToInterrupt(3));\n\n\t// Each button assigned to an accessory Dcc code.\n#ifdef VISUALSTUDIO\n\tpush0.begin(IDLEFT, '0');\n\tpush1.begin(IDRIGHT, '1');\n\tpush2.begin(IDDC, '2');\n\tpush3.begin(IDEPS, '3');\n\tpush4.begin(IDTJD, '4');\n\tpush5.begin(IDSERVOMIN, '5');\n\tpush6.begin(IDSERVOMAX, '6');\n\tpush7.begin(IDLIGHT, '7');\n#else\n\tpush0.begin(IDLEFT, 30);\n\tpush1.begin(IDRIGHT, 32);\n\tpush2.begin(IDDC, 34);\n\tpush3.begin(IDEPS, 36);\n\tpush4.begin(IDTJD, 38);\n\tpush5.begin(IDSERVOMIN, 40);\n\tpush6.begin(IDSERVOMAX, 42);\n\tpush7.begin(IDLIGHT, 44);\n#endif\n\t// Drivers setups\n\n\t// four turnouts are connected to the l293d shield.\n\t// l293d part\n\tPortLeft.begin(SHIELDL293D_PORT_M1, 200, MOTOR12_1KHZ);\n\tPortRight.begin(SHIELDL293D_PORT_M2, 200, MOTOR12_1KHZ);\n\tPortDc.begin(SHIELDL293D_PORT_M3, 200, MOTOR34_1KHZ);\n\tPortEps.begin(SHIELDL293D_PORT_M4, 200, MOTOR34_1KHZ);\n\tportServo.begin(SHIELDL293D_SERVO1_PIN);\n\n\t// l298n circuit.\n\tPortTjd.begin(50, 52, DIGITAL);\n\tPortLight.begin(46, 48, DIGITAL);\n\n\t// Accessories setups\n\n\t// Assign Dcc code for each accessory.\n\tturnoutLeft.begin(&PortLeft, IDLEFT, 50, 150);\n\tturnoutRight.begin(&PortRight, IDRIGHT, 3000, 150);\n\tturnoutDc.begin(&PortDc, IDDC, 500, 150);\n\tturnoutEps.begin(&PortEps, IDEPS, 3000, 150);\n\n\tturnoutTjd.begin(&PortTjd, IDTJD, 0, 150);\n\tlight.begin(&PortLight, IDLIGHT, 500, 150);\n\tservo.begin(&portServo, 1000, 40, 50, 2);\n\tservo.AddMinMaxMovingPositions(IDSERVOMIN, IDSERVOMAX);"
        },
        {
          "name": "loop",
          "body": "Accessories::loop();\n\n\tCommanders::loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  // this check is only needed on the Leonardo:\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "switch (Ethernet.maintain())\n  {\n    case 1:\n      //renewed fail\n      Serial.println(\"Error: renewed fail\");\n      break;\n\n    case 2:\n      //renewed success\n      Serial.println(\"Renewed success\");\n\n      //print your local IP address:\n      printIPAddress();\n      break;\n\n    case 3:\n      //rebind fail\n      Serial.println(\"Error: rebind fail\");\n      break;\n\n    case 4:\n      //rebind success\n      Serial.println(\"Rebind success\");\n\n      //print your local IP address:\n      printIPAddress();\n      break;\n\n    default:\n      //nothing happened\n      break;"
        },
        {
          "name": "printIPAddress",
          "body": "Serial.print(\"My IP address: \");\n  for (byte thisByte = 0; thisByte < 4; thisByte++) {\n    // print the value of each byte of the IP address:\n    Serial.print(Ethernet.localIP()[thisByte], DEC);\n    Serial.print(\".\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  // this check is only needed on the Leonardo:\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// wait for a new client:\n  EthernetClient client = server.available();\n\n  // when the client sends the first byte, say hello:\n  if (client) {\n    if (!gotAMessage) {\n      Serial.println(\"We have a new client\");\n      client.println(\"Hello, client!\");\n      gotAMessage = true;"
        }
      ]
    },
    {
      "name": "TINY_GSM_MODEM_SIM800",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h",
        "StreamDebugger.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // !!!!!!!!!!!\n  // Set your reset, enable, power pins here\n  // !!!!!!!!!!!\n\n  SerialMon.println(\"Wait...\");\n\n  // Set GSM module baud rate\n  TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n  // SerialAT.begin(9600);\n  delay(6000);"
        },
        {
          "name": "loop",
          "body": "// Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  SerialMon.print(\"Initializing modem...\");\n  if (!modem.restart()) {\n    // if (!modem.init()) {\n    SerialMon.println(F(\" [fail]\"));\n    SerialMon.println(F(\"************************\"));\n    SerialMon.println(F(\" Is your modem connected properly?\"));\n    SerialMon.println(F(\" Is your serial speed (baud rate) correct?\"));\n    SerialMon.println(F(\" Is your modem powered on?\"));\n    SerialMon.println(F(\" Do you use a good, stable power source?\"));\n    SerialMon.println(F(\" Try using File -> Examples -> TinyGSM -> tools -> \"\n                        \"AT_Debug to find correct configuration\"));\n    SerialMon.println(F(\"************************\"));\n    delay(10000);\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Audio.h",
        "Wire.h",
        "SPI.h",
        "SD.h",
        "SerialFlash.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(3);\n  \n  //while (!Serial) ;\n  //delay(100);\n  \n  // Configure the tone detectors with the frequency and number\n  // of cycles to match.  These numbers were picked for match\n  // times of approx 30 ms.  Longer times are more precise.\n  row1.frequency(697, 21);\n  row2.frequency(770, 23);\n  row3.frequency(852, 25);\n  row4.frequency(941, 28);\n  column1.frequency(1209, 36);\n  column2.frequency(1336, 40);\n  column3.frequency(1477, 44);\n  \n  // The 7 segment display is \"common anode), where the\n  // common pin connects to +3.3V.  LOW turns the LED on\n  // and HIGH turns the LED off.  If you use a common\n  // cathode display, you will need to change all the HIGH\n  // to LOW and LOW to HIGH.\n  pinMode(sevenseg_a, OUTPUT);\n  pinMode(sevenseg_b, OUTPUT);\n  pinMode(sevenseg_c, OUTPUT);\n  pinMode(sevenseg_d, OUTPUT);\n  pinMode(sevenseg_e, OUTPUT);\n  pinMode(sevenseg_f, OUTPUT);\n  pinMode(sevenseg_g, OUTPUT);\n  digitalWrite(sevenseg_a, HIGH);\n  digitalWrite(sevenseg_b, HIGH);\n  digitalWrite(sevenseg_c, HIGH);\n  digitalWrite(sevenseg_d, HIGH);\n  digitalWrite(sevenseg_e, HIGH);\n  digitalWrite(sevenseg_f, HIGH);\n  digitalWrite(sevenseg_g, HIGH);"
        },
        {
          "name": "loop",
          "body": "float r1, r2, r3, r4, c1, c2, c3;\n  char digit=0;\n\n  // read all seven tone detectors\n  r1 = row1.read();\n  r2 = row2.read();\n  r3 = row3.read();\n  r4 = row4.read();\n  c1 = column1.read();\n  c2 = column2.read();\n  c3 = column3.read();\n\n  // print the raw data, for troubleshooting\n  Serial.print(\"tones: \");\n  Serial.print(r1);\n  Serial.print(\", \");\n  Serial.print(r2);\n  Serial.print(\", \");\n  Serial.print(r3);\n  Serial.print(\", \");\n  Serial.print(r4);\n  Serial.print(\",   \");\n  Serial.print(c1);\n  Serial.print(\", \");\n  Serial.print(c2);\n  Serial.print(\", \");\n  Serial.print(c3);\n\n  // check all 12 combinations for key press\n  if (r1 >= row_threshold) {\n    if (c1 > column_threshold) {\n      digit = '1';\n      digitalWrite(sevenseg_a, HIGH);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, HIGH);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, HIGH);\n      digitalWrite(sevenseg_g, HIGH);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [
        "Audio.h",
        "Wire.h",
        "SPI.h",
        "SD.h",
        "SerialFlash.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(12);\n\n  // Enable the audio shield and set the output volume.\n  audioShield.enable();\n  audioShield.volume(0.5);\n  \n  while (!Serial) ;\n  delay(100);\n  \n  // Configure the tone detectors with the frequency and number\n  // of cycles to match.  These numbers were picked for match\n  // times of approx 30 ms.  Longer times are more precise.\n  row1.frequency(697, 21);\n  row2.frequency(770, 23);\n  row3.frequency(852, 25);\n  row4.frequency(941, 28);\n  column1.frequency(1209, 36);\n  column2.frequency(1336, 40);\n  column3.frequency(1477, 44);"
        },
        {
          "name": "loop",
          "body": "float r1, r2, r3, r4, c1, c2, c3;\n  char digit=0;\n\n  // read all seven tone detectors\n  r1 = row1.read();\n  r2 = row2.read();\n  r3 = row3.read();\n  r4 = row4.read();\n  c1 = column1.read();\n  c2 = column2.read();\n  c3 = column3.read();\n\n  // print the raw data, for troubleshooting\n  Serial.print(\"tones: \");\n  Serial.print(r1);\n  Serial.print(\", \");\n  Serial.print(r2);\n  Serial.print(\", \");\n  Serial.print(r3);\n  Serial.print(\", \");\n  Serial.print(r4);\n  Serial.print(\",   \");\n  Serial.print(c1);\n  Serial.print(\", \");\n  Serial.print(c2);\n  Serial.print(\", \");\n  Serial.print(c3);\n\n  // check all 12 combinations for key press\n  if (r1 >= row_threshold) {\n    if (c1 > column_threshold) {\n      digit = '1';"
        }
      ]
    },
    {
      "name": "BLYNK_NO_INFO",
      "keywords": [],
      "libraries": [
        "BlynkSimpleStream.h",
        "DigiCDC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Blynk will work through SerialUSB\n  // Do not read or write this serial manually in your sketch\n  SerialUSB.begin();\n  Blynk.begin(SerialUSB, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Oak has already configured WiFi\n  Blynk.config(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  //The loop starts only when the Serial Monitor is opened.\n  while(!Serial);\n  Wire.begin();\n\n  if (!digital_inputs.init()) {\n    Serial.println(\"Digital input GPIO expander initialization fail!!\");"
        },
        {
          "name": "loop",
          "body": "//Reads and Prints all channels (in a single operation)\n  readAll();\n\n  //Read one-by-one each channel and print them one-by-one\n  readings = digital_inputs.read(DIN_READ_CH_PIN_00);\n  Serial.println(\"CH00: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_01);\n  Serial.println(\"CH01: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_02);\n  Serial.println(\"CH02: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_03);\n  Serial.println(\"CH03: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_04);\n  Serial.println(\"CH04: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_05);\n  Serial.println(\"CH05: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_06);\n  Serial.println(\"CH06: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_07);\n  Serial.println(\"CH07: \"+String(readings));\n\n  Serial.println();\n\n  delay(250);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // The loop starts only when the Serial Monitor is opened.\n  while (!Serial);\n\n  //Set over current behavior of all channels to latch mode:\n  digital_outputs.setLatch();\n\n  // Uncomment this line to set over current behavior of all\n  // channels to auto retry mode instead of latch mode:\n  //digital_outputs.setRetry();\n  \n  //At startup set all channels to OPEN\n  digital_outputs.setAll(0);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"DIGITAL OUT:\");\n  \n  // Set all channels to CLOSED\n  digital_outputs.setAll(255);\n  Serial.print(\"All channels are CLOSED for 1 s...\");\n  delay(1000);\n  \n  // Set all channels to OPEN\n  digital_outputs.setAll(0);\n  Serial.println(\"now they are OPEN.\");\n  delay(1000);\n\n  // Toggle each channel for 1 s, one by one\n  \n  digital_outputs.set(0, HIGH);\n  Serial.print(\"CH0 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(0, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(1, HIGH);\n  Serial.print(\"CH1 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(1, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(2, HIGH);\n  Serial.print(\"CH2 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(2, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(3, HIGH);\n  Serial.print(\"CH3 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(3, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(4, HIGH);\n  Serial.print(\"CH4 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(4, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(5, HIGH);\n  Serial.print(\"CH5 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(5, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(6, HIGH);\n  Serial.print(\"CH6 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(6, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(7, HIGH);\n  Serial.print(\"CH7 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(7, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  Serial.println();\n  delay(1000);"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setupWiFi",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);"
        },
        {
          "name": "setupSinricPro",
          "body": "SinricProDimSwitch &myDimSwitch = SinricPro[DIMSWITCH_ID];\n\n  // set callback function to device\n  myDimSwitch.onPowerState(onPowerState);\n  myDimSwitch.onPowerLevel(onPowerLevel);\n  myDimSwitch.onAdjustPowerLevel(onAdjustPowerLevel);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting DimSwitch on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();"
        }
      ]
    },
    {
      "name": "SD_FAT_TYPE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "EthernetUdp.h",
        "ArduinoMDNS.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// NOTE: Alternatively, you can assign a fixed IP to configure your\n//       Ethernet shield.\n//       Ethernet.begin(mac, ip);   \n  Ethernet.begin(mac); \n  \n  // Initialize the mDNS library. You can now reach or ping this\n  // Arduino via the host name \"arduino.local\", provided that your operating\n  // system is mDNS/Bonjour-enabled (such as macOS).\n  // Always call this before any other method!\n  mdns.begin(Ethernet.localIP(), \"arduino\");\n\n  // We specify the function that the mDNS library will call when it\n  // discovers a service instance. In this case, we will call the function\n  // named \"serviceFound\".\n  mdns.setServiceFoundCallback(serviceFound);\n\n  Serial.begin(9600);\n  Serial.println(\"Enter a mDNS service name via the Arduino Serial Monitor \"\n                 \"to discover instances\");\n  Serial.println(\"on the network.\");\n  Serial.println(\"Examples are \\\"_http\\\", \\\"_afpovertcp\\\" or \\\"_ssh\\\" (Note \"\n                 \"the underscores).\");"
        },
        {
          "name": "loop",
          "body": "char serviceName[256];\n  int length = 0;\n  \n  // read in a service name from the Arduino IDE's Serial Monitor.\n  while (Serial.available()) {\n    serviceName[length] = Serial.read();\n    length = (length+1) % 256;\n    delay(5);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n  // Print a message to the LCD.\n  lcd.print(\"hello, world!\");"
        },
        {
          "name": "loop",
          "body": "// Turn off the display:\n  lcd.noDisplay();\n  delay(500);\n  // Turn on the display:\n  lcd.display();\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "INA.h",
        "avr/dtostrf.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "/*!\n   * @brief    Arduino method called once at startup to initialize the system\n   * @details  This is an Arduino IDE method which is called first upon boot or restart. It is only\n   *           called one time and then control goes to the \"loop()\" method, from which control\n   *           never returns. The serial port is initialized and the INA.begin() method called to\n   *           find all INA devices on the I2C bus and then the devices are initialized to given\n   *           conversion and averaging rates.\n   * @return   void\n   */\n  Serial.begin(SERIAL_SPEED);\n#ifdef __AVR_ATmega32U4__  // If a 32U4 processor, then wait 2 seconds to initialize\n  delay(2000);\n#endif\n  Serial.print(\"\\n\\nDisplay INA Readings V1.0.8\\n\");\n  Serial.print(\" - Searching & Initializing INA devices\\n\");\n  /************************************************************************************************\n  ** The INA.begin call initializes the device(s) found with an expected ±1 Amps maximum current **\n  ** and for a 0.1Ohm resistor, and since no specific device is given as the 3rd parameter all   **\n  ** devices are initially set to these values.                                                  **\n  ************************************************************************************************/\n  devicesFound = INA.begin(MAXIMUM_AMPS, SHUNT_MICRO_OHM);  // Expected max Amp & shunt resistance\n  while (devicesFound == 0) {\n    Serial.println(F(\"No INA device found, retrying in 10 seconds...\"));\n    delay(10000);                                             // Wait 10 seconds before retrying\n    devicesFound = INA.begin(MAXIMUM_AMPS, SHUNT_MICRO_OHM);  // Expected max Amp & shunt resistance"
        },
        {
          "name": "loop",
          "body": "/*!\n   * @brief    Arduino method for the main program loop\n   * @details  This is the main program for the Arduino IDE, it is an infinite loop and keeps on\n   * repeating. In order to format the output use is made of the \"sprintf()\" function, but in the\n   * Arduino implementation it has no support for floating point output, so the \"dtostrf()\" function\n   * is used to convert the floating point numbers into formatted strings.\n   * @return   void\n   */\n  static uint16_t loopCounter = 0;     // Count the number of iterations\n  static char     sprintfBuffer[100];  // Buffer to format output\n  static char     busChar[8], shuntChar[10], busMAChar[10], busMWChar[10];  // Output buffers\n\n  Serial.print(F(\"Nr Adr Type   Bus      Shunt       Bus         Bus\\n\"));\n  Serial.print(F(\"== === ====== ======== =========== =========== ===========\\n\"));\n  for (uint8_t i = 0; i < devicesFound; i++)  // Loop through all devices\n  {\n    dtostrf(INA.getBusMilliVolts(i) / 1000.0, 7, 4, busChar);      // Convert floating point to char\n    dtostrf(INA.getShuntMicroVolts(i) / 1000.0, 9, 4, shuntChar);  // Convert floating point to char\n    dtostrf(INA.getBusMicroAmps(i) / 1000.0, 9, 4, busMAChar);     // Convert floating point to char\n    dtostrf(INA.getBusMicroWatts(i) / 1000.0, 9, 4, busMWChar);    // Convert floating point to char\n    sprintf(sprintfBuffer, \"%2d %3d %s %sV %smV %smA %smW\\n\", i + 1, INA.getDeviceAddress(i),\n            INA.getDeviceName(i), busChar, shuntChar, busMAChar, busMWChar);\n    Serial.print(sprintfBuffer);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "MicroGamer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "mg.boot();\n  mg.clear();"
        },
        {
          "name": "loop",
          "body": "mg.setCursor(0, 0);\n  if ( ! mg.doubleBuffer()) {\n    mg.println(\"Some text that\");\n    mg.println(\"glitches\");\n    mg.println(\"because double buffer\");\n    mg.println(\"is not enabled\");\n    mg.println(\"===============\");"
        }
      ]
    },
    {
      "name": "MY_FS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FS.h",
        "SPIFFS.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\r\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\r\n\r\n    Serial.print(\"Connecting to Wi-Fi\");\r\n    while (WiFi.status() != WL_CONNECTED)\r\n    {\r\n        Serial.print(\".\");\r\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\r\n\r\n    cstorage.loop();\r\n\r\n    if (app.ready() && !taskCompleted)\r\n    {\r\n        taskCompleted = true;\r\n\r\n        Serial.println(\"Download object...\");\r\n\r\n        GoogleCloudStorage::GetOptions options;\r\n\r\n#if defined(ENABLE_FS)\r\n\r\n#if defined(SHOW_PROGRESS)\r\n        cstorage.download(aClient, GoogleCloudStorage::Parent(STORAGE_BUCKET_ID, \"media.mp4\"), getFile(media_file), options, aResult_no_callback);\r\n\r\n        for (;;)\r\n        {\r\n            printResult(aResult_no_callback);\r\n            if (aResult_no_callback.downloadInfo().total == aResult_no_callback.downloadInfo().downloaded || aResult_no_callback.error().code() > 0)\r\n                break;"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\r\n    unsigned long ms = millis();\r\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\r\n    {\r\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\r\n        // JWT is a static object of JWTClass and it's not thread safe.\r\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\r\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\r\n        JWT.loop(app.getAuth());\r\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\r\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\r\n    {\r\n\r\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\r\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\r\n        {\r\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\r\n    {\r\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        },
        {
          "name": "fileCallback",
          "body": "// FILE_OPEN_MODE_READ, FILE_OPEN_MODE_WRITE and FILE_OPEN_MODE_APPEND are defined in this library\r\n    // MY_FS is defined in this example\r\n    switch (mode)\r\n    {\r\n    case file_mode_open_read:\r\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_READ);\r\n        break;\r\n    case file_mode_open_write:\r\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_WRITE);\r\n        break;\r\n    case file_mode_open_append:\r\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_APPEND);\r\n        break;\r\n    case file_mode_remove:\r\n        MY_FS.remove(filename);\r\n        break;\r\n    default:\r\n        break;"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "rtdbDownloadCallback",
          "body": "if (info.status == firebase_rtdb_download_status_init)\n    {\n        Serial.printf(\"Downloading firmware file %s (%d)\\n\", info.remotePath.c_str(), info.size);"
        },
        {
          "name": "rtdbUploadCallback",
          "body": "if (info.status == firebase_rtdb_upload_status_init)\n    {\n        Serial.printf(\"Uploading firmware file %s (%d) to %s\\n\", info.localFileName.c_str(), info.size, info.remotePath.c_str());"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (Firebase.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        // Assume you use the following code to upload the firmware file stored on SD card to RTDB at path test/firmware/bin\n\n        /*\n        Serial.println(\"\\nUpload firmware to database...\\n\");\n        if (!Firebase.setFile(fbdo, StorageType::FLASH, \"test/firmware/bin\", \"<firmware.bin>\", rtdbUploadCallback))\n            Serial.println(fbdo.errorReason());\n        */\n\n        Serial.println(\"\\nDownload firmware file...\\n\");\n\n        // This function will allocate 16k+ memory for internal SSL client.\n        if (!Firebase.downloadOTA(fbdo, F(\"test/firmware/bin\"), rtdbDownloadCallback /* callback function */))\n            Serial.println(fbdo.errorReason());"
        }
      ]
    },
    {
      "name": "LGFX_AUTODETECT",
      "keywords": [],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "drawGrid",
          "body": "randomValues_t v;\n  auto cv = v.constValues;\n\n  float theta = ( M_PI / 180.0f ) * 22.5; // angle\n  float sin0 = sinf(theta);\n  float cos0 = cosf(theta);\n  float sin1 = sinf(M_PI-theta);\n  float cos1 = cosf(M_PI-theta);\n\n  for( int32_t y=-tft.height()*2; y<tft.height()*2; y+=8 ) {\n    int32_t x0Pos = -tft.width();\n    int32_t y0Pos = tft.height()-y;\n    int32_t x1Pos = tft.width();\n    int32_t y1Pos = tft.height()-y;\n    float x0 = (x0Pos * cos0 - y0Pos * sin0)+cv.middleX;\n    float y0 = (y0Pos * cos0 + x0Pos * sin0)+cv.middleY;\n    float x1 = (x1Pos * cos0 - y1Pos * sin0)+cv.middleX;\n    float y1 = (y1Pos * cos0 + x1Pos * sin0)+cv.middleY;\n    tft.drawWideLine( x0, y0, x1, y1, 0.5f, heatMapGradient ); // gradient antialiased"
        },
        {
          "name": "runRandomLinesDemo",
          "body": "for( int i=0;i<256;i++) {\n    randomValues_t v;\n    switch( i++%5 ) {\n      case 0: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.gradient888 );  break;\n      case 1: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.colorstart );   break;\n      case 2: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.color24start ); break;\n      case 3: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.color16start ); break;\n      case 4: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.color8start );  break;"
        },
        {
          "name": "runGradientDemo",
          "body": "drawGrid();\n\n  randomValues_t v;\n  auto cv = v.constValues;\n\n  const lgfx::rgb888_t colors888[] = { {0x00,0xff,0x00"
        },
        {
          "name": "setup",
          "body": "tft.init();\n  tft.fillScreen(TFT_WHITE);"
        },
        {
          "name": "loop",
          "body": "static bool toggler = true;\n  toggler = !toggler;\n  if( toggler ) {\n    runRandomLinesDemo();\n    vTaskDelay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "m1.led(1, 255, 0, 0); // Set LED color solid:red\n  m2.led(1, 0, 255, 0); // Set LED color solid:green\n  \n  m1.enable(); // Enable Motor Action\n  m2.enable();\n  m1.speedRpm(10);\n  m2.speedRpm(10);"
        },
        {
          "name": "loop",
          "body": "m1.moveByDistanceDegree(30);\n  m2.moveByDistanceDegree(-30);\n    \n  delay(3000);\n\n  m1.moveByDistanceDegree(-30);\n  m2.moveByDistanceDegree(30);\n  \n  delay(3000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initiate MIDI communications, listen to all channels\n    midiA.begin(MIDI_CHANNEL_OMNI);\n    midiB.begin(MIDI_CHANNEL_OMNI);"
        },
        {
          "name": "loop",
          "body": "if (midiA.read())\n    {\n        // Thru on A has already pushed the input message to out A.\n        // Forward the message to out B as well.\n        midiB.send(midiA.getType(),\n                   midiA.getData1(),\n                   midiA.getData2(),\n                   midiA.getChannel());"
        }
      ]
    },
    {
      "name": "DEFAULT_I2C_ADDR",
      "keywords": [
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "seesaw_neopixel.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  //while (!Serial) delay(10);   // wait until serial port is opened\n\n  Serial.println(F(\"Adafruit PID 5295 I2C QT Slide Potentiometer test!\"));\n\n  if (!seesaw1.begin(DEFAULT_I2C_ADDR) || !seesaw2.begin(DEFAULT_I2C_ADDR+1)) {\n    Serial.println(F(\"seesaws not found!\"));\n    while(1) delay(10);"
        },
        {
          "name": "loop",
          "body": "// read the potentiometer\n  uint16_t slide1_val = seesaw1.analogRead(ANALOGIN);\n  uint16_t slide2_val = seesaw2.analogRead(ANALOGIN);\n  Serial.print(slide1_val);\n  Serial.print(\", \");\n  Serial.println(slide2_val);\n\n  for (uint8_t i=0; i< pixels1.numPixels(); i++) {\n    pixels1.setPixelColor(i, Wheel(slide1_val / 4));\n    pixels2.setPixelColor(i, Wheel(slide2_val / 4));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "onUpdateCallback",
          "body": "Serial.print(F(\"DDNSGeneric - IP Change Detected: \"));\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "body": "// For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif  // #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000)\n\n  Serial.print(\"\\nStart DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n#if DDNS_USING_WIFI_AT\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if (ESP8266 || ESP32)\n  WiFi.mode(WIFI_STA);\n  \n#elif USE_WIFI_NINA\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DueFlashStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  byte b1 = 3;\n  uint8_t b2 = 1;\n  dueFlashStorage.write(0,b1);\n  dueFlashStorage.write(1,b2);\n  //dueFlashStorage.write(2,b2);"
        },
        {
          "name": "loop",
          "body": "// read from flash at address 0 and 1 and print them\n  Serial.print(\"0:\");\n  Serial.print(dueFlashStorage.read(0));\n  Serial.print(\" 1:\");\n  Serial.print(dueFlashStorage.read(1));  \n  \n  // read from address 2, increment it, print and then write incremented value back to flash storage\n  uint8_t i = dueFlashStorage.read(2)+1;\n  Serial.print(\" 2:\");\n  Serial.print(dueFlashStorage.read(2)); \n  dueFlashStorage.write(2,i);\n  \n  Serial.println();\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "DueFlashStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(500);\n\n  /* Flash is erased every time new code is uploaded. Write the default configuration to flash if first time */\n  // running for the first time?\n  uint8_t codeRunningForTheFirstTime = dueFlashStorage.read(0); // flash bytes will be 255 at first run\n  Serial.print(\"codeRunningForTheFirstTime: \");\n  if (codeRunningForTheFirstTime) {\n    Serial.println(\"yes\");\n    /* OK first time running, set defaults */\n    configuration.a = 1;\n    configuration.b = 0;\n    configuration.bigInteger = 1147483647; // my lucky number\n    configuration.message = \"Hello world!\";\n    configuration.c = 's';\n\n    // write configuration struct to flash at adress 4\n    byte b2[sizeof(Configuration)]; // create byte array to store the struct\n    memcpy(b2, &configuration, sizeof(Configuration)); // copy the struct to the byte array\n    dueFlashStorage.write(4, b2, sizeof(Configuration)); // write byte array to flash\n\n    // write 0 to address 0 to indicate that it is not the first time running anymore\n    dueFlashStorage.write(0, 0);"
        },
        {
          "name": "loop",
          "body": "/* read configuration struct from flash */\n  byte* b = dueFlashStorage.readAddress(4); // byte array which is read from flash at adress 4\n  Configuration configurationFromFlash; // create a temporary struct\n  memcpy(&configurationFromFlash, b, sizeof(Configuration)); // copy byte array to temporary struct\n\n  // print the content\n  Serial.print(\"a:\");\n  Serial.print(configurationFromFlash.a);\n\n  Serial.print(\" b:\");\n  Serial.print(configurationFromFlash.b);\n\n  Serial.print(\" bigInteger:\");\n  Serial.print(configurationFromFlash.bigInteger);\n\n  Serial.print(\" message:\");\n  Serial.print(configurationFromFlash.message);\n\n  Serial.print(\" c:\");\n  Serial.print(configurationFromFlash.c);\n  Serial.println();\n  Serial.println();\n\n  /* change some values in the struct and write them back */\n  // increment b by 1 (modulus 100 to start over at 0 when 100 is reached)\n  configurationFromFlash.b = (configurationFromFlash.b+1) % 100;\n\n  // change the message\n  String message = configurationFromFlash.message;\n  if (configurationFromFlash.message == \"Hello world!\")\n    configurationFromFlash.message = \"Hello Arduino Due!\";\n  else\n    configurationFromFlash.message = \"Hello world!\";\n\n  // write configuration struct to flash at adress 4\n  byte b2[sizeof(Configuration)]; // create byte array to store the struct\n  memcpy(b2, &configurationFromFlash, sizeof(Configuration)); // copy the struct to the byte array\n  dueFlashStorage.write(4, b2, sizeof(Configuration)); // write byte array to flash\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "IRsend.h",
        "IRrecv.h",
        "IRremoteESP8266.h",
        "IRutils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "irrecv.enableIRIn();  // Start up the IR receiver.\n  irsend.begin();       // Start up the IR sender.\n\n  Serial.begin(kBaudRate, SERIAL_8N1);\n  while (!Serial)  // Wait for the serial connection to be establised.\n    delay(50);\n  Serial.println();\n\n  Serial.print(\"DumbIRRepeater is now running and waiting for IR input \"\n               \"on Pin \");\n  Serial.println(kRecvPin);\n  Serial.print(\"and will retransmit it on Pin \");\n  Serial.println(kIrLedPin);"
        },
        {
          "name": "loop",
          "body": "// Check if an IR message has been received.\n  if (irrecv.decode(&results)) {  // We have captured something.\n    // The capture has stopped at this point.\n\n    // Convert the results into an array suitable for sendRaw().\n    // resultToRawArray() allocates the memory we need for the array.\n    uint16_t *raw_array = resultToRawArray(&results);\n    // Find out how many elements are in the array.\n    uint16_t length = getCorrectedRawLength(&results);\n    // Send it out via the IR LED circuit.\n    irsend.sendRaw(raw_array, length, kFrequency);\n    // Resume capturing IR messages. It was not restarted until after we sent\n    // the message so we didn't capture our own message.\n    irrecv.resume();\n    // Deallocate the memory allocated by resultToRawArray().\n    delete [] raw_array;\n\n    // Display a crude timestamp & notification.\n    uint32_t now = millis();\n    Serial.printf(\n        \"%06u.%03u: A message that was %d entries long was retransmitted.\\n\",\n        now / 1000, now % 1000, length);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "LoRa.h",
        "MKRWAN.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  // No need to call modem.dumb() with arduino-LoRa >= 0.5.0\n  //modem.dumb();\n\n  Serial.println(\"LoRa Sender\");\n\n  // Configure LoRa module to transmit and receive at 915 MHz (915*10^6) \n  // Replace 915E6 with the frequency you need (eg. 433E6 for 433 MHz)\n  if (!LoRa.begin(915E6)) {\n    Serial.println(\"Starting LoRa failed!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"Sending packet: \");\n  Serial.println(counter);\n\n  // send packet\n  LoRa.beginPacket();\n  LoRa.print(\"hello \");\n  LoRa.print(counter);\n  LoRa.endPacket();\n\n  counter++;\n\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  // wait for Serial Monitor to connect. Needed for native USB port boards only:\n  while (!Serial);\n\n  Serial.print(\"Initializing SD card...\");\n\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"initialization failed. Things to check:\");\n    Serial.println(\"1. is a card inserted?\");\n    Serial.println(\"2. is your wiring correct?\");\n    Serial.println(\"3. did you change the chipSelect pin to match your shield or module?\");\n    Serial.println(\"Note: press reset button on the board and reopen this Serial Monitor after fixing your issue!\");\n    while (true);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "attachInterrupt"
      ],
      "libraries": [
        "MAX3100Serial.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "serialEvent",
          "body": "internal = true;"
        },
        {
          "name": "max3100_irq",
          "body": "detachInterrupt(0);\n  external = true;"
        },
        {
          "name": "setup",
          "body": "// Arduino USART setup.\n  Serial.begin(internalBaud);\n\n  // Display USART header on Arduino.\n  Serial.println();\n  Serial.println(\"Maxim Integrated MAX3100 testing.\");\n  Serial.println(\"(C) 2016 Ewan Parker.\");\n  Serial.print(\">>> Internal Arduino USART :: \");\n  Serial.print(internalBaud); Serial.println(\" bps <<<\");\n  Serial.println();\n\n  // MAX3100 USART setup.\n  serial2.begin(externalBaud);\n  // Disable MAX3100 interrupt processing while in SPI communications.\n  SPI.usingInterrupt(0);\n  // Attach an interrupt so we know when we have received input from the\n  // external USART.  Without this we would need to continually poll to see if\n  // a byte was available.\n  attachInterrupt(0, max3100_irq, LOW);\n\n  // Display USART header on MAX3100.\n  serial2.println(\"Maxim Integrated MAX3100 testing.\");\n  serial2.println(\"(C) 2016 Ewan Parker.\");\n  serial2.print(\">>> External MAX3100CPD USART :: \");\n  serial2.print(externalBaud); serial2.println(\" bps <<<\");\n  serial2.println();"
        },
        {
          "name": "loop",
          "body": "// Incoming character from the Arduino's USART.\n  if (internal)\n  {\n    internal = false;\n    char c = Serial.read(); // Read the character from the Arduino\n    serial2.write(c);       // and write it to the MAX3100"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting DweetGet on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// send the GET request\n  Serial.println(\"Making GET request\");\n  httpClient.get(path);\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  /*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n  \n  Serial.print(\"\\nStarting DweetGet_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "body": "// assemble the path for the GET message:\n  String path = \"/get/latest/dweet/for/\" + dweetName;\n\n  // send the GET request\n  Serial.println(\"Making GET request\");\n  httpClient.get(path);\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  /*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting DweetPost on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// assemble the body of the POST message:\n  int sensorValue = analogRead(A0);\n\n  String postData = \"{\\\"sensorValue\\\":\\\"\";\n  postData += sensorValue;\n  postData += \"\\\""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStarting DweetPost_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "body": "// assemble the path for the POST message:\n  String dweetName = \"scandalous-cheese-hoarder\";\n  String path = \"/dweet/for/\" + dweetName;\n  String contentType = \"application/json\";\n\n  // assemble the body of the POST message:\n  int sensorValue = analogRead(A0);\n  String postData = \"{\\\"sensorValue\\\":\\\"\"; \n  postData += sensorValue;\n  postData += \"\\\""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "onUpdateCallback",
          "body": "Serial.print(F(\"DDNSGeneric - IP Change Detected: \"));\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "body": "// For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif  // #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000)\n\n  Serial.print(\"\\nStart DynDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n#if DDNS_USING_WIFI_AT\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if (ESP8266 || ESP32)\n  WiFi.mode(WIFI_STA);\n  \n#elif USE_WIFI_NINA\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "ctype.h",
        "Keypad.h",
        "ctype.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    pinMode(ledPin, OUTPUT);\n    digitalWrite(ledPin, LOW);                 // Turns the LED on.\n    ltrpad.begin( makeKeymap(alphaKeys) );\n    numpad.begin( makeKeymap(numberKeys) );\n    ltrpad.addEventListener(keypadEvent_ltr);  // Add an event listener.\n    ltrpad.setHoldTime(500);                   // Default is 1000mS\n    numpad.addEventListener(keypadEvent_num);  // Add an event listener.\n    numpad.setHoldTime(500);                   // Default is 1000mS"
        },
        {
          "name": "loop",
          "body": "if( alpha )\n        key = ltrpad.getKey( );\n    else\n        key = numpad.getKey( );\n\n    if (alpha && millis()-startTime>100) {           // Flash the LED if we are using the letter keymap.\n        digitalWrite(ledPin,!digitalRead(ledPin));\n        startTime = millis();"
        },
        {
          "name": "keypadEvent_ltr",
          "body": "// in here when in alpha mode.\n    kpadState = ltrpad.getState( );\n    swOnState( key );"
        },
        {
          "name": "keypadEvent_num",
          "body": "// in here when using number keypad\n    kpadState = numpad.getState( );\n    swOnState( key );"
        },
        {
          "name": "swOnState",
          "body": "switch( kpadState ) {\n        case PRESSED:\n            if (isalpha(key)) {              // This is a letter key so we're using the letter keymap.\n                if (physKey != key) {        // New key so start with the first of 3 characters.\n                    pressCount = 0;\n                    virtKey = key;\n                    physKey = key;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "onUpdateCallback",
          "body": "Serial.print(\"DDNSGeneric - IP Change Detected: \");\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "body": "// For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif  // #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000)\n\n  Serial.print(\"\\nStart Dynu_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n#if DDNS_USING_WIFI_AT\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if (ESP8266 || ESP32)\n  WiFi.mode(WIFI_STA);\n  \n#elif USE_WIFI_NINA\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoECCX08.h",
        "utility/ECCX08CSR.h",
        "utility/ECCX08DefaultTLSConfig.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"Failed to communicate with ECC508/ECC608!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (!ECCX08.readCounter(keyId, counter)) {\n    Serial.println(\"Failed to read counter\");\n    while (1);"
        }
      ]
    },
    {
      "name": "TEMPKEY_SLOT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    while (!Serial);\n\n    if (!ECCX08.begin()) {\n        Serial.println(\"Failed to initialize ECCX08 board.\");\n        while (1);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoECCX08.h",
        "utility/ECCX08JWS.h",
        "utility/ECCX08DefaultTLSConfig.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"Failed to communicate with ECC508/ECC608!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"Random number = \");\n  Serial.println(ECCX08.random(65535));\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "utility/ECCX08DefaultTLSConfig.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  Serial.println(\"ECCX08 Signing\");\n  Serial.println();\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"Failed to communicate with ECC508/ECC608!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// do nothing"
        },
        {
          "name": "printBufferHex",
          "body": "for (int i = 0; i < inputLength; i++) {\n    Serial.print(input[i] >> 4, HEX);\n    Serial.print(input[i] & 0x0f, HEX);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "uint8_t eepromval;\n  \n  Serial.begin(115200);\n  \n  while (!Serial) delay(10);   // wait until serial port is opened\n  \n  if(!ss.begin()){\n    Serial.println(F(\"seesaw not found!\"));\n    while(1) delay(10);"
        },
        {
          "name": "loop",
          "body": "//DONT WRITE EEPROM IN A LOOP!!!! YOU WILL DESTROY YOUR FLASH!!!"
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_CRC on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  //Print length of data to run CRC on.\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  //Print the result of calling eeprom_crc()\n  Serial.print(\"CRC32 of EEPROM data: 0x\");\n  Serial.println(eeprom_crc(), HEX);\n  Serial.print(\"Done!\");"
        },
        {
          "name": "loop",
          "body": "/* Empty loop */"
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_Clear on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n  \n  // initialize the LED pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  Serial.print(\"Emulated EEPROM length (bytes) = \"); Serial.println(EEPROM.length());\n\n  unsigned long startMillis = millis();\n  \n  for (int i = 0 ; i < EEPROM.length() ; i++) \n  {\n    EEPROM.write(i, 0);"
        },
        {
          "name": "loop",
          "body": "/** Empty loop. **/"
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "printMyObject",
          "body": "Serial.println(\"===============\");\n  Serial.print(\"Field1: \"); Serial.println(customVar.field1, 5);\n  Serial.print(\"Field2: \"); Serial.println(customVar.field2);\n  Serial.print(\"Name: \"); Serial.println(customVar.name);\n  Serial.println(\"===============\");"
        },
        {
          "name": "secondTest",
          "body": "int eeAddress = START_ADDRESS + sizeof(WRITTEN_SIGNATURE) + sizeof(float); //Move address to the next byte after float 'f'.\n\n  MyObject customVar; //Variable to store custom object read from EEPROM.\n  EEPROM.get(eeAddress, customVar);\n\n  Serial.println(\"Read custom object from EEPROM: \");\n  printMyObject(customVar);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_get on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  // Check signature at address 0\n  int signature;\n\n  float f;\n  int eeAddress;\n\n  EEPROM.get(START_ADDRESS, signature);\n\n  // If the EEPROM doesn't store valid data, then no WRITTEN_SIGNATURE\n  if (signature != WRITTEN_SIGNATURE)\n  {\n    Serial.println(\"EEPROM doesn't store valid data, writing WRITTEN_SIGNATURE and some example data\");\n\n    EEPROM.put(START_ADDRESS, WRITTEN_SIGNATURE);\n\n    f = 123.456f;  //Variable to store in EEPROM.\n    eeAddress = START_ADDRESS + sizeof(WRITTEN_SIGNATURE);   //Location we want the data to be put.\n\n    //One simple call, with the address first and the object second.\n    EEPROM.put(eeAddress, f);\n\n    Serial.print(\"Float written to EEPROM: \");\n    Serial.println(f, 3);\n\n    /** Put is designed for use with custom structures also. **/\n\n    //Data to store.\n    MyObject customVar =\n    {\n      3.14159f,\n      65,\n      \"Working!\""
        },
        {
          "name": "loop",
          "body": "/* Empty loop */"
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_iteration on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  /***\n    Iterate the EEPROM using a for loop.\n  ***/\n\n  for (int index = 0 ; index < EEPROM.length() ; index++) \n  {\n    // Add one to each cell in the EEPROM   \n    EEPROM.write(index, EEPROM.read(index) + 1);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "printMyObject",
          "body": "Serial.println(\"===============\");\n  Serial.print(\"Field1: \"); Serial.println(customVar.field1, 5);\n  Serial.print(\"Field2: \"); Serial.println(customVar.field2);\n  Serial.print(\"Name: \"); Serial.println(customVar.name);\n  Serial.println(\"===============\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_put on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  float f = 123.456f;  //Variable to store in EEPROM.\n  int eeAddress = START_ADDRESS + sizeof(WRITTEN_SIGNATURE);   //Location we want the data to be put.\n\n  //One simple call, with the address first and the object second.\n  EEPROM.put(eeAddress, f);\n\n  Serial.print(\"Float written to EEPROM: \");\n  Serial.println(f, 3);\n\n  /** Put is designed for use with custom structures also. **/\n\n  //Data to store.\n  MyObject customVar =\n  {\n    3.14159f,\n    65,\n    \"Working!\""
        },
        {
          "name": "loop",
          "body": "/* Empty loop */"
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_read on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());"
        },
        {
          "name": "loop",
          "body": "// read a byte from the current address of the EEPROM\n  value = EEPROM.read(address);\n\n  Serial.print(address);\n  Serial.print(\"\\t\");\n  Serial.print(value, DEC);\n  Serial.println();\n \n  if (++address == EEPROM.length()) \n  {\n    address = 0;"
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_read on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());"
        },
        {
          "name": "loop",
          "body": "unsigned long startMillis = millis();\n  \n  for (int i = 0 ; i < EEPROM.length() ; i++) \n  {\n    /***\n      The function EEPROM.update(address, val) is equivalent to the following:\n  \n      if( EEPROM.read(address) != val )\n      {\n        EEPROM.write(address, val);"
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_write on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());"
        },
        {
          "name": "loop",
          "body": "unsigned long startMillis = millis();\n  \n  for (int i = 0 ; i < EEPROM.length() ; i++) \n  {\n    /***\n      The function EEPROM.update(address, val) is equivalent to the following:\n  \n      if( EEPROM.read(address) != val )\n      {\n        EEPROM.write(address, val);"
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  //while(!Serial);           // Wait for Serial Monitor before continuing\n\n  display.begin();\n\n#if defined(FLEXIBLE_213) || defined(FLEXIBLE_290)\n  // The flexible displays have different buffers and invert settings!\n  display.setBlackBuffer(1, false);\n  display.setColorBuffer(1, false);\n#endif\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) {     // For each of 4 rotations...\n    display.setRotation(r);    // Set rotation\n    display.fillScreen(0);     // and clear screen\n    display.clearBuffer();\n    img.draw(display, 0, 0);\n    display.display();\n    delay(30 * 1000); // Pause 30 sec."
        }
      ]
    },
    {
      "name": "USE_SD_CARD",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  //while(!Serial);           // Wait for Serial Monitor before continuing\n\n  display.begin();\n\n#if defined(FLEXIBLE_213) || defined(FLEXIBLE_290)\n  // The flexible displays have different buffers and invert settings!\n  display.setBlackBuffer(1, false);\n  display.setColorBuffer(1, false);\n#endif\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    display.setRotation(r);    // Set rotation\n    display.fillScreen(0);     // and clear screen\n    display.clearBuffer();\n    img.draw(display, 0, 0);\n    display.display();\n    delay(30 * 1000); // Pause 30 sec."
        }
      ]
    },
    {
      "name": "EPD_CS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(115200);\n  //while(!Serial) delay(10);           // Wait for Serial Monitor before continuing\n\n  display.begin(THINKINK_TRICOLOR);\n  display.setRotation(3);  \n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    errorEPD(\"Flash begin() failed\");"
        },
        {
          "name": "loop",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    display.setRotation(r);    // Set rotation\n    display.fillScreen(0);     // and clear screen\n    display.clearBuffer();\n    img.draw(display, 0, 0);\n    display.display();\n    delay(30 * 1000); // Pause 30 sec."
        },
        {
          "name": "errorEPD",
          "body": "display.fillScreen(0);     // clear screen\n  display.clearBuffer();\n  display.setTextSize(2);\n  display.setCursor(10, 10);\n  display.setTextColor(EPD_BLACK);\n  display.print(errormsg); \n  display.display();\n\n  while (1) {\n    delay(10);"
        }
      ]
    },
    {
      "name": "SD_CS",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "SdFat.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  //while(!Serial);           // Wait for Serial Monitor before continuing\n\n  display.begin();\n  display.clearBuffer();\n /*\n  Serial.print(\"Initializing filesystem...\");\n  display.setTextSize(3);\n  display.setCursor(10,10);\n  display.setTextColor(EPD_BLACK);\n  display.print(\"SD Card...\");\n  */\n  display.display();\n\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    display.println(\"failed!\");\n    display.display();\n    for(;;); // Fatal error, do not continue"
        },
        {
          "name": "loop",
          "body": "char selected_file[80] = {0"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "EthernetENC.h",
        "BlynkSimpleEthernetENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n#if USE_BLYNK_WM\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart ENC28J60_Blynk using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart ENC28J60_Blynk on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Serial.println(\"\\nStart ENC28J60_Blynk, no WM, on \" + String(BOARD_TYPE) + String(\" using Local Server\"));\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Serial.println(\"\\nStart ENC28J60_Blynk, no WM, on \" + String(BOARD_TYPE) + String(\" using Cloud Server\"));\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n    Serial.print(F(\"Local IP = \"));       \n    Serial.println(Ethernet.localIP());\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BUTTON_PIN",
      "keywords": [
        "Serial",
        "delay",
        "attachInterrupt"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "body": "//isButtonPressed = !digitalRead(BUTTON_PIN); // Invert state, since button is \"Active LOW\"\n\n  if ( !isButtonPressed && !digitalRead(BUTTON_PIN)) // You can write any condition to trigger e-mail sending\n  {\n    isButtonPressed = true;\n    count++;\n    Serial.println(\"Button pressed\");"
        },
        {
          "name": "processButton",
          "body": "// *** WARNING: You are limited to send ONLY ONE E-MAIL PER 5 SECONDS! ***\n  // Let's send an e-mail when you press the button\n  // connected to digital pin BUTTON_PIN (2) on your Arduino\n  static String body;\n\n  if (isButtonPressed) // You can write any condition to trigger e-mail sending\n  {\n    body = String(\"You pushed the button \") + count + \" times.\";\n\n    // This can be seen in the Serial Monitor\n    Serial.println(body);\n\n    Blynk.email(\"your_email@gmail.com\", \"Subject: Button Logger\", body);\n\n    isButtonPressed = false;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n#if USE_BLYNK_WM\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart ENC28J60_Blynk_Email using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart ENC28J60_Blynk_Email on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Serial.println(\"\\nStart ENC28J60_Blynk_Email, no WM, on \" + String(BOARD_TYPE) + String(\" using Local Server\"));\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Serial.println(\"\\nStart ENC28J60_Blynk_Email, no WM, on \" + String(BOARD_TYPE) + String(\" using Cloud Server\"));\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = 25.0;\n  float humidity    = 50.0;\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if USE_BLYNK_WM\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart ENC28J60_WM_Config using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart ENC28J60_WM_Config on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Serial.println(\"\\nStart ENC28J60_WM_Config, no WM, on \" + String(BOARD_TYPE) + String(\" using Local Server\"));\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Serial.println(\"\\nStart ENC28J60_WM_Config, no WM, on \" + String(BOARD_TYPE) + String(\" using Cloud Server\"));\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "LGFX_M5PAPER",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "M5EPD.h",
        "M5CoreInk.h",
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// M5.begin();\n\n  gfx.init();   // 初期化を行います。LCDもEPDも共通です。\n\n  gfx.setRotation(0);  // 回転方向の設定はLCDもEPDも共通です。0～3で右回りに90度ずつ回転します。4～7は上下反転になります。\n\n  w = gfx.width();\n  h = gfx.height();\n\n  gfx.setBrightness(128); // バックライトの輝度設定はEPDでは効果を持ちません。\n\n// EPDの動作モードを設定できます。描画用途に応じて 都度、変更してください。\n// ※ M5Stack CoreInk では epd_quality以外は差はありません。\n  gfx.setEpdMode(epd_mode_t::epd_fastest);  // 最速更新、白黒反転なし、残像が残りやすい\n  gfx.setEpdMode(epd_mode_t::epd_fast);     // 高速更新、白黒反転なし、残像が残りやすい\n  gfx.setEpdMode(epd_mode_t::epd_text);     // 高品質更新、白黒反転が一瞬起きる（白背景用）\n  gfx.setEpdMode(epd_mode_t::epd_quality);  // 高品質更新、白黒反転が一瞬起きる\n\n// M5Paper (IT8951)での各モードの特徴は以下の通りです。\n// epd_fastest = DU4  更新時間 120msec  完全な白と黒のみ描画でき、中間階調は描画されない。また、中間階調で表示されている箇所を更新できない。\n// epd_fast    = DU   更新時間 260msec  完全な白と黒のみ描画でき、中間階調は描画されない。\n// epd_text    = GL16 更新時間 450msec  グレースケール16階調で描画できる。白背景・黒文字 用途\n// epd_quality = GC16 更新時間 450msec  グレースケール16階調で描画できる。画像用途\n\n\n// 描画関数はすべてLCDと同様に利用可能です。\n// 色指定もLCDと同様に指定できますが、自動的にグレースケールに変換されます。\n// （グレースケール変換時の比率は R1:G2:B1 です。緑色がやや明るく表現されます。）\n\n  int rectwidth = std::min(w, h) / 2;\n  gfx.fillTriangle( w / 2, 0, 0, h - 1, w - 1, h - 1, TFT_RED);\n  gfx.fillCircle(w/2, h/2, rectwidth, TFT_GREEN);\n  gfx.fillRect((w-rectwidth)/2, (h-rectwidth)/2, rectwidth, rectwidth, TFT_BLUE);\n\n  delay(3000);\n\n\n// 描画処理をstartWrite/endWriteで囲むと、endWrite() のタイミングでまとめて画面に反映できます。\n// または、display() を呼んだ時点でも画面に反映できます。\n\n  gfx.startWrite(); // 描画内容の即時反映を抑止。\n\n  for (int i = 0; i < 20; ++i)\n  {\n    gfx.drawLine(i * w / 20, 0, w - 1, i * h / 20, TFT_BLACK);  // この時点では画面に反映されない。\n    gfx.drawLine(0, i * h / 20, i * w / 20, h - 1, TFT_BLACK);"
        },
        {
          "name": "loop",
          "body": "static int count = 0;\n\n  if (0 == (count & 15))\n  {\n    switch ((count >> 4) & 3)\n    {\n    case 0:  gfx.setEpdMode(epd_mode_t::epd_quality);  break;\n    case 1:  gfx.setEpdMode(epd_mode_t::epd_text   );  break;\n    case 2:  gfx.setEpdMode(epd_mode_t::epd_fast   );  break;\n    case 3:  gfx.setEpdMode(epd_mode_t::epd_fastest);  break;"
        }
      ]
    },
    {
      "name": "EPD_DC",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  // while (!Serial) { delay(10);"
        },
        {
          "name": "loop",
          "body": "// don't do anything!"
        },
        {
          "name": "testdrawtext",
          "body": "display.setCursor(0, 0);\n  display.setTextColor(color);\n  display.setTextWrap(true);\n  display.print(text);"
        }
      ]
    },
    {
      "name": "CAMERA_MODEL_WROVER_KIT",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "body": "Serial.println(\"handleNewMessages\");\n  Serial.println(String(numNewMessages));\n\n  for (int i = 0; i < numNewMessages; i++)\n  {\n    String chat_id = String(bot.messages[i].chat_id);\n    String text = bot.messages[i].text;\n\n    String from_name = bot.messages[i].from_name;\n    if (from_name == \"\")\n      from_name = \"Guest\";\n\n    if (text == \"/flash\")\n    {\n      flashState = !flashState;\n      digitalWrite(FLASH_LED_PIN, flashState);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  pinMode(FLASH_LED_PIN, OUTPUT);\n  digitalWrite(FLASH_LED_PIN, flashState); //defaults to low\n\n  if (!setupCamera())\n  {\n    Serial.println(\"Camera Setup Failed!\");\n    while (true)\n    {\n      delay(100);"
        },
        {
          "name": "loop",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);"
        }
      ]
    },
    {
      "name": "PROJECT_ID",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "ESP_Google_Sheet_Client.h"
      ],
      "functions": [
        {
          "name": "WiFiEvent",
          "body": "// Do not run any function here to prevent stack overflow or nested interrupt\n\n#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)\n\n    switch (event)\n    {\n    case ARDUINO_EVENT_ETH_START:\n        Serial.println(\"ETH Started\");\n        // set eth hostname here\n        ETH.setHostname(\"esp32-ethernet\");\n        break;\n    case ARDUINO_EVENT_ETH_CONNECTED:\n        Serial.println(\"ETH Connected\");\n        break;\n    case ARDUINO_EVENT_ETH_GOT_IP:\n        Serial.print(\"ETH MAC: \");\n        Serial.print(ETH.macAddress());\n        Serial.print(\", IPv4: \");\n        Serial.print(ETH.localIP());\n        if (ETH.fullDuplex())\n        {\n            Serial.print(\", FULL_DUPLEX\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32)\n    WiFi.onEvent(WiFiEvent);\n    ETH.begin(ETH_ADDR, ETH_POWER_PIN, ETH_MDC_PIN, ETH_MDIO_PIN, ETH_TYPE, ETH_CLK_MODE);\n#endif"
        },
        {
          "name": "loop",
          "body": "#if defined(ESP32)\n\n    if (eth_connected)\n    {\n        if (!gsheetSetupReady)\n            setupGsheet();\n\n        bool ready = GSheet.ready();\n\n        if (ready && !taskComplete)\n        {\n\n            // Google sheet code here\n\n            taskComplete = true;"
        },
        {
          "name": "setupGsheet",
          "body": "// Set the callback for Google API access token generation status (for debug only)\n    GSheet.setTokenCallback(tokenStatusCallback);\n\n    // Set the seconds to refresh the auth token before expire (60 to 3540, default is 300 seconds)\n    GSheet.setPrerefreshSeconds(10 * 60);\n\n    // Begin the access token generation for Google API authentication\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n    gsheetSetupReady = true;"
        },
        {
          "name": "tokenStatusCallback",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP32AnalogRead.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "adc.attach(33);\n\tSerial.begin(115200);"
        },
        {
          "name": "loop",
          "body": "delay(50);\n\tSerial.println(\"Voltage = \"+String(adc.readVoltage()));"
        }
      ]
    },
    {
      "name": "DEBUG",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPAutoWiFiConfig.h",
        "WiFi.h",
        "WiFiClient.h",
        "WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// setup code that must be run every time\n#ifdef DEBUG\n  Serial.begin(115200);\n  Serial.println();\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "//  .. other code that MUST run all the time\n  if (ESPAutoWiFiConfigLoop()) {  // handle WiFi config webpages\n    return;  // skip the rest of the loop until config finished"
        },
        {
          "name": "notFound",
          "body": "server.send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "handleRoot",
          "body": "server.send(200, \"text/plain\", \"hello from esp8266!\\r\\n\");"
        },
        {
          "name": "startWebServer",
          "body": "server.on(\"/\", handleRoot);\n  server.onNotFound(notFound);\n  server.begin();"
        }
      ]
    },
    {
      "name": "DEBUG",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPAutoWiFiConfig.h",
        "WiFi.h",
        "WiFiClient.h",
        "WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// setup code that must be run every time\n#ifdef DEBUG\n  Serial.begin(115200);\n  Serial.println();\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "//  .. other code that MUST run all the time\n  if (ESPAutoWiFiConfigLoop()) {  // handle WiFi config webpages\n    return;  // skip the rest of the loop until config finished"
        },
        {
          "name": "notFound",
          "body": "server.send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "handleRoot",
          "body": "server.send(200, \"text/plain\", \"hello from esp8266!\\r\\n\");"
        },
        {
          "name": "startWebServer",
          "body": "server.on(\"/\", handleRoot);\n  server.onNotFound(notFound);\n  server.begin();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SafeString.h",
        "loopTimer.h",
        "BufferedOutput.h",
        "millisDelay.h",
        "SafeStringReader.h",
        "AccelStepper.h",
        "MAX31856_noDelay.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);"
        },
        {
          "name": "blinkLed7",
          "body": "if (ledDelay.justFinished()) {   // check if delay has timed out\n    ledDelay.repeat(); // start delay again without drift\n    if (stop) {\n      digitalWrite(led, LOW); // turn led on/off\n      ledOn = false;\n      return;"
        },
        {
          "name": "printTemp",
          "body": "if (printDelay.justFinished()) {\n    printDelay.repeat(); // start delay again without drift\n    //  runStepper(); // <<<< extra call here\n    bufferedOut.print(F(\"Temp:\")); bufferedOut.println(simulatedTempReading);\n    //  runStepper(); // <<<< extra call here\n    bufferedOut.print(F(\"Position current:\")); bufferedOut.print(stepper.currentPosition());\n    //  runStepper(); // <<<< extra call here\n    if (closeDampler) {\n      bufferedOut.println(F(\" Close Damper\"));"
        },
        {
          "name": "processUserInput",
          "body": "if (sfReader.read()) { // echo input and 100ms timeout, non-blocking!!\n    sfReader.toLowerCase(); // ignore case\n    if (sfReader == \"close\") { // all lower case\n      closeDampler = true;"
        },
        {
          "name": "setDamperPosition",
          "body": "if (closeDampler) {\n    stepper.moveTo(0);"
        },
        {
          "name": "runStepper",
          "body": "loopTimer.check(serialBufferedOut); // moved here from loop()\n  stepper.run();"
        },
        {
          "name": "loop",
          "body": "bufferedOut.nextByteOut(); // call this one or more times each loop() to release buffered chars\n  processUserInput();\n  blinkLed7(closeDampler); // call the method to blink the led\n  printTemp(); // print the temp\n  int rtn = readTemp(); // check for errors here\n  if (rtn == 0) {\n    // have new reading"
        }
      ]
    },
    {
      "name": "LGFX_USE_V1",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp",
        "driver/rtc_io.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "switch(esp_sleep_get_wakeup_cause())\n  {\n  case ESP_SLEEP_WAKEUP_EXT0 :\n  case ESP_SLEEP_WAKEUP_EXT1 :\n  case ESP_SLEEP_WAKEUP_TIMER :\n  case ESP_SLEEP_WAKEUP_TOUCHPAD :\n  case ESP_SLEEP_WAKEUP_ULP :\n    lcd.init_without_reset(); // deep sleep からの復帰時はinit_without_resetを呼び出す。\n    break;\n\n  default :\n    lcd.init();            // 通常起動時はinitを呼び出す。\n    lcd.clear(TFT_WHITE);\n    lcd.clear(TFT_BLACK);\n    lcd.startWrite();      // 背景を描画しておく\n    lcd.setColorDepth(24);\n    {\n      LGFX_Sprite sp(&lcd);\n      sp.createSprite(128, 128);\n      sp.createPalette();\n      for (int y = 0; y < 128; y++)\n        for (int x = 0; x < 128; x++)\n          sp.writePixel(x, y, sp.color888(x << 1, x + y, y << 1));\n      for (int y = 0; y < lcd.height(); y += 128)\n        for (int x = 0; x < lcd.width(); x += 128)\n          sp.pushSprite(x, y);"
        },
        {
          "name": "loop",
          "body": "delay(10000);"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32_WM_Config using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32_WM_Config using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32_WM_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32WM_ForcedConfig using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32WM_ForcedConfig using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32WM_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n#if ( ARDUINO_ESP32S2_DEV || ARDUINO_FEATHERS2 || ARDUINO_PROS2 || ARDUINO_MICROS2 )\n  delay(2000);\n#else  \n  delay(200);\n#endif\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_Config using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_Config using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (int i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_ForcedConfig using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_ForcedConfig using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleEsp32_BLE.h",
        "BLEDevice.h",
        "BLEServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.setDeviceName(\"Blynk\");\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_USE_BT_ONLY",
      "keywords": [
        "EEPROM",
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "noticeAlive",
          "body": "if (USE_BLE)\n    Blynk_BLE.virtualWrite(V0, F(\"OK\"));\n  else\n    Blynk_WF.virtualWrite(V0, F(\"OK\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "checkStatus",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {     \n    if (!USE_BLE)\n    {\n      // report Blynk connection\n      heartBeatPrint();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \"));\n#else\n  Serial.print(F(\" without SSL on \"));\n#endif\n\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(BLYNK_ESP32_BT_WF_VERSION);\n  \n#if USE_BLYNK_WM  \n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  pinMode(WIFI_BLE_SELECTION_PIN, INPUT_PULLUP);\n\n#if BLYNK_USE_BLE_ONLY\n  Blynk_BLE.setDeviceName(BLE_Device_Name);\n\n  #if ESP32_BLE_WF_DEBUG\n  Serial.println(F(\"Blynk_BLE begin\"));\n  #endif\n\n  Blynk_BLE.begin(auth);\n#else\n  if (digitalRead(WIFI_BLE_SELECTION_PIN) == HIGH)\n  {\n    USE_BLE = false;\n    Serial.println(F(\"GPIO14 HIGH, Use WiFi\"));\n#if USE_BLYNK_WM\n#if ESP32_BLE_WF_DEBUG\n    Serial.println(F(\"USE_BLYNK_WM: Blynk_WF begin\"));\n#endif\n\n    // Set config portal SSID and Password\n    Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    // Set config portal IP address\n    Blynk.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  \n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n    Blynk_WF.setConfigPortalChannel(0);\n\n    // From v1.0.6, select either one of these to set static IP + DNS\n    Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n\n  //////////////////////////////////////////////\n    \n  #if USING_CUSTOMS_STYLE\n    Blynk.setCustomsStyle(NewCustomsStyle);\n  #endif\n  \n  #if USING_CUSTOMS_HEAD_ELEMENT\n    Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "#if BLYNK_USE_BLE_ONLY\n  Blynk_BLE.run();\n#else\n  if (USE_BLE)\n    Blynk_BLE.run();\n  else\n    Blynk_WF.run();\n#endif\n\n  timer.run(); \n  checkStatus();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_USE_BT_ONLY",
      "keywords": [
        "EEPROM",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "noticeAlive",
          "body": "if (USE_BT)\n    Blynk_BT.virtualWrite(V0, F(\"OK\"));\n  else\n    Blynk_WF.virtualWrite(V0, F(\"OK\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "checkStatus",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    if (!USE_BT)\n    {\n      // report Blynk connection\n      heartBeatPrint();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \"));\n#else\n  Serial.print(F(\" without SSL on \"));\n#endif\n\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(BLYNK_ESP32_BT_WF_VERSION);\n  \n#if USE_BLYNK_WM  \n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  pinMode(WIFI_BT_SELECTION_PIN, INPUT_PULLUP);\n\n#if BLYNK_USE_BT_ONLY\n  Blynk_BT.setDeviceName(BT_Device_Name);\n\n#if ESP32_BT_WF_DEBUG\n  Serial.println(F(\"Blynk_BT begin\"));\n#endif\n  \n  Blynk_BT.begin(auth);\n#else\n  if (digitalRead(WIFI_BT_SELECTION_PIN) == HIGH)\n  {\n    USE_BT = false;\n    Serial.println(F(\"GPIO14 HIGH, Use WiFi\"));\n#if USE_BLYNK_WM\n#if ESP32_BT_WF_DEBUG\n    Serial.println(F(\"USE_BLYNK_WM: Blynk_WF begin\"));\n#endif\n    // Set config portal SSID and Password\n    Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    // Set config portal IP address\n    Blynk.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  \n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n    Blynk_WF.setConfigPortalChannel(0);\n\n    // From v1.0.6, select either one of these to set static IP + DNS\n    Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n    //////////////////////////////////////////////\n    \n  #if USING_CUSTOMS_STYLE\n    Blynk.setCustomsStyle(NewCustomsStyle);\n  #endif\n  \n  #if USING_CUSTOMS_HEAD_ELEMENT\n    Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "#if BLYNK_USE_BT_ONLY\n  Blynk_BT.run();\n#else\n  if (USE_BT)\n    Blynk_BT.run();\n  else\n    Blynk_WF.run();\n#endif\n\n  timer.run();\n  checkStatus();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "_ESP32_ETH_MGR_LOGLEVEL_",
      "keywords": [
        "EEPROM",
        "Serial",
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "WebServer.h",
        "ESPmDNS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP32_W6100_Manager.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "handleFileUpload",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;"
        },
        {
          "name": "handleFileDelete",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileCreate",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileList",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "beginEthernet",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP32_FSWebServer using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n\n  // this is just for checking if we are alive and connected to WiFi\n  check_status();;"
        }
      ]
    },
    {
      "name": "_ESP32_ETH_MGR_LOGLEVEL_",
      "keywords": [
        "EEPROM",
        "Serial",
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "WebServer.h",
        "ESPmDNS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP32_W6100_Manager.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "handleFileUpload",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;"
        },
        {
          "name": "handleFileDelete",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileCreate",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileList",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "beginEthernet",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP32_FSWebServer_DRD using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // this is just for checking if we are alive and connected to WiFi\n  check_status();\n\n  server.handleClient();"
        }
      ]
    },
    {
      "name": "DEBUG_ETHERNET_WEBSERVER_PORT",
      "keywords": [
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "WebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));        // H means alive\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong current_millis;\n\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;"
        },
        {
          "name": "handleFileDelete",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileCreate",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileUpload",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;"
        },
        {
          "name": "handleFileList",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;"
        },
        {
          "name": "initFS",
          "body": "// Initialize LittleFS/SPIFFS file-system\n  // Format SPIFFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      while (true)\n      {\n#if USE_LITTLEFS\n        Serial.println(F(\"LittleFS failed!. Please use SPIFFS.\"));\n#else\n        Serial.println(F(\"SPIFFS failed!. Please use LittleFS.\"));\n#endif\n        // Stay forever here as useless to go further\n        delay(5000);"
        },
        {
          "name": "listDir",
          "body": "File root = FileFS.open(\"/\");\n  File file = root.openNextFile();\n  while (file)\n  {\n    String fileName = file.name();\n    size_t fileSize = file.size();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n    file = root.openNextFile();"
        },
        {
          "name": "initWebserver",
          "body": "//SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n\n  //load editor\n  server.on(\"/edit\", HTTP_GET, []()\n  {\n    if (!handleFileRead(\"/edit.htm\"))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting ESP32_FS_EthernetWebServer on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  initFS();\n  listDir();\n  initWebserver();\n\n  Serial.print(\"HTTP server started @\");\n  Serial.println(ETH.localIP());\n\n  Serial.print(F(\"Open http://\"));\n  Serial.print(ETH.localIP());\n  Serial.println(F(\"/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n  \n  SerialMon.print(F(\"\\nStart ESP32_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n\n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  //SerialAT.begin(115200);\n  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP32-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP32_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP32_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP32_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP32_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SHT3x.h"
      ],
      "functions": [
        {
          "name": "SensorUpdate",
          "body": "static float temperature;\n  static float rHumidity;\n\n  Sensor.UpdateData();\n\n  temperature = Sensor.GetTemperature();\n  rHumidity   = Sensor.GetRelHumidity();\n\n  if (!isnan(temperature) && !isnan(rHumidity))\n  {\n    if (Blynk_GSM.connected())\n    {\n      Blynk_GSM.virtualWrite(V1, String(temperature, 1));\n      Blynk_GSM.virtualWrite(V2, String(rHumidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n  static unsigned long checksensor_timeout = 0;\n\n#define SENSOR_CHECK_INTERVAL     10000L\n#define STATUS_CHECK_INTERVAL     60000L\n  // Read and send Sensor data every SENSOR_CHECK_INTERVAL (10) seconds\n  if ((millis() > checksensor_timeout) || (checksensor_timeout == 0))\n  {\n    // Read and send Sensor to Blynk\n    SensorUpdate();\n\n    checksensor_timeout = millis() + SENSOR_CHECK_INTERVAL;\n\n    // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n    if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n    {\n      // report status to Blynk\n      heartBeatPrint();\n  \n      checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n  \n  SerialMon.print(F(\"\\nStart ESP32_GSM_SHT3x (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  Sensor.Begin();\n\n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  //SerialAT.begin(115200);\n  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP32-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP32_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP32_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP32_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP32_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();"
        }
      ]
    },
    {
      "name": "SIMCOM_2G",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "HardwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//  while (!Serial);\n\n  pinMode(RST, OUTPUT);\n  digitalWrite(RST, HIGH); // Default state\n\n  // Turn on the module by pulsing PWRKEY low for a little bit\n  // This amount of time depends on the specific module that's used\n  modem.powerOn(BOTLETICS_PWRKEY); // Power on the module\n\n  Serial.begin(9600);\n  Serial.println(F(\"ESP32 SIMCom Basic Test\"));\n  Serial.println(F(\"Initializing....(May take several seconds)\"));\n\n  // SIM7000 takes about 3s to turn on and SIM7500 takes about 15s\n  // Press reset button if the module is still turning on and the board doesn't find it.\n  // When the module is on it should communicate right after pressing reset\n  \n  // Start at default SIM7000 shield baud rate\n  modemSS.begin(115200, SERIAL_8N1, TX, RX); // baud rate, protocol, ESP32 RX pin, ESP32 TX pin\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modemSS.println(\"AT+IPR=9600\"); // Set baud rate\n  delay(100); // Short pause to let the command run\n  modemSS.begin(9600, SERIAL_8N1, TX, RX); // Switch to 9600\n  if (! modem.begin(modemSS)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while (1); // Don't proceed if it couldn't find the device"
        },
        {
          "name": "printMenu",
          "body": "Serial.println(F(\"-------------------------------------\"));\n  // General\n  Serial.println(F(\"[?] Print this menu\"));\n  Serial.println(F(\"[a] Read the ADC; 2.8V max for SIM800/808, 0V-VBAT for SIM7000 shield\"));\n  Serial.println(F(\"[b] Read supply voltage\")); // Will also give battery % charged for most modules\n  Serial.println(F(\"[C] Read the SIM CCID\"));\n  Serial.println(F(\"[U] Unlock SIM with PIN code\"));\n  Serial.println(F(\"[i] Read signal strength (RSSI)\"));\n  Serial.println(F(\"[n] Get network status\"));\n  Serial.println(F(\"[1] Get network connection info\")); // See what connection type and band you're on!\n\n#if !defined(SIMCOM_7000) && !defined(SIMCOM_7070)\n  // Audio\n  Serial.println(F(\"[v] Set audio Volume\"));\n  Serial.println(F(\"[V] Get volume\"));\n  Serial.println(F(\"[H] Set headphone audio (SIM800/808)\"));\n  Serial.println(F(\"[e] Set external audio (SIM800/808)\"));\n  Serial.println(F(\"[T] Play audio Tone\"));\n  Serial.println(F(\"[P] PWM/buzzer out (SIM800/808)\"));\n#endif\n\n  // Calling\n  Serial.println(F(\"[c] Make phone Call\"));\n  Serial.println(F(\"[A] Get call status\"));\n  Serial.println(F(\"[h] Hang up phone\"));\n  Serial.println(F(\"[p] Pick up phone\"));\n\n#ifdef SIMCOM_2G\n  // FM (SIM800 only!)\n  Serial.println(F(\"[f] Tune FM radio (SIM800)\"));\n  Serial.println(F(\"[F] Turn off FM (SIM800)\"));\n  Serial.println(F(\"[m] Set FM volume (SIM800)\"));\n  Serial.println(F(\"[M] Get FM volume (SIM800)\"));\n  Serial.println(F(\"[q] Get FM station signal level (SIM800)\"));\n#endif\n\n  // SMS\n  Serial.println(F(\"[N] Number of SMS's\"));\n  Serial.println(F(\"[r] Read SMS #\"));\n  Serial.println(F(\"[R] Read all SMS\"));\n  Serial.println(F(\"[d] Delete SMS #\"));\n  Serial.println(F(\"[D] Delete all SMS\"));\n  Serial.println(F(\"[s] Send SMS\"));\n  Serial.println(F(\"[u] Send USSD\"));\n  \n  // Time\n  Serial.println(F(\"[y] Enable local time stamp (SIM800/808/70X0)\"));\n  Serial.println(F(\"[Y] Enable NTP time sync (SIM800/808/70X0)\")); // Need to use \"G\" command first!\n  Serial.println(F(\"[t] Get network time\")); // Works just by being connected to network\n\n  // Data Connection\n  Serial.println(F(\"[G] Enable cellular data\"));\n  Serial.println(F(\"[g] Disable cellular data\"));\n  Serial.println(F(\"[l] Query GSMLOC (2G)\"));\n#if !defined(SIMCOM_3G) && !defined(SIMCOM_7500) && !defined(SIMCOM_7600)\n  Serial.println(F(\"[w] Read webpage\"));\n  Serial.println(F(\"[W] Post to website\"));\n#endif\n  // The following option below posts dummy data to dweet.io for demonstration purposes. See the\n  // IoT_example sketch for an actual application of this function!\n  Serial.println(F(\"[2] Post to dweet.io - 2G / LTE CAT-M / NB-IoT\")); // SIM800/808/900/7000/7070\n  Serial.println(F(\"[3] Post to dweet.io - 3G / 4G LTE\")); // SIM5320/7500/7600\n\n  // GPS\n  if (type >= SIM808_V1) {\n    Serial.println(F(\"[O] Turn GPS on (SIM808/5320/7XX0)\"));\n    Serial.println(F(\"[o] Turn GPS off (SIM808/5320/7XX0)\"));\n    Serial.println(F(\"[L] Query GPS location (SIM808/5320/7XX0)\"));\n    if (type == SIM808_V1) {\n      Serial.println(F(\"[x] GPS fix status (SIM808 v1 only)\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"modem> \"));\n  while (! Serial.available() ) {\n    if (modem.available()) {\n      Serial.write(modem.read());"
        },
        {
          "name": "flushSerial",
          "body": "while (Serial.available())\n    Serial.read();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "loopTimer.h",
        "millisDelay.h",
        "BufferedOutput.h"
      ],
      "functions": [
        {
          "name": "blinkTask",
          "body": "ledOn = false;\n  // start delay\n  ledDelay.start(1000);\n\n  for (;;) {   // loop forever\n    blinkTaskTimer.check();\n    vTaskDelay(1); // need this to prevent wdt panic\n\n    if (ledDelay.justFinished()) {\n      ledDelay.repeat(); // start delay again without drift\n      // toggle the led\n      ledOn = !ledOn;\n      if (ledOn) {\n        digitalWrite(led, HIGH); // turn led on"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  for (int i = 10; i > 0; i--) {\n    Serial.println(i);\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "loopTimer.check();\n  bufferedOut.nextByteOut(); // check if any output to print\n\n  if (printTimers.justFinished()) {\n    printTimers.restart(); // this may drift\n    loopTimer.print(bufferedOut);\n    blinkTaskTimer.print(bufferedOut);"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n  \n  SerialMon.print(F(\"\\nStart ESP32_MRD_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  #if USING_MRD\n    Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  #else\n    Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n  #endif\n#endif\n\n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  //SerialAT.begin(115200);\n  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP32-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP32_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP32_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP32_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP32_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "WiFiUdp.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    DBG(\"Establishing connection to WiFi..\");"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t0) > 1000)\n  {\n    t0 = millis();\n\n    byte note = 45;\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Das Booting\");\n\n  ETH_startup();\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin(MIDI_CHANNEL_OMNI);\n\n  // Normal callbacks - always available\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 100)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    //   DBG(F(\"\\nsendNoteOn\"), note, velocity, channel);\n    MIDI.sendNoteOn(note, velocity, channel);\n    //MIDI.sendNoteOff(note, velocity, channel);"
        },
        {
          "name": "OnAppleMidiException",
          "body": "switch (e)\n  {\n    case APPLEMIDI_NAMESPACE::Exception::BufferFullException:\n      DBG(F(\"*** BufferFullException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParseException:\n      DBG(F(\"*** ParseException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::TooManyParticipantsException:\n      DBG(F(\"*** TooManyParticipantsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UnexpectedInviteException:\n      DBG(F(\"*** UnexpectedInviteException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParticipantNotFoundException:\n      DBG(F(\"*** ParticipantNotFoundException\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ComputerNotInDirectory:\n      DBG(F(\"*** ComputerNotInDirectory\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NotAcceptingAnyone:\n      DBG(F(\"*** NotAcceptingAnyone\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ListenerTimeOutException:\n      DBG(F(\"*** ListenerTimeOutException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::MaxAttemptsException:\n      DBG(F(\"*** MaxAttemptsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NoResponseFromConnectionRequestException:\n      DBG(F(\"***:yyy did't respond to the connection request. Check the address and port, and any firewall or router settings. (time)\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::SendPacketsDropped:\n      DBG(F(\"*** SendPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ReceivedPacketsDropped:\n      DBG(F(\"******************************************** ReceivedPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UdpBeginPacketFailed:\n      DBG(F(\"*** UdpBeginPacketFailed\"), value);\n      break;"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "hexdump",
          "body": "const uint8_t* src = (const uint8_t*) mem;\n\n  Serial.printf(\"\\n[HEXDUMP] Address: 0x%08X len: 0x%X (%d)\", (ptrdiff_t)src, len, len);\n\n  for (uint32_t i = 0; i < len; i++)\n  {\n    if (i % cols == 0)\n    {\n      Serial.printf(\"\\n[0x%08X] 0x%08X: \", (ptrdiff_t)src, i);"
        },
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ESP32_WebSocketClient on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "hexdump",
          "body": "const uint8_t* src = (const uint8_t*) mem;\n\n  Serial.printf(\"\\n[HEXDUMP] Address: 0x%08X len: 0x%X (%d)\", (ptrdiff_t)src, len, len);\n\n  for (uint32_t i = 0; i < len; i++)\n  {\n    if (i % cols == 0)\n    {\n      Serial.printf(\"\\n[0x%08X] 0x%08X: \", (ptrdiff_t)src, i);"
        },
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n\n      break;\n\n    case WStype_CONNECTED:\n      Serial.printf(\"[WSc] Connected to url: %s\\n\", payload);\n\n      // send message to server when Connected\n      webSocket.sendTXT(\"Connected\");\n\n      break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      webSocket.sendTXT(\"message here\");\n\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      webSocket.sendBIN(payload, length);\n\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n\n      break;\n\n    default:\n      break;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ESP32_WebSocketClientSSL on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n      Serial.print(\"[IOc] Get event: \");\n      Serial.println((char*) payload);\n\n      break;\n\n    case sIOtype_ACK:\n      Serial.print(\"[IOc] Get ack: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_ERROR:\n      Serial.print(\"[IOc] Get error: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_BINARY_EVENT:\n      Serial.print(\"[IOc] Get binary: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_BINARY_ACK:\n      Serial.print(\"[IOc] Get binary ack: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_PING:\n      Serial.println(\"[IOc] Get PING\");\n\n      break;\n\n    case sIOtype_PONG:\n      Serial.println(\"[IOc] Get PONG\");\n\n      break;\n\n    default:\n      break;"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"WebSockets Client IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP32_WebSocketClientSocketIO on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  WiFiMulti.addAP(ssid, pass);\n\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "WebSocketsServer_Generic.h"
      ],
      "functions": [
        {
          "name": "hexdump",
          "body": "const uint8_t* src = (const uint8_t*) mem;\n\n  Serial.printf(\"\\n[HEXDUMP] Address: 0x%08X len: 0x%X (%d)\", (ptrdiff_t)src, len, len);\n\n  for (uint32_t i = 0; i < len; i++)\n  {\n    if (i % cols == 0)\n    {\n      Serial.printf(\"\\n[0x%08X] 0x%08X: \", (ptrdiff_t)src, i);"
        },
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ESP32_WebSocketServer on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "BlynkSimpleEsp32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClientSecure.h",
        "BlynkSimpleEsp32_SSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "PubSubClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"\");\n  Serial.print(\"Arduino MQTT OTA Test \");\n  Serial.println(__TIMESTAMP__);\n\n  Serial.printf(\"Sketch size: %u\\n\", ESP.getSketchSize());\n  Serial.printf(\"Free size: %u\\n\", ESP.getFreeSketchSpace());"
        },
        {
          "name": "receive_ota",
          "body": "uint32_t startTime = millis();\n  uint32_t size = pub.payload_len();\n  if (size == 0)\n    return;\n\n  Serial.print(\"Receiving OTA of \");\n  Serial.print(size);\n  Serial.println(\" bytes...\");\n\n  Serial.setDebugOutput(true);\n  if (ESP.updateSketch(*pub.payload_stream(), size, true, false)) {\n    Serial.println(\"Clearing retained message.\");\n    client.publish(MQTT::Publish(pub.topic(), \"\")\n                   .set_retain());\n    client.disconnect();\n\n    Serial.printf(\"Update Success: %lu\\nRebooting...\\n\", millis() - startTime);\n    ESP.restart();\n    delay(10000);"
        },
        {
          "name": "loop",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\"Connecting to \");\n    Serial.print(ssid);\n    Serial.println(\"...\");\n    WiFi.begin(ssid, pass);\n    if (WiFi.waitForConnectResult() != WL_CONNECTED)\n      return;\n\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h"
      ],
      "functions": [
        {
          "name": "connectNetwork",
          "body": "Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  delay(10);\n  Serial.println();\n  Serial.println();\n\n  connectNetwork();"
        },
        {
          "name": "loop",
          "body": "String response;\n\n  unsigned long value = millis();\n\n  // Send value to the cloud\n  // similar to Blynk.virtualWrite()\n\n  Serial.print(\"Sending value: \");\n  Serial.println(value);\n\n  String putData = String(\"[\\\"\") + value + \"\\\"]\";\n  if (httpRequest(String(\"PUT /\") + auth + \"/update/V2\", putData, response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);"
        }
      ]
    },
    {
      "name": "DEBUG",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESPAutoWiFiConfig.h",
        "ESP8266WiFi.h",
        "ESP8266WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// setup code that must be run every time\n#ifdef DEBUG\n  Serial.begin(115200);\n  Serial.println();\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "//  .. other code that MUST run all the time\n  if (ESPAutoWiFiConfigLoop()) {  // handle WiFi config webpages\n    return;  // skip the rest of the loop until config finished"
        },
        {
          "name": "notFound",
          "body": "server.send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "handleRoot",
          "body": "server.send(200, \"text/plain\", \"hello from esp8266!\\r\\n\");"
        },
        {
          "name": "startWebServer",
          "body": "server.on(\"/\", handleRoot);\n  server.onNotFound(notFound);\n  server.begin();"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_Config using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_ForcedConfig using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION); \n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "STATUS_CHECK_INTERVAL",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_Config using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  \n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_ForcedConfig using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);;\n  \n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (int i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "sendTXTMessage",
          "body": "static uint64_t sendTXTMessage_timeout = 0;\n\n  uint64_t now = millis();\n\n  //KH\n#define SEND_INTERVAL         30000L\n\n  // sendTXTMessage every SEND_INTERVAL (30) seconds.\n  if (now > sendTXTMessage_timeout)\n  {\n    //webSocket.sendTXT(\"message here\");\n    // creat JSON message\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    array.add(messageToSend);\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    webSocket.sendTXT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n\n    sendTXTMessage_timeout = millis() + SEND_INTERVAL;"
        },
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP8266_AsyncWSClient on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "// No more webSocket.loop() in Async\n\n  sendTXTMessage();"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "connectNetwork",
          "body": "Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  delay(10);\n  Serial.println();\n  Serial.println();\n\n  connectNetwork();"
        },
        {
          "name": "loop",
          "body": "String response;\n\n  unsigned long value = millis();\n\n  // Send value to the cloud\n  // similar to Blynk.virtualWrite()\n\n  Serial.print(\"Sending value: \");\n  Serial.println(value);\n\n  if (httpRequest(\"GET\", String(\"/external/api/update?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2&value=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n\n  SerialMon.print(F(\"\\nStart ESP8266_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n  \n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP8266-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP8266_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP8266_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP8266_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP8266_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SHT3x.h"
      ],
      "functions": [
        {
          "name": "SensorUpdate",
          "body": "static float temperature;\n  static float rHumidity;\n\n  Sensor.UpdateData();\n\n  temperature = Sensor.GetTemperature();\n  rHumidity   = Sensor.GetRelHumidity();\n\n  if (!isnan(temperature) && !isnan(rHumidity))\n  {\n    if (Blynk_GSM.connected())\n    {\n      Blynk_GSM.virtualWrite(V1, String(temperature, 1));\n      Blynk_GSM.virtualWrite(V2, String(rHumidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n  static unsigned long checksensor_timeout = 0;\n\n#define SENSOR_CHECK_INTERVAL     10000L\n#define STATUS_CHECK_INTERVAL     60000L\n  // Read and send Sensor data every SENSOR_CHECK_INTERVAL (10) seconds\n  if ((millis() > checksensor_timeout) || (checksensor_timeout == 0))\n  {\n    // Read and send Sensor to Blynk\n    SensorUpdate();\n\n    checksensor_timeout = millis() + SENSOR_CHECK_INTERVAL;\n\n    // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n    if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n    {\n      // report status to Blynk\n      heartBeatPrint();\n  \n      checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n\n  SerialMon.print(F(\"\\nStart ESP8266_GSM_SHT3x (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  SerialMon.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  Sensor.Begin();\n  \n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP8266-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP8266_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP8266_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP8266_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP8266_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n\n  SerialMon.print(F(\"\\nStart ESP8266_MRD_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  #if USING_MRD\n    Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  #else\n    Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n  #endif\n#endif\n  \n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP8266-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP8266_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP8266_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP8266_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP8266_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "WiFiUdp.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    DBG(\"Establishing connection to WiFi..\");"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t0) > 1000)\n  {\n    t0 = millis();\n\n    byte note = 45;\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266mDNS.h",
        "WiFiClient.h",
        "WiFiUdp.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  WiFi.softAP(ssid, pass);\n\n  DBG(F(\"Started soft access point:\"), WiFi.softAPIP(), \"Port\", AppleMIDI.getPort());\n  DBG(F(\"AppleMIDI device name:\"), AppleMIDI.getName());\n  // Set up mDNS responder:\n  if (!MDNS.begin(AppleMIDI.getName()))\n    DBG(F(\"Error setting up MDNS responder!\"));\n  char str[128] = \"\";\n  strcat(str, AppleMIDI.getName());\n  strcat(str,\".local\");\n  DBG(F(\"mDNS responder started at:\"), str);\n  MDNS.addService(\"apple-midi\", \"udp\", AppleMIDI.getPort());\n  DBG(F(\"Open Wifi settings and connect to soft acess point using 'ssid'\"));\n  DBG(F(\"Start MIDI Network app on iPhone/iPad or rtpMIDI on Windows\"));\n  DBG(F(\"AppleMIDI-ESP8266 will show in the 'Directory' list (rtpMIDI) or\"));\n  DBG(F(\"under 'Found on the network' list (iOS). Select and click 'Connect'\"));\n  \n  MIDI.begin();\n\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);"
        },
        {
          "name": "loop",
          "body": "MDNS.update();\n  \n  // Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t0) > 1000)\n  {\n    t0 = millis();\n\n    byte note = 45;\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266_Lib.h",
        "BlynkSimpleShieldEsp8266.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  delay(10);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, wifi, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Setup WiFi network\n  WiFi.config(device_ip, gateway_ip, subnet_mask);\n  WiFi.begin(ssid, pass);\n\n  // Setup Blynk\n  Blynk.config(BLYNK_AUTH_TOKEN);\n  while (Blynk.connect() == false) {"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266_SSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  WiFi.mode(WIFI_STA);\n\n  int cnt = 0;\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n    if (cnt++ >= 10) {\n      WiFi.beginSmartConfig();\n      while (1) {\n        delay(1000);\n        if (WiFi.smartConfigDone()) {\n          Serial.println();\n          Serial.println(\"SmartConfig: Success\");\n          break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "sendTXTMessage",
          "body": "static uint64_t sendTXTMessage_timeout = 0;\n\n  uint64_t now = millis();\n\n  //KH\n#define SEND_INTERVAL         30000L\n\n  // sendTXTMessage every SEND_INTERVAL (30) seconds.\n  if (now > sendTXTMessage_timeout)\n  {\n    //webSocket.sendTXT(\"message here\");\n    // creat JSON message\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    array.add(messageToSend);\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    webSocket.sendTXT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n\n    sendTXTMessage_timeout = millis() + SEND_INTERVAL;"
        },
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClient on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();\n\n  sendTXTMessage();"
        }
      ]
    },
    {
      "name": "WS_SERVER",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "ArduinoJson.h",
        "ESP8266WiFi.h",
        "ESP8266mDNS.h",
        "Updater.h",
        "WiFiUdp.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "greetings_",
          "body": "StaticJsonDocument<200> doc;\n  doc[\"type\"] = \"greetings\";\n  doc[\"mac\"] = WiFi.macAddress();\n  doc[\"ip\"] = IpAddress2String(WiFi.localIP());\n  doc[\"version\"] = version;\n  doc[\"name\"] = name;\n  doc[\"chip\"] = chip;\n\n  char data[200];\n  serializeJson(doc, data);\n  webSocket.sendTXT(data);"
        },
        {
          "name": "register_",
          "body": "StaticJsonDocument<200> doc;\n  doc[\"type\"] = \"register\";\n  doc[\"mac\"] = WiFi.macAddress();\n\n  char data[200];\n  serializeJson(doc, data);\n  webSocket.sendTXT(data);\n  ws_conn = true;"
        },
        {
          "name": "OTA",
          "body": "Serial.print(F(\"[WSc] OTA mode: \"));\n  const char* go = \"go\";\n  const char* ok = \"ok\";\n\n  if (strncmp( msg[\"value\"], go, strlen(go)) == 0 )\n  {\n    Serial.print(F(\"go\\n\"));\n    SketchSize = int(msg[\"size\"]);\n    maxSketchSpace = (ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000;\n    Serial.printf(\"[WSc] Max sketch size: %u\\n\", maxSketchSpace);\n    Serial.printf(\"[WSc] Sketch size: %d\\n\", SketchSize);\n    Serial.setDebugOutput(true);\n\n    if (!Update.begin(maxSketchSpace))\n    {\n      //start with max available size\n      Update.printError(Serial);\n      ESP.restart();"
        },
        {
          "name": "STATE",
          "body": "// Do something with message\n  (void) msg;"
        },
        {
          "name": "text",
          "body": "// Convert mesage to something usable\n  char msgch[length];\n\n  for (unsigned int i = 0; i < length; i++)\n  {\n    Serial.print((char)payload[i]);\n    msgch[i] = ((char)payload[i]);"
        },
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientOTA on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n      break;\n\n    case WStype_CONNECTED:\n      Serial.printf(\"[WSc] Connected to url: %s\\n\", payload);\n\n      // send message to server when Connected\n      webSocket.sendTXT(\"Connected\");\n      break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      webSocket.sendTXT(\"message here\");\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      webSocket.sendBIN(payload, length);\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n      break;\n\n    default:\n      break;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientSSL on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n      Serial.print(\"[IOc] Get event: \");\n      Serial.println((char*) payload);\n\n      break;\n\n    case sIOtype_ACK:\n      Serial.print(\"[IOc] Get ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_ERROR:\n      Serial.print(\"[IOc] Get error: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_EVENT:\n      Serial.print(\"[IOc] Get binary: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_ACK:\n      Serial.print(\"[IOc] Get binary ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_PING:\n      Serial.println(\"[IOc] Get PING\");\n\n      break;\n\n    case sIOtype_PONG:\n      Serial.println(\"[IOc] Get PONG\");\n\n      break;\n\n    default:\n      break;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientSocketIO on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  // disable AP\n  if (WiFi.getMode() & WIFI_AP)\n  {\n    WiFi.softAPdisconnect(true);"
        },
        {
          "name": "loop",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n    {\n      char * sptr = NULL;\n      int id = strtol((char *)payload, &sptr, 10);\n\n      Serial.print(\"[IOc] Get event: \");\n      Serial.print((char*) payload);\n      Serial.print(\", id: \");\n      Serial.println(id);\n\n      if (id)\n      {\n        payload = (uint8_t *)sptr;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientSocketIOack on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  // disable AP\n  if (WiFi.getMode() & WIFI_AP)\n  {\n    WiFi.softAPdisconnect(true);"
        },
        {
          "name": "loop",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Hash.h",
        "ESP8266WiFi.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "sendMessage",
          "body": "webSocket.sendTXT(msg.c_str(), msg.length() + 1);"
        },
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n      break;\n\n    case WStype_CONNECTED:\n    {\n      Serial.printf(\"[WSc] Connected to url: %s\\n\",  payload);\n\n      String msg = \"CONNECT\\r\\naccept-version:1.1,1.0\\r\\nheart-beat:10000,10000\\r\\n\\r\\n\";\n      sendMessage(msg);"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientStomp on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  // connect to WiFi\n  Serial.print(\"Logging into WLAN: \");\n  Serial.print(wlan_ssid);\n  Serial.print(\" ...\");\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(wlan_ssid, wlan_password);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Hash.h",
        "ESP8266WiFi.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n      break;\n\n    case WStype_CONNECTED:\n    {\n      Serial.printf(\"[WSc] Connected to url: %s\\n\",  payload);"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientStompOverSockJs on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  // connect to WiFi\n  Serial.print(\"Logging into WLAN: \");\n  Serial.print(wlan_ssid);\n  Serial.print(\" ...\");\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(wlan_ssid, wlan_password);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n      Serial.print(\"[IOc] Get event: \");\n      Serial.println((char*) payload);\n\n      break;\n\n    case sIOtype_ACK:\n      Serial.print(\"[IOc] Get ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_ERROR:\n      Serial.print(\"[IOc] Get error: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_EVENT:\n      Serial.print(\"[IOc] Get binary: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_ACK:\n      Serial.print(\"[IOc] Get binary ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_PING:\n      Serial.println(\"[IOc] Get PING\");\n\n      break;\n\n    case sIOtype_PONG:\n      Serial.println(\"[IOc] Get PONG\");\n\n      break;\n\n    default:\n      break;"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClient_Sticky_SocketIO on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  // disable AP\n  if (WiFi.getMode() & WIFI_AP)\n  {\n    WiFi.softAPdisconnect(true);"
        },
        {
          "name": "loop",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "body": "(void) length;\n\n  switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServer on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(\"Version \" + String(WEBSOCKETS_GENERIC_VERSION));\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "analogWrite",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "body": "(void) length;\n\n  switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(LED_BLUE, OUTPUT);\n\n  digitalWrite(LED_RED, 1);\n  digitalWrite(LED_GREEN, 1);\n  digitalWrite(LED_BLUE, 1);\n\n  //Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServerAllFunctionsDemo on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "unsigned long t = millis();\n  webSocket.loop();\n  server.handleClient();\n\n  if ((t - last_10sec) > 10 * 1000)\n  {\n    counter++;\n    bool ping = (counter % 2);\n    int i = webSocket.connectedClients(ping);\n    Serial.printf(\"%d Connected websocket clients ping: %d\\n\", i, ping);\n    last_10sec = millis();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");"
        },
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServerFragmentation on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServerHttpHeaderValidation on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "_WEBSOCKETS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "analogWrite",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "body": "(void) length;\n\n  switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(LED_BLUE, OUTPUT);\n\n  digitalWrite(LED_RED, 1);\n  digitalWrite(LED_GREEN, 1);\n  digitalWrite(LED_BLUE, 1);\n\n  // Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServer_LEDcontrol on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  //WiFi.config(static_ip, static_gw, static_sn);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n  //KH\n#define HEARTBEAT_INTERVAL    20000L\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (20) seconds.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + HEARTBEAT_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();\n  webSocket.loop();\n  server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "ESPAsyncWebServer.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    // Connect to Wi-Fi\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(1000);\n        Serial.println(\"Connecting to WiFi...\");"
        },
        {
          "name": "loop",
          "body": "// Main loop"
        }
      ]
    },
    {
      "name": "HEARTBEAT_INTERVAL",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n  {\n    if (ESPAsync_WiFiManager->isConfigMode())\n      Serial.print(\"C\");        // C means in Config Mode\n    else\n      Serial.print(\"F\");        // F means not connected to WiFi"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n  //KH\n#define HEARTBEAT_INTERVAL    20000L\n  // Print hearbeat every HEARTBEAT_INTERVAL (20) seconds.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + HEARTBEAT_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESPAsync_WiFi using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFI_MANAGER_LITE_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  ESPAsync_WiFiManager = new ESPAsync_WiFiManager_Lite();\n  String AP_SSID = \"your_customized_ssid\";\n  String AP_PWD  = \"your_customized_pwd\";\n  \n  // Set customized AP SSID and PWD\n  ESPAsync_WiFiManager->setConfigPortal(AP_SSID, AP_PWD);\n\n  // Optional to change default AP IP(192.168.4.1) and channel(10)\n  //ESPAsync_WiFiManager->setConfigPortalIP(IPAddress(192, 168, 120, 1));\n  ESPAsync_WiFiManager->setConfigPortalChannel(0);\n\n#if USING_CUSTOMS_STYLE\n  ESPAsync_WiFiManager->setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  ESPAsync_WiFiManager->setCustomsHeadElement(PSTR(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "ESPAsync_WiFiManager->run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "LOCAL_DEBUG",
      "keywords": [
        "EEPROM",
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n  {\n    if (ESPAsync_WiFiManager->isConfigMode())\n      Serial.print(\"C\");        // C means in Config Mode\n    else\n      Serial.print(\"F\");        // F means not connected to WiFi"
        },
        {
          "name": "publishMQTT",
          "body": "MQTT_connect();\n\n  if (Temperature->publish(measuredTemp))\n  {\n    //Serial.println(F(\"Failed to send value to Temperature feed!\"));\n    Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "subscribeMQTT",
          "body": "Adafruit_MQTT_Subscribe *subscription;\n\n  MQTT_connect();\n\n  while ((subscription = mqtt->readSubscription(5000)))\n  {\n    if (subscription == LED_Control)\n    {\n      Serial.print(F(\"\\nGot: \"));\n      Serial.println((char *)LED_Control->lastread);\n\n      if (!strcmp((char*) LED_Control->lastread, \"ON\"))\n      {\n        digitalWrite(LED_PIN, HIGH);"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n  //KH\n#define HEARTBEAT_INTERVAL    5000L\n  // Print WiFi hearbeat, Publish MQTT Topic every HEARTBEAT_INTERVAL (5) seconds.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      // MQTT related jobs\n      publishMQTT();\n      subscribeMQTT();"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n\n    if (client)\n    {\n      Serial.println(F(\"\\nCreating new WiFi client object OK\"));"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected())\n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  pinMode(LED_PIN, OUTPUT);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESPAsync_WiFi_MQTT using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFI_MANAGER_LITE_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  ESPAsync_WiFiManager = new ESPAsync_WiFiManager_Lite();\n\n  String AP_SSID = \"your_customized_ssid\";\n  String AP_PWD  = \"your_customized_pwd\";\n  \n  // Set customized AP SSID and PWD\n  ESPAsync_WiFiManager->setConfigPortal(AP_SSID, AP_PWD);\n\n  // Optional to change default AP IP(192.168.4.1) and channel(10)\n  //ESPAsync_WiFiManager->setConfigPortalIP(IPAddress(192, 168, 120, 1));\n  ESPAsync_WiFiManager->setConfigPortalChannel(0);\n\n#if USING_CUSTOMS_STYLE\n  ESPAsync_WiFiManager->setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  ESPAsync_WiFiManager->setCustomsHeadElement(PSTR(\"<style>html{filter: invert(10%);"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "ESPAsync_WiFiManager->run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoOTA.h",
        "FS.h",
        "SPIFFS.h",
        "ESPmDNS.h",
        "WiFi.h",
        "AsyncTCP.h",
        "ESP8266WiFi.h",
        "ESPAsyncTCP.h",
        "ESP8266mDNS.h",
        "ESPAsyncWebSrv.h",
        "SPIFFSEditor.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if(type == WS_EVT_CONNECT){\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n    client->printf(\"Hello Client %u :)\", client->id());\n    client->ping();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.setDebugOutput(true);\n  WiFi.mode(WIFI_AP_STA);\n  WiFi.softAP(hostName);\n  WiFi.begin(ssid, password);\n  if (WiFi.waitForConnectResult() != WL_CONNECTED) {\n    Serial.printf(\"STA: Failed!\\n\");\n    WiFi.disconnect(false);\n    delay(1000);\n    WiFi.begin(ssid, password);"
        },
        {
          "name": "loop",
          "body": "ArduinoOTA.handle();\n  ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "ESP_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay",
        "EEPROM",
        "analogRead"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "handleFileUpload",
          "body": "if (server.uri() != \"/edit\") \n  {\n    return;"
        },
        {
          "name": "handleFileDelete",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileCreate",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileList",
          "body": "if (!server.hasArg(\"dir\")) \n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// this is just for checking if we are alive and connected to WiFi\n  check_status();\n  \n  server.handleClient();\n  MDNS.update();"
        }
      ]
    },
    {
      "name": "ESP_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "handleFileUpload",
          "body": "if (server.uri() != \"/edit\") \n  {\n    return;"
        },
        {
          "name": "handleFileDelete",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileCreate",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileList",
          "body": "if (!server.hasArg(\"dir\")) \n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!DBG_OUTPUT_PORT);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP_FSWebServer_DRD with DoubleResetDetect using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // this is just for checking if we are alive and connected to WiFi\n  check_status();\n  \n  server.handleClient();\n  MDNS.update();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && !taskCompleted)\n  {\n    taskCompleted = true;\n\n    String ETag = \"\";\n    String wrong_ETag = \"ANY_WRONG_ETag\";\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int/data\", 100) ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK)\n    {\n      Serial.printf(\"ETag, %s\\n\\n\", fbdo.ETag().c_str());\n      ETag = fbdo.ETag();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "HardwareBLESerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (!bleSerial.beginAndSetupBLE(\"Echo\")) {\n    Serial.begin(9600);\n    while (true) {\n      Serial.println(\"failed to initialize HardwareBLESerial!\");\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "// this must be called regularly to perform BLE updates\n  bleSerial.poll();\n\n  while (bleSerial.availableLines() > 0) {\n    bleSerial.print(\"You said: \");\n    char line[128]; bleSerial.readLine(line, 128);\n    bleSerial.println(line);"
        }
      ]
    },
    {
      "name": "BOT_TOKEN",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "WiFiNINA.h",
        "UniversalTelegramBot.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "body": "for (int i = 0; i < numNewMessages; i++)\n  {\n    bot.sendMessage(bot.messages[i].chat_id, bot.messages[i].text, \"\");"
        },
        {
          "name": "printWiFiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);"
        }
      ]
    },
    {
      "name": "ADAFRUIT_CC3000_IRQ",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_CC3000.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(F(\"Hello, CC3000!\\n\")); \n\n  Serial.print(\"Free RAM: \"); Serial.println(getFreeRam(), DEC);\n  \n  /* Initialise the module */\n  Serial.println(F(\"\\nInitializing...\"));\n  if (!cc3000.begin())\n  {\n    Serial.println(F(\"Couldn't begin()! Check your wiring?\"));\n    while(1);"
        },
        {
          "name": "loop",
          "body": "// Try to get a client which is connected.\n  Adafruit_CC3000_ClientRef client = echoServer.available();\n  if (client) {\n     // Check if there is data available to read.\n     if (client.available() > 0) {\n       // Read a byte and write it to all clients.\n       uint8_t ch = client.read();\n       client.write(ch);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "stringCallback",
          "body": "Firmata.sendString(myString);"
        },
        {
          "name": "sysexCallback",
          "body": "Firmata.sendSysex(command, argc, argv);"
        },
        {
          "name": "setup",
          "body": "Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n  Firmata.attach(STRING_DATA, stringCallback);\n  Firmata.attach(START_SYSEX, sysexCallback);\n  Firmata.begin(57600);"
        },
        {
          "name": "loop",
          "body": "while (Firmata.available()) {\n    Firmata.processInput();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // Set the timeout\n  auto startNow = millis() + 2500;\n  while (!Serial && millis() < startNow);\n  Serial.println(\"Hello, Edge Control Sketch!\");\n\n  // Enable power lines \n  Power.enable3V3();\n  Power.enable5V();\n\n  // Start the I2C connection \n  Wire.begin();\n\n  // Initialize the expander pins \n  Expander.begin();\n  Expander.pinMode(EXP_LED1, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n    Serial.println(\"Blink\");\n    Expander.digitalWrite(EXP_LED1, LOW);\n    delay(500);\n    Expander.digitalWrite(EXP_LED1, HIGH);\n    delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "your-fomo-project_inferencing.h",
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/edgeimpulse/fomo.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"__EDGE IMPULSE FOMO (NO-PSRAM)__\");\n\n    // camera settings\n    // replace with your own model!\n    camera.pinout.aithinker();\n    camera.brownout.disable();\n    // NON-PSRAM FOMO only works on 96x96 (yolo) RGB565 images\n    camera.resolution.yolo();\n    camera.pixformat.rgb565();\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Put object in front of camera\");"
        },
        {
          "name": "loop",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(100);\n\n  BlynkEdgent.begin();"
        },
        {
          "name": "loop",
          "body": "BlynkEdgent.run();"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(100);\n\n  BlynkEdgent.begin();"
        },
        {
          "name": "loop",
          "body": "BlynkEdgent.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": []
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "BlynkEdgentNCP.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  // Give Serial Monitor some time to connect\n  delay(3000);\n\n  BLYNK_LOG(\"Main firmware: %s\", BLYNK_FIRMWARE_VERSION);\n  BLYNK_LOG(\"Build: %s\", __DATE__ \" \" __TIME__);\n\n  // Initialize the Blynk.NCP hardware\n  if (Blynk.initNCP()) {\n    String ver = Blynk.getNcpVersion();\n    BLYNK_LOG(\"Blynk.NCP firmware: %s\", ver.c_str());"
        },
        {
          "name": "loop",
          "body": "timer.run();\n  Blynk.run();\n  delay(1);"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(100);\n\n  BlynkEdgent.begin();"
        },
        {
          "name": "loop",
          "body": "BlynkEdgent.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial"
      ],
      "libraries": [
        "StreamUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize serial port\n  Serial.begin(9600);\n  while (!Serial)\n    continue;\n\n#if STREAMUTILS_ENABLE_EEPROM\n\n#if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)\n  Serial.println(\"Initializing EEPROM...\");\n  EEPROM.begin(512);\n#endif\n\n  Serial.println(\"Make sure to run the EepromWrite example first!\");\n\n  Serial.println(\"Reading EEPROM... \");\n  EepromStream s(0, 12);\n  Serial.print(s.readString());\n\n#else\n  Serial.println(\"EepromStream is not supported on this platform. Sorry\");\n#endif"
        },
        {
          "name": "loop",
          "body": "// not used in this example"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial"
      ],
      "libraries": [
        "StreamUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize serial port\n  Serial.begin(9600);\n  while (!Serial)\n    continue;\n\n#if STREAMUTILS_ENABLE_EEPROM\n\n#if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)\n  Serial.println(\"Initializing EEPROM...\");\n  EEPROM.begin(512);\n#endif\n\n  Serial.println(\"Writing to EEPROM...\");\n  EepromStream s(0, 12);\n  s.print(\"Hello World!\");\n\n#if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)\n  Serial.println(\"Saving...\");\n  s.flush();  // only required on ESP\n#endif\n\n  Serial.println(\"Done!\");\n  Serial.println(\"Now, run the EepromRead example.\");\n\n#else\n  Serial.println(\"EepromStream is not supported on this platform. Sorry\");\n#endif"
        },
        {
          "name": "loop",
          "body": "// not used in this example"
        }
      ]
    },
    {
      "name": "dscClassicSeries",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "dscKeybusInterface.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(1000);\n  Serial.println();\n  Serial.println();\n\n  Serial.print(F(\"WiFi....\"));\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(wifiSSID, wifiPassword);\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "// Updates status if WiFi drops and reconnects\n  if (!wifiConnected && WiFi.status() == WL_CONNECTED) {\n    Serial.println(\"WiFi reconnected\");\n    wifiConnected = true;\n    dsc.pauseStatus = false;\n    dsc.statusChanged = true;"
        },
        {
          "name": "appendPartition",
          "body": "char partitionNumber[2];\n  itoa(sourceNumber + 1, partitionNumber, 10);\n  strcat(messageContent, partitionNumber);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = \"/UsersData/\";\n        path += auth.token.uid.c_str(); //<- user uid of current user that sign in with Emal/Password\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());\n\n        // You can use refresh token from Firebase.getRefreshToken() to sign in next time without providing Email and Password.\n        // See SignInWithRefreshIDToken example."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "EEPROM_EMULATION_SIZE",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EmulatedEEPROM on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  // Check signature at address 0\n  int signature;\n\n  EEPROM.get(0, signature);\n\n  // If the EEPROM is empty then no WRITTEN_SIGNATURE\n  if (signature != WRITTEN_SIGNATURE)\n  {\n    Serial.println(\"EEPROM is empty, writing WRITTEN_SIGNATURE and some example data:\");\n\n    EEPROM.put(0, WRITTEN_SIGNATURE);\n\n    Serial.print(\"->\");\n\n    for (int i = sizeof(WRITTEN_SIGNATURE); i < 20; i++)\n    {\n      EEPROM.write(i, 100 + i);\n      Serial.print(\" \");\n      Serial.print(100 + i);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/viz/mjpeg.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"__RE-ENCODE MJPEG STREAM__\");\n\n    // camera settings\n    // replace with your own model!\n    camera.pinout.aithinker();\n    camera.brownout.disable();\n    // higher resolution cannot be handled\n    camera.resolution.qvga();\n    camera.quality.best();\n\n    // since we want to access the raw pixels\n    // capture in RGB565 format\n    // keep in mind that you need a lot of RAM to store\n    // all this data at high resolutions\n    // (e.g. QVGA = 320 x 240 x 2 = 1536 kB)\n    camera.pixformat.rgb565();\n\n    // MJPEG settings\n    mjpeg.onFrame(&reencode_frame);\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    // connect to WiFi\n    while (!wifi.connect().isOk())\n        Serial.println(wifi.exception.toString());\n\n    // start mjpeg http server\n    while (!mjpeg.begin().isOk())\n        Serial.println(mjpeg.exception.toString());\n\n    // assert camera can capture frames\n    while (!camera.capture().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"ToF OK\");\n    Serial.println(\"WiFi OK\");\n    Serial.println(\"MjpegStream OK\");\n    Serial.println(mjpeg.address());"
        },
        {
          "name": "loop",
          "body": "// nothing to do here, MJPEG server runs in background"
        },
        {
          "name": "reencode_frame",
          "body": "// log how much time elapsed from last frame\n    const size_t now = millis();\n    const uint16_t height = camera.resolution.getHeight();\n    const uint16_t width = camera.resolution.getWidth();\n\n    ESP_LOGI(\"benchmark\", \"%d ms elapsed from last frame\", now - tick);\n    tick = now;\n\n    // frame->buf contains RGB565 data\n    // that is, 2 bytes per pixel\n    //\n    // in this test, we're going to do a \"negative\" effect\n    // feel free to replace this with your own code\n    for (uint16_t y = 0; y < height; y++) {\n        uint16_t *row = (uint16_t*) (frame->buf + width * 2 * y);\n\n        for (uint16_t x = 0; x < width; x++) {\n            // read pixel and parse to R, G, B components\n            const uint16_t pixel = row[x];\n            uint16_t r = (pixel >> 11) & 0b11111;\n            uint16_t g = (pixel >> 5) & 0b111111;\n            uint16_t b = pixel & 0b11111;\n\n            // actual work: make negative\n            r = 31 - r;\n            g = 63 - g;\n            b = 31 - b;\n\n            // re-pack to RGB565\n            row[x] = (r << 11) | (g << 5) | b;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoMotorCarrier.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Establishing the communication with the Motor Carrier\n  if (controller.begin())\n  {\n    Serial.print(\"Motor Carrier connected, firmware version \");\n    Serial.println(controller.getFWVersion());"
        },
        {
          "name": "loop",
          "body": "//Chose the encoder to use:encoder1(default) or encoder2\n  Serial.print(\"Encoder1 Pos [counts]: \");\n  Serial.print(encoder1.getRawCount());\n  Serial.print(\" Encoder1 vel [counts/sec]: \");\n  Serial.println(encoder1.getCountPerSecond());\n  Serial.print(\"Encoder2 Pos [counts]: \");\n  Serial.print(encoder2.getRawCount());\n  Serial.print(\" Encoder2 vel [counts/sec]: \");\n  Serial.println(encoder2.getCountPerSecond());\n  Serial.println(\"\");\n\n  //Keep active the communication between Nano & Motor Carrier\n  //Ping the SAMD11\n  controller.ping();\n  //wait\n  delay(50);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.print(\"Encoder 0 State: \");\n  Serial.println(encoders[0].getCurrentState(),BIN);\n  Serial.print(\"Encoder 0 Pulses: \");\n  Serial.println(encoders[0].getPulses());\n  Serial.print(\"Encoder 0 Revolutions: \");\n  Serial.println(encoders[0].getRevolutions());\n  Serial.println();\n \n  Serial.print(\"Encoder 1 State: \");\n  Serial.println(encoders[1].getCurrentState(),BIN);\n  Serial.print(\"Encoder 1 Pulses: \");\n  Serial.println(encoders[1].getPulses());\n  Serial.print(\"Encoder 1 Revolutions: \");\n  Serial.println(encoders[1].getRevolutions());\n  Serial.println();\n  delay(25);"
        }
      ]
    },
    {
      "name": "PAIR_BUTTON",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "analogRead"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);    // initialize serial communication\n  while (!Serial);\n\n  pinMode(CTRL_LED, OUTPUT); // initialize the built-in LED pin to indicate when a central is connected\n  pinMode(PAIR_LED, OUTPUT);\n  pinMode(PAIR_BUTTON, INPUT_PULLUP);\n\n\n  Serial.println(\"Serial connected\");\n  \n  // Callback function with confirmation code when new device is pairing.\n  BLE.setDisplayCode([](uint32_t confirmCode){\n    Serial.println(\"New device pairing request.\");\n    Serial.print(\"Confirm code matches pairing device: \");\n    char code[6];\n    sprintf(code, \"%06d\", confirmCode);\n    Serial.println(code);"
        },
        {
          "name": "loop",
          "body": "// wait for a BLE central\n  BLEDevice central = BLE.central();\n\n\n  // If button is pressed, allow pairing for 30 sec\n  if (!BLE.pairable() && digitalRead(PAIR_BUTTON) == LOW){\n    pairingStarted = millis();\n    BLE.setPairable(Pairable::ONCE);\n    Serial.println(\"Accepting pairing for 30s\");"
        },
        {
          "name": "updateBatteryLevel",
          "body": "/* Read the current voltage level on the A0 analog input pin.\n     This is used here to simulate the charge level of a battery.\n  */\n  int battery = analogRead(A0);\n  int batteryLevel = map(battery, 0, 1023, 0, 100);\n\n  if (batteryLevel != oldBatteryLevel) {      // if the battery level has changed\n    // Serial.print(\"Battery Level % is now: \"); // print it\n    // Serial.println(batteryLevel);\n    batteryLevelChar.writeValue(batteryLevel);  // and update the battery level characteristic\n    oldBatteryLevel = batteryLevel;           // save the level for next comparison"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": []
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": []
    },
    {
      "name": "BLYNK_DEBUG",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BLE.h",
        "BlynkSimpleSerialBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  ble.setLogLevel(BLE_LOG_ERRORS);\n  ble.begin();\n  ble.serial();\n  ble.setAdvertName(\"Blynk BLE\");\n  ble.startAdvert();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(ble, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Ethernet.h",
        "BlynkSimpleEnergiaEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, \"blynk-cloud.com\", 80);\n  //Blynk.begin(auth, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial1.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi.h",
        "BlynkSimpleEnergiaWiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 80);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!BLE.begin()) {\n    Serial.println(\"failed to initialize BLE!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "BLE.poll();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RTCZero.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  rtc.begin(); // initialize RTC\n\n  rtc.setEpoch(1451606400); // Jan 1, 2016"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"Unix time = \");\n  Serial.println(rtc.getEpoch());\n\n  Serial.print(\"Seconds since Jan 1 2000 = \");\n  Serial.println(rtc.getY2kEpoch());\n\n  // Print date...\n  Serial.print(rtc.getDay());\n  Serial.print(\"/\");\n  Serial.print(rtc.getMonth());\n  Serial.print(\"/\");\n  Serial.print(rtc.getYear());\n  Serial.print(\"\\t\");\n\n  // ...and time\n  print2digits(rtc.getHours());\n  Serial.print(\":\");\n  print2digits(rtc.getMinutes());\n  Serial.print(\":\");\n  print2digits(rtc.getSeconds());\n\n  Serial.println();\n\n  delay(1000);"
        },
        {
          "name": "print2digits",
          "body": "if (number < 10) {\n    Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SerialFlash.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//uncomment these if using Teensy audio shield\n  //SPI.setSCK(14);  // Audio shield has SCK on pin 14\n  //SPI.setMOSI(7);  // Audio shield has MOSI on pin 7\n\n  //uncomment these if you have other SPI chips connected\n  //to keep them disabled while using only SerialFlash\n  //pinMode(4, INPUT_PULLUP);\n  //pinMode(10, INPUT_PULLUP);\n\n  Serial.begin(9600);\n\n  // wait up to 10 seconds for Arduino Serial Monitor\n  unsigned long startMillis = millis();\n  while (!Serial && (millis() - startMillis < 10000)) ;\n  delay(100);\n\n  SerialFlash.begin(FlashChipSelect);\n  unsigned char id[5];\n  SerialFlash.readID(id);\n  unsigned long size = SerialFlash.capacity(id);\n\n  if (size > 0) {\n    Serial.print(\"Flash Memory has \");\n    Serial.print(size);\n    Serial.println(\" bytes.\");\n    Serial.println(\"Erasing ALL Flash Memory:\");\n    // Estimate the (lengthy) wait time.\n    Serial.print(\"  estimated wait: \");\n    int seconds = (float)size / eraseBytesPerSecond(id) + 0.5;\n    Serial.print(seconds);\n    Serial.println(\" seconds.\");\n    Serial.println(\"  Yes, full chip erase is SLOW!\");\n    SerialFlash.eraseAll();\n    unsigned long dotMillis = millis();\n    unsigned char dotcount = 0;\n    while (SerialFlash.ready() == false) {\n      if (millis() - dotMillis > 1000) {\n        dotMillis = dotMillis + 1000;\n        Serial.print(\".\");\n        dotcount = dotcount + 1;\n        if (dotcount >= 60) {\n          Serial.println();\n          dotcount = 0;"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite"
      ],
      "libraries": [
        "MIDI.h"
      ],
      "functions": [
        {
          "name": "handleError",
          "body": "digitalWrite(LED_BUILTIN, (err == 0)? LOW : HIGH);"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  MIDI.setHandleError(handleError);\n  MIDI.begin(1);"
        },
        {
          "name": "loop",
          "body": "MIDI.read();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "CanSatKit.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "SerialUSB.begin(115200);\n\n  // radio.begin() returns true if communication with radio module\n  // onboard is correct\n  bool ok = radio.begin();\n\n  if (ok) {\n      // print that radio is ok\n      SerialUSB.println(\"Radio OK!\");\n      // stop printing radio debug to SerialUSB since everything is OK\n      radio.disable_debug();"
        },
        {
          "name": "loop",
          "body": "// CanSatKitRadio.transmit returns true if there is enough space in\n  // radio transmission buffer\n  bool ok = radio.transmit(\"Hello World!\");\n\n  if (!ok) {\n      // if CanSatKitRadio.transmit returned false -- print that buffer is full\n      // to prevent from buffer overflow - increase delay or send less data...\n      SerialUSB.println(\"Transmit buffer full!\");"
        }
      ]
    },
    {
      "name": "CUR_VERSION",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Servo.h",
        "menu.h",
        "menuIO/esp8266Out.h",
        "menuIO/xmlFmt.h",
        "menuIO/serialIn.h",
        "menuIO/xmlFmt.h",
        "menuIO/jsonFmt.h",
        "streamFlow.h",
        "Streaming.h",
        "menuIO/jsFmt.h",
        "FS.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "body": "switch(type) {\n    case WStype_DISCONNECTED:\n      //USE_SERIAL.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n    case WStype_CONNECTED: {\n        IPAddress ip = webSocket.remoteIP(num);\n        //USE_SERIAL.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n        webSocket.sendTXT(num, \"console.log('ArduinoMenu Connected')\");"
        },
        {
          "name": "pageStart",
          "body": "_trace(Serial<<\"pasgeStart!\"<<endl);\n  serverOut<<\"HTTP/1.1 200 OK\\r\\n\"\n    <<\"Content-Type: text/xml\\r\\n\"\n    <<\"Connection: close\\r\\n\"\n    <<\"Expires: 0\\r\\n\"\n    <<\"\\r\\n\";\n  serverOut<<\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\r\\n\"\n    \"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\";\n  serverOut<<xslt;\n  serverOut<<CUR_VERSION\"/device.xslt\";\n  serverOut<<\"\\\"?>\\r\\n<menuLib\"\n    #ifdef WEB_DEBUG\n      <<\" debug=\\\"yes\\\"\"\n    #endif\n    <<\" host=\\\"\";\n    serverOut.print(APName);\n    serverOut<<\"\\\">\\r\\n<sourceURL ver=\\\"\" CUR_VERSION \"/\\\">\";\n  if (server.hasHeader(\"host\"))\n    serverOut.print(server.header(\"host\"));\n  else\n    serverOut.print(APName);\n  serverOut<<\"</sourceURL>\";"
        },
        {
          "name": "pageEnd",
          "body": "serverOut<<\"</menuLib>\";\n  server.client().stop();"
        },
        {
          "name": "jsonStart",
          "body": "_trace(Serial<<\"jsonStart!\"<<endl);\n  serverOut<<\"HTTP/1.1 200 OK\\r\\n\"\n    <<\"Content-Type: application/json; charset=utf-8\\r\\n\"\n    <<\"Connection: close\\r\\n\"\n    <<\"Expires: 0\\r\\n\"\n    <<\"\\r\\n\";"
        },
        {
          "name": "jsonEnd",
          "body": "server.client().stop();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  myservo.attach(ESCPIN);\n\n  webNav.canExit=false;\n  jsonNav.canExit=false;\n  wsNav.canExit=false;\n\n  for(uint8_t t = 4; t > 0; t--) {\n      Serial.printf(\"[SETUP] BOOT WAIT %d...\\n\", t);\n      Serial.flush();\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "wsOut.response.remove(0);//clear websocket json buffer\n  webSocket.loop();\n  server.handleClient();\n  delay(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    // Connect to wifi\n    WiFi.begin(ssid, password);\n\n    // Wait some time to connect to wifi\n    for(int i = 0; i < 10 && WiFi.status() != WL_CONNECTED; i++) {\n        Serial.print(\".\");\n        delay(1000);"
        },
        {
          "name": "loop",
          "body": "// let the websockets client check for incoming messages\n    if(client.available()) {\n        client.poll();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  // Connect to wifi\n  WiFi.begin(ssid, password);\n\n  // Wait some time to connect to wifi\n  for(int i = 0; i < 15 && WiFi.status() != WL_CONNECTED; i++) {\n      Serial.print(\".\");\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "WebsocketsClient client = server.accept();\n  if(client.available()) {\n    WebsocketsMessage msg = client.readBlocking();\n\n    // log\n    Serial.print(\"Got Message: \");\n    Serial.println(msg.data());\n\n    // return echo\n    client.send(\"Echo: \" + msg.data());\n\n    // close the connection\n    client.close();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  WiFi.begin(ssid, pass);\n  while (WiFi.status() != WL_CONNECTED) Serial.print(\".\"), delay(300);\n  Serial.print(\"\\nConnected, IP address: \");\n  Serial.println(WiFi.localIP());\n\n  JS.begin();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "ESP8266WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    // Connect to wifi\n    WiFi.begin(ssid, password);\n\n    // Wait some time to connect to wifi\n    for(int i = 0; i < 10 && WiFi.status() != WL_CONNECTED; i++) {\n        Serial.print(\".\");\n        delay(1000);"
        },
        {
          "name": "loop",
          "body": "// let the websockets client check for incoming messages\n    if(client.available()) {\n        client.poll();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "ESP8266WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  // Connect to wifi\n  WiFi.begin(ssid, password);\n\n  // Wait some time to connect to wifi\n  for(int i = 0; i < 15 && WiFi.status() != WL_CONNECTED; i++) {\n      Serial.print(\".\");\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "WebsocketsClient client = server.accept();\n  if(client.available()) {\n    WebsocketsMessage msg = client.readBlocking();\n\n    // log\n    Serial.print(\"Got Message: \");\n    Serial.println(msg.data());\n\n    // return echo\n    client.send(\"Echo: \" + msg.data());\n\n    // close the connection\n    client.close();"
        }
      ]
    },
    {
      "name": "BAUD",
      "keywords": [
        "Wire",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h",
        "UnoWiFiDevEd.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(BAUD);\n  pinMode(13, OUTPUT);\n  digitalWrite(13, LOW);\n\n  ESPSerial.begin(BAUD);"
        },
        {
          "name": "loop",
          "body": "while (Serial.available()) {\n    char inChar = (char)Serial.read();\n    ESPSerial.write(inChar);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);        // initialize serial communications with your computer"
        },
        {
          "name": "loop",
          "body": "int xAxis = Esplora.readAccelerometer(X_AXIS);    // read the X axis\n  int yAxis = Esplora.readAccelerometer(Y_AXIS);    // read the Y axis\n  int zAxis = Esplora.readAccelerometer(Z_AXIS);    // read the Z axis\n\n  Serial.print(\"x: \");      // print the label for X\n  Serial.print(xAxis);      // print the value for the X axis\n  Serial.print(\"\\ty: \");    // print a tab character, then the label for Y\n  Serial.print(yAxis);      // print the value for the Y axis\n  Serial.print(\"\\tz: \");    // print a tab character, then the label for Z\n  Serial.println(zAxis);    // print the value for the Z axis\n\n  delay(500);              // wait half a second (500 milliseconds)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// There's nothing to set up for this sketch"
        },
        {
          "name": "loop",
          "body": "Esplora.writeRGB(255, 0, 0);  // make the LED red\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(0, 255, 0);  // make the LED green\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(0, 0, 255);  // make the LED blue\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(255, 255, 0); // make the LED yellow\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(0, 255, 255); // make the LED cyan\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(255, 0, 255); // make the LED magenta\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(255, 255, 255); // make the LED white\n  delay(1000);                  // wait 1 second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);       // initialize serial communication with your computer\n  Mouse.begin();            // take control of the mouse"
        },
        {
          "name": "loop",
          "body": "int xValue = Esplora.readJoystickX();        // read the joystick's X position\n  int yValue = Esplora.readJoystickY();        // read the joystick's Y position\n  int button = Esplora.readJoystickSwitch();   // read the joystick pushbutton\n  Serial.print(\"Joystick X: \");                // print a label for the X value\n  Serial.print(xValue);                        // print the X value\n  Serial.print(\"\\tY: \");                       // print a tab character and a label for the Y value\n  Serial.print(yValue);                        // print the Y value\n  Serial.print(\"\\tButton: \");                  // print a tab character and a label for the button\n  Serial.print(button);                        // print the button value\n\n  int mouseX = map(xValue, -512, 512, 10, -10);  // map the X value to a range of movement for the mouse X\n  int mouseY = map(yValue, -512, 512, -10, 10);  // map the Y value to a range of movement for the mouse Y\n  Mouse.move(mouseX, mouseY, 0);                 // move the mouse\n\n  if (button == 0) {                           // if the joystick button is pressed\n    Mouse.press();                             // send a mouse click"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Keyboard.begin();"
        },
        {
          "name": "loop",
          "body": "// Iterate through all the buttons:\n  for (byte thisButton = 0; thisButton < 8; thisButton++) {\n    boolean lastState = buttonStates[thisButton];\n    boolean newState = Esplora.readButton(buttons[thisButton]);\n    if (lastState != newState) { // Something changed!\n      /*\n        The Keyboard library allows you to \"press\" and \"release\" the\n        keys as two distinct actions. These actions can be\n        linked to the buttons we're handling.\n       */\n      if (newState == PRESSED) {\n        Keyboard.press(keystrokes[thisButton]);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// read the sensors into variables:\n  int xAxis = Esplora.readJoystickX();\n  int yAxis = Esplora.readJoystickY();\n  int slider = Esplora.readSlider();\n\n  // convert the sensor readings to light levels:\n  byte red   = map(xAxis, -512, 512, 0, 255);\n  byte green = map(yAxis, -512, 512, 0, 255);\n  byte blue  = slider / 4;\n\n  // print the light levels:\n  Serial.print(red);\n  Serial.print(' ');\n  Serial.print(green);\n  Serial.print(' ');\n  Serial.println(blue);\n\n  // write the light levels to the LED.\n  Esplora.writeRGB(red, green, blue);\n\n  // add a delay to keep the LED from flickering:\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// read the sensors into variables:\n  int mic = Esplora.readMicrophone();\n  int light = Esplora.readLightSensor();\n  int slider = Esplora.readSlider();\n\n  // convert the sensor readings to light levels:\n  byte red   = constrain(mic, 0, 255);\n  byte green = constrain(\n                 map(light, lowLight, highLight, minGreen, maxGreen),\n                 0, 255);\n  byte blue  = slider / 4;\n\n  // print the light levels (to see what's going on):\n  Serial.print(red);\n  Serial.print(' ');\n  Serial.print(green);\n  Serial.print(' ');\n  Serial.println(blue);\n\n  // write the light levels to the LED.\n  // note that the green value is always 0:\n  Esplora.writeRGB(red, green, blue);\n\n  // add a delay to keep the LED from flickering:\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);\n\n  // print an intial message\n  Serial.println(\"To calibrate the light sensor, press and hold Switch 1\");"
        },
        {
          "name": "loop",
          "body": "// if switch 1 is pressed, go to the calibration function again:\n  if (Esplora.readButton(1) == LOW) {\n    calibrate();"
        },
        {
          "name": "calibrate",
          "body": "// tell the user what do to using the serial monitor:\n  Serial.println(\"While holding switch 1, shine a light on the light sensor, then cover it.\");\n\n  // calibrate while switch 1 is pressed:\n  while (Esplora.readButton(1) == LOW) {\n    // read the sensor value:\n    int light  = Esplora.readLightSensor();\n\n    // record the maximum sensor value:\n    if (light > lightMax) {\n      lightMax = light;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": ""
        },
        {
          "name": "loop",
          "body": "// read the button labeled SWITCH_DOWN. If it's low,\n  // then play a note:\n  if (Esplora.readButton(SWITCH_DOWN) == LOW) {\n    int slider = Esplora.readSlider();\n\n    // use map() to map the slider's range to the\n    // range of notes you have:\n    byte thisNote = map(slider, 0, 1023, 0, 13);\n    // play the note corresponding to the slider's position:\n    Esplora.tone(note[thisNote]);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);     // initialize serial communication"
        },
        {
          "name": "loop",
          "body": "// read the slider and three of the buttons\n  int slider = Esplora.readSlider();\n  int resetButton = Esplora.readButton(SWITCH_1);\n  int serveButton = Esplora.readButton(SWITCH_3);\n  int switchPlayerButton = Esplora.readButton(SWITCH_4);\n\n  Serial.print(slider);                // print the slider value\n  Serial.print(\",\");                   // add a comma\n  Serial.print(resetButton);           // print the reset button value\n  Serial.print(\",\");                   // add another comma\n  Serial.print(serveButton);           // print the serve button value\n  Serial.print(\",\");                   // add another comma\n  Serial.println(switchPlayerButton);  // print the last button with a newline\n  delay(10);                           // delay before sending the next set"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "while (!Serial); // needed for Leonardo-based board like Esplora\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "if (Serial.available())\n    parseCommand();"
        },
        {
          "name": "parseCommand",
          "body": "char cmd = Serial.read();\n  switch (cmd) {\n    case 'D':\n      dumpInputs();\n      break;\n    case 'R':\n      setRed();\n      break;\n    case 'G':\n      setGreen();\n      break;\n    case 'B':\n      setBlue();\n      break;\n    case 'T':\n      setTone();\n      break;"
        },
        {
          "name": "dumpInputs",
          "body": "Serial.print(Esplora.readButton(SWITCH_1));\n  Serial.print(',');\n  Serial.print(Esplora.readButton(SWITCH_2));\n  Serial.print(',');\n  Serial.print(Esplora.readButton(SWITCH_3));\n  Serial.print(',');\n  Serial.print(Esplora.readButton(SWITCH_4));\n  Serial.print(',');\n  Serial.print(Esplora.readSlider());\n  Serial.print(',');\n  Serial.print(Esplora.readLightSensor());\n  Serial.print(',');\n  Serial.print(Esplora.readTemperature(DEGREES_C));\n  Serial.print(',');\n  Serial.print(Esplora.readMicrophone());\n  Serial.print(',');\n  Serial.print(Esplora.readJoystickSwitch());\n  Serial.print(',');\n  Serial.print(Esplora.readJoystickX());\n  Serial.print(',');\n  Serial.print(Esplora.readJoystickY());\n  Serial.print(',');\n  Serial.print(Esplora.readAccelerometer(X_AXIS));\n  Serial.print(',');\n  Serial.print(Esplora.readAccelerometer(Y_AXIS));\n  Serial.print(',');\n  Serial.print(Esplora.readAccelerometer(Z_AXIS));\n  Serial.println();"
        },
        {
          "name": "setRed",
          "body": "Esplora.writeRed(Serial.parseInt());"
        },
        {
          "name": "setGreen",
          "body": "Esplora.writeGreen(Serial.parseInt());"
        },
        {
          "name": "setBlue",
          "body": "Esplora.writeBlue(Serial.parseInt());"
        },
        {
          "name": "setTone",
          "body": "Esplora.tone(Serial.parseInt());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// read the sensor into a variable:\n  int loudness = Esplora.readMicrophone();\n\n  // map the sound level to a brightness level for the LED:\n  int brightness = map(loudness, 0, 1023, 0, 255);\n  // write the brightness to the green LED:\n  Esplora.writeGreen(brightness);\n\n\n  // print the microphone levels and the LED levels (to see what's going on):\n  Serial.print(\"sound level: \");\n  Serial.print(loudness);\n  Serial.print(\" Green brightness: \");\n  Serial.println(brightness);\n  // add a delay to keep the LED from flickering:\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Keyboard.begin();\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "/*\n   * note: we don't use Arduino's delay() here, because we can't\n   * normally do anything while delaying. Our own version lets us\n   * check for button presses often enough to not miss any event.\n   */\n  activeDelay(50);\n\n  /*\n   * the justActivated variable may be set to true in the\n   * checkSwitchPress() function. Here we check its status to\n   * print the table headers and configure what's needed to.\n   */\n  if (justActivated == true) {\n    justActivated = false; // do this just once\n    printHeaders();\n    // do next sampling ASAP\n    nextSampleAt = startedAt = millis();"
        },
        {
          "name": "printHeaders",
          "body": "Keyboard.print(\"Time\");\n  Keyboard.write(KEY_TAB);\n  activeDelay(300); // Some spreadsheets are slow, e.g. Google\n  // Drive that wants to save every edit.\n  Keyboard.print(\"Accel X\");\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(\"Accel Y\");\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(\"Accel Z\");\n  Keyboard.println();\n  activeDelay(300);"
        },
        {
          "name": "logAndPrint",
          "body": "// do all the samplings at once, because keystrokes have delays\n  unsigned long timeSecs = (millis() - startedAt) / 1000;\n  int xAxis = Esplora.readAccelerometer(X_AXIS);\n  int yAxis = Esplora.readAccelerometer(Y_AXIS);\n  int zAxis = Esplora.readAccelerometer(Z_AXIS);\n\n  Esplora.writeRed(100);\n\n  Keyboard.print(timeSecs);\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(xAxis);\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(yAxis);\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(zAxis);\n  Keyboard.println();\n  activeDelay(300);\n  Keyboard.write(KEY_HOME);\n\n  Esplora.writeRed(0);"
        },
        {
          "name": "activeDelay",
          "body": "unsigned long at = millis() + amount;\n  while (millis() < at) {\n    checkSwitchPress();"
        },
        {
          "name": "checkSwitchPress",
          "body": "boolean startBtn = Esplora.readButton(SWITCH_DOWN);\n\n  if (startBtn != lastStartBtn) {\n    if (startBtn == HIGH) { // button released\n      active = !active;\n      if (active)\n        justActivated = true;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);      // initialize serial communications with your computer"
        },
        {
          "name": "loop",
          "body": "// read the temperature sensor in Celsius, then Fahrenheit:\n  int celsius = Esplora.readTemperature(DEGREES_C);\n  int fahrenheit = Esplora.readTemperature(DEGREES_F);\n\n  // print the results:\n  Serial.print(\"Temperature is: \");\n  Serial.print(celsius);\n  Serial.print(\" degrees Celsius, or \");\n  Serial.print(fahrenheit);\n  Serial.println(\" degrees Fahrenheit.\");\n  Serial.println(\"     Fahrenheit = (9/5 * Celsius) + 32\");\n\n  // wait a second before reading again:\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    while (!Serial)\n        ;\n\n    Serial.println(\"Ethernet example for H7 + PMC\");\n\n    // Bring up the ethernet interface\n    net.connect();\n\n    // Show the network address\n    SocketAddress addr;\n    net.get_ip_address(&addr);\n    Serial.print(\"IP address: \");\n    Serial.println(addr.get_ip_address() ? addr.get_ip_address() : \"None\");\n\n    // Open a socket on the network interface, and create a TCP connection to mbed.org\n    TCPSocket socket;\n    socket.open(&net);\n\n    net.gethostbyname(\"ifconfig.io\", &addr);\n    addr.set_port(80);\n    socket.connect(addr);\n\n    String request;\n    request += \"GET / HTTP/1.1\\r\\n\";\n    request += \"Host: ifconfig.io\\r\\n\";\n    request += \"User-Agent: curl/7.64.1\\r\\n\";\n    request += \"Accept: */*\\r\\n\";\n    request += \"Connection: close\\r\\n\";\n    request += \"\\r\\n\";\n\n    auto scount = socket.send(request.c_str(), request.length());\n    Serial.print(\"Sent \");\n    Serial.print(scount);\n    Serial.println(\" bytes: \");\n    Serial.print(request);\n\n    // Receive a simple HTTP response\n    const size_t rlen { 64"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BUTTON_PIN",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "attachInterrupt"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "body": "//isButtonPressed = !digitalRead(BUTTON_PIN); // Invert state, since button is \"Active LOW\"\n\n  if ( !isButtonPressed && !digitalRead(BUTTON_PIN)) // You can write any condition to trigger e-mail sending\n  {\n    isButtonPressed = true;\n    count++;\n    Serial.println(\"Button pressed\");"
        },
        {
          "name": "processButton",
          "body": "// *** WARNING: You are limited to send ONLY ONE E-MAIL PER 5 SECONDS! ***\n  // Let's send an e-mail when you press the button\n  // connected to digital pin BUTTON_PIN (2) on your Arduino\n  static String body;\n\n  if (isButtonPressed) // You can write any condition to trigger e-mail sending\n  {\n    body = String(\"You pushed the button \") + count + \" times.\";\n\n    // This can be seen in the Serial Monitor\n    Serial.println(body);\n\n    Blynk.email(\"your_email@gmail.com\", \"Subject: Button Logger\", body);\n\n    isButtonPressed = false;"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_Email on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_RP2040 on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n\n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n  #if USE_LOCAL_SERVER\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #else\n    //Blynk.begin(auth);\n    // You can also specify server:\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(BlynkServer);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_SAMD on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_SAM_DUE on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart W5500_Blynk_Teensy on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#else\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_nRF52 on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "DHT_PIN",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_WM_Config on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  dht.begin();\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "ArduinoRS485.h",
        "ArduinoModbus.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "if (!modbusTCPClient.connected()) {\n    // client not connected, start the Modbus TCP client\n    Serial.println(\"Attempting to connect to Modbus TCP server\");\n    \n    if (!modbusTCPClient.begin(server, 502)) {\n      Serial.println(\"Modbus TCP Client failed to connect!\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "ArduinoRS485.h",
        "ArduinoModbus.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// listen for incoming clients\n  EthernetClient client = ethServer.available();\n  \n  if (client) {\n    // a new client connected\n    Serial.println(\"new client\");\n\n    // let the Modbus TCP accept the connection \n    modbusTCPServer.accept(client);\n\n    while (client.connected()) {\n      // poll for Modbus TCP requests, while client connected\n      modbusTCPServer.poll();\n\n      // update the LED\n      updateLED();"
        },
        {
          "name": "updateLED",
          "body": "// read the current value of the coil\n  int coilValue = modbusTCPServer.coilRead(0x00);\n\n  if (coilValue) {\n    // coil value set, turn LED on\n    digitalWrite(ledPin, HIGH);"
        }
      ]
    },
    {
      "name": "API_KEY",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "Ethernet.h",
        "FirebaseClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n    ssl_client.setClient(&eth);\n\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    printResult(aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "MULTIPLY_FACTOR",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "createPage",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>EthernetWebServer_BigData-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleRoot",
          "body": "//out.reserve(STRING_SIZE);\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < (100 * MULTIPLY_FACTOR); lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"WiFiWebServer_BigData_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "initEthernet",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if ( defined( ESP32 )  && USE_ETHERNET_GENERIC )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    SerialDebug.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware"
        },
        {
          "name": "setup",
          "body": "out.reserve(STRING_SIZE);\n\n  //Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EthernetWebServer_BigData on \"));\n  SerialDebug.print(BOARD_NAME);\n  SerialDebug.print(F(\" with \"));\n  SerialDebug.println(SHIELD_TYPE);\n  SerialDebug.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));"
        },
        {
          "name": "loop",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Keypad.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    pinMode(ledPin, OUTPUT);              // Sets the digital pin as output.\n    digitalWrite(ledPin, HIGH);           // Turn the LED on.\n    ledPin_state = digitalRead(ledPin);   // Store initial LED state. HIGH when LED is on.\n    keypad.addEventListener(keypadEvent); // Add an event listener for this keypad"
        },
        {
          "name": "loop",
          "body": "char key = keypad.getKey();\n\n    if (key) {\n        Serial.println(key);"
        },
        {
          "name": "keypadEvent",
          "body": "switch (keypad.getState()){\n    case PRESSED:\n        if (key == '#') {\n            digitalWrite(ledPin,!digitalRead(ledPin));\n            ledPin_state = digitalRead(ledPin);        // Remember LED state, lit or unlit."
        }
      ]
    },
    {
      "name": "BUTTON_PIN",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    pinMode(BUTTON_PIN, INPUT_PULLUP);"
        },
        {
          "name": "loop",
          "body": "if (digitalRead(BUTTON_PIN) == LOW) {\n        // stores button click time in the buffer, appending after the last element\n        buffer.push(millis());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SigFox.h",
        "ArduinoLowPower.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (debug == true) {\n\n    // We are using Serial1 instead of Serial because we are going into standby\n    // and the USB port could get confused during wakeup. To read the debug prints,\n    // connect pins 13-14 (TX-RX) to a 3.3 V USB-to-serial converter\n\n    Serial1.begin(115200);\n    while (!Serial1) {"
        },
        {
          "name": "loop",
          "body": "// Sleep until an event is recognized\n  LowPower.sleep();\n\n  // if we get here it means that an event was received\n\n  SigFox.begin();\n\n  if (debug == true) {\n    Serial1.println(\"Alarm event on sensor \" + String(alarm_source));"
        },
        {
          "name": "alarmEvent1",
          "body": "alarm_source = 1;"
        },
        {
          "name": "alarmEvent2",
          "body": "alarm_source = 2;"
        },
        {
          "name": "reboot",
          "body": "NVIC_SystemReset();\n  while (1);"
        }
      ]
    },
    {
      "name": "SD_FAT_TYPE",
      "keywords": [
        "Serial",
        "analogRead",
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "logRecord",
          "body": "if (overrun) {\n    // Add one since this record has no adc data. Could add overrun field.\n    overrun++;\n    data->adc[0] = 0X8000 | overrun;"
        },
        {
          "name": "printRecord",
          "body": "static uint32_t nr = 0;\n  if (!data) {\n    pr->print(F(\"LOG_INTERVAL_USEC,\"));\n    pr->println(LOG_INTERVAL_USEC);\n    pr->print(F(\"rec#\"));\n    for (size_t i = 0; i < ADC_COUNT; i++) {\n      pr->print(F(\",adc\"));\n      pr->print(i);"
        },
        {
          "name": "dateTime",
          "body": "DateTime now = rtc.now();\n\n  // Return date using FS_DATE macro to format fields.\n  *date = FS_DATE(now.year(), now.month(), now.day());\n\n  // Return time using FS_TIME macro to format fields.\n  *time = FS_TIME(now.hour(), now.minute(), now.second());\n\n  // Return low time bits in units of 10 ms.\n  *ms10 = now.second() & 1 ? 100 : 0;"
        },
        {
          "name": "binaryToCsv",
          "body": "uint8_t lastPct = 0;\n  uint32_t t0 = millis();\n  data_t binData[FIFO_DIM];\n\n  if (!binFile.seekSet(512)) {\n\t  error(\"binFile.seek failed\");"
        },
        {
          "name": "clearSerialInput",
          "body": "uint32_t m = micros();\n  do {\n    if (Serial.read() >= 0) {\n      m = micros();"
        },
        {
          "name": "createBinFile",
          "body": "binFile.close();\n  while (sd.exists(binName)) {\n    char* p = strchr(binName, '.');\n    if (!p) {\n      error(\"no dot in filename\");"
        },
        {
          "name": "logData",
          "body": "int32_t delta;  // Jitter in log time.\n  int32_t maxDelta = 0;\n  uint32_t maxLogMicros = 0;\n  uint32_t maxWriteMicros = 0;\n  size_t maxFifoUse = 0;\n  size_t fifoCount = 0;\n  size_t fifoHead = 0;\n  size_t fifoTail = 0;\n  uint16_t overrun = 0;\n  uint16_t maxOverrun = 0;\n  uint32_t totalOverrun = 0;\n  uint32_t fifoBuf[128*FIFO_SIZE_SECTORS];\n  data_t* fifoData = (data_t*)fifoBuf;\n\n  // Write dummy sector to start multi-block write.\n  dbgAssert(sizeof(fifoBuf) >= 512);\n  memset(fifoBuf, 0, sizeof(fifoBuf));\n  if (binFile.write(fifoBuf, 512) != 512) {\n    error(\"write first sector failed\");"
        },
        {
          "name": "openBinFile",
          "body": "char name[FILE_NAME_DIM];\n  clearSerialInput();\n  Serial.println(F(\"Enter file name\"));\n  if (!serialReadLine(name, sizeof(name))) {\n    return;"
        },
        {
          "name": "printData",
          "body": "if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "printUnusedStack",
          "body": "#if HAS_UNUSED_STACK\n  Serial.print(F(\"\\nUnused stack: \"));\n  Serial.println(UnusedStack());\n#endif  // HAS_UNUSED_STACK"
        },
        {
          "name": "testSensor",
          "body": "const uint32_t interval = 200000;\n  int32_t diff;\n  data_t data;\n  clearSerialInput();\n  Serial.println(F(\"\\nTesting - type any character to stop\\n\"));\n  delay(1000);\n  printRecord(&Serial, nullptr);\n  uint32_t m = micros();\n  while (!Serial.available()) {\n    m += interval;\n    do {\n      diff = m - micros();"
        },
        {
          "name": "setup",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);\n    digitalWrite(ERROR_LED_PIN, HIGH);"
        },
        {
          "name": "loop",
          "body": "printUnusedStack();\n  // Read any Serial data.\n  clearSerialInput();\n\n  if (ERROR_LED_PIN >= 0) {\n    digitalWrite(ERROR_LED_PIN, LOW);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay",
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "LittleFS.h",
        "SPI.h",
        "Esp.h",
        "SparkFun_WebServer_ESP32_W5500.h",
        "ESPAsyncWebServer.h",
        "Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Set up the W5500 Chip Select\n  pinMode(pin_W5500_CS, OUTPUT);\n  digitalWrite(pin_W5500_CS, HIGH);\n\n  //Set up the W5500 interrupt pin\n  pinMode(pin_W5500_INT, INPUT_PULLUP);\n  \n  //Check if the board has a power enable pin. Configure it if required\n  if (pin_POWER_CONTROL >= 0)\n  {\n    pinMode(pin_POWER_CONTROL, OUTPUT);\n    digitalWrite(pin_POWER_CONTROL, HIGH);"
        },
        {
          "name": "loop",
          "body": "// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n  //If useArduinoEthernet.txt does not exist in LittleFS, use ESP32_W5500 and ESPAsyncWebServer\n\n  if (!LittleFS.exists(\"/useArduinoEthernet.txt\"))\n  {\n  \n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // ESP32_W5500\n\n    //Create useArduinoEthernet.txt so the code will use Arduino Ethernet next time\n    File file = LittleFS.open(\"/useArduinoEthernet.txt\", FILE_WRITE);\n    file.close();\n\n    Serial.println(\"Using ESP32_W5500:\");\n    Serial.println();\n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Configure the W5500\n  \n    //Must be called before ETH.begin()\n    ESP32_W5500_onEvent();\n  \n    //Start the ethernet connection\n    ETH.begin( pin_POCI, pin_PICO, pin_SCK, pin_W5500_CS, pin_W5500_INT ); //Use default clock speed and SPI Host\n  \n    ESP32_W5500_waitForConnect();\n  \n    // Print your local IP address:\n    Serial.print(\"My IP address: \");\n    Serial.println(ETH.localIP());\n    Serial.println();\n  \n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Configure the Web Server\n  \n    Serial.println(\"Starting Web Server\");\n\n    asyncWebServer = new AsyncWebServer(80); //Instantiate the web server. Use port 80\n    asyncWebSocket = new AsyncWebSocket(\"/ws\"); //Instantiate the web socket\n\n    asyncWebSocket->onEvent(onWsEvent);\n    asyncWebServer->addHandler(asyncWebSocket);\n\n    static char webPage[100];\n    snprintf(webPage, sizeof(webPage), \"<!DOCTYPE html>\\r\\n<html>\\r\\n<h2>I am an ESP32_W5500 web page</h2>\\r\\n<br>\\r\\n</html>\\r\\n\");\n    \n    asyncWebServer->on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request){\n      request->send(200, \"text/html\", webPage);"
        },
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT) {\n    Serial.println(\"Websocket client connected\");"
        }
      ]
    },
    {
      "name": "debug",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "debug.begin(9600);\n  debug.println(\"MAX30105 Basic Readings Example\");\n\n  // Initialize sensor\n  if (particleSensor.begin() == false)\n  {\n    debug.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "debug.print(\" R[\");\n  debug.print(particleSensor.getRed());\n  debug.print(\"] IR[\");\n  debug.print(particleSensor.getIR());\n  debug.print(\"] G[\");\n  debug.print(particleSensor.getGreen());\n  debug.print(\"]\");\n\n  debug.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Serial.println(\"MAX30105 Presence Sensing Example\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "samplesTaken++;\n\n  Serial.print(\"IR[\");\n  Serial.print(particleSensor.getIR());\n  Serial.print(\"] Hz[\");\n  Serial.print((float)samplesTaken / ((millis() - startTime) / 1000.0), 2);\n  Serial.print(\"]\");\n\n  long currentDelta = particleSensor.getIR() - unblockedValue;\n\n  Serial.print(\" delta[\");\n  Serial.print(currentDelta);\n  Serial.print(\"]\");\n\n  if (currentDelta > (long)100)\n  {\n    Serial.print(\" Something is there!\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "float temperature = particleSensor.readTemperature();\n\n  Serial.print(\"temperatureC=\");\n  Serial.print(temperature, 4);\n\n  float temperatureF = particleSensor.readTemperatureF(); //Because I am a bad global citizen\n\n  Serial.print(\" temperatureF=\");\n  Serial.print(temperatureF, 4);\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "Wire"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "Serial.println(particleSensor.getIR()); //Send raw data to plotter"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "long irValue = particleSensor.getIR();\n\n  if (checkForBeat(irValue) == true)\n  {\n    //We sensed a beat!\n    long delta = millis() - lastBeat;\n    lastBeat = millis();\n\n    beatsPerMinute = 60 / (delta / 1000.0);\n\n    if (beatsPerMinute < 255 && beatsPerMinute > 20)\n    {\n      rates[rateSpot++] = (byte)beatsPerMinute; //Store this reading in the array\n      rateSpot %= RATE_SIZE; //Wrap variable\n\n      //Take average of readings\n      beatAvg = 0;\n      for (byte x = 0 ; x < RATE_SIZE ; x++)\n        beatAvg += rates[x];\n      beatAvg /= RATE_SIZE;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "particleSensor.check(); //Check the sensor, read up to 3 samples\n\n  while (particleSensor.available()) //do we have new data?\n  {\n    samplesTaken++;\n\n    Serial.print(\" R[\");\n    Serial.print(particleSensor.getFIFORed());\n    Serial.print(\"] IR[\");\n    Serial.print(particleSensor.getFIFOIR());\n    Serial.print(\"] G[\");\n    Serial.print(particleSensor.getFIFOGreen());\n    Serial.print(\"] Hz[\");\n    Serial.print((float)samplesTaken / ((millis() - startTime) / 1000.0), 2);\n    Serial.print(\"]\");\n\n    Serial.println();\n\n    particleSensor.nextSample(); //We're finished with this sample so move to next sample"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(interruptPin, INPUT);\n\n  Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "particleSensor.check(); //Check the sensor, read up to 3 samples\n\n  while (particleSensor.available()) //do we have new data?\n  {\n    samplesTaken++;\n\n    Serial.print(\" R[\");\n    Serial.print(particleSensor.getRed());\n    Serial.print(\"] IR[\");\n    Serial.print(particleSensor.getIR());\n    Serial.print(\"] G[\");\n    Serial.print(particleSensor.getGreen());\n    Serial.print(\"] Hz[\");\n    Serial.print((float)samplesTaken / ((millis() - startTime) / 1000.0), 2);\n    Serial.print(\"]\");\n\n    if (digitalRead(interruptPin) == LOW) //Hardware way of reading interrupts\n    {\n      Serial.print(\" INT!\");"
        }
      ]
    },
    {
      "name": "MAX_BRIGHTNESS",
      "keywords": [
        "Wire",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200); // initialize serial communication at 115200 bits per second:\n\n  pinMode(pulseLED, OUTPUT);\n  pinMode(readLED, OUTPUT);\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(F(\"MAX30105 was not found. Please check wiring/power.\"));\n    while (1);"
        },
        {
          "name": "loop",
          "body": "bufferLength = 100; //buffer length of 100 stores 4 seconds of samples running at 25sps\n\n  //read the first 100 samples, and determine the signal range\n  for (byte i = 0 ; i < bufferLength ; i++)\n  {\n    while (particleSensor.available() == false) //do we have new data?\n      particleSensor.check(); //Check the sensor for new data\n\n    redBuffer[i] = particleSensor.getRed();\n    irBuffer[i] = particleSensor.getIR();\n    particleSensor.nextSample(); //We're finished with this sample so move to next sample\n\n    Serial.print(F(\"red=\"));\n    Serial.print(redBuffer[i], DEC);\n    Serial.print(F(\", ir=\"));\n    Serial.println(irBuffer[i], DEC);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial); //We must wait for Teensy to come online\n  Serial.println(\"Max sample rate example\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "byte samplesTaken = 0;\n  long startTime = micros();\n\n  while(samplesTaken < 10)\n  {\n    particleSensor.check(); //Check the sensor, read up to 3 samples\n    while (particleSensor.available()) //do we have new data?\n    {\n      samplesTaken++;\n      particleSensor.getFIFOIR();\n      particleSensor.nextSample(); //We're finished with this sample so move to next sample"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Database.loop();"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Databases.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        Serial.println(\"Export documents to the Storage bucket... \");\n\n        // This required the Owner and Editor permissions for the account.\n        // See how to add permission here, https://github.com/mobizt/Firebase-ESP-Client#iam-permission-and-api-enable\n\n        EximDocumentOptions exportOptions(\"\" /* Which collection ids to export. Unspecified means all collections. */, STORAGE_BUCKET_ID, \"test_path\" /* The path in the Firebase Storage bucket to store the data */);\n\n        String payload = Databases.exportDocuments(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), exportOptions);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  // Set pin 8 as INPUT_PULLUP to avoid spurious wakeup\n  pinMode(pin, INPUT_PULLUP);\n  // Attach a wakeup interrupt on pin 8, calling repetitionsIncrease when the device is woken up\n  LowPower.attachInterruptWakeup(pin, repetitionsIncrease, CHANGE);"
        },
        {
          "name": "loop",
          "body": "for (int i = 0; i < repetitions; i++) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(500);\n    digitalWrite(LED_BUILTIN, LOW);\n    delay(500);"
        },
        {
          "name": "repetitionsIncrease",
          "body": "// This function will be called once on device wakeup\n  // You can do some little operations here (like changing variables which will be used in the loop)\n  // Remember to avoid calling delay() and long running functions since this functions executes in interrupt context\n  repetitions ++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Audio.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  // Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(12);\n\n  // Configure the window algorithm to use\n  myFFT.windowFunction(AudioWindowHanning1024);\n  //myFFT.windowFunction(NULL);\n\n  // Create a synthetic sine wave, for testing\n  // To use this, edit the connections above\n  sinewave.amplitude(0.8);\n  sinewave.frequency(1034.007);"
        },
        {
          "name": "loop",
          "body": "float n;\n  int i;\n\n  if (myFFT.available()) {\n    // each time new FFT data is available\n    // print it all to the Arduino Serial Monitor\n    Serial.print(\"FFT: \");\n    for (i=0; i<40; i++) {\n      n = myFFT.read(i);\n      if (n >= 0.01) {\n        Serial.print(n);\n        Serial.print(\" \");"
        }
      ]
    },
    {
      "name": "SCL_INDEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "body": "/* Build raw data */\n  double ratio = twoPi * signalFrequency / samplingFrequency; // Fraction of a complete cycle stored at each sample (in radians)\n  for (uint16_t i = 0; i < samples; i++)\n  {\n    vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n    //vReal[i] = uint8_t((amplitude * (sin(i * ratio) + 1.0)) / 2.0);/* Build data displaced on the Y axis to include only positive values*/\n    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows"
        },
        {
          "name": "PrintVector",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\tbreak;"
        }
      ]
    },
    {
      "name": "SCL_INDEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Frequency\\tDetected\\ttakes (ms)\");\n  Serial.println(\"=======================================\\n\");\n  for(double frequency = startFrequency; frequency<=stopFrequency; frequency+=step_size)\n  {\n    /* Build raw data */\n    double ratio = twoPi * frequency / sampling; // Fraction of a complete cycle stored at each sample (in radians)\n    for (uint16_t i = 0; i < samples; i++)\n    {\n      vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n      vImag[i] = 0; //Reset the imaginary values vector for each new frequency"
        },
        {
          "name": "PrintVector",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / sampling);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * sampling) / samples);\n\tbreak;"
        }
      ]
    },
    {
      "name": "CHANNEL",
      "keywords": [
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "sampling_period_us = round(1000000*(1.0/samplingFrequency));\r\n  Serial.begin(115200);\r\n  while(!Serial);\r\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "body": "/*SAMPLING*/\r\n  microseconds = micros();\r\n  for(int i=0; i<samples; i++)\r\n  {\r\n      vReal[i] = analogRead(CHANNEL);\r\n      vImag[i] = 0;\r\n      while(micros() - microseconds < sampling_period_us){\r\n        //empty loop"
        },
        {
          "name": "PrintVector",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\r\n  {\r\n    double abscissa;\r\n    /* Print abscissa value */\r\n    switch (scaleType)\r\n    {\r\n      case SCL_INDEX:\r\n        abscissa = (i * 1.0);\r\n\tbreak;\r\n      case SCL_TIME:\r\n        abscissa = ((i * 1.0) / samplingFrequency);\r\n\tbreak;\r\n      case SCL_FREQUENCY:\r\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\r\n\tbreak;"
        }
      ]
    },
    {
      "name": "SCL_INDEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "body": "/* Build raw data */\n  double ratio = twoPi * signalFrequency / samplingFrequency; // Fraction of a complete cycle stored at each sample (in radians)\n  for (uint16_t i = 0; i < samples; i++)\n  {\n    vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n    //vReal[i] = uint8_t((amplitude * (sin(i * ratio) + 1.0)) / 2.0);/* Build data displaced on the Y axis to include only positive values*/\n    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows"
        },
        {
          "name": "PrintVector",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\t      break;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n        break;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\t      break;"
        }
      ]
    },
    {
      "name": "SCL_INDEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "body": "/* Build raw data */\n  double ratio = twoPi * signalFrequency / samplingFrequency; // Fraction of a complete cycle stored at each sample (in radians)\n  for (uint16_t i = 0; i < samples; i++)\n  {\n    vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n    //vReal[i] = uint8_t((amplitude * (sin(i * ratio) + 1.0)) / 2.0);/* Build data displaced on the Y axis to include only positive values*/\n    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows"
        },
        {
          "name": "PrintVector",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\tbreak;"
        }
      ]
    },
    {
      "name": "SAMPLES",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "PDM.h"
      ],
      "functions": [
        {
          "name": "zero",
          "body": "for (uint16_t i=0; i<size; i++) {\n        v[i] = 0;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    while(!Serial);\n    Serial.println(\"Ready\");\n      // Configure the data receive callback\n    PDM.onReceive(onPDMdata);\n\n    // Optionally set the gain\n    // Defaults to 20 on the BLE Sense and 24 on the Portenta Vision Shield\n    // PDM.setGain(30);\n\n    PDM.setBufferSize(SAMPLES<<1);\n\n    // Initialize PDM with:\n    // - one channel (mono mode)\n    // - a 16 kHz sample rate for the Arduino Nano 33 BLE Sense\n    // - a 32 kHz or 64 kHz sample rate for the Arduino Portenta Vision Shield\n    if (!PDM.begin(channels, frequency)) {\n        Serial.println(\"Failed to start PDM!\");\n        while (1);"
        },
        {
          "name": "loop",
          "body": "if (samplesRead == SAMPLES) {\n\n    // do the FFT and extract the peak\n    zero(imag, SAMPLES);\n    IntSignal signal(real, imag, SAMPLES);\n    transformer.FFT(signal);\n    signal.getSignalModule(module);\n    float peak_position = getApproxMaxPosition(module, SAMPLES>>1);\n    float peak_frequency = (peak_position*frequency)/SAMPLES;\n\n    // print the peak value on Serial\n    Serial.println(peak_frequency);\n    \n    // Clear the read count\n    samplesRead = 0;"
        },
        {
          "name": "onPDMdata",
          "body": "// Query the number of available bytes\n  int bytesAvailable = PDM.available();\n\n  // Read into the sample buffer only if we have enogh bytes (2*SAMPLES)\n  PDM.read(sampleBuffer, bytesAvailable);\n\n  // 16-bit, 2 bytes per sample\n  samplesAvailable = bytesAvailable / 2;"
        }
      ]
    },
    {
      "name": "FFT_SPEED_OVER_PRECISION",
      "keywords": [
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "sampling_period_us = round(1000000*(1.0/samplingFrequency));\n  Serial.begin(115200);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "body": "/*SAMPLING*/\n  microseconds = micros();\n  for(int i=0; i<samples; i++)\n  {\n      vReal[i] = analogRead(CHANNEL);\n      vImag[i] = 0;\n      while(micros() - microseconds < sampling_period_us){\n        //empty loop"
        },
        {
          "name": "PrintVector",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    float abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\tbreak;"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for FSK4\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[FSK4] Sending FSK4 data packet ... \"));\n\n  // send out idle condition for 1000 ms\n  fsk4.idle();\n  delay(1000);\n\n  // FSK4Client supports binary write methods\n\n  // send some bytes as a preamble\n  for(int i = 0; i < 8; i++) {\n    fsk4.write(0x1B);"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for RTTY\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[FSK4] Sending FSK4 data packet ... \"));\n\n  // send out idle condition for 500 ms\n  fsk4.idle();\n  delay(1000);\n\n  // FSK4Client supports binary write methods\n\n  // send some bytes as a preamble\n  for(int i = 0; i < 8; i++) {\n    fsk4.write(0x1B);"
        }
      ]
    },
    {
      "name": "HEARTBEAT_INTERVAL",
      "keywords": [
        "Serial",
        "delay",
        "analogRead"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));        // H means alive\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong current_millis;\n\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;"
        },
        {
          "name": "handleFileDelete",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileCreate",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");"
        },
        {
          "name": "handleFileUpload",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;"
        },
        {
          "name": "handleFileList",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;"
        },
        {
          "name": "initFS",
          "body": "// Initialize LittleFS/SPIFFS file-system\n  if (!FileFS.begin())\n  {\n    FileFS.format();\n\n    if (!FileFS.begin())\n    {\n      while (true)\n      {\n#if USE_LITTLEFS\n        Serial.println(F(\"LittleFS failed!. Please use SPIFFS.\"));\n#else\n        Serial.println(F(\"SPIFFS failed!. Please use LittleFS.\"));\n#endif\n        // Stay forever here as useless to go further\n        delay(5000);"
        },
        {
          "name": "listDir",
          "body": "Dir dir = filesystem->openDir(\"/\");\n  Serial.println(F(\"Opening / directory\"));\n\n  while (dir.next())\n  {\n    String fileName = dir.fileName();\n    size_t fileSize = dir.fileSize();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());"
        },
        {
          "name": "initWebserver",
          "body": "//SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n\n  //load editor\n  server.on(\"/edit\", HTTP_GET, []()\n  {\n    if (!handleFileRead(\"/edit.htm\"))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting FS_EthernetWebServer on \" + String(BOARD_TYPE));\n  Serial.print(\" using \");\n  Serial.println(FS_Name);\n  Serial.println(\"With \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n#if USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // Ethernet           0                 X            X            X            X        0\n  // Ethernet2          X                 X            X            X            X        0\n  // Ethernet3          X                 X            X            X            X        0\n  // EthernetLarge      X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  // Just info to know how to connect correctly\n  Serial.println(\"=========================\");\n  Serial.println(\"Currently Used SPI pinout:\");\n  Serial.print(\"MOSI:\");\n  Serial.println(MOSI);\n  Serial.print(\"MISO:\");\n  Serial.println(MISO);\n  Serial.print(\"SCK:\");\n  Serial.println(SCK);\n  Serial.print(\"CS/SS:\");\n  Serial.println(USE_THIS_SS_PIN);\n  Serial.println(F(\"=========================\"));\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  initFS();\n  listDir();\n  initWebserver();\n\n  Serial.print(\"HTTP server started @\");\n  Serial.println(Ethernet.localIP());\n\n  Serial.print(F(\"Open http://\"));\n  Serial.print(Ethernet.localIP());\n  Serial.println(F(\"/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "Serial",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "SD.h",
        "SoftwareSerial.h",
        "HardwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Serial.println(F(\"*** FTP Example ***\"));\n\n  #ifdef LED\n    pinMode(LED, OUTPUT);\n    digitalWrite(LED, LOW);\n  #endif\n  \n  pinMode(RST, OUTPUT);\n  digitalWrite(RST, HIGH); // Default state\n\n  modem.powerOn(BOTLETICS_PWRKEY); // Power on the module\n  moduleSetup(); // Establishes first-time serial comm and prints IMEI\n\n  // Set modem to full functionality\n  modem.setFunctionality(1); // AT+CFUN=1\n\n  // Configure a GPRS APN, username, and password.\n  // You might need to do this to access your network's GPRS/data\n  // network.  Contact your provider for the exact APN, username,\n  // and password values.  Username and password are optional and\n  // can be removed, but APN is required.\n  //modem.setNetworkSettings(F(\"your APN\"), F(\"your username\"), F(\"your password\"));\n  //modem.setNetworkSettings(F(\"m2m.com.attz\")); // For AT&T IoT SIM card\n  //modem.setNetworkSettings(F(\"telstra.internet\")); // For Telstra (Australia) SIM card - CAT-M1 (Band 28)\n  modem.setNetworkSettings(F(\"hologram\")); // For Hologram SIM card\n\n  // Optionally configure HTTP gets to follow redirects over SSL.\n  // Default is not to follow SSL redirects, however if you uncomment\n  // the following line then redirects over SSL will be followed.\n  //modem.setHTTPSRedirect(true);\n\n  /*\n  // Other examples of some things you can set:\n  modem.setPreferredMode(38); // Use LTE only, not 2G\n  modem.setPreferredLTEMode(1); // Use LTE CAT-M only, not NB-IoT\n  modem.setOperatingBand(\"CAT-M\", 12); // AT&T uses band 12\n//  modem.setOperatingBand(\"CAT-M\", 13); // Verizon uses band 13\n  modem.enableRTC(true);\n  \n  modem.enableSleepMode(true);\n  modem.set_eDRX(1, 4, \"0010\");\n  modem.enablePSM(true);\n\n  // Set the network status LED blinking pattern while connected to a network (see AT+SLEDS command)\n  modem.setNetLED(true, 2, 64, 3000); // on/off, mode, timer_on, timer_off\n  modem.setNetLED(false); // Disable network status LED\n  */\n\n  // Connect to cell network and verify connection\n  // If unsuccessful, keep retrying every 2s until a connection is made\n  while (!netStatus()) {\n    Serial.println(F(\"Failed to connect to cell network, retrying...\"));\n    delay(2000); // Retry every 2s"
        },
        {
          "name": "loop",
          "body": ""
        },
        {
          "name": "moduleSetup",
          "body": "// SIM7000 takes about 3s to turn on and SIM7500 takes about 15s\n  // Press Arduino reset button if the module is still turning on and the board doesn't find it.\n  // When the module is on it should communicate right after pressing reset\n\n  // Software serial:\n  modemSS.begin(115200); // Default SIM7000 shield baud rate\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modemSS.println(\"AT+IPR=9600\"); // Set baud rate\n  delay(100); // Short pause to let the command run\n  modemSS.begin(9600);\n  if (! modem.begin(modemSS)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while (1); // Don't proceed if it couldn't find the device"
        }
      ]
    },
    {
      "name": "Serial1",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial1.begin(115200, SERIAL_8E1);\n  Serial2.begin(115200, SERIAL_8E1);\n\n  delay(1000);\n\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(LORA_BOOT0, OUTPUT);\n  digitalWrite(LORA_BOOT0, HIGH);\n  pinMode(LORA_RESET, OUTPUT);\n  digitalWrite(LORA_RESET, HIGH);\n  delay(200);\n  digitalWrite(LORA_RESET, LOW);\n  delay(200);\n  digitalWrite(LORA_RESET, HIGH);"
        },
        {
          "name": "resetModule",
          "body": "Serial.println(\"resetting module\");\n  digitalWrite(LORA_RESET, HIGH);\n  delay(100);\n  digitalWrite(LORA_RESET, LOW);\n  delay(100);\n  digitalWrite(LORA_RESET, HIGH);\n\n  while (!Serial);"
        },
        {
          "name": "loop",
          "body": "while (Serial1.available()) {      // If anything comes in Serial (USB),\n    tx_buf[tx++] = Serial1.read();   // read it and send it out Serial1 (pins 0 & 1)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/face/detection.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___FACE DETECTION___\");\n\n    // camera settings\n    // !!!!REPLACE WITH YOUR OWN MODEL!!!!\n    camera.pinout.freenove_s3(); // e.g. xiao(), lilygo_tcamera_s3(), ...\n    camera.brownout.disable();\n    // face detection only works at 240x240\n    camera.resolution.face();\n    camera.quality.high();\n\n    // you can choose fast detection (50ms)\n    detection.fast();\n    // or accurate detection (80ms)\n    detection.accurate();\n\n    // you can set a custom confidence score\n    // to consider a face valid\n    // (in range 0 - 1, default is 0.5)\n    detection.confidence(0.7);\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Awaiting for face...\");"
        },
        {
          "name": "loop",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/face/detection.h",
        "eloquent_esp32cam/face/recognition.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(4000);\n    Serial.begin(115200);\n    Serial.println(\"Begin\");\n\n    // !!!!REPLACE WITH YOUR OWN MODEL!!!!\n    camera.pinout.freenove_s3(); // e.g. xiao(), lilygo_tcamera_s3(), ...\n    camera.brownout.disable();\n    // face recognition only works at 240x240\n    camera.resolution.face();\n    camera.quality.high();\n\n    // face recognition only works with accurate detection\n    detection.accurate();\n    detection.confidence(0.7);\n\n    // face recognition confidence\n    recognition.confidence(0.85);\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    // init recognizer\n    while (!recognition.begin().isOk())\n        Serial.println(recognition.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Face recognizer OK\");\n\n    // delete stored data, if user confirms\n    if (prompt(\"Do you want to delete all existing faces? [yes|no]\").startsWith(\"y\")) {\n        Serial.println(\"Deleting all existing faces...\");\n        recognition.deleteAll();"
        },
        {
          "name": "loop",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;"
        },
        {
          "name": "enroll",
          "body": "String name = prompt(\"Enter person name:\");\n\n    if (recognition.enroll(name).isOk())\n        Serial.println(\"Success!\");\n    else\n        Serial.println(recognition.exception.toString());"
        },
        {
          "name": "recognize",
          "body": "if (!recognition.recognize().isOk()) {\n        Serial.println(recognition.exception.toString());\n        return;"
        }
      ]
    },
    {
      "name": "TINY_GSM_MODEM_SIM800",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "TinyGsmClient.h",
        "SoftwareSerial.h",
        "StreamDebugger.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // Set GSM module baud rate\n  SerialAT.begin(9600);\n  delay(6000);\n\n  if (!modem.init()) {\n    SerialMon.println(\n        F(\"***********************************************************\"));\n    SerialMon.println(F(\" Cannot initialize modem!\"));\n    SerialMon.println(\n        F(\"   Use File -> Examples -> TinyGSM -> tools -> AT_Debug\"));\n    SerialMon.println(F(\"   to find correct configuration\"));\n    SerialMon.println(\n        F(\"***********************************************************\"));\n    return;"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setID",
          "body": "BraccioClass::setID(id);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  factory.begin();\n  while (!Serial);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Write the ID you want to use for this motor:\");\n  String ret = \"\";\n  do {\n    ret = Serial.readStringUntil('\\n');"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  while (!Serial) delay(10);   // wait until serial port is opened\n  \n  if(!ss.begin()){\n    Serial.println(\"seesaw not found!\");\n    while(1) delay(10);"
        },
        {
          "name": "loop",
          "body": "// set the brightness of the LED:\n  ss.analogWrite(led, brightness);\n\n  // change the brightness for next time through the loop:\n  brightness = brightness + fadeAmount;\n\n  // reverse the direction of the fading at the ends of the fade:\n  if (brightness <= 0 || brightness >= 255) {\n    fadeAmount = -fadeAmount;"
        }
      ]
    }
  ],
  "vocab": [
    "Serial",
    "delay",
    "Wire",
    "analogRead",
    "digitalWrite",
    "analogWrite",
    "attachInterrupt",
    "EEPROM"
  ]
}