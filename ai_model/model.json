{
  "templates": [
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "millis",
        "delay",
        "analogread"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);\n    }\n    Serial.println(\" done.\");\n\n    Input.begin();\n    Input.enable();\n\n    analogReadResolution(adcResolution);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"0-5V Input Channel \");\n    switch (inputChannels[inputChannelIndex]) {\n        case INPUT_05V_CH01: Serial.print(\"01\"); break;\n        case INPUT_05V_CH02: Serial.print(\"02\"); break;\n        case INPUT_05V_CH03: Serial.print(\"03\"); break;\n        case INPUT_05V_CH04: Serial.print(\"04\"); break;\n        case INPUT_05V_CH05: Serial.print(\"05\"); break;\n        case INPUT_05V_CH06: Serial.print(\"06\"); break;\n        case INPUT_05V_CH07: Serial.print(\"07\"); break;\n        case INPUT_05V_CH08: Serial.print(\"08\"); break;\n        default: break;\n    }\n    Serial.print(\": \");\n\n    auto [ voltsMuxer, voltsInput ] = getAverageAnalogRead(inputChannels[inputChannelIndex]);\n\n    Serial.print(voltsInput);\n    Serial.print(\" (\");\n    Serial.print(voltsMuxer);\n    Serial.println(\")\");\n    delay(1000);\n\n    inputChannelIndex = ++inputChannelIndex % inputChannelsLen;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "digitalwrite",
        "analogwrite",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "blynkAnotherDevice",
          "parameters": "",
          "body": "//向被控制端发送数据\n  if (value) {\n    bridge1.digitalWrite(12, HIGH);  //被控制端的12号管脚将被设为 HIGH\n    bridge1.virtualWrite(V5, 1); // 向被控制端V5管脚发送1，被控制端需要用BLYNK_WRITE(V5) 接收\n\n    /////////////////////////////////////////////////////////////////////////////////////////\n    //特别注意，如果向被控制端的虚拟管脚发送数据，\n    //被控制端需要用 BLYNK_WRITE函数来接收，类似于接收来自app端的虚拟管脚数据\n    //\n    //    BLYNK_WRITE(V5){\n    //    int pinData = param.asInt(); // 接收来自bridge的数据\n    //    }\n    //\n    /////////////////////////////////////////////////////////////////////////////////////////\n  } else {\n    bridge1.digitalWrite(12, LOW); //被控制端的12号管脚将被设为 LOW\n    bridge1.virtualWrite(V5, 0); // 向被控制端V5管脚发送0，被控制端需要用BLYNK_WRITE(V5) 接收\n  }\n  // value取反\n  value = !value;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, blynkAnotherDevice);  // 每秒钟调用 blynkAnotherDevice 函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "led",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "digitalwrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(2, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalWrite(2, HIGH);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "digitalread",
        "timer",
        "device_name",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "notifyOnButtonPress",
          "parameters": "",
          "body": "int isButtonPressed = !digitalRead(2);\n  if (isButtonPressed) {\n    Serial.println(\"Button is pressed.\");\n    Blynk.notify(\"Yaaay... button is pressed!\");\n    // 你也可以使用 {DEVICE_NAME}来代替项目名称，用法如下：\n    // Blynk.notify(String(\"{DEVICE_NAME} running for \") + uptime + \" minutes.\");\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  pinMode(2, INPUT_PULLUP);//设置GPIO2为中断管脚\n  attachInterrupt(digitalPinToInterrupt(2), notifyOnButtonPress, CHANGE);//GPIO2添加中断函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "millis",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "eventsource"
      ],
      "libraries": [
        "Braccio++.h",
        "AppState.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (Braccio.begin(custom_main_menu)) {\n    app.enableButtons();\n    /* Allow greater angular velocity than the default one. */\n    Braccio.setAngularVelocity(45.0f);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // Configure and start Serial Communication\n  Serial.begin(9600); \n  while (!Serial) {};           // Wait for serial port to connect. \n\n  axis.begin();                 // Configure inputs pins, outputs pins and interruptions pins\n  \n  axis.checkInputs();           // Verify the boolean value of the axis inputs and print in the serial monitor"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward() == HIGH)\n    Serial.println(\"Forward Button was pressed!\");\n\n  // Check the backward button signal\n  if(axis.readBtnBackward() == HIGH)\n    Serial.println(\"Backward Button was pressed!\");\n  \n  // Check the Endstop Home switch signal\n  if(axis.readEndstopHome() == HIGH)\n    Serial.println(\"Endstop Home was pressed!\");\n\n  // Check the Endstop Far switch signal\n  if(axis.readEndstopFar() == HIGH)\n    Serial.println(\"Endstop Far was pressed!\");\n  \n  // Check the Emergency Stop Button signal\n  if(axis.readBtnEmergencyStop() == LOW)\n    // The emergency stop button is attached in the interrupt service routine\n    // So when you click the button, you will see the Emergency message printed too\n    Serial.println(\"Emergency Stop Button was pressed!\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {};          // Wait to open the serial monitor\n \n  axisX.begin();               // Configure X-axis inputs pins, outputs pins and interruptions pins\n  axisY.begin();               // Configure Y-axis inputs pins, outputs pins and interruptions pins\n\n  axisX.checkInputs();         // Verify the boolean value of X-axis inputs and print in the serial monitor\n  \n  axisY.checkInputs();         // Verify the boolean value of Y-axis inputs and print in the serial monitor"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "millis"
      ],
      "libraries": [
        "Braccio++.h",
        "AppState.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();\n    }\n  }\n\n  /* Execute every 50 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 50)\n    {\n      prev = now;\n\n      if (Braccio.isJoystickPressed_UP())\n        app.update(Button::Up);\n      if (Braccio.isJoystickPressed_DOWN())\n        app.update(Button::Down);\n      if (Braccio.isJoystickPressed_LEFT())\n        app.update(Button::Left);\n      if (Braccio.isJoystickPressed_RIGHT())\n        app.update(Button::Right);\n    }\n  }"
        },
        {
          "name": "directionScreen",
          "parameters": "void",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "parameters": "",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);\n  }\n  prev_joystick_pressed_enter = curr_joystick_pressed_enter;\n\n  /* SELECT */\n\n  static bool prev_joystick_pressed_select = false;\n  bool const curr_joystick_pressed_select = Braccio.isJoystickPressed_SELECT();\n  if (!prev_joystick_pressed_select && curr_joystick_pressed_select) {\n    app.update(Button::Enter);\n  }\n  prev_joystick_pressed_select = curr_joystick_pressed_select;\n\n  /* DOWN */\n\n  static bool prev_joystick_pressed_down = false;\n  bool const curr_joystick_pressed_down = Braccio.isJoystickPressed_DOWN();\n  if (!prev_joystick_pressed_down && curr_joystick_pressed_down) {\n    handle_OnButtonDownPressed();\n  }\n  if (prev_joystick_pressed_down && !curr_joystick_pressed_down) {\n    handle_OnButtonDownReleased();\n  }\n  prev_joystick_pressed_down = curr_joystick_pressed_down;\n\n  /* UP */\n\n  static bool prev_joystick_pressed_up = false;\n  bool const curr_joystick_pressed_up = Braccio.isJoystickPressed_UP();\n  if (!prev_joystick_pressed_up && curr_joystick_pressed_up) {\n    handle_OnButtonUpPressed();\n  }\n  if (prev_joystick_pressed_up && !curr_joystick_pressed_up) {\n    handle_OnButtonUpReleased();\n  }\n  prev_joystick_pressed_up = curr_joystick_pressed_up;\n\n  /* LEFT */\n\n  static bool prev_joystick_pressed_left = false;\n  bool const curr_joystick_pressed_left = Braccio.isJoystickPressed_LEFT();\n  if (!prev_joystick_pressed_left && curr_joystick_pressed_left) {\n    handle_OnButtonLeftPressed();\n  }\n  if (prev_joystick_pressed_left && !curr_joystick_pressed_left) {\n    handle_OnButtonLeftReleased();\n  }\n  prev_joystick_pressed_left = curr_joystick_pressed_left;\n\n  /* RIGHT */\n\n  static bool prev_joystick_pressed_right = false;\n  bool const curr_joystick_pressed_right = Braccio.isJoystickPressed_RIGHT();\n  if (!prev_joystick_pressed_right && curr_joystick_pressed_right) {\n    handle_OnButtonRightPressed();\n  }\n  if (prev_joystick_pressed_right && !curr_joystick_pressed_right) {\n    handle_OnButtonRightReleased();\n  }\n  prev_joystick_pressed_right = curr_joystick_pressed_right;"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "delay"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {};         // Wait to open the serial monitor\n\n  motor.begin();              // Configure inputs pins, outputs pins and interruptions pins\n  motor.startWithoutHoming(); // Initialize the motor separately without being part of an axis\n\n  Serial.println(\"To start, send any key to serial ...\");\n\n  // Without this instruction the motor will move after the upload (It is dangerous)\n  while((Serial.available() <= 0)){};\n\n  motor.setTotalSteps(50000); // Set the max step of the motor\n  Serial.println(\"Motor moves.\");\n  motor.moveSteps(20000);     // Motor moves\n\n  motor.pause();              // Pause the motor\n  Serial.println(\"Motor does not move.\");\n  motor.moveSteps(50);        // Motor does not move\n  delay(2000);\n  \n  motor.play();               // Enable motor\n  Serial.println(\"Motor moves.\");\n  motor.moveSteps(15000);     // Motor moves again"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "distance",
        "delay",
        "fetch"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (Braccio.begin()){\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n\n    /* Move to home position. */\n    gripper.move().to(initialAngle);       delay(TIME_DELAY);\n    wristRoll.move().to(initialAngle);     delay(TIME_DELAY);\n    wristPitch.move().to(initialAngle);    delay(TIME_DELAY);\n    elbow.move().to(initialAngle);         delay(TIME_DELAY);\n    shoulder.move().to(initialAngle);      delay(TIME_DELAY);\n    base.move().to(initialBase);           delay(TIME_DELAY);\n  }\n\n  Serial.begin(115200);\n  while(!Serial){}"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Fetch the joints positions\n  Braccio.positions(angles);\n\n  // Print the joint angles\n  Serial.println(\"************* Joints Angles *************\");\n  Serial.println(\"|\\tMotor ID\\t|\\tAngle\\t|\");\n  Serial.println(\"----------------------------------------\");\n  Serial.print(\"| 1 - Gripper\\t\\t|\\t\" + String(angles[0]) + \"\\t|\\n\" + \n               \"| 2 - Wrist Rotation\\t|\\t\" + String(angles[1]) + \"\\t|\\n\" +\n               \"| 3 - Wrist Vertical\\t|\\t\" + String(angles[2]) + \"\\t|\\n\" + \n               \"| 4 - Elbow\\t\\t|\\t\" + String(angles[3]) + \"\\t|\\n\" + \n               \"| 5 - Shoulder\\t\\t|\\t\" + String(angles[4]) + \"\\t|\\n\" + \n               \"| 6 - Base\\t\\t|\\t\" + String(angles[5]) + \"\\t|\\n\");\n  Serial.println(\"*****************************************\\n\\n\\n\\n\\n\");\n  Serial.println(\"\\n\\n\\n\\n\");\n  \n  delay(TIME_DELAY);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_obj_t * btn1 = lv_btn_create(lv_scr_act());\n  lv_obj_set_size(btn1, 120, 75);\n  lv_obj_t * label1 = lv_label_create(btn1);\n  lv_label_set_text(label1, \"BTN 1\");\n  lv_obj_align(btn1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_center(label1);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "meterscreen"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "parameters": "lv_event_t * e",
          "body": "/* Set the meter value */\n  Braccio.lvgl_lock();\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "meterScreen",
          "parameters": "void",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 8, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(meterScreen);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle <= 315 ) {\n      currentAngle += 15.0;\n    } else {\n      currentAngle = 315.0;\n    }\n  }\n\n  // Check if the Joystick Right is pressed\n  if (pressedKey == JOYSTICK_RIGHT) {\n    if (currentAngle > 15 ) {\n      currentAngle -= 15.0;\n    } else {\n      currentAngle = 0.0;\n    }\n  }\n\n  Braccio.move(motorID).to(currentAngle); // Moves the motor to the new angle\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "checkJoystick",
          "parameters": "int input",
          "body": "String joystick[] = { \"\",\n    \"Joystick left was moved!\",\n    \"Joystick right was moved!\",\n    \"Joystick select button was pressed!\",\n    \"Joystick up was moved!\",\n    \"Joystick down was moved!\"};\n   return joystick[input];"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial){}\n  Braccio.begin();\n  Serial.println(\"Press any button or move the joystick.\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int joystickPos = Braccio.getKey();\n  message = checkJoystick(joystickPos);\n  if(message != \"\"){\n    Serial.println(message);\n    message = \"\";\n  }\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "buffer",
        "current",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin();\n  delay(500);\n  \n  Serial.begin(115200);\n  while(!Serial){}"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"To start, send any key to the serial port:\");\n  while((Serial.available() <= 0)){};\n  Serial.read(); // Clear the serial buffer\n  \n  for(motorID = 1; motorID <=6; motorID++){\n    Serial.println(\"\\nMoving the motor \" + String(motorID));\n    Serial.println(\"Current angle 0.0 (zero)\");\n    \n    Braccio.move(motorID).to(0.0f);\n    delay(2000);  // delay between movements\n\n    Serial.println(\"Current angle 90.0\");\n    Braccio.move(motorID).to(90.0f);\n    delay(2000);  // delay between movements\n\n    Serial.println(\"Current angle 180.0\");\n    Braccio.move(motorID).to(180.0f);\n    delay(2000);  // delay between movements\n\n    Serial.println(\"Current angle 270.0\");\n    Braccio.move(motorID).to(270.0f);\n    delay(2000);  // delay between movements\n\n    Serial.println(\"Current angle 315.0\\n\");\n    Braccio.move(motorID).to(315.0f);\n    delay(2000);  // delay between movements\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n   Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "millis",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "parameters": "",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);\n// 创建LabeledValue组件，输入管脚设置为V5"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "wifi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n   Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "millis",
        "timer",
        "device_name"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "notifyUptime",
          "parameters": "",
          "body": "long uptime = millis() / 60000L;\n  Blynk.notify(String(\"Running for \") + uptime + \" minutes.\");//通知手机该项目运行时间\n  // 你也可以使用 {DEVICE_NAME}来代替项目名称，用法如下：\n  // Blynk.notify(String(\"{DEVICE_NAME} running for \") + uptime + \" minutes.\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  Blynk.notify(\"Device started\");//开机是发送通知\n  timer.setInterval(60000L, notifyUptime);//每分钟调用一次该函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "current",
        "wifi",
        "rtc",
        "timer",
        "html",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "TimeLib.h",
        "WidgetRTC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  // 更多资料，请参考: http://www.pjrc.com/teensy/td_libs_Time.html\n  setSyncInterval(10 * 60); // 设置同步间隔时间，10分钟。\n  timer.setInterval(1000L, clockDisplay);//每隔1s，运行clockDisplay，显示时间"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "rtc",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "requestTime",
          "parameters": "",
          "body": "//查询时间\n  Blynk.sendInternal(\"rtc\", \"sync\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(10000L, requestTime);//每隔10s运行requestTime"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "led",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  axis.begin();                 // Configure inputs pins, outputs pins and interruptions pins\n  \n  Serial.println(\"Press the Start Button to start the machine\");\n  while(!axis.ready());         // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward() == HIGH)\n    axis.moveForward();  // Motor rotates clockwise\n\n  // Check the backward button signal\n  if(axis.readBtnBackward() == HIGH)\n    axis.moveBackward(); // Motor rotates anticlockwise"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "millis"
      ],
      "libraries": [
        "Braccio++.h",
        "AppState.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();\n    }\n  }\n\n  /* Execute every 50 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 50)\n    {\n      prev = now;\n\n      if (Braccio.isJoystickPressed_UP())\n        app.update(Button::Up);\n      if (Braccio.isJoystickPressed_DOWN())\n        app.update(Button::Down);\n      if (Braccio.isJoystickPressed_LEFT())\n        app.update(Button::Left);\n      if (Braccio.isJoystickPressed_RIGHT())\n        app.update(Button::Right);\n    }\n  }"
        },
        {
          "name": "directionScreen",
          "parameters": "void",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "parameters": "",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);\n  }\n  prev_joystick_pressed_enter = curr_joystick_pressed_enter;\n\n  /* SELECT */\n\n  static bool prev_joystick_pressed_select = false;\n  bool const curr_joystick_pressed_select = Braccio.isJoystickPressed_SELECT();\n  if (!prev_joystick_pressed_select && curr_joystick_pressed_select) {\n    app.update(Button::Enter);\n  }\n  prev_joystick_pressed_select = curr_joystick_pressed_select;\n\n  /* DOWN */\n\n  static bool prev_joystick_pressed_down = false;\n  bool const curr_joystick_pressed_down = Braccio.isJoystickPressed_DOWN();\n  if (!prev_joystick_pressed_down && curr_joystick_pressed_down) {\n    handle_OnButtonDownPressed();\n  }\n  if (prev_joystick_pressed_down && !curr_joystick_pressed_down) {\n    handle_OnButtonDownReleased();\n  }\n  prev_joystick_pressed_down = curr_joystick_pressed_down;\n\n  /* UP */\n\n  static bool prev_joystick_pressed_up = false;\n  bool const curr_joystick_pressed_up = Braccio.isJoystickPressed_UP();\n  if (!prev_joystick_pressed_up && curr_joystick_pressed_up) {\n    handle_OnButtonUpPressed();\n  }\n  if (prev_joystick_pressed_up && !curr_joystick_pressed_up) {\n    handle_OnButtonUpReleased();\n  }\n  prev_joystick_pressed_up = curr_joystick_pressed_up;\n\n  /* LEFT */\n\n  static bool prev_joystick_pressed_left = false;\n  bool const curr_joystick_pressed_left = Braccio.isJoystickPressed_LEFT();\n  if (!prev_joystick_pressed_left && curr_joystick_pressed_left) {\n    handle_OnButtonLeftPressed();\n  }\n  if (prev_joystick_pressed_left && !curr_joystick_pressed_left) {\n    handle_OnButtonLeftReleased();\n  }\n  prev_joystick_pressed_left = curr_joystick_pressed_left;\n\n  /* RIGHT */\n\n  static bool prev_joystick_pressed_right = false;\n  bool const curr_joystick_pressed_right = Braccio.isJoystickPressed_RIGHT();\n  if (!prev_joystick_pressed_right && curr_joystick_pressed_right) {\n    handle_OnButtonRightPressed();\n  }\n  if (prev_joystick_pressed_right && !curr_joystick_pressed_right) {\n    handle_OnButtonRightReleased();\n  }\n  prev_joystick_pressed_right = curr_joystick_pressed_right;"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {};          // Wait to open the serial monitor\n\n  axisX.begin();               // Configure X-axis inputs pins, outputs pins and interruptions pins\n  axisY.begin();               // Configure Y-axis inputs pins, outputs pins and interruptions pins\n\n  Serial.println(\"Send any key to serial ...\");\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){};\n\n  axisX.start();               // Initialize the X-axis\n  axisY.start();               // Initialize the Y-axis"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward() == HIGH)\n    axisX.moveForward();\n  \n  // Check the forward button signal\n  if(axisY.readBtnForward() == HIGH)\n    axisY.moveForward();\n\n  // Check the forward button signal\n  if(axisX.readBtnBackward() == HIGH)\n    axisX.moveBackward();\n\n  // Check the forward button signal\n  if(axisY.readBtnBackward() == HIGH)\n    axisY.moveBackward();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "eventsource"
      ],
      "libraries": [
        "Braccio++.h",
        "AppState.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (Braccio.begin(custom_main_menu)) {\n    app.enableButtons();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "current"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {};         // Wait to open the serial monitor\n  motor.begin();              // Configure inputs pins, outputs pins and interruptions pins\n  motor.startWithoutHoming(); // Initialize the motor without homing procedure, detached\n                              // interruptions pins and configures endstops as OUTPUT\n                              // Use this function only with the motor outside the axis\n  motor.setTotalSteps(50000); // Set the max step of the motor (necessary, because the total setp count is initialized with zero)"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of steps: \");\n\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){};\n  steps = Serial.parseInt();  // Reads the value in the serial port\n\n  // Print the current step value before running the command\n  Serial.println(\"Currentstep before running the command: \" + String(motor.getStep()));\n  \n  motor.moveSteps(steps);     // Runs the command\n\n  // Print the current step value after running the command\n  Serial.println(\"Curentstep after running the command: \" + String(motor.getStep()));\n  \n  Serial.read();              // Clean serial buffer"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style;\n  lv_style_init(&style);\n  lv_style_set_bg_color(&style, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style, lv_color_hex(COLOR_TEAL));\n  lv_style_set_border_width(&style, 5);\n  lv_style_set_text_color(&style, lv_color_hex(COLOR_ORANGE));\n\n  lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); \n  lv_obj_set_size(btn1, 120, 75);\n  \n  lv_obj_t * label1 = lv_label_create(btn1);\n  lv_label_set_text(label1, \"BTN 1\");\n  \n  lv_obj_align(btn1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_center(label1);\n\n  lv_obj_add_style(btn1, &style, 0);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "parameters": "lv_event_t * e",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_PRESSED) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was selected\\n\", txt);\n    Serial.println(String(txt) + \" was selected.\");\n  }\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n  \n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "delay",
        "matrix",
        "meterscreen"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "parameters": "lv_event_t * e",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object\n  }\n  else {\n    lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  }"
        },
        {
          "name": "eventHandlerMenu",
          "parameters": "lv_event_t * e",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen(); // Load meter screen\n  lv_obj_del(btnm); // Delete the object"
        },
        {
          "name": "meterScreen",
          "parameters": "void",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 8, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(motorMenu);\n\n  delay(5000); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1500); // Necessary to set the motor ID correctly\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 15.00;\n    } else {\n      currentAngle = 315;\n    }\n  }\n\n  // Check if the Joystick Right is pressed\n  if (pressedKey == JOYSTICK_RIGHT) {\n    if (currentAngle > 15 ) {\n      currentAngle -= 15.00;\n    } else {\n      currentAngle = 0;\n    }\n  }\n\n  Braccio.move(motorID).to(currentAngle); // Moves the motor to the new angle\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "current",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin();\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for(int i = 1; i <= 6; i++){\n    Braccio.move(i).to(0.0f);\n    delay(1000); // Necessary to set the motor ID correctly\n  }\n  \n  Serial.begin(115200);\n  \n  Serial.println(\"Press the Enter Button to select the motor 1.\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check if the control key pressed is the Enter Button\n  if(Braccio.getKey() == BUTTON_ENTER){\n    \n    if(motorID <= 6){\n      \n      motorID++;  // Increment the ID\n      \n      if(motorID > 6){\n        motorID = 1; // Restart the ID to motor 1\n      }\n    }\n      \n    movement = true; // Flag allows the motor to move\n    \n    while(Braccio.getKey() == BUTTON_ENTER); // Avoids more than one increment\n    Serial.println(\"Motor \" + String(motorID) + \" selected.\");\n  }\n\n  if(movement){\n    \n    for (float angle = 0.0; angle <= 315.0; angle+=45.0){\n      Braccio.move(motorID).to(angle);\n      \n      Serial.println(\"Motor \" + String(motorID) + \" - current angle: \" + String(angle));\n      delay(250);\n    }\n\n    delay(500);\n    \n    for (float angle = 315.0; angle >= 0.0; angle-=45.0){\n      Braccio.move(motorID).to(angle);\n      \n      Serial.println(\"Motor \" + String(motorID) + \" - current angle: \" + String(angle));\n      delay(250);\n    }\n    \n    movement = false;\n    \n    Serial.println(\"\\n\\nPress the Enter Button to select the next motor.\\n\\n\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "distance",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (Braccio.begin()){\n    /* Warning:\n       Keep a safe distance from the robot until you make sure the code is properly\n       working. Be mindful of the robot’s movement prior to that, as it could be\n       speedy and accidentally hit someone.\n    */\n\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(TIME_DELAY);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n    movement = true; // Trigger joints' movements\n\n  if (movement) {\n    Braccio.moveTo(WAVE_POS[0], WAVE_POS[1], WAVE_POS[2], WAVE_POS[3], WAVE_POS[4], WAVE_POS[5]);\n    delay(TIME_DELAY);\n\n    for (int i = 1; i <= 5; i++) {\n      wristPitch.move().to(120.0f);         delay(TIME_DELAY);\n      wristPitch.move().to(200.0f);         delay(2*TIME_DELAY);\n      wristPitch.move().to(WAVE_POS[3]);\n    }\n\n    movement = false; // Stop joints' movements\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "digitalread"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "parameters": "",
          "body": "int isButtonPressed = !digitalRead(2); \n  if (isButtonPressed) // 你可以在此设置任何触发邮件发送的条件\n  {//按钮按下时，发送邮件\n    Serial.println(\"Button is pressed.\"); // 串口输出\n    Blynk.email(\"your_email@mail.com\", \"Subject: Button Logger\", \"You just pushed the button...\");\n    // 如果只是想在手机app上显示，可以用以下格式\n    //Blynk.email(\"Subject: Button Logger\", \"You just pushed the button...\");\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  //当开发板连接到服务器时，发送一封邮件\n  //收件人，邮件主题，邮件内容\n  Blynk.email(\"your_email@mail.com\", \"Subject\", \"My Blynk project is online.\");\n  // 设置按钮管脚为中断输入\n  pinMode(2, INPUT_PULLUP);\n  // 为GPIO2设置中断，中断函数为emailOnButtonPress\n  attachInterrupt(digitalPinToInterrupt(2), emailOnButtonPress, CHANGE);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "led",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, blinkLedWidget);//每隔1秒执行blinkLedWidget函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "led",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "blinkLedWidget",
          "parameters": "",
          "body": "if (ledStatus) {\n    led1.setColor(BLYNK_RED);//设置为红色\n    Serial.println(\"LED on V1: red\");\n    ledStatus = false;\n  } else {\n    led1.setColor(BLYNK_GREEN);//设置为绿色\n    Serial.println(\"LED on V1: green\");\n    ledStatus = true;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  led1.on();//点亮LED\n  timer.setInterval(1000L, blinkLedWidget);//每隔一秒运行blinkLedWidget函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "led",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(300L, fadeLedWidget);//每隔300毫秒执行fadeLedWidget函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "digitalread",
        "led",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "buttonLedWidget",
          "parameters": "",
          "body": "boolean isPressed = (digitalRead(btnPin) == LOW);//读取按钮是否按下，注意，此处是针对 低电平 有效的按钮\n  if (isPressed != btnState) {//如果当前按钮状态与之前不一样\n    if (isPressed) {//如果当前是按下的\n      led3.on();//点亮led\n    } else {\n      led3.off();//关闭led\n    }\n    btnState = isPressed;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  pinMode(btnPin, INPUT_PULLUP);//btnPin管脚设为上升中断模式\n  timer.setInterval(500L, buttonLedWidget);//每隔500毫秒执行buttonLedWidget"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "led",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  // Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {};          // Wait to open the serial monitor\n  \n  motor.begin();               // Configure inputs pins, outputs pins and interruptions pins\n  motor.startWithoutHoming();  // Initialize the motor without homing procedure, detached\n                               // interruptions pins and configures endstops as OUTPUT\n                               // Use this function only with the motor outside the axis"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(motor.readBtnForward() == HIGH)\n    motor.moveForward();        // Motor rotates clockwise\n\n  // Check the backward button signal\n  if(motor.readBtnBackward() == HIGH)\n    motor.moveBackward();       // Motor rotates anticlockwise"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  axis.begin();                 // Configure inputs pins, outputs pins and interruptions pins\n\n  Serial.println(\"Press the Start Button to start the machine.\");\n  while(!axis.ready());         // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure\n  \n  Serial.println(\"Move the axis between to minimum step (zero, 0) and the total step (\" + String(String(axis.getTotalSteps())) + \")\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the step: \");\n  \n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){};\n  stepNum = Serial.parseInt();  // Reads the value in the serial port\n\n  // Print the current step value before running the command\n  Serial.println(\"Current step before: \" + String(axis.getStep()));\n\n  axis.toStep(stepNum);         // Runs the command\n\n  // Print the current step value after running the command\n  Serial.println(\"Current steps after: \" + String(axis.getStep()));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "delay",
        "matrix",
        "meterscreen"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "parameters": "lv_event_t * e",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object\n  }\n  else {\n    lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  }"
        },
        {
          "name": "eventHandlerMenu",
          "parameters": "lv_event_t * e",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen();\n  lv_obj_del(btnm);"
        },
        {
          "name": "meterScreen",
          "parameters": "void",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 22, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(motorMenu);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 10.00;\n    } else {\n      currentAngle = 315;\n    }\n  }\n\n  // Check if the Joystick Right is pressed\n  if (pressedKey == JOYSTICK_RIGHT) {\n    if (currentAngle > 15 ) {\n      currentAngle -= 10.00;\n    } else {\n      currentAngle = 0;\n    }\n  }\n\n  Braccio.move(motorID).to(currentAngle); // Moves the motor to the new angle\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "distance",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (Braccio.begin()){\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n    movement = true; // Trigger joints' movements\n\n  if (movement) {\n    Braccio.moveTo(AGREE_POS[0], AGREE_POS[1], AGREE_POS[2], AGREE_POS[3], AGREE_POS[4], AGREE_POS[5]);\n    delay(TIME_DELAY/10);\n\n    for (int i = 1; i <= 10; i++) {\n      wristPitch.move().to(190.0f);       delay(TIME_DELAY/2);\n      wristPitch.move().to(240.0f);       delay(TIME_DELAY);\n      wristPitch.move().to(AGREE_POS[3]);\n    }\n\n    movement = false; // Stop joints' movements\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(); // Initialize Braccio\n  \n  delay(500); // Waits for the Braccio initialization\n  \n  // Sets the initial angle for the motors\n  for(int i = 1; i <= 6; i++){\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly\n  }\n    \n  Serial.begin(115200);\n  \n  Serial.println(\"Press the Enter Button to select the motor 1.\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n  \n  // Check if the control key pressed is the Enter Button\n  if(pressedKey == BUTTON_ENTER){\n    if(motorID < 6){\n      \n      motorID++;  // Increment the ID\n      \n    } else {\n      motorID = 1; // Restart the ID to motor 1\n    }\n    \n    currentAngle = initialAngle;\n    \n    while(Braccio.getKey() == BUTTON_ENTER); // Avoids more than one increment\n\n    Serial.println(\"Motor \" + String(motorID) + \" selected.\");\n    Serial.println(\"Use the left and right joystick to move the selected motor.\");\n  }\n\n  // Check if the Joystick Left is pressed\n  if(pressedKey == JOYSTICK_LEFT){\n    currentAngle = currentAngle + 5.00;\n  }\n\n  // Check if the Joystick Right is pressed\n  if(pressedKey == JOYSTICK_RIGHT){\n    currentAngle = currentAngle - 5.00;\n  }\n  \n  Braccio.move(motorID).to(currentAngle); // Moves the motor to the new angle\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "parameters": "lv_event_t * e",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_PRESSING) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s is pressed\\n\", txt);\n    Serial.println(String(txt) + \" is pressed.\");\n  }\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n\n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n\n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  robot.begin();                // Configure the two-axis robot inputs pins, outputs pins, and interruptions pins\n\n  Serial.println(\"Press the Start Button to start the machine\");\n  while(!robot.ready());        // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the step for X-axis: \");\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){};\n  stepNumX = Serial.parseInt(); // Reads the value in the serial port\n\n  \n  Serial.println(\"Enter the number of the step for Y-axis: \");\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){};\n  stepNumY = Serial.parseInt(); // Reads the value in the serial port\n\n  // Print the current step value before running the command\n  Serial.println(\"Current step before - X-axis: \" + String(axisX.getStep()));\n  Serial.println(\"Current step before - Y-axis: \" + String(axisY.getStep()));\n  \n  robot.toStepXY(stepNumX, stepNumY); // Runs the command\n\n  // Print the axis current step value after running the command\n  Serial.println(\"Current steps after - X-axis: \" + String(axisX.getStep()));\n  Serial.println(\"Current steps after - Y-axis: \" + String(axisY.getStep()));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "millis",
        "display",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "parameters": "",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "spi"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "spi"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "spi",
        "display"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "led",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n//Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  axis.begin();                 // Configure inputs pins, outputs pins and interruptions pins\n\n  Serial.println(\"Press the Start Button to start the machine\");\n  while(!axis.ready());         // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure\n  \n  Serial.println(\"Move the axis between to minimum position 0cm and the maximum position 45cm\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the position: \");\n  \n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){};\n  // Reads the value in the serial port\n  positionNum = Serial.parseInt(); \n\n  // Print the position before running the command\n  Serial.println(\"Position before: \" + String(axis.getPosition()));\n\n  axis.toPosition(positionNum); // Runs the command\n\n  // Print the position after running the command\n  Serial.println(\"Position after: \" + String(axis.getPosition()));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "buffer",
        "analogread"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {};         // Wait to open the serial monitor\n\n  motor.begin();              // Configure inputs pins, outputs pins and interruptions pins\n\n  motor.startWithoutHoming(); // Initialize the motor without homing procedure, detached\n                              // interruptions pins and configures endstops as OUTPUT\n                              // Use this function only with the motor outside the axis\n  \n  Serial.println(\"To start, send any key to serial port ...\");\n  // Without this instruction the motor will move after the upload (It is dangerous)\n  // Wait for data in the serial port\n  while((Serial.available() <= 0)){};\n  Serial.read();              // Clean serial buffer\n\n  Serial.println(\"Use the potentiometer to control the speed.\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the input pin\n  speedMotor = analogRead(potentiometer);\n\n  // Re-maps an analog value to speed value\n  speedMotor = map(speedMotor, 0, 1023, MIN_SPEED, MAX_SPEED);\n\n  Serial.println(speedMotor); // Send the new value to serial monitor\n\n  motor.setSpeed(speedMotor); // Sets the motor speed\n  \n  // Check the forward button signal\n  if(motor.readBtnForward() == HIGH)\n    motor.moveForward();      // Motor rotates clockwise"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "delay",
        "matrix",
        "meterscreen"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "parameters": "lv_event_t * e",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object\n  }\n  else {\n    lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  }"
        },
        {
          "name": "eventHandlerMenu",
          "parameters": "lv_event_t * e",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen();\n  lv_obj_del(btnm);"
        },
        {
          "name": "meterScreen",
          "parameters": "void",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 22, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 3, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(motorMenu);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 10.00;\n    } else {\n      currentAngle = 315;\n    }\n  }\n\n  // Check if the Joystick Right is pressed\n  if (pressedKey == JOYSTICK_RIGHT) {\n    if (currentAngle > 15 ) {\n      currentAngle -= 10.00;\n    } else {\n      currentAngle = 0;\n    }\n  }\n\n  Braccio.move(motorID).to(currentAngle); // Moves the motor to the new angle\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "parameters": "lv_event_t * e",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_RELEASED) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was released\\n\", txt);\n    Serial.println(String(txt) + \" was released.\");\n  }\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n\n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n\n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Braccio.begin();\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly\n  }\n\n  Serial.begin(115200);\n  while (!Serial) {}\n\n  Serial.println(\"Press the up and down joystick to select one motor.\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  // Check if the control key pressed is the Joystick Up\n  if (pressedKey == JOYSTICK_UP) {\n\n    if (motorID < 6) {\n      motorID++;  // Increment the ID\n    } else {\n      motorID = 1; // Restart the ID to motor 1\n    }\n\n    currentAngle = initialAngle;\n    \n    while (Braccio.getKey() == JOYSTICK_UP); // Avoids more than one increment\n\n    Serial.println(\"Motor \" + String(motorID) + \" selected.\");\n    Serial.println(\"Use the left and right joystick to move the selected motor.\");\n  }\n\n  // Check if the control key pressed is the Joystick Down\n  if (pressedKey == JOYSTICK_DOWN) {\n\n    if (motorID > 1) {\n      motorID--;  // Increment the ID\n    } else {\n      motorID = 6; // Select motor 6\n    }\n\n    while (Braccio.getKey() == JOYSTICK_DOWN); // Avoids more than one increment\n\n    Serial.println(\"Motor \" + String(motorID) + \" selected.\");\n    Serial.println(\"Use the left and right joystick to move the selected motor.\");\n  }\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    currentAngle = currentAngle + 5.00;\n  }\n\n  // Check if the Joystick Right is pressed\n  if (pressedKey == JOYSTICK_RIGHT) {\n    currentAngle = currentAngle - 5.00;\n  }\n\n  Braccio.move(motorID).to(currentAngle); // Moves the motor to the new angle\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(0xFFFFFF));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_width(btnm1, 3, 2);  // Make \"Option 4\" twice as wide as \"Option 5\"\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial)\n  {\n  };                          // Wait to open the serial monitor\n\n  robot.begin();              // Configure the two-axis robot inputs pins, outputs pins, and interruptions pins\n\n  Serial.println(\"Press the Start Button to start the machine\");\n  while (!robot.ready())\n    ;                         // Wait for Start button to be pressed\n                              // The start button is attached to the interrupt\n                              // service routine that enables the motor and runs\n                              // the homing procedure\n\n  Serial.println(\"Move the axis between to minimum position 0cm and the maximum position 45cm\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the position for X-axis: \");\n  // Waits for the user to send a value via serial port\n  while ((Serial.available() <= 0))\n  {\n  };\n  // Reads the value in the serial port\n  positionX = Serial.parseInt();\n\n  Serial.println(\"Enter the number of the position for Y-axis: \");\n  // Waits for the user to send a value via serial port\n  while ((Serial.available() <= 0))\n  {\n  };\n  // Reads the value in the serial port\n  positionY = Serial.parseInt();\n\n  // Print the axis position before running the command\n  Serial.println(\"Position before - X-axis: \" + String(axisX.getPosition()));\n  Serial.println(\"Position before - Y-axis: \" + String(axisY.getPosition()));\n\n  // Runs the command\n  robot.toPositionXY(positionX, positionY);\n\n  // Print the axis position after running the command\n  Serial.println(\"Position after - X-axis: \" + String(axisX.getPosition()));\n  Serial.println(\"Position after - Y-axis: \" + String(axisY.getPosition()));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "led",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "sendFlagToServer",
          "parameters": "",
          "body": "if (flag) {\n    Blynk.virtualWrite(V0, 1);\n  } else {\n    Blynk.virtualWrite(V0, 0);\n  }\n  flag = !flag;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, sendFlagToServer);//每秒执行一次"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  // Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "lcd"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n\n  lcd.clear(); //LCD清屏\n  lcd.print(4, 0, \"Hello\"); // 使用格式: (X坐标: 0-15, Y坐标: 0-1, \"Message you want to print\")\n  lcd.print(4, 1, \"World\");\n  //如果在主函数中使用该函数，请通过调用事件的方式显示，如果直接显示会导致硬件掉线。"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "millis",
        "lcd",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "sendSeconds",
          "parameters": "",
          "body": "//发送秒到V0\n  Blynk.virtualWrite(V0, millis() / 1000);"
        },
        {
          "name": "sendMillis",
          "parameters": "",
          "body": "//发送微秒到V1\n  Blynk.virtualWrite(V1, millis());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n\n  timer.setInterval(1000L, sendSeconds);//发送秒\n  timer.setInterval(1000L, sendMillis);//发送微秒"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "millis",
        "lcd",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "spi"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n\n  // If you want to remove all points:\n  //myMap.clear();\n\n  int index = 0;\n  float lat = 51.5074;\n  float lon = 0.1278;\n  myMap.location(index, lat, lon, \"value\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  robot.begin();                // Configure the two-axis robot inputs pins, outputs pins, and interruptions pins\n\n  robot.setLengthXY(45, 38);    // Set the axis (X,Y) length\n  \n  Serial.println(\"Press the Start Button to start the machine\");\n  while(!robot.ready());        // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure\n  \n  Serial.println(\"Moving the robot to the initial XY position ...\");\n\n  robot.toPositionXY(INITIAL_POS_X, INITIAL_POS_Y); // Send tool to the initial position\n\n  Serial.println(\"Press the forward button to continue ...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    robot.drawLine(5,5,5,10);   // Draws one line\n    delay(500);\n\n    robot.drawLine(5,10,10,10); // Draws other line\n    delay(500);\n\n    robot.drawLine(10,10,5,5);  // Draws a diagonal line\n    delay(500);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "hc-sr04",
        "distance",
        "digitalwrite",
        "pulsein",
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "readUltrasonic",
          "parameters": "",
          "body": "long duration;                // Variable for the duration of sound wave travel\n  int distance;                 // Variable for the distance measurement\n  \n  // Clears the trigPin condition\n  digitalWrite(trigPin, LOW);\n  delayMicroseconds(2);\n\n  // Sets the trigPin HIGH (ACTIVE) for 10 microseconds\n  digitalWrite(trigPin, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(trigPin, LOW);\n\n  // Reads the echoPin, returns the sound wave travel time in microseconds\n  duration = pulseIn(echoPin, HIGH);\n\n  // Calculating the distance\n   // Speed of sound wave divided by 2 (go and back)\n  distance = duration * 0.034 / 2;\n\n  return distance;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(trigPin, OUTPUT);     // Sets the trigPin as an OUTPUT\n  pinMode(echoPin, INPUT);      // Sets the echoPin as an INPUT\n\n  Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  axis.begin();                 // Configure inputs pins, outputs pins and interruptions pins\n\n  Serial.println(\"Press the Start Button to start the machine\");\n  while(!axis.ready());         // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure\n \n  Serial.println(\"Move the axis between to minimum position 0cm and the maximum position 45cm\");\n\n  Serial.println(\"Move some object in front of the sensor\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward()){\n    positionNum = readUltrasonic() - motorOffset;\n    // Moves the robot carriage\n    axis.toPosition(positionNum);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_BG));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_BTN));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_BORDER));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEXT));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_width(btnm1, 1, 2);  // Make \"Button 2\" twice as wide as \"Button 3\"\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "wifi",
        "millis",
        "timer",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "parameters": "",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);\n  Blynk.virtualWrite(V6, millis() / 1000);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  // Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);\n   timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  robot.begin();                // Configure the two-axis robot inputs pins, outputs pins, and interruptions pins\n\n  robot.setLengthXY(45, 38);    // Set the axis (X,Y) length\n  \n  Serial.println(\"Press the Start Button to start the machine\");\n  while(!robot.ready());        // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure\n  \n  Serial.println(\"Moving the robot to the initial XY position ...\");\n\n  robot.toPositionXY(INITIAL_POS_X, INITIAL_POS_Y); // Send tool to the initial position\n\n  Serial.println(\"Press the forward button to continue ...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    robot.drawLine(5,5,5,10);   // Draws horizontal line\n    delay(500);\n\n    robot.drawLine(5,10,10,10); // Draws vertical line\n    delay(500);\n\n    robot.drawLine(10,10,10,5); // Draws horizontal line\n    delay(500);\n\n    robot.drawLine(10,5,5,5);   // Draws a vertical line\n    delay(500);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "rgb",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "Adafruit_NeoPixel.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);\n  strip.begin();\n  strip.show();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "wifi",
        "led",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "spi"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n\n  // Clear the terminal content\n  terminal.clear();\n\n  // This will print Blynk Software version to the Terminal Widget when\n  // your hardware gets connected to Blynk Server\n  terminal.println(F(\"Blynk v\" BLYNK_VERSION \": Device started\"));\n  terminal.println(F(\"-------------\"));\n  terminal.println(F(\"Type 'Marco' and get a reply, or type\"));\n  terminal.println(F(\"anything else and get it printed back.\"));\n  terminal.flush();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "api",
        "auth",
        "https",
        "ssl",
        "json",
        "wifi"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  Blynk.virtualWrite(V0, \"https://raw.githubusercontent.com/blynkkk/blynk-library/master/extras/logo.txt\");\n\n  // You can perform HTTPS requests even if your hardware alone can't handle SSL\n  // 如果您使用的开发板有足够的RAM，\n  //Blynk也可以接收更大的消息。你可以设置BLYNK_MAX_READBYTES 为4096\n  //Blynk.virtualWrite(V0, \"https://api.sunrise-sunset.org/json?lat=50.4495484&lng=30.5253873&date=2016-10-01\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "interrupt"
      ],
      "libraries": [
        "Arduino_EMBRYO_2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {};           // Wait to open the serial monitor\n\n  robot.begin();                // Configure the two-axis robot inputs pins, outputs pins, and interruptions pins\n\n  robot.setLengthXY(45, 25);    // Set the axis (X,Y) length\n  \n  Serial.println(\"Press the Start Button to start the machine\");\n  while(!robot.ready());        // Wait for Start button to be pressed\n                                // The start button is attached to the interrupt\n                                // service routine that enables the motor and runs\n                                // the homing procedure\n  \n  Serial.println(\"Moving the robot to the initial XY position ...\");\n\n  // Send tool to the initial position\n  robot.toPositionXY(CENTER_X, CENTER_Y);\n  \n  Serial.println(\"Press the forward button to continue ...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    // Draws a circle\n    robot.drawCircle(CENTER_X, CENTER_Y, RADIUS);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "millis",
        "delay",
        "analogread"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_19V);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);\n    }\n    Serial.println(\" done.\");\n\n    Input.begin();\n    Input.enable();\n\n    analogReadResolution(adcResolution);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"19V Input Channel \");\n    Serial.print(\": \");\n\n    auto [ voltsMuxer, voltsReference ] = getAverageAnalogRead(INPUT_19V_REF);\n\n    Serial.print(voltsReference);\n    Serial.print(\" (\");\n    Serial.print(voltsMuxer);\n    Serial.println(\")\");\n    delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "display",
        "tft",
        "lcd",
        "sd"
      ],
      "libraries": [
        "LovyanGFX.hpp",
        "LGFX_AUTODETECT.hpp",
        "lgfx_user/LGFX_ESP32_sample.hpp",
        "LGFX_TFT_eSPI.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "// 最初に初期化関数を呼び出します。\n  lcd.init();\n\n\n// 回転方向を 0～3 の4方向から設定します。(4～7を使用すると上下反転になります。)\n  lcd.setRotation(1);\n\n\n// バックライトの輝度を 0～255 の範囲で設定します。\n  lcd.setBrightness(128);\n\n\n// 必要に応じてカラーモードを設定します。（初期値は16）\n// 16の方がSPI通信量が少なく高速に動作しますが、赤と青の諧調が5bitになります。\n// 24の方がSPI通信量が多くなりますが、諧調表現が綺麗になります。\n//lcd.setColorDepth(16);  // RGB565の16ビットに設定\n  lcd.setColorDepth(24);  // RGB888の24ビットに設定(表示される色数はパネル性能によりRGB666の18ビットになります)\n\n\n// 基本的な図形の描画関数は以下の通りです。\n/*\n  fillScreen    (                color);  // 画面全体の塗り潰し\n  drawPixel     ( x, y         , color);  // 点\n  drawFastVLine ( x, y   , h   , color);  // 垂直線\n  drawFastHLine ( x, y, w      , color);  // 水平線\n  drawRect      ( x, y, w, h   , color);  // 矩形の外周\n  fillRect      ( x, y, w, h   , color);  // 矩形の塗り\n  drawRoundRect ( x, y, w, h, r, color);  // 角丸の矩形の外周\n  fillRoundRect ( x, y, w, h, r, color);  // 角丸の矩形の塗り\n  drawCircle    ( x, y      , r, color);  // 円の外周\n  fillCircle    ( x, y      , r, color);  // 円の塗り\n  drawEllipse   ( x, y, rx, ry , color);  // 楕円の外周\n  fillEllipse   ( x, y, rx, ry , color);  // 楕円の塗り\n  drawLine      ( x0, y0, x1, y1        , color); // ２点間の直線\n  drawTriangle  ( x0, y0, x1, y1, x2, y2, color); // ３点間の三角形の外周\n  fillTriangle  ( x0, y0, x1, y1, x2, y2, color); // ３点間の三角形の塗り\n  drawBezier    ( x0, y0, x1, y1, x2, y2, color); // ３点間のベジエ曲線\n  drawBezier    ( x0, y0, x1, y1, x2, y2, x3, y3, color); // ４点間のベジエ曲線\n  drawArc       ( x, y, r0, r1, angle0, angle1, color);   // 円弧の外周\n  fillArc       ( x, y, r0, r1, angle0, angle1, color);   // 円弧の塗り\n*/\n\n\n// 例えばdrawPixelで点を書く場合は、引数は X座標,Y座標,色 の３つ。\n  lcd.drawPixel(0, 0, 0xFFFF); // 座標0:0に白の点を描画\n\n\n// カラーコードを生成する関数が用意されており、色の指定に使用できます。\n// 引数は、赤,緑,青をそれぞれ 0～255で指定します。\n// 色情報の欠落を防ぐため、color888を使う事を推奨します。\n  lcd.drawFastVLine(2, 0, 100, lcd.color888(255,   0,   0)); // 赤で垂直の線を描画\n  lcd.drawFastVLine(4, 0, 100, lcd.color565(  0, 255,   0)); // 緑で垂直の線を描画\n  lcd.drawFastVLine(6, 0, 100, lcd.color332(  0,   0, 255)); // 青で垂直の線を描画\n\n\n// カラーコード生成関数を使用しない場合は以下のようになります。\n// RGB888 24ビットで指定 uint32_t型\n// RGB565 16ビットで指定 uint16_t型、int32_t型\n// RGB332  8ビットで指定 uint8_t型\n\n// uint32_t型を使用すると、RGB888の24ビットとして扱われます。\n// 16進数2桁で赤緑青の順に記述できます。\n// uint32_t型の変数を使うか、末尾にUを付けるか、uint32_t型にキャストして使用します。\n  uint32_t red = 0xFF0000;\n  lcd.drawFastHLine(0, 2, 100, red);            // 赤で水平の線を描画\n  lcd.drawFastHLine(0, 4, 100, 0x00FF00U);      // 緑で水平の線を描画\n  lcd.drawFastHLine(0, 6, 100, (uint32_t)0xFF); // 青で水平の線を描画\n\n\n// uint16_t型およびint32_t型を使用すると、RGB565の16ビットとして扱われます。\n// 特別な書き方をしない場合はint32_t型として扱われるので、この方式になります。\n// （AdafruitGFX や TFT_eSPI との互換性のために、このようにしています。）\n  uint16_t green = 0x07E0;\n  lcd.drawRect(10, 10, 50, 50, 0xF800);         // 赤で矩形の外周を描画\n  lcd.drawRect(12, 12, 50, 50, green);          // 緑で矩形の外周を描画\n  lcd.drawRect(14, 14, 50, 50, (uint16_t)0x1F); // 青で矩形の外周を描画\n\n\n// int8_t型、uint8_t型を使用すると、RGB332の8ビットとして扱われます。\n  uint8_t blue = 0x03;\n  lcd.fillRect(20, 20, 20, 20, (uint8_t)0xE0);  // 赤で矩形の塗りを描画\n  lcd.fillRect(30, 30, 20, 20, (uint8_t)0x1C);  // 緑で矩形の塗りを描画\n  lcd.fillRect(40, 40, 20, 20, blue);           // 青で矩形の塗りを描画\n\n\n// 描画関数の引数の色は省略できます。\n// 省略した場合、setColor関数で設定した色 または最後に使用した色を描画色として使用します。\n// 同じ色で繰り返し描画する場合は、省略した方がわずかに速く動作します。\n  lcd.setColor(0xFF0000U);                        // 描画色に赤色を指定\n  lcd.fillCircle ( 40, 80, 20    );               // 赤色で円の塗り\n  lcd.fillEllipse( 80, 40, 10, 20);               // 赤色で楕円の塗り\n  lcd.fillArc    ( 80, 80, 20, 10, 0, 90);        // 赤色で円弧の塗り\n  lcd.fillTriangle(80, 80, 60, 80, 80, 60);       // 赤色で三角の塗り\n  lcd.setColor(0x0000FFU);                        // 描画色に青色を指定\n  lcd.drawCircle ( 40, 80, 20    );               // 青色で円の外周\n  lcd.drawEllipse( 80, 40, 10, 20);               // 青色で楕円の外周\n  lcd.drawArc    ( 80, 80, 20, 10, 0, 90);        // 青色で円弧の外周\n  lcd.drawTriangle(60, 80, 80, 80, 80, 60);       // 青色で三角の外周\n  lcd.setColor(0x00FF00U);                        // 描画色に緑色を指定\n  lcd.drawBezier( 60, 80, 80, 80, 80, 60);        // 緑色で二次ベジエ曲線\n  lcd.drawBezier( 60, 80, 80, 20, 20, 80, 80, 60);// 緑色で三次ベジエ曲線\n\n// グラデーションの線を描画するdrawGradientLine は色の指定を省略できません。\n  lcd.drawGradientLine( 0, 80, 80, 0, 0xFF0000U, 0x0000FFU);// 赤から青へのグラデーション直線\n\n  delay(1000);\n\n// clearまたはfillScreenで画面全体を塗り潰せます。\n// fillScreenはfillRectの画面全体を指定したのと同じで、色の指定は描画色の扱いになります。\n  lcd.fillScreen(0xFFFFFFu);  // 白で塗り潰し\n  lcd.setColor(0x00FF00u);    // 描画色に緑色を指定\n  lcd.fillScreen();           // 緑で塗り潰し\n\n// clearは描画系の関数とは別で背景色という扱いで色を保持しています。\n// 背景色は出番が少ないですが、スクロール機能使用時の隙間を塗る色としても使用されます。\n  lcd.clear(0xFFFFFFu);       // 背景色に白を指定して塗り潰し\n  lcd.setBaseColor(0x000000u);// 背景色に黒を指定\n  lcd.clear();                // 黒で塗り潰し\n\n\n// SPIバスの確保と解放は描画関数を呼び出した時に自動的に行われますが、\n// 描画スピードを重視する場合は、描画処理の前後に startWriteとendWriteを使用します。\n// SPIバスの確保と解放が抑制され、速度が向上します。\n// 電子ペーパー(EPD)の場合、startWrite()以降の描画は、endWrite()を呼ぶ事で画面に反映されます。\n  lcd.drawLine(0, 1, 39, 40, red);       // SPIバス確保、線を描画、SPIバス解放\n  lcd.drawLine(1, 0, 40, 39, blue);      // SPIバス確保、線を描画、SPIバス解放\n  lcd.startWrite();                      // SPIバス確保\n  lcd.drawLine(38, 0, 0, 38, 0xFFFF00U); // 線を描画\n  lcd.drawLine(39, 1, 1, 39, 0xFF00FFU); // 線を描画\n  lcd.drawLine(40, 2, 2, 40, 0x00FFFFU); // 線を描画\n  lcd.endWrite();                        // SPIバス解放\n\n\n// startWriteとendWriteは呼出し回数を内部でカウントしており、\n// 繰り返し呼び出した場合は最初と最後のみ動作します。\n// startWriteとendWriteは必ず対になるように使用してください。\n// (SPIバスを占有して構わない場合は、最初にstartWriteを一度呼び、endWriteしない使い方も可能です。)\n  lcd.startWrite();     // カウント+1、SPIバス確保\n  lcd.startWrite();     // カウント+1\n  lcd.startWrite();     // カウント+1\n  lcd.endWrite();       // カウント-1\n  lcd.endWrite();       // カウント-1\n  lcd.endWrite();       // カウント-1、SPIバス解放\n  lcd.endWrite();       // 何もしない\n// なお過剰にendWriteを呼び出した場合は何も行わず、カウントがマイナスになることもありません。\n\n\n// startWriteのカウントの状態に依らず、強制的にSPIバスを解放・確保したい場合は、\n// endTransaction・beginTransactionを使用します。\n// カウントはクリアされないので、辻褄が合わなくならないよう注意してください。\n  lcd.startWrite();       // カウント+1、SPIバス確保\n  lcd.startWrite();       // カウント+1\n  lcd.drawPixel(0, 0);    // 描画\n  lcd.endTransaction();   // SPIバス解放\n  // ここで他のSPIデバイスの使用が可能\n  // 同じSPIバスの別のデバイス(SDカード等)を使う場合、\n  // 必ずSPIバスが解放された状態で行ってください。\n  lcd.beginTransaction(); // SPIバスの確保\n  lcd.drawPixel(0, 0);    // 描画\n  lcd.endWrite();         // カウント-1\n  lcd.endWrite();         // カウント-1、SPIバス解放\n\n\n\n// drawPixelとは別に、writePixelという点を描画する関数があります。\n// drawPixelは必要に応じてSPIバスの確保を行うのに対し、\n// writePixelはSPIバスの状態をチェックしません。\n  lcd.startWrite();  // SPIバス確保\n  for (uint32_t x = 0; x < 128; ++x) {\n    for (uint32_t y = 0; y < 128; ++y) {\n      lcd.writePixel(x, y, lcd.color888( x*2, x + y, y*2));\n    }\n  }\n  lcd.endWrite();    // SPIバス解放\n// 名前が write～ で始まる関数は全て明示的にstartWriteを呼び出しておく必要があります。\n// writePixel、writeFastVLine、writeFastHLine、writeFillRect が該当します。\n\n  delay(1000);\n\n// スプライト（オフスクリーン）への描画も同様の描画関数が使えます。\n// 最初にスプライトの色深度をsetColorDepthで指定します。（省略した場合は16として扱われます。）\n//sprite.setColorDepth(1);   // 1ビット( 2色)パレットモードに設定\n//sprite.setColorDepth(2);   // 2ビット( 4色)パレットモードに設定\n//sprite.setColorDepth(4);   // 4ビット(16色)パレットモードに設定\n//sprite.setColorDepth(8);   // RGB332の8ビットに設定\n//sprite.setColorDepth(16);  // RGB565の16ビットに設定\n  sprite.setColorDepth(24);  // RGB888の24ビットに設定\n\n\n// ※ setColorDepth(8);を設定後に createPalette()を呼ぶ事で、256色パレットモードになります\n// sprite.createPalette();\n\n\n// createSpriteで幅と高さを指定してメモリを確保します。\n// 消費するメモリは色深度と面積に比例します。大きすぎるとメモリ確保に失敗しますので注意してください。\n  sprite.createSprite(65, 65); // 幅65、高さ65でスプライトを作成。\n\n  for (uint32_t x = 0; x < 64; ++x) {\n    for (uint32_t y = 0; y < 64; ++y) {\n      sprite.drawPixel(x, y, lcd.color888(3 + x*4, (x + y)*2, 3 + y*4));  // スプライトに描画\n    }\n  }\n  sprite.drawRect(0, 0, 65, 65, 0xFFFF);\n\n// 作成したスプライトはpushSpriteで任意の座標に出力できます。\n// 出力先はインスタンス作成時に引数で渡したLGFXになります。\n  sprite.pushSprite(64, 0);        // lcdの座標64,0にスプライトを描画\n\n// spriteのインスタンス作成時に描画先のポインタを渡していない場合や、\n// 複数のLGFXがある場合などは、出力先を第一引数に指定してpushSpriteすることもできます。\n  sprite.pushSprite(&lcd, 0, 64);  // lcdの座標0,64にスプライトを描画\n\n  delay(1000);\n\n  // pushRotateZoomでスプライトを回転拡大縮小して描画できます。\n  // setPivotで設定した座標が回転中心として扱われ、描画先の座標に回転中心が位置するように描画されます。\n  sprite.setPivot(32, 32);    // 座標32,32を中心として扱う\n  int32_t center_x = lcd.width()/2;\n  int32_t center_y = lcd.height()/2;\n  lcd.startWrite();\n  for (int angle = 0; angle <= 360; ++angle) {\n    sprite.pushRotateZoom(center_x, center_y, angle, 2.5, 3); // 画面中心に角度angle、幅2.5倍、高さ3倍で描画\n\n    if ((angle % 36) == 0) lcd.display(); // 電子ペーパーの場合の表示更新を 36回に一度行う\n  }\n  lcd.endWrite();\n\n  delay(1000);\n\n  // 使用しなくなったスプライトのメモリを解放するには deleteSprite を使用します。\n  sprite.deleteSprite();\n\n  // deleteSprite の後でも、同じインスタンスの再利用が可能です。\n  sprite.setColorDepth(4);     // 4ビット(16色)パレットモードに設定\n  sprite.createSprite(65, 65);\n\n  // パレットモードのスプライトでは、描画関数の引数の色をパレット番号として扱います。\n  // pushSprite等で描画する際に、パレットを参照して実際の描画色が決まります。\n\n  // 4ビット(16色)パレットモードの場合、パレット番号は0～15が使用可能です。\n  // パレットの初期色は、0が黒,末尾のパレットが白で、0から末尾にかけてグラデーションになっています。\n  // パレットの色を設定するには setPaletteColor を使用します。\n  sprite.setPaletteColor(1, 0x0000FFU);    // パレット1番を青に設定\n  sprite.setPaletteColor(2, 0x00FF00U);    // パレット2番を緑に設定\n  sprite.setPaletteColor(3, 0xFF0000U);    // パレット3番を赤に設定\n\n  sprite.fillRect(10, 10, 45, 45, 1);             // パレット1番で矩形の塗り\n  sprite.fillCircle(32, 32, 22, 2);               // パレット2番で円の塗り\n  sprite.fillTriangle(32, 12, 15, 43, 49, 43, 3); // パレット3番で三角の塗り\n\n  // pushSpriteの最後の引数で、描画しない色を指定することができます。\n  sprite.pushSprite( 0,  0, 0);  // パレット0を透過扱いでスプライトを描画\n  sprite.pushSprite(65,  0, 1);  // パレット1を透過扱いでスプライトを描画\n  sprite.pushSprite( 0, 65, 2);  // パレット2を透過扱いでスプライトを描画\n  sprite.pushSprite(65, 65, 3);  // パレット3を透過扱いでスプライトを描画\n\n  delay(5000);\n\n  lcd.startWrite(); // ここでstartWrite()することで、SPIバスを占有したままにする。"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "static int count = 0;\n  static int a = 0;\n  static int x = 0;\n  static int y = 0;\n  static float zoom = 3;\n  ++count;\n  if ((a += 1) >= 360) a -= 360;\n  if ((x += 2) >= lcd.width()) x -= lcd.width();\n  if ((y += 1) >= lcd.height()) y -= lcd.height();\n  sprite.setPaletteColor(1, lcd.color888( 0, 0, count & 0xFF));\n  sprite.setPaletteColor(2, lcd.color888( 0,~count & 0xFF, 0));\n  sprite.setPaletteColor(3, lcd.color888( count & 0xFF, 0, 0));\n\n  sprite.pushRotateZoom(x, y, a, zoom, zoom, 0);\n\n  if ((count % 100) == 0) lcd.display(); // 電子ペーパーの場合の表示更新を 100回に一度行う"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "i2c",
        "ili9341",
        "lcd",
        "display",
        "sd",
        "pwm"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "// SPIバスとパネルの初期化を実行すると使用可能になります。\n  display.init();\n\n  display.setTextSize((std::max(display.width(), display.height()) + 255) >> 8);\n\n  // タッチが使用可能な場合のキャリブレーションを行います。（省略可）\n  if (display.touch())\n  {\n    if (display.width() < display.height()) display.setRotation(display.getRotation() ^ 1);\n\n    // 画面に案内文章を描画します。\n    display.setTextDatum(textdatum_t::middle_center);\n    display.drawString(\"touch the arrow marker.\", display.width()>>1, display.height() >> 1);\n    display.setTextDatum(textdatum_t::top_left);\n\n    // タッチを使用する場合、キャリブレーションを行います。画面の四隅に表示される矢印の先端を順にタッチしてください。\n    std::uint16_t fg = TFT_WHITE;\n    std::uint16_t bg = TFT_BLACK;\n    if (display.isEPD()) std::swap(fg, bg);\n    display.calibrateTouch(nullptr, fg, bg, std::max(display.width(), display.height()) >> 3);\n  }\n\n  display.fillScreen(TFT_BLACK);"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "display.startWrite();\n  display.setRotation(++count & 7);\n  display.setColorDepth((count & 8) ? 16 : 24);\n\n  display.setTextColor(TFT_WHITE);\n  display.drawNumber(display.getRotation(), 16, 0);\n\n  display.setTextColor(0xFF0000U);\n  display.drawString(\"R\", 30, 16);\n  display.setTextColor(0x00FF00U);\n  display.drawString(\"G\", 40, 16);\n  display.setTextColor(0x0000FFU);\n  display.drawString(\"B\", 50, 16);\n\n  display.drawRect(30,30,display.width()-60,display.height()-60,count*7);\n  display.drawFastHLine(0, 0, 10);\n\n  display.endWrite();\n\n  int32_t x, y;\n  if (display.getTouch(&x, &y)) {\n    display.fillRect(x-2, y-2, 5, 5, count*7);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    while(!Serial);\n\n    delay(1000);\n\n    Serial.println(\"3-Wire Valve Demo\");\n\n    EdgeControl.begin();\n    Latching.begin();\n\n    Serial.println(\"Starting\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Closing\");\n    Latching.channelDirection(LATCHING_OUT_1, POSITIVE);\n    Latching.strobe(4500);\n\n    delay(2500);\n\n    Serial.println(\"Opening\");\n    Latching.channelDirection(LATCHING_OUT_1, NEGATIVE);\n    Latching.strobe(4500);\n    delay(2500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "lcd"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "drawGradation",
          "parameters": "void",
          "body": "// 背景にグラデーションを描画する\n  lcd.startWrite();\n  lcd.setAddrWindow(0, 0, lcd.width(), lcd.height());\n  for (int y = 0; y < lcd.height(); ++y) {\n    for (int x = 0; x < lcd.width(); ++x) {\n      lcd.writeColor(lcd.color888(x>>1, (x + y) >> 2, y>>1), 1);\n    }\n  }\n  lcd.endWrite();"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "lcd.init();\n\n  drawGradation();\n\n  // 文字の描画方法には大きく分けて２通り、print 系の関数と drawString 系の関数があります。\n\n  // drawString 関数では、第１引数で文字列を指定し、第２引数でX座標、第３引数でY座標を指定します。\n  lcd.drawString(\"string!\", 10, 10);\n\n  // drawNumber 関数では、第１引数が数値になります。\n  lcd.drawNumber(123, 100, 10);\n\n  // drawFloat 関数では、第１引数が数値、第２引数が小数点以下の桁数になり、第３引数がX座標、第４引数がY座標になります。\n  lcd.drawFloat(3.14, 2, 150, 10);\n\n  // print 関数では、setCursor関数で指定した座標 (またはprint関数で最後に描画した文字の続き)に描画します。\n  lcd.setCursor(10, 20);\n  lcd.print(\"print!\");\n\n  // printf関数で、第２引数以降の内容を描画できます。(C言語のprintf準拠ですので文字列や浮動小数も描画できます)\n  int value = 123;\n  lcd.printf(\"test %d\", value);\n\n  // println関数で、文字列を描画後に改行できます。print(\"\\n\");と同じ効果です。\n  lcd.println(\"println\");\n\n  // フォントを変更するには、setFont関数を使用します。\n  // TFT_eSPIのsetTextFont関数と同じフォントは Font0 ～ Font8 になります。\n  // ※ エディタの入力支援が使える場合、引数に&fonts::まで入力する事でフォント一覧が表示されます\n  lcd.setFont(&fonts::Font4);\n  lcd.println(\"TestFont4\");\n\n  // TFT_eSPIとの互換性のためにsetTextFont関数による番号でのフォント変更にも対応しています。\n  // 引数に指定できる数字は 0, 2, 4, 6, 7, 8 です。(TFT_eSPI準拠です)\n  // ※ ただし この方法は、他の番号のフォントも強制的にバイナリに含まれサイズが膨らむため、非推奨です。\n  lcd.setTextFont(2);\n  lcd.println(\"TestFont2\");\n\n\n  // setTextColorで色を変更できます。\n  // １つ目の引数が文字色、２つ目の引数が背景色になります。\n  lcd.setTextColor(0x00FFFFU, 0xFF0000U);\n  lcd.print(\"CyanText RedBack\");\n  // ※ 同じ場所に文字を繰り返し描画し直したい場合、背景色を指定して重ね書きすることを推奨します。\n  //    fillRect等で消去してから書き直すと、ちらつきが発生する可能性があります。\n\n\n  // setTextColorで第１引数のみを指定し第２引数を省略した場合は、\n  // 背景を塗り潰さず文字だけを描画します。\n  lcd.setTextColor(0xFFFF00U);\n  lcd.print(\"YellowText ClearBack\");\n\n\n  // Font6は時計用の文字のみが収録されています。\n  lcd.setFont(&fonts::Font6);\n  lcd.print(\"apm.:-0369\");\n\n  // Font7は７セグメント液晶風のフォントが収録されています。\n  lcd.setFont(&fonts::Font7);\n  lcd.print(\".:-147\");\n\n  // Font8は数字のみが収録されています。\n  lcd.setFont(&fonts::Font8);\n  lcd.print(\".:-258\");\n\n\n  delay(3000);\n  drawGradation();\n\n// IPAフォントをコンバートした日本語フォントが４種類ｘ９サイズ = 36通りプリセットされています。\n// 末尾の数字がサイズを表しており、8, 12, 16, 20, 24, 28, 32, 36, 40 が用意されています。\n// fonts::lgfxJapanMincho_12      // 明朝体 サイズ12 固定幅フォント\n// fonts::lgfxJapanMinchoP_16     // 明朝体 サイズ16 プロポーショナルフォント\n// fonts::lgfxJapanGothic_20      // ゴシック体 サイズ20 固定幅フォント\n// fonts::lgfxJapanGothicP_24     // ゴシック体 サイズ24 プロポーショナルフォント\n\n// efontをコンバートした日本語・韓国語・中国語（簡体字・繁体字）フォントが各４種類ｘ５サイズ＝20通りプリセットされています。\n// 数字がサイズを表しており、10, 12, 14, 16, 24 が用意されています。\n// 末尾の文字は b= ボールド(太字) / i= イタリック(斜体) を表しています。\n// fonts::efontJA_10              // 日本語 サイズ10\n// fonts::efontCN_12_b            // 簡体字 サイズ12 ボールド\n// fonts::efontTW_14_bi           // 繁体字 サイズ14 ボールドイタリック\n// fonts::efontKR_16_i            // 韓国語 サイズ16 イタリック\n\n  lcd.setCursor(0, 0);\n  lcd.setFont(&fonts::lgfxJapanMincho_16);   lcd.print(\"明朝体 16 Hello World\\nこんにちは世界\\n\");\n//lcd.setFont(&fonts::lgfxJapanMinchoP_16);  lcd.print(\"明朝 P 16 Hello World\\nこんにちは世界\\n\");\n  lcd.setFont(&fonts::lgfxJapanGothic_16);   lcd.print(\"ゴシック体 16 Hello World\\nこんにちは世界\\n\");\n//lcd.setFont(&fonts::lgfxJapanGothicP_16);  lcd.print(\"ゴシック P 16 Hello World\\nこんにちは世界\\n\");\n\n// ※ やまねこ氏の [日本語フォントサブセットジェネレーター](https://github.com/yamamaya/lgfxFontSubsetGenerator)\n//    を使用することで、必要な文字だけを含む小サイズのフォントデータを作成できます。\n\n\n  delay(3000);\n  drawGradation();\n\n\n  // LovyanGFXでは AdafruitGFX フォントも setFont 関数で使用できます。\n  // (TFT_eSPIとの互換性のために setFreeFont関数も用意しています)\n  lcd.setFont(&fonts::FreeSerif9pt7b);\n\n\n  // 右揃え や 中央揃え で描画したい場合は、setTextDatum 関数で基準位置を指定します。\n  // 縦方向が top、middle、baseline、bottomの4通り、横方向が left、center、rightの3通りです。\n  // 縦と横の指定を組み合わせた12通りの中から指定します。\n  lcd.setTextDatum( textdatum_t::top_left        );\n  lcd.setTextDatum( textdatum_t::top_center      );\n  lcd.setTextDatum( textdatum_t::top_right       );\n  lcd.setTextDatum( textdatum_t::middle_left     );\n  lcd.setTextDatum( textdatum_t::middle_center   );\n  lcd.setTextDatum( textdatum_t::middle_right    );\n  lcd.setTextDatum( textdatum_t::baseline_left   );\n  lcd.setTextDatum( textdatum_t::baseline_center );\n  lcd.setTextDatum( textdatum_t::baseline_right  );\n  lcd.setTextDatum( textdatum_t::bottom_left     );\n  lcd.setTextDatum( textdatum_t::bottom_center   );\n  lcd.setTextDatum( textdatum_t::bottom_right    );\n  // ※  \"textdatum_t::\" は省略可能です\n  // ※ print系関数には縦方向の指定のみ効果があり、横方向の指定は効果がありません。\n\n  // 右下揃え\n  lcd.setTextDatum( bottom_right );\n  lcd.drawString(\"bottom_right\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 左下揃え\n  lcd.setTextDatum( bottom_left );\n  lcd.drawString(\"bottom_left\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 右上揃え\n  lcd.setTextDatum( top_right );\n  lcd.drawString(\"top_right\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 左上揃え\n  lcd.setTextDatum( top_left );\n  lcd.drawString(\"top_left\",  lcd.width() / 2,  lcd.height() / 2);\n\n\n  // 基準座標に中心線を描画\n  lcd.drawFastVLine(lcd.width() / 2, 0, lcd.height(), 0xFFFFFFU);\n  lcd.drawFastHLine(0, lcd.height() / 2, lcd.width(), 0xFFFFFFU);\n\n\n  delay(3000);\n  drawGradation();\n\n  lcd.setFont(&Font2);\n  lcd.setCursor(0, 0);\n\n\n  lcd.drawRect(8, 8, lcd.width() - 16, lcd.height() - 16, 0xFFFFFFU);\n\n  // setClipRect関数で描画する範囲を限定できます。指定した範囲外には描画されなくなります。\n  // ※ テキスト系のみならず、すべての描画関数に影響します。\n  lcd.setClipRect(10, 10, lcd.width() - 20, lcd.height() - 20);\n\n\n  // setTextSize 関数で 文字の拡大率を指定します。\n  // 第１引数で横方向の倍率、第２引数で縦方向の倍率を指定します。\n  // 第２引数を省略した場合は、第１引数の倍率が縦と横の両方に反映されます。\n  lcd.setTextSize(2.7, 4);\n  lcd.println(\"Size 2.7 x 4\");\n\n  lcd.setTextSize(2.5);\n  lcd.println(\"Size 2.5 x 2.5\");\n\n  lcd.setTextSize(1.5, 2);\n  lcd.println(\"Size 1.5 x 2\");\n\n  delay(1000);\n\n  lcd.setTextColor(0xFFFFFFU, 0);\n  for (float i = 0; i < 30; i += 0.01) {\n    lcd.setTextSize(sin(i)+1.1, cos(i)+1.1);\n    lcd.drawString(\"size test\", 10, 10);\n  }\n\n  lcd.setTextSize(1);\n\n  // setTextWrap 関数で、print 関数が画面端(描画範囲端)に到達した時の折り返し動作を指定します。\n  // 第１引数をtrueにすると、右端到達後に左端へ移動します。\n  // 第２引数をtrueにすると、下端到達後に上端へ移動します。(省略時:false)\n  lcd.setTextWrap(false);\n  lcd.println(\"setTextWrap(false) testing... long long long long string wrap test string \");\n  // false指定時は位置調整されず、描画範囲外にはみ出した部分は描画されません。\n\n  lcd.setTextWrap(true);\n  lcd.setTextColor(0xFFFF00U, 0);\n  lcd.println(\"setTextWrap(true) testing... long long long long string wrap test string \");\n  // true指定時は描画範囲内に収まるよう座標を自動調整します。\n\n  delay(1000);\n\n  // 第２引数にtrue指定時は、画面下端に到達すると続きを上端から描画します。\n  lcd.setTextColor(0xFFFFFFU, 0);\n  lcd.setTextWrap(true, true);\n  lcd.println(\"setTextWrap(true, true) testing...\");\n  for (int i = 0; i < 100; ++i) {\n    lcd.printf(\"wrap test %03d \", i);\n    delay(50);\n  }\n\n\n  drawGradation();\n\n  // setTextScroll 関数で、画面下端に到達した時のスクロール動作を指定します。\n  // setScrollRect 関数でスクロールする矩形範囲を指定します。(未指定時は画面全体がスクロールします)\n  // ※ スクロール機能は、LCDが画素読出しに対応している必要があります。\n  lcd.setTextScroll(true);\n\n  // 第１～第４引数で X Y Width Height の矩形範囲を指定し、第５引数でスクロール後の色を指定します。第５引数は省略可(省略時は変更なし)\n  lcd.setScrollRect(10, 10, lcd.width() - 20, lcd.height() - 20, 0x00001FU);\n\n  for (int i = 0; i < 50; ++i) {\n    lcd.printf(\"scroll test %d \\n\", i);\n  }\n\n\n  // setClipRectの範囲指定を解除します。\n  lcd.clearClipRect();\n\n  // setScrollRectの範囲指定を解除します。\n  lcd.clearScrollRect();\n\n\n  lcd.setTextSize(1);\n  lcd.setTextColor(0xFFFFFFU, 0);\n\n\n  // setTextPadding 関数で、drawString 系関数で背景塗り潰し時の最小幅を指定できます。\n  lcd.setTextPadding(100);\n\n\n  drawGradation();"
        },
        {
          "name": "drawNumberTest",
          "parameters": "const lgfx::IFont* font",
          "body": "lcd.setFont(font);\n\n  lcd.fillScreen(0x0000FF);\n\n  lcd.setColor(0xFFFF00U);\n  lcd.drawFastVLine( 80, 0, 240);\n  lcd.drawFastVLine(160, 0, 240);\n  lcd.drawFastVLine(240, 0, 240);\n  lcd.drawFastHLine(0,  45, 320);\n  lcd.drawFastHLine(0,  95, 320);\n  lcd.drawFastHLine(0, 145, 320);\n  lcd.drawFastHLine(0, 195, 320);\n\n  for (int i = 0; i < 200; ++i) {\n    lcd.setTextDatum( textdatum_t::bottom_right    );     lcd.drawNumber(i,  80,  45);\n    lcd.setTextDatum( textdatum_t::bottom_center   );     lcd.drawNumber(i, 160,  45);\n    lcd.setTextDatum( textdatum_t::bottom_left     );     lcd.drawNumber(i, 240,  45);\n    lcd.setTextDatum( textdatum_t::baseline_right  );     lcd.drawNumber(i,  80,  95);\n    lcd.setTextDatum( textdatum_t::baseline_center );     lcd.drawNumber(i, 160,  95);\n    lcd.setTextDatum( textdatum_t::baseline_left   );     lcd.drawNumber(i, 240,  95);\n    lcd.setTextDatum( textdatum_t::middle_right    );     lcd.drawNumber(i,  80, 145);\n    lcd.setTextDatum( textdatum_t::middle_center   );     lcd.drawNumber(i, 160, 145);\n    lcd.setTextDatum( textdatum_t::middle_left     );     lcd.drawNumber(i, 240, 145);\n    lcd.setTextDatum( textdatum_t::top_right       );     lcd.drawNumber(i,  80, 195);\n    lcd.setTextDatum( textdatum_t::top_center      );     lcd.drawNumber(i, 160, 195);\n    lcd.setTextDatum( textdatum_t::top_left        );     lcd.drawNumber(i, 240, 195);\n  }"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "// ※ 名前が\"Free\"で始まるフォントは 9pt 12pt 18pt 24ptの４種類があります。\n  drawNumberTest( &fonts::Font0                   );\n  drawNumberTest( &fonts::Font2                   );\n  drawNumberTest( &fonts::Font4                   );\n  drawNumberTest( &fonts::Font6                   );\n  drawNumberTest( &fonts::Font7                   );\n  drawNumberTest( &fonts::Font8                   );\n  drawNumberTest( &fonts::TomThumb                );\n  drawNumberTest( &fonts::FreeMono9pt7b           );\n  drawNumberTest( &fonts::FreeMonoBold9pt7b       );\n  drawNumberTest( &fonts::FreeMonoOblique9pt7b    );\n  drawNumberTest( &fonts::FreeMonoBoldOblique9pt7b);\n  drawNumberTest( &fonts::FreeSans9pt7b           );\n  drawNumberTest( &fonts::FreeSansBold9pt7b       );\n  drawNumberTest( &fonts::FreeSansOblique9pt7b    );\n  drawNumberTest( &fonts::FreeSansBoldOblique9pt7b);\n  drawNumberTest( &fonts::FreeSerif9pt7b          );\n  drawNumberTest( &fonts::FreeSerifBold9pt7b      );\n  drawNumberTest( &fonts::FreeSerifItalic9pt7b    );\n  drawNumberTest( &fonts::FreeSerifBoldItalic9pt7b);\n  drawNumberTest( &fonts::Orbitron_Light_24       );\n  drawNumberTest( &fonts::Roboto_Thin_24          );\n  drawNumberTest( &fonts::Satisfy_24              );\n  drawNumberTest( &fonts::Yellowtail_32           );"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "millis",
        "delay",
        "analogread"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_19V);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);\n    }\n    Serial.println(\" done.\");\n\n    Input.begin();\n    Input.enable();\n\n    analogReadResolution(adcResolution);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"4-20mA Input Channel \");\n    switch (inputChannels[inputChannelIndex]) {\n        case INPUT_420mA_CH01: Serial.print(\"01\"); break;\n        case INPUT_420mA_CH02: Serial.print(\"02\"); break;\n        case INPUT_420mA_CH03: Serial.print(\"03\"); break;\n        case INPUT_420mA_CH04: Serial.print(\"04\"); break;\n        default: break;\n    }\n    Serial.print(\": \");\n\n    auto [ voltsMuxer, voltsReference ] = getAverageAnalogRead(inputChannels[inputChannelIndex]);\n\n    Serial.print(voltsReference);\n    Serial.print(\" (\");\n    Serial.print(voltsMuxer);\n    Serial.println(\")\");\n    delay(1000);\n\n    inputChannelIndex = ++inputChannelIndex % inputChannelsLen;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "lcd",
        "display",
        "matrix"
      ],
      "libraries": [
        "LovyanGFX.hpp",
        "image.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "lcd.init();\n  lcd.startWrite();"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "/*\n  画像データを描画する関数は幾つか種類があります。\n\n方法１．事前に描画範囲を設定しておき、次にデータの長さを指定して描画する方法\n方法２．描画する座標と幅・高さを指定してデータを描画する方法\n\n\n\n方法１．事前に描画範囲を設定しておき、次にデータの長さを指定して描画する方法\n\nこの方法では、setWindow/setAddrWindow関数で描画範囲を設定したあと、\nwritePixels/pushPixels関数で画像データの長さを指定して描画します。\n\n  setWindow( x0, y0, x1, y1 );   // 描画範囲の指定。左上座標と右下座標を指定します。\n  setAddrWindow( x, y, w, h );   // 描画範囲の指定。左上座標と幅と高さを指定します。\n\nsetWindow は画面外の座標を指定した場合の動作は保証されません。\nsetAddrWindow は描画範囲外が指定された場合は範囲内に調整されます。\n ※ ただし自動調整された結果、実際に設定される幅や高さが指定した値より小さくなる可能性があるので注意が必要です。\n\n  writePixels   ( *data, len, swap );  // 画像を描画する。(事前にstartWrite、事後にendWriteが必要）\n  pushPixels    ( *data, len, swap );  // 画像を描画する。(startWrite・endWriteは不要）\n\n ※ writePixelsはAdafruitGFX由来の関数で、pushPixelsはTFT_eSPI由来の関数です。\n    描画内容は同等ですが、startWrite/endWriteが自動で行われるか否かが違います。\n\n第１引数：画像データのポインタ（データ型に応じて色の形式を判断して変換が行われます。）\n第２引数：画像データのピクセル数（バイト数でない点に注意。）\n第３引数：バイト順変換フラグ（省略時は事前にsetSwapBytes関数で設定した値が使用されます。）\n\n第１引数のdataの型に基づいて色の形式変換が行われます。\n  uint8_t*  の場合、 8bitカラー RGB332として扱います。\n  uint16_t* の場合、16bitカラー RGB565として扱います。\n  void*     の場合、24bitカラー RGB888として扱います。\n ※ （３バイトのプリミティブ型が無いため、void*型を24bitカラー扱いとしています）\n\n ※ LCDに描画する際に、LCDの色数モードに応じて色形式の変換が自動的に行われます。\n*/\n  lcd.clear(TFT_DARKGREY);\n  lcd.setColorDepth(16);  // LCDを16bitカラーモードに設定する。\n  lcd.setSwapBytes(true); // バイト順変換を有効にする。\n  int len = image_width * image_height;\n\n  // 画像の幅と高さをsetAddrWindowで事前に設定し、writePixelsで描画します。\n  lcd.setAddrWindow(0, 0, image_width, image_height);         // 描画範囲を設定。\n  lcd.writePixels((uint16_t*)rgb565, len); // RGB565の16bit画像データを描画。\n\n  // データとバイト順変換の指定が一致していない場合、色化けします。\n  lcd.setAddrWindow(0, 40, image_width, image_height);\n  // 第3引数でfalseを指定することでバイト順変換の有無を指定できます。\n  lcd.writePixels((uint16_t*)rgb565, len, false); // RGB565の画像をバイト順変換無しで描画すると色が化ける。\n\n  // 描画範囲が画面外にはみ出すなどして画像の幅や高さと合わなくなった場合、描画結果が崩れます。\n  lcd.setAddrWindow(-1, 80, image_width, image_height); // X座標が-1（画面外）のため、正しく設定できない。\n  lcd.writePixels((uint16_t*)rgb565, len); // 描画先の幅と画像の幅が不一致のため描画内容が崩れる。\n\n  // データと型が一致していない場合も、描画結果が崩れます。\n  lcd.setAddrWindow(0, 120, image_width, image_height);\n  // RGB565のデータをわざとuint8_tにキャストし、RGB332の8bitカラーとして扱わせる。\n  lcd.writePixels((uint8_t*)rgb565, len);  // 画像の形式と型が一致していないため描画が乱れる。\n\n  // データと型が一致していれば、描画先の色数に合わせて適切な形式変換が行われます。\n  lcd.setAddrWindow(0, 160, image_width, image_height);\n  lcd.writePixels((uint8_t*)rgb332, len);  // RGB332のデータでも16bitカラーのLCDに正しく描画できる。\n\n\n// ※ LCDへの画像データの送信は、メモリの若いアドレスにあるデータから順に1Byte単位で送信されます。\n//    このため、例えばRGB565の16bit型のデータを素直にuint16_tの配列で用意すると、送信の都合としてはバイト順が入れ替わった状態になります。\n//    この場合は事前にsetSwapBytes(true)を使用したり、第３引数にtrueを指定する事で、バイト順の変換が行われて正常に描画できます。\n//    なお用意する画像データを予め上位下位バイトを入れ替えた状態で作成すれば、この変換は不要になり速度面で有利になります。\n\n  lcd.setAddrWindow(40,  0, image_width, image_height);\n  lcd.writePixels((uint16_t*)swap565, len, false); // 予め上位下位が入れ替わった16bitデータの場合はバイト順変換を無効にする。\n\n  lcd.setAddrWindow(40, 40, image_width, image_height);\n  lcd.writePixels((uint16_t*)swap565, len, true);  // 逆に、予め上位下位が入れ替わったデータにバイト順変換を行うと色が化ける。\n\n  lcd.setAddrWindow(40, 80, image_width, image_height);\n  lcd.writePixels((void*)rgb888, len, true);  // 24bitのデータも同様に、RGB888の青が下位側にあるデータはバイト順変換が必要。\n\n  lcd.setAddrWindow(40, 120, image_width, image_height);\n  lcd.writePixels((void*)bgr888, len, false);  // 同様に、BGR888の赤が下位側にあるデータはバイト順変換は不要。\n\n  lcd.setAddrWindow(40, 160, image_width, image_height);\n  lcd.writePixels((void*)bgr888, len, true);  // 設定を誤ると、色が化ける。（赤と青が入れ替わる）\n\n  lcd.display();\n  delay(4000);\n  lcd.clear(TFT_DARKGREY);\n\n/*\n方法２．描画する座標と幅・高さを指定してデータを描画する方法\n\nこの方法では、pushImage関数を用いて描画範囲と描画データを指定して描画します。\n\n  pushImage( x, y, w, h, *data);                  // 指定された座標に画像を描画する。\n\n方法１と違い、画面外にはみ出す座標を指定しても描画が乱れることはありません。（はみ出した部分は描画されません。）\n方法１と違い、バイト順の変換を指定する引数が無いため、事前にsetSwapBytesによる設定が必要です。\nなお方法１と同様に、dataの型に応じて色変換が行われます。\n*/\n\n  lcd.setSwapBytes(true); // バイト順変換を有効にする。\n\n  // 描画先の座標と画像の幅・高さを指定して画像データを描画します。\n  lcd.pushImage(   0, 0, image_width, image_height, (uint16_t*)rgb565); // RGB565の16bit画像データを描画。\n\n  // データとバイト順変換の指定が一致していない場合、色化けします。\n  lcd.pushImage(   0, 40, image_width, image_height, (uint16_t*)swap565); // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n\n  // 描画範囲が画面外にはみ出すなどした場合でも、描画結果が崩れることはありません。\n  lcd.pushImage(-1, 80, image_width, image_height, (uint16_t*)rgb565); // X座標-1（画面外）を指定しても描画は乱れない。\n\n  // データと型が一致していない場合は、描画結果が崩れます。\n  lcd.pushImage(0, 120, image_width, image_height, (uint8_t*)rgb565); // RGB565のデータをuint8_tにキャストし、RGB332として扱わせると描画が乱れる。\n\n  // データと型が一致していれば、適切に形式変換が行われます。\n  lcd.pushImage(0, 160, image_width, image_height, (uint8_t*)rgb332); // RGB332のデータでも正しく描画できる。\n\n\n  lcd.setSwapBytes(false);   // バイト順の変換を無効にする。\n  lcd.pushImage( 40,   0, image_width, image_height, (uint8_t* )rgb332);  // good. RGB332のデータはバイト順変換の影響を受けない。\n  lcd.pushImage( 40,  40, image_width, image_height, (uint16_t*)rgb565);  // NG. RGB565のデータはバイト順変換が必要。\n  lcd.pushImage( 40,  80, image_width, image_height, (void*    )rgb888);  // NG. RGB888のデータはバイト順変換が必要。\n  lcd.pushImage( 40, 120, image_width, image_height, (uint16_t*)swap565); // good. バイト順変換済みRGB565のデータは色化けしない。\n  lcd.pushImage( 40, 160, image_width, image_height, (void*    )bgr888);  // good. バイト順変換済みRGB888のデータは色化けしない。\n\n  lcd.setSwapBytes(true);   // バイト順の変換を有効にする。\n  lcd.pushImage( 80,   0, image_width, image_height, (uint8_t* )rgb332);  // good. RGB332のデータはバイト順変換の影響を受けない。\n  lcd.pushImage( 80,  40, image_width, image_height, (uint16_t*)rgb565);  // good. バイト順変換が有効ならRGB565のデータは色化けしない。\n  lcd.pushImage( 80,  80, image_width, image_height, (void*    )rgb888);  // good. バイト順変換が有効ならRGB888のデータは色化けしない。\n  lcd.pushImage( 80, 120, image_width, image_height, (uint16_t*)swap565); // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n  lcd.pushImage( 80, 160, image_width, image_height, (void*    )bgr888);  // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n\n// データの型として、lgfx::名前空間に定義されている型を利用する事もできます。\n// これらの型にキャストする場合はsetSwapBytesの設定は無視されます。\n  lcd.pushImage(120,   0, image_width, image_height, (lgfx:: rgb332_t*) rgb332); // good  8bitデータ\n  lcd.pushImage(120,  40, image_width, image_height, (lgfx:: rgb565_t*) rgb565); // good 16bitデータ\n  lcd.pushImage(120,  80, image_width, image_height, (lgfx:: rgb888_t*) rgb888); // good 24bitデータ\n  lcd.pushImage(120, 120, image_width, image_height, (lgfx::swap565_t*)swap565); // good バイト順変換済み16bitデータ\n  lcd.pushImage(120, 160, image_width, image_height, (lgfx:: bgr888_t*) bgr888); // good バイト順変換済み24bitデータ\n\n// 第６引数で透過色を指定できます。透過指定された色のある部分は描画されません。\n  lcd.pushImage(160,   0, image_width, image_height, (lgfx:: rgb332_t*) rgb332, 0);                   // 黒を透過指定\n  lcd.pushImage(160,  40, image_width, image_height, (lgfx:: rgb565_t*) rgb565, (uint8_t)0xE0);       // 赤を透過指定\n  lcd.pushImage(160,  80, image_width, image_height, (lgfx:: rgb888_t*) rgb888, (uint16_t)0x07E0);    // 緑を透過指定\n  lcd.pushImage(160, 120, image_width, image_height, (lgfx::swap565_t*)swap565, (uint32_t)0x0000FFU); // 青を透過指定\n  lcd.pushImage(160, 160, image_width, image_height, (lgfx:: bgr888_t*) bgr888, TFT_WHITE);           // 白を透過指定\n\n  lcd.display();\n  delay(4000);\n  lcd.clear(TFT_DARKGREY);\n\n// pushImageRotateZoom関数を使うと、画像を回転拡大縮小させて描画できます。\n  for (int angle = 0; angle <= 360; ++angle) {\n    lcd.pushImageRotateZoom\n      ( lcd.width()  >> 2  // 描画先の中心座標X\n      , lcd.height() >> 1  // 描画先の中心座標Y\n      , image_width  >> 1  // 画像の中心座標X\n      , image_height >> 1  // 画像の中心座標Y\n      , angle              // 回転角度\n      , 3.0                // X方向の描画倍率 (マイナス指定で反転可能)\n      , 3.0                // Y方向の描画倍率 (マイナス指定で反転可能)\n      , image_width        // 画像データの幅\n      , image_height       // 画像データの高さ\n      , rgb332             // 画像データのポインタ\n      );\n\n// pushImageRotateZoomWithAA関数を使うと、アンチエイリアスが有効になります。\n    lcd.pushImageRotateZoomWithAA\n      ( lcd.width()*3>> 2\n      , lcd.height() >> 1\n      , image_width  >> 1\n      , image_height >> 1\n      , angle\n      , 3.0\n      , 3.0\n      , image_width\n      , image_height\n      , rgb332\n      );\n\n    if ((angle % 36) == 0) { lcd.display(); }\n  }\n\n  lcd.clear(TFT_DARKGREY);\n\n// pushImageAffine関数を使うと、画像をアフィン変換で変形させて描画できます。\n// アフィン変換のパラメータはfloat型の配列で指定します。\n  {\n    float matrix[6] = // 等倍表示\n      { 1.0,  0.0,  (float)lcd.width()  / 2\n      , 0.0,  1.0,  (float)lcd.height() / 2 };\n    lcd.pushImageAffine(matrix, image_width, image_height, rgb332);\n  }\n\n  lcd.display();\n  delay(1000);\n  lcd.clear(TFT_DARKGREY);\n\n  {\n    float matrix[6] = // 横２倍表示\n      { 2.0,  0.0,  (float)lcd.width()  / 2\n      , 0.0,  1.0,  (float)lcd.height() / 2 };\n    lcd.pushImageAffine(matrix, image_width, image_height, rgb332);\n  }\n\n  lcd.display();\n  delay(1000);\n  lcd.clear(TFT_DARKGREY);\n\n  {\n    float matrix[6] = // 縦２倍表示\n      { 1.0,  0.0,  (float)lcd.width()  / 2\n      , 0.0,  2.0,  (float)lcd.height() / 2 };\n    lcd.pushImageAffine(matrix, image_width, image_height, rgb332);\n  }\n\n  lcd.display();\n  delay(1000);\n  lcd.clear(TFT_DARKGREY);\n\n  {\n    float matrix[6] = // 斜め変形\n      { 1.0, -0.4,  (float)lcd.width()  / 2\n      , 0.0,  1.0,  (float)lcd.height() / 2 };\n    lcd.pushImageAffine(matrix, image_width, image_height, rgb332);\n  }\n\n  lcd.display();\n  delay(1000);\n  lcd.clear(TFT_DARKGREY);\n\n  // pushImageAffineWithAA関数を使用するとアンチエイリアスが有効になります。\n  {\n    float matrix[6] =\n      { 1.0,  0.0,  (float)lcd.width()  / 2\n      , 0.0,  1.0,  (float)lcd.height() / 2 };\n    for (int i = -300; i < 300; i++) {\n      float f = (float)i / 100;\n      matrix[1] = f;\n      matrix[3] = f;\n      lcd.pushImageAffineWithAA(matrix, image_width, image_height, rgb332);\n\n      if ((i % 30) == 0) { lcd.display(); }\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "light"
      ],
      "libraries": [
        "Accessories.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n//\twhile (!Serial);\t\t// For Leonardo only. No effect on other Arduino.\n\n\tAccessories::begin();\n\n\t// Ports setups\n\n\texpander.begin(EXPANDER_ID, 1, 2, 3, 4);\n\n\tPortLight0.begin(EXPANDER_PIN(EXPANDER_ID, 0), DIGITAL);\n\tPortLight1.begin(EXPANDER_PIN(EXPANDER_ID, 4), DIGITAL);\n\tPortLight2.begin(EXPANDER_PIN(EXPANDER_ID, 7), DIGITAL);\n\t\n\t// Accessories setups\n\n    // Declare accessories.\n\tlight0.begin(&PortLight0, 1, 1000);\n\tlight1.begin(&PortLight1, 2, 550);\n\tlight2.begin(&PortLight2, 3, 1500);\n\t\n\t// Declare light fading/dimming.\n\t//light0.SetFading(20, 10);\n\t//light1.SetFading(20, 10);\n\t//light2.SetFading(20, 10);\n\n\tlight0.Blink();\n\tlight1.Blink();\n\tlight2.Blink();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Accessories::loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "A4963.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  A4963.begin();\n  \n  A4963.setPWM(pwm_value);"
        },
        {
          "name": "ping",
          "parameters": "",
          "body": "Serial.write(\"A4963\");"
        },
        {
          "name": "write",
          "parameters": "",
          "body": "uint8_t data[3];\n  Serial.readBytes(data, 3);\n  \n  uint16_t address=data[0];\n  uint16_t value=(uint16_t(data[1]) | uint16_t(data[2])<<8);\n  uint16_t result=0;\n\n  if(address<8)\n  {\n    result=A4963.write(address<<13, value);\n  }\n  else if(address==PWM_ADDRESS)\n  {\n    A4963.setPWM(value);\n    pwm_value=value;\n  }\n  Serial.write(result&0xFF);\n  Serial.write(result>>8);"
        },
        {
          "name": "read",
          "parameters": "",
          "body": "uint8_t data[1];\n  Serial.readBytes(data, 1);\n  \n  uint16_t address=data[0];\n  uint16_t result=0;\n\n  if(address<8)\n  {\n    result=A4963.read(address<<13);\n  }\n  else if(address==PWM_ADDRESS)\n  {\n    result=pwm_value;\n  }\n  Serial.write(result&0xFF);\n  Serial.write(result>>8);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "uint8_t command=Serial.read();\n  switch(command)\n  {\n    case 'p':\n      ping();\n      break;\n    case 'w':\n      write();\n      break;\n    case 'r':\n      read();\n      break;\n    default:;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [
        "A4990MotorShield.h"
      ],
      "functions": [
        {
          "name": "stopIfFault",
          "parameters": "",
          "body": "if (motors.getFault())\n  {\n    motors.setSpeeds(0,0);\n    Serial.println(\"Fault\");\n    while(1);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_PIN, OUTPUT);\n  Serial.begin(115200);\n  Serial.println(\"Pololu A4990 Dual Motor Driver Shield for Arduino\");\n  \n  // uncomment one or both of the following lines if your motors' directions need to be flipped\n  //motors.flipM1(true);\n  //motors.flipM2(true);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// run M1 motor with positive speed\n\n  digitalWrite(LED_PIN, HIGH);\n  \n  for (int speed = 0; speed <= 400; speed++)\n  {\n    motors.setM1Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n\n  for (int speed = 400; speed >= 0; speed--)\n  {\n    motors.setM1Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n  \n  // run M1 motor with negative speed\n  \n  digitalWrite(LED_PIN, LOW);\n  \n  for (int speed = 0; speed >= -400; speed--)\n  {\n    motors.setM1Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n  \n  for (int speed = -400; speed <= 0; speed++)\n  {\n    motors.setM1Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n\n  // run M2 motor with positive speed\n  \n  digitalWrite(LED_PIN, HIGH);\n  \n  for (int speed = 0; speed <= 400; speed++)\n  {\n    motors.setM2Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n\n  for (int speed = 400; speed >= 0; speed--)\n  {\n    motors.setM2Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n  \n  // run M2 motor with negative speed\n  \n  digitalWrite(LED_PIN, LOW);\n  \n  for (int speed = 0; speed >= -400; speed--)\n  {\n    motors.setM2Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n  \n  for (int speed = -400; speed <= 0; speed++)\n  {\n    motors.setM2Speed(speed);\n    stopIfFault();\n    delay(2);\n  }\n  \n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "uart",
        "delay"
      ],
      "libraries": [
        "variant.h",
        "stdio.h",
        "adk.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "cpu_irq_enable();\n  printf(\"\\r\\nADK demo start\\r\\n\");\n  delay(200);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "uint8_t buf[RCVSIZE];\n  uint32_t nbread = 0;\n  char helloworld[] = \"Hello World!\\r\\n\";\n\n  Usb.Task();\n\n  if (adk.isReady()) {\n    /* Write hello string to ADK */\n    adk.write(strlen(helloworld), (uint8_t *)helloworld);\n\n    delay(1000);\n\n    /* Read data from ADK and print to UART */\n    adk.read(&nbread, RCVSIZE, buf);\n    if (nbread > 0) {\n      printf(\"RCV: \");\n      for (uint32_t i = 0; i < nbread; ++i) {\n        printf(\"%c\", (char)buf[i]);\n      }\n      printf(\"\\r\\n\");\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "encryption",
        "key"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "AES128.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"Key: \");\n  printHex(key, 16);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(enc_iv, 16);\n  Serial.println(\" \");\n  Serial.print(\"AES128 Encryption of '\");\n  printHex(input, 16);\n  Serial.print(\"' is 0x\");\n  AES128.runEnc(key, 16, input, 16, enc_iv);   // expect 0x65D0F7758B094114AFA6D33A5EA0716A\n  printHex(input, 16);\n  Serial.println(\" \");\n  Serial.println(\" \");\n  Serial.print(\"Key: \");\n  printHex(key, 16);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(dec_iv, 16);\n  Serial.println(\" \");\n  Serial.print(\"AES128 Decryption of '\");\n  printHex(input, 16);\n  Serial.print(\"' is 0x\");\n  AES128.runDec(key, 16, input, 16, dec_iv);\n  printHex(input, 16);\n  Serial.println(\" \");\n  while (1);"
        },
        {
          "name": "printHex",
          "parameters": "uint8_t *text, size_t size",
          "body": "for (byte i = 0; i < size; i = i + 1) {\n    if (text[i] < 16) {\n      Serial.print(\"0\");\n    }\n    Serial.print(text[i], HEX);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https"
      ],
      "libraries": [
        "AccelStepper.h",
        "AFMotor.h"
      ],
      "functions": [
        {
          "name": "forwardstep",
          "parameters": "",
          "body": "motor1.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep",
          "parameters": "",
          "body": "motor1.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n   Serial.println(\"Stepper test!\");\n  \n   stepper.setSpeed(50);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "stepper.runSpeed();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https"
      ],
      "libraries": [
        "AccelStepper.h",
        "AFMotor.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "parameters": "",
          "body": "motor1.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "parameters": "",
          "body": "motor1.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "forwardstep2",
          "parameters": "",
          "body": "motor2.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep2",
          "parameters": "",
          "body": "motor2.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "stepper1.setMaxSpeed(200.0);\n    stepper1.setAcceleration(100.0);\n    stepper1.moveTo(24);\n    \n    stepper2.setMaxSpeed(300.0);\n    stepper2.setAcceleration(100.0);\n    stepper2.moveTo(1000000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Change direction at the limits\n    if (stepper1.distanceToGo() == 0)\n\tstepper1.moveTo(-stepper1.currentPosition());\n    stepper1.run();\n    stepper2.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay",
        "timestamp"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  int16_t state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize APRS client\n  Serial.print(F(\"[APRS] Initializing ... \"));\n  // symbol:                      '>' (car)\n  state = aprs.begin('>');\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[APRS] Sending position ... \"));\n  \n  // send a location without message or timestamp\n  char destination[] = \"N0CALL\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  int state = aprs.sendPosition(destination, 0, latitude, longitude);\n  delay(500);\n  \n  // send a location with message and without timestamp\n  char message[] = \"I'm here!\";\n  state |= aprs.sendPosition(destination, 0, latitude, longitude, message);\n  delay(500);\n  \n  // send a location with message and timestamp\n  char timestamp[] = \"093045z\";\n  state |= aprs.sendPosition(destination, 0, latitude, longitude, message, timestamp);\n  delay(500);\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n  }\n\n  // wait one minute before transmitting again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "tone"
      ],
      "libraries": [
        "RadioLib.h",
        "melody.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AFSK client\n  Serial.print(F(\"[AFSK] Initializing ... \"));\n  state = audio.begin();\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[AFSK] Executing Order 66 ... \"));\n\n  // calculate whole note duration\n  int wholenote = (60000 * 4) / 120;\n\n  // iterate over the melody\n  for(unsigned int note = 0; note < sizeof(melody) / sizeof(melody[0]); note += 2) {\n    // calculate the duration of each note\n    int noteDuration = 0;\n    int divider = melody[note + 1];\n    if(divider > 0) {\n      // regular note, just proceed\n      noteDuration = wholenote / divider;\n    } else if(divider < 0) {\n      // dotted notes are represented with negative durations!!\n      noteDuration = wholenote / abs(divider);\n      noteDuration *= 1.5; // increases the duration in half for dotted notes\n    }\n\n    // we only play the note for 90% of the duration, leaving 10% as a pause\n    audio.tone(melody[note]);\n    delay(noteDuration*0.9);\n    audio.noTone();\n    delay(noteDuration*0.1);\n  }\n\n  Serial.println(F(\"done!\"));\n\n  // wait for a second\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "tone"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AFSK client\n  Serial.print(F(\"[AFSK] Initializing ... \"));\n  state = audio.begin();\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// AFSKClient can be used to transmit tones,\n  // same as Arduino tone() function\n  \n  // 400 Hz tone\n  Serial.print(F(\"[AFSK] 400 Hz tone ... \"));\n  audio.tone(400);\n  delay(1000);\n\n  // silence\n  Serial.println(F(\"done!\"));\n  audio.noTone();\n  delay(1000);\n\n  // AFSKClient can also be used to transmit HAM-friendly\n  // RTTY, Morse code, Hellschreiber, SSTV and AX.25.\n  // Details on how to use AFSK are in the example\n  // folders for each of the above modes."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "tone"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AFSK client\n  Serial.print(F(\"[AFSK] Initializing ... \"));\n  state = audio.begin();\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // after that, set mode to OOK\n  Serial.print(F(\"[SX1278] Switching to OOK ... \"));\n  state = radio.setOOK(true);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// AFSKClient can be used to transmit tones,\n  // same as Arduino tone() function\n\n  // 400 Hz tone\n  Serial.print(F(\"[AFSK] 400 Hz tone ... \"));\n  audio.tone(400);\n  delay(1000);\n\n  // silence\n  Serial.println(F(\"done!\"));\n  audio.noTone();\n  delay(1000);\n\n  // AFSKClient can also be used to transmit HAM-friendly\n  // RTTY, Morse code, Hellschreiber, SSTV and AX.25.\n  // Details on how to use AFSK are in the example\n  // folders for each of the above modes.\n\n  // CAUTION: Unlike standard AFSK, the result when using OOK\n  // must be demodulated as AM!"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(13, OUTPUT); // Set Digital Pin 13 as an Output"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalWrite(13, HIGH); // Turn the LED ON\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)\n\tdigitalWrite(13, LOW); // Turn the LED OFF\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "current",
        "digitalread",
        "digitalwrite",
        "delay",
        "millis",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(12, INPUT_PULLUP); // Set Digital Pin 12 as an Input with a Pullup to 5V\n\tpinMode(13, OUTPUT); // Set Digital Pin 13 as an Output"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// See if button is being pushed\n\t// BUtton UN-Pushed returns high (pull-up)\n\t// Button PUSHED returns LOW (switch connects D12 to Ground)\n\t// Notice the double == in the line below\n\t// - a single = sets the two sides equal (not what we want)\n\t// - a double == Compares the two sides\n\tif (digitalRead(12) == LOW)\n\t{\n\t\t// Button is pressed, wait until it's released\n\t\twhile (digitalRead(12) == LOW)\n\t\t\t; // Do nothing while we wait\n\t\tblink = !blink; // Reverse the value of blink (if it was true, make it false, and vice-versa)\n\t\tledState = LOW;\n\t\tdigitalWrite(13, ledState);\n\t\tdelay(200); // Delay for 200ms to ignore any \"bounce\" in the switch\n\t}\n\n\tif (blink)\n\t{\n\t\tif (millis() - previousMillis >= 500)\n\t\t{\n\t\t\tpreviousMillis = millis(); // Store the last time you blinked the LED\n\n\t\t\t// if the LED is off turn it on and vice-versa:\n\t\t\tif (ledState == LOW)\n\t\t\t{\n\t\t\t\tledState = HIGH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tledState = LOW;\n\t\t\t}\n\n\t\t\tdigitalWrite(13, ledState);\n\t\t}\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "tone",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(buzzer_pin, OUTPUT); // Configure the buzzer pin as an output pin"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Play low to high frequencies\n\tfor(i = 25; i < 120; i++)\n\t{\n\t\ttone(buzzer_pin, 20 * i, 200); // Create a tone/note from 500 to 2400 Hz\n\t\tdelay(20);\n\t}\n\t\n\t// Now play high to low frequencies\n\tfor(i = 120; i >= 25; i--)\n\t{\n\t\ttone (buzzer_pin, 20 * i, 200); // Create a tone/note from 2400 Hz to 500 hz\n\t\tdelay(20);\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "hc-sr04",
        "delay",
        "rtc"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Start Serial port so we can see the results\n\n\tSerial.println(\"DS1302RTC Read Test\");\n\tSerial.println(\"-------------------\");\n\n\tSerial.println(\"RTC module activated\");\n\tSerial.println();\n\tdelay(500);\n\n\tif (RTC.haltRTC())\n\t{\n\t\tSerial.println(\"The DS1302 is stopped.  Set the time as shown\");\n\t\tSerial.println(\"below to initialize the clock and begin running.\");\n\t\tSerial.println();\n\t}\n\t\n\tSerial.println(\"To set the time, send a string in the following format:\");\n\tSerial.println(\"yy,m,d,h,m,s  {Year, Month, Day, Hour, Minute, Second}\");\n\tSerial.println(\"i.e. 16,9,1,11,30,00 would set the time to September 1, 2016 at 11:30:00 AM\");\n\tdelay(3000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "tmElements_t tm;\n\ttime_t t;\n\n\t//check for input to set the RTC, minimum length is 12, i.e. yy,m,d,h,m,s\n\tif (Serial.available() >= 12)\n\t{\n\t\t//note that the tmElements_t Year member is an offset from 1970,\n\t\t//but the RTC wants the last two digits of the calendar year.\n\t\t//use the convenience macros from Time.h to do the conversions.\n\t\tint y = Serial.parseInt();\n\t\tif (y >= 100 && y < 1000)\n\t\t\tSerial.println(\"Error: Year must be two digits or four digits!\");\n\t\telse\n\t\t{\n\t\t\tif (y >= 1000)\n\t\t\t\ttm.Year = CalendarYrToTm(y);\n\t\t\telse    //(y < 100)\n\t\t\t\ttm.Year = y2kYearToTm(y);\n\t\t\ttm.Month = Serial.parseInt();\n\t\t\ttm.Day = Serial.parseInt();\n\t\t\ttm.Hour = Serial.parseInt();\n\t\t\ttm.Minute = Serial.parseInt();\n\t\t\ttm.Second = Serial.parseInt();\n\t\t\tt = makeTime(tm);\n\t\t\t//use the time_t value to ensure correct weekday is set\n\t\t\tif(RTC.set(t) == 0)   // Success\n\t\t\t{\n\t\t\t\tsetTime(t);\n\t\t\t\tSerial.println(\"RTC set.\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tSerial.println(\"RTC set failed!\");\n\t\t\t//dump any extraneous input\n\t\t\twhile (Serial.available() > 0) Serial.read();\n\t\t}\n\t}\n\n\tSerial.print(\"UNIX Time: \");\n\tSerial.print(RTC.get());\n\n\tif (! RTC.read(tm))\n\t{\n\t\tSerial.print(\"  Time = \");\n\t\tprint2digits(tm.Hour);\n\t\tSerial.write(':');\n\t\tprint2digits(tm.Minute);\n\t\tSerial.write(':');\n\t\tprint2digits(tm.Second);\n\t\tSerial.print(\", Date (D/M/Y) = \");\n\t\tSerial.print(tm.Day);\n\t\tSerial.write('/');\n\t\tSerial.print(tm.Month);\n\t\tSerial.write('/');\n\t\tSerial.print(tmYearToCalendar(tm.Year));\n\t\tSerial.print(\", DoW = \");\n\t\tSerial.print(tm.Wday);\n\t\tSerial.println();\n\t}\n\telse\n\t{\n\t\tSerial.println(\"DS1302 read error!  Please check the circuitry.\");\n\t\tSerial.println();\n\t\tdelay(9000);\n\t}\n\n\t// Wait one second before repeating :)\n\tdelay (1000);"
        },
        {
          "name": "print2digits",
          "parameters": "int number",
          "body": "if (number >= 0 && number < 10)\n\t\tSerial.write('0');\n\tSerial.print(number);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "i2c",
        "lcd"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Open serial port at 9600 baud for debugging\n\tSerial.begin(9600);\n\n\ti2c_scan.scan();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "analogread",
        "digitalread",
        "delay",
        "display"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(Vx, INPUT); // Configure Vx (A0) as an Input\n\tpinMode(Vy, INPUT); // Configure Vy (A1) as an Input\n\tpinMode(Button, INPUT_PULLUP); // Configure Button (A2) as an Input, internally \"pulled-up\" to 5V\n\t                               // Note, we're configuring an Analog input as digital input\n\t                               // which is perfectly fine.  I did this to make the wiring easier\n\t                               // and keep all of the wires on the same side of the board\n\n\tSerial.begin(9600); // Initialize Serial Port at 9600 baud to display the results"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int x, y, btn;\n\t\n\tx = analogRead(Vx);\t// Read the analog value of Vx (Analog Values are from 0-1023 which equate to 0V to 5V)\n\ty = analogRead(Vy); // Read the analog value of Vy\n\tbtn = digitalRead(Button); // Read the button.  When the button is open (unpushed),\n\t                           // the input will read High (+5V)\n\t                           // When the button is closed (pressed), the input pin\n\t                           // is connected to ground and will read Low (0V)\n\t\n\tSerial.print(x);\t// Print the X value to the serial port\n\tSerial.print(\"\\t\"); // Print a Tab character \n\tSerial.print(y); \t// Print the Y value\n\tSerial.print(\"\\t\"); // Print a Tab\n\tSerial.println(btn); // Print the value of the Btn (0=Pushed, 1 = Not Pushed)\n\t\n\tdelay(250); // Delay 250ms so the results don't print too quickly"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "i2c",
        "lcd",
        "display"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "lcd.init(); // Initialize the LCD\n\tlcd.clear(); // Clear the LCD (set cursor to 0, 0)\n\tlcd.backlight(); // Turn on the LCD backlight\n\tlcd.print(\"Arduino Learning\"); // Print \"Arduino Learning\" on the first line\n\tlcd.setCursor(5, 1); // Move the cursor to (x, y)  (y=1 is 2nd line)\n\tlcd.print(\"Board!\"); // Print \"Board!\" in the middle of the 2nd line"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "i2c",
        "delay",
        "lcd",
        "display"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "lcd.init(); // Initialize the LCD\n\tlcd.clear(); // Clear the LCD (set cursor to 0, 0)\n\tlcd.backlight(); // Turn on the LCD backlight\n\tlcd.print(\"Arduino Learning\"); // Print \"Arduino Learning\" on the first line\n\tlcd.setCursor(5, 1); // Move the cursor to (x, y)  (y=1 is 2nd line)\n\tlcd.print(\"Board!\"); // Print \"Board!\" in the middle of the 2nd line\n\t\n\tdelay(3000); // Wait 3 seconds\n\tlcd.clear(); // Clear Display"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "lcd.setCursor(0, 0);\n\tlcd.print(\"counter = \"); // Display \"counter =\"\n\tlcd.print(counter);\n\t\n\tcounter++;  // Increment the counter value\n\tif (counter > 9999) {\n\t\tcounter = 0; // Reset counter to 0 after it reaches 9999\n\t\tlcd.clear();\n\t}\n\tdelay(150); // Sleep 100 ms (otherwise it will count too fast)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(10, OUTPUT); // Set Digital Pin 10 as an Output"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalWrite(10, HIGH); // Turn the LED ON\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)\n\tdigitalWrite(10, LOW); // Turn the LED OFF\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "buffer",
        "mpu6050",
        "motion",
        "current",
        "i2c",
        "digitalwrite",
        "led",
        "display",
        "interrupt",
        "devices"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "dmpDataReady",
          "parameters": "",
          "body": "mpuInterrupt = true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// join I2C bus (I2Cdev library doesn't do this automatically)\n\tWire.begin();\n\tTWBR = 24; // 400kHz I2C clock (200kHz if CPU is 8MHz)\n\n\t// initialize serial communication\n\t// (115200 chosen because it is required for Teapot Demo output, but it's\n\t// really up to you depending on your project)\n\tSerial.begin(115200);\n\n\t// initialize device\n\tSerial.println(F(\"Initializing I2C devices...\"));\n\tmpu.initialize();\n\n\t// verify connection\n\tSerial.println(F(\"Testing device connections...\"));\n\tSerial.println(mpu.testConnection() ? F(\"MPU6050 connection successful\") : F(\"MPU6050 connection failed\"));\n\n\t// wait for ready\n\tSerial.println(F(\"\\nSend any character to begin DMP programming and demo: \"));\n\twhile (Serial.available() && Serial.read()); // empty buffer\n\twhile (!Serial.available());                 // wait for data\n\twhile (Serial.available() && Serial.read()); // empty buffer again\n\n\t// load and configure the DMP\n\tSerial.println(F(\"Initializing DMP...\"));\n\tdevStatus = mpu.dmpInitialize();\n\n\t// supply your own gyro offsets here, use the output of ALB_MPU650_Calibrate\n\t// since each gyro is a little different from the factory\n\tmpu.setXAccelOffset(-3058);\n\tmpu.setYAccelOffset(2105);\n\tmpu.setZAccelOffset(1313);\n\tmpu.setXGyroOffset(8);\n\tmpu.setYGyroOffset(-11);\n\tmpu.setZGyroOffset(11);\n\n\t// make sure it worked (returns 0 if so)\n\tif (devStatus == 0)\n\t{\n\t\t// turn on the DMP, now that it's ready\n\t\tSerial.println(F(\"Enabling DMP...\"));\n\t\tmpu.setDMPEnabled(true);\n\n\t\t// enable Arduino interrupt detection\n\t\tSerial.println(F(\"Enabling interrupt detection (Arduino external interrupt 0)...\"));\n\t\tattachInterrupt(0, dmpDataReady, RISING);\n\t\tmpuIntStatus = mpu.getIntStatus();\n\n\t\t// set our DMP Ready flag so the main loop() function knows it's okay to use it\n\t\tSerial.println(F(\"DMP ready! Waiting for first interrupt...\"));\n\t\tdmpReady = true;\n\n\t\t// get expected DMP packet size for later comparison\n\t\tpacketSize = mpu.dmpGetFIFOPacketSize();\n\t}\n\telse\n\t{\n\t\t// ERROR!\n\t\t// 1 = initial memory load failed\n\t\t// 2 = DMP configuration updates failed\n\t\t// (if it's going to break, usually the code will be 1)\n\t\tSerial.print(F(\"DMP Initialization failed (code \"));\n\t\tSerial.print(devStatus);\n\t\tSerial.println(F(\")\"));\n\t}\n\n\t// configure LED for output\n\tpinMode(LED_PIN, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// if programming failed, don't try to do anything\n\tif (!dmpReady) return;\n\n\t// wait for MPU interrupt or extra packet(s) available\n\twhile (!mpuInterrupt && fifoCount < packetSize)\n\t{\n\t\t// other program behavior stuff here\n\t\t// .\n\t\t// .\n\t\t// .\n\t\t// if you are really paranoid you can frequently test in between other\n\t\t// stuff to see if mpuInterrupt is true, and if so, \"break;\" from the\n\t\t// while() loop to immediately process the MPU data\n\t\t// .\n\t\t// .\n\t\t// .\n\t}\n\n\t// reset interrupt flag and get INT_STATUS byte\n\tmpuInterrupt = false;\n\tmpuIntStatus = mpu.getIntStatus();\n\n\t// get current FIFO count\n\tfifoCount = mpu.getFIFOCount();\n\n\t// check for overflow (this should never happen unless our code is too inefficient)\n\tif ((mpuIntStatus & 0x10) || fifoCount == 1024)\n\t{\n\t\t// reset so we can continue cleanly\n\t\tmpu.resetFIFO();\n\t\tSerial.println(F(\"FIFO overflow!\"));\n\n\t\t// otherwise, check for DMP data ready interrupt (this should happen frequently)\n\t}\n\telse if (mpuIntStatus & 0x02)\n\t{\n\t\t// wait for correct available data length, should be a VERY short wait\n\t\twhile (fifoCount < packetSize) fifoCount = mpu.getFIFOCount();\n\n\t\t// read a packet from FIFO\n\t\tmpu.getFIFOBytes(fifoBuffer, packetSize);\n\n\t\t// track FIFO count here in case there is > 1 packet available\n\t\t// (this lets us immediately read more without waiting for an interrupt)\n\t\tfifoCount -= packetSize;\n\n\t\t// display Euler angles in degrees\n\t\tmpu.dmpGetQuaternion(&q, fifoBuffer);\n\t\tmpu.dmpGetGravity(&gravity, &q);\n\t\tmpu.dmpGetYawPitchRoll(ypr, &q, &gravity);\n\t\tSerial.print(\"ypr\\t\");\n\t\tSerial.print(ypr[0] * 180 / M_PI);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(ypr[1] * 180 / M_PI);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.println(ypr[2] * 180 / M_PI);\n\n\t\t// blink LED to indicate activity\n\t\tblinkState = !blinkState;\n\t\tdigitalWrite(LED_PIN, blinkState);\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "buffer",
        "mpu6050",
        "i2c",
        "delay",
        "sensors"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// join I2C bus (I2Cdev library doesn't do this automatically)\n\tWire.begin();\n\t// COMMENT NEXT LINE IF YOU ARE USING ARDUINO DUE\n\tTWBR = 24; // 400kHz I2C clock (200kHz if CPU is 8MHz). Leonardo measured 250kHz.\n\n\t// initialize serial communication\n\tSerial.begin(115200);\n\n\t// initialize device\n\tmpu.initialize();\n\n\t// wait for ready\n\twhile (Serial.available() && Serial.read()); // empty buffer\n\twhile (!Serial.available())\n\t{\n\t\tSerial.println(F(\"Send any character to start sketch.\\n\"));\n\t\tdelay(1500);\n\t}\n\twhile (Serial.available() && Serial.read()); // empty buffer again\n\n\t// start message\n\tSerial.println(\"\\nMPU6050 Calibration Sketch\");\n\tdelay(2000);\n\tSerial.println(\"\\nYour MPU6050 should be placed in horizontal position, with package letters facing up. \\nDon't touch it until you see a finish message.\\n\");\n\tdelay(3000);\n\t// verify connection\n\tSerial.println(mpu.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\");\n\tdelay(1000);\n\t// reset offsets\n\tmpu.setXAccelOffset(0);\n\tmpu.setYAccelOffset(0);\n\tmpu.setZAccelOffset(0);\n\tmpu.setXGyroOffset(0);\n\tmpu.setYGyroOffset(0);\n\tmpu.setZGyroOffset(0);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (state == 0)\n\t{\n\t\tSerial.println(\"\\nReading sensors for first time...\");\n\t\tmeansensors();\n\t\tstate++;\n\t\tdelay(1000);\n\t}\n\n\tif (state == 1)\n\t{\n\t\tSerial.println(\"\\nCalculating offsets...\");\n\t\tcalibration();\n\t\tstate++;\n\t\tdelay(1000);\n\t}\n\n\tif (state == 2)\n\t{\n\t\tmeansensors();\n\t\tSerial.println(\"\\nFINISHED!\");\n\t\tSerial.print(\"\\nSensor readings with these offsets:\\t\");\n\t\tSerial.print(mean_ax);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(mean_ay);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(mean_az);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(mean_gx);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(mean_gy);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.println(mean_gz);\n\t\tSerial.print(\"Your offsets:\\t\");\n\t\tSerial.print(ax_offset);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(ay_offset);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(az_offset);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(gx_offset);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.print(gy_offset);\n\t\tSerial.print(\"\\t\");\n\t\tSerial.println(gz_offset);\n\t\tSerial.println(\"Data is printed as: acelX acelY acelZ giroX giroY giroZ\\n\");\n\t\tSerial.println(\"Check that your sensor readings are close to 0 0 16384 0 0 0\");\n\t\tSerial.println(\"If calibration was succesful write down your offsets so you can set them\");\n\t\tSerial.println(\"in your projects using something similar to:\");\n\t\tSerial.println(\"\");\n\t\tSerial.print(\"mpu.setXAccelOffset(\");\n\t\tSerial.print(ax_offset);\n\t\tSerial.println(\");\");\n\t\tSerial.print(\"mpu.setYAccelOffset(\");\n\t\tSerial.print(ay_offset);\n\t\tSerial.println(\");\");\n\t\tSerial.print(\"mpu.setZAccelOffset(\");\n\t\tSerial.print(az_offset);\n\t\tSerial.println(\");\");\n\t\tSerial.print(\"mpu.setXGyroOffset(\");\n\t\tSerial.print(gx_offset);\n\t\tSerial.println(\");\");\n\t\tSerial.print(\"mpu.setYGyroOffset(\");\n\t\tSerial.print(gy_offset);\n\t\tSerial.println(\");\");\n\t\tSerial.print(\"mpu.setZGyroOffset(\");\n\t\tSerial.print(gz_offset);\n\t\tSerial.println(\");\");\n\n\t\twhile (1);\n\t}"
        },
        {
          "name": "meansensors",
          "parameters": "",
          "body": "long i = 0, buff_ax = 0, buff_ay = 0, buff_az = 0, buff_gx = 0, buff_gy = 0, buff_gz = 0;\n\n\twhile (i < (buffersize + 101))\n\t{\n\t\t// read raw accel/gyro measurements from device\n\t\tmpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n\n\t\tif (i > 100 && i <= (buffersize + 100)) //First 100 measures are discarded\n\t\t{\n\t\t\tbuff_ax = buff_ax + ax;\n\t\t\tbuff_ay = buff_ay + ay;\n\t\t\tbuff_az = buff_az + az;\n\t\t\tbuff_gx = buff_gx + gx;\n\t\t\tbuff_gy = buff_gy + gy;\n\t\t\tbuff_gz = buff_gz + gz;\n\t\t}\n\t\tif (i == (buffersize + 100))\n\t\t{\n\t\t\tmean_ax = buff_ax / buffersize;\n\t\t\tmean_ay = buff_ay / buffersize;\n\t\t\tmean_az = buff_az / buffersize;\n\t\t\tmean_gx = buff_gx / buffersize;\n\t\t\tmean_gy = buff_gy / buffersize;\n\t\t\tmean_gz = buff_gz / buffersize;\n\t\t}\n\t\ti++;\n\t\tdelay(2); //Needed so we don't get repeated measures\n\t}"
        },
        {
          "name": "calibration",
          "parameters": "",
          "body": "ax_offset = -mean_ax / 8;\n\tay_offset = -mean_ay / 8;\n\taz_offset = (16384 - mean_az) / 8;\n\n\tgx_offset = -mean_gx / 4;\n\tgy_offset = -mean_gy / 4;\n\tgz_offset = -mean_gz / 4;\n\n\twhile (1) \n\t{\n\t\tint ready = 0;\n\t\tmpu.setXAccelOffset(ax_offset);\n\t\tmpu.setYAccelOffset(ay_offset);\n\t\tmpu.setZAccelOffset(az_offset);\n\n\t\tmpu.setXGyroOffset(gx_offset);\n\t\tmpu.setYGyroOffset(gy_offset);\n\t\tmpu.setZGyroOffset(gz_offset);\n\n\t\tmeansensors();\n\n\t\t// Serial.println(\"...\");\n\t\t/*\n\t\tSerial.print(\"ax: \");\n\t\tSerial.print(mean_ax);\n\t\tSerial.print(\"\\tay: \");\n\t\tSerial.print(mean_ay);\n\t\tSerial.print(\"\\taz: \");\n\t\tSerial.print(mean_az);\n\t\tSerial.print(\"\\tgx: \");\n\t\tSerial.print(mean_gx);\n\t\tSerial.print(\"\\tgy: \");\n\t\tSerial.print(mean_gy);\n\t\tSerial.print(\"\\tgz: \");\n\t\tSerial.print(mean_gz);\n\t\t*/\n\n\t\tif (abs(mean_ax) <= acel_deadzone) ready++;\n\t\telse ax_offset = ax_offset - mean_ax / acel_deadzone;\n\n\t\tif (abs(mean_ay) <= acel_deadzone) ready++;\n\t\telse ay_offset = ay_offset - mean_ay / acel_deadzone;\n\n\t\tif (abs(16384 - mean_az) <= acel_deadzone) ready++;\n\t\telse az_offset = az_offset + (16384 - mean_az) / acel_deadzone;\n\n\t\tif (abs(mean_gx) <= giro_deadzone) ready++;\n\t\telse gx_offset = gx_offset - mean_gx / (giro_deadzone + 1);\n\n\t\tif (abs(mean_gy) <= giro_deadzone) ready++;\n\t\telse gy_offset = gy_offset - mean_gy / (giro_deadzone + 1);\n\n\t\tif (abs(mean_gz) <= giro_deadzone) ready++;\n\t\telse gz_offset = gz_offset - mean_gz / (giro_deadzone + 1);\n\n\t\tSerial.print(ready);\n\t\tSerial.println(\" of 6 offsets calculated.\");\n\n\t\tif (ready == 6) break;\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "spi",
        "delay"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\tSPI.begin();\n\trfid.init();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if(rfid.isCard())\n\t{\n\t\tif(rfid.readCardSerial())\n\t\t{\n\t\t\tSerial.print(rfid.serNum[0], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[1], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[2], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[3], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[4], HEX);\n\t\t\tSerial.println(\"\");\n\t\t\tdelay(1000);\n\t\t}\n\t}\n\trfid.halt();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "current",
        "digitalread",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(2, OUTPUT); // Set Digital Pin 2 as an Output (Relay Control)\n\tpinMode(3, INPUT_PULLUP); // Set Digital Pin 3 as an Input (From the Button)\n\tpinMode(13, OUTPUT); // Set Digital Pin 13 as an Output (Nano LED)"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "button = digitalRead(3); // Read from D3\n\t\n\t// Reverse the value of button (! = \"Not\", so !button = \"Not\" Button)\n\t// If Button is HIGH (or 1), !button will be LOW (or 0)\n\tbutton = !button;\n\tdigitalWrite(2, button); // Set the relay control to the button\n\tdigitalWrite(13, button); // Mirror the button and relay on the Nano LED\n\t\n\tdelay(250); // Delay for 250ms to reduce the bounce in the relay"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Start serial communications at 9600 baud\n\tSerial.begin(9600);\n\n\t// Print \"Hello World!\" and move to the next line\n\tSerial.println(\"Hello World!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Start serial communications at 9600 baud\n\tSerial.println(\"Hello World!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"i = \"); // Print \"i = \" to the serial port\n\tSerial.println(i);    // Print the value of \"i\"\n\ti = i + 1;\t\t\t  // Add one to \"i\" (so it's higher for the next time)\n\tdelay(1000);\t\t  // delay 1 second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "servo",
        "delay"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "myservo.attach(2);  // attaches the servo on pin 2 to the servo object\n\tmyservo.write(90);  // Center Servo\n\tdelay(3000);        // Delay 3 seconds"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(pos = 0; pos <= 180; pos++) // goes from 0 degrees to 180 degrees\n\t{\n\t\tmyservo.write(pos);         // tell servo to go to position in variable 'pos'\n\t\tdelay(10);                  // waits 10ms for the servo to reach the position\n\t}\n\tfor(pos = 180; pos >= 0; pos--) // goes from 180 degrees to 0 degrees\n\t{\n\t\tmyservo.write(pos);         // tell servo to go to position in variable 'pos'\n\t\tdelay(10);                  // waits 10ms for the servo to reach the position\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "millis",
        "segment",
        "display",
        "timer"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "byte numDigits = 4; // Only 1 digit for this demo\n  byte digitPins[] = { 2, 5, 6, 13 }; // Pins 2,5,6,13 connect to digit pins D1, D2, D3, D4 (common cathode) of the display\n  byte segmentPins[] = {3, 7, 11, 9, 8, 4, 12, 10}; // Connect to segments a,b,c,d,e,f,g,decimal\n\n  sevseg.begin(COMMON_CATHODE, numDigits, digitPins, segmentPins);\n  sevseg.setBrightness(90);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "static unsigned long timer = millis();\n  static int value = 0;\n  \n  if (millis() >= timer) {\n    value++;\n    timer += 100; \n    if (value == 10000) { // Reset to 0 after counting past 9999\n      value = 0;\n    }\n    \n    // (value to display, # of decimal places)\n    sevseg.setNumber(value, 1);\n  }\n\n  sevseg.refreshDisplay(); // Must run repeatedly"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "millis",
        "segment",
        "display",
        "timer"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "byte numDigits = 1; // Only 1 digit for this demo\n  byte digitPins[] = { 5 }; // Pin 5 connects to common cathode of the display\n  byte segmentPins[] = {6, 7, 8, 9, 10, 11, 12, 13}; // Connect to segments a,b,c,d,e,f,g,decimal\n\n  sevseg.begin(COMMON_CATHODE, numDigits, digitPins, segmentPins);\n  sevseg.setBrightness(90);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "static unsigned long timer = millis();\n  static int value = 0;\n  \n  if (millis() >= timer) {\n    value++;\n    timer += 500; \n    if (value == 10) { // Reset to 0 after counting past 9\n      value = 0;\n    }\n    \n    // (value to display, # of decimal places)\n    sevseg.setNumber(value, 0); // 0 for decimal places shows decimal for single digits\n    \t\t\t\t\t\t\t// 1 for decimal places turns off decimal point for single digits\n  }\n\n  sevseg.refreshDisplay(); // Must run repeatedly"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "hc-sr04",
        "distance",
        "digitalwrite",
        "pulsein",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\tpinMode(trigPin, OUTPUT);\n\tpinMode(echoPin, INPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalWrite(trigPin, LOW);\n\tdelayMicroseconds(2);\n\tdigitalWrite(trigPin, HIGH);\n\tdelayMicroseconds(10);\n\tdigitalWrite(trigPin, LOW);\n\n\t// Call pulseIn function to wait for High pulse\n\t// result will be time in microseconds until pulse is detected\n\tduration = pulseIn(echoPin, HIGH);\n\n\tif (duration < 100000)\n\t{\n\t\tinches = microSecondsToInches(duration);\n\t\tcm = microSecondsToCentimeters(duration);\n\n\t\tSerial.print(\"Ping Time: \");\n\t\tSerial.print(duration);\n\t\tSerial.print(\"uS, \");\n\t\tSerial.print(cm);\n\t\tSerial.print(\"cm, \");\n\t\tSerial.print(inches);\n\t\tSerial.println(\"in\");\n\t}\n\tdelay(100);"
        },
        {
          "name": "microSecondsToInches",
          "parameters": "long microseconds",
          "body": "// Sound travels at 1125 feet per second\n\t// or 74.642 microseconds per inch\n\t// This gives the distance travelled by the ping, outbound\n\t// and return, so we divide by 2 to get the distance of the obstacle.\n\treturn microseconds / 74.642 / 2.0;"
        },
        {
          "name": "microSecondsToCentimeters",
          "parameters": "long microseconds",
          "body": "// Sound travels at 1125 feet per second\n\t// or 29.386 microseconds per centimeter\n\t// This gives the distance travelled by the ping, outbound\n\t// and return, so we divide by 2 to get the distance of the obstacle.\n\treturn microseconds / 29.387 / 2.0;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "current",
        "digitalwrite",
        "digitalread",
        "delay",
        "led",
        "flash",
        "debounce"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(led, OUTPUT);  \t\t// Configure on-board LED pin as an output\n\tdigitalWrite(led, lamp);\t// Set LED to On or Off to simulate Lamp\n\tpinMode(digitalPin, INPUT);\t// Configure D2 as an input from Sound Sensor module\n\n\tSerial.begin(9600);\t\t\t// Open Serial Port\n\tSerial.println(\"Sound Sensor Test\");\n\n\tdigitalVal = digitalRead(digitalPin); // Read current value from Sound Sensor\n\tSerial.println(digitalVal);\t// Print current value of sound sensor (0 or 1)\n\tprevVal = digitalVal;\t    // Keep track of prior value (so we know when it changes)"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalVal = digitalRead(digitalPin); // Read current value from Sound Sensor\n\tif (digitalVal != prevVal)\t// Detect change\n\t{\n\t\tSerial.println(digitalVal);  // Print new value\n\t\tlamp = !lamp;\t// If lamp was On, turn it Off and vice-versa\n\t\tdigitalWrite(led, lamp);\t// Set LED to On or Off to simulate Lamp\n\t\tdelay(500);\t// Delay 500ms to \"debounce\" input\n\t\tdigitalVal = digitalRead(digitalPin); // Read current value again\n\t\tSerial.println(digitalVal);\t// Print new value\n\t\tprevVal = digitalVal;\t// Keep track of prior value\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "analogread",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(led, OUTPUT);\n\tdigitalWrite(led, lamp);\n\tpinMode(analogPin, INPUT);\n\n\tSerial.begin(115200);\n\tSerial.println(\"Sound Sensor Test\");\n\n\tanalogVal = analogRead(analogPin);\n\tSerial.println(analogVal);\n\tprevVal = analogVal;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "analogVal = analogRead(analogPin);\n\tif ((analogVal > analogTrigger) && (prevVal < analogTrigger))\n\t{\n\t\tSerial.println(analogVal);\n\t\tlamp = !lamp;\n\t\tdigitalWrite(led, lamp);\n\t\tdelay(500);\n\t\tanalogVal = analogRead(analogPin);\n\t\tSerial.println(analogVal);\n\t\tprevVal = analogVal;\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  \n  stepper1.setMaxSpeed(1000.0);\n  stepper1.setAcceleration(300.0);\n  stepper1.setSpeed(1000);\n  stepper1.moveTo(5000);\n\n  Serial.println(\"Moving Stepper to Position 5000\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Serial.println(stepper1.currentPosition());\n  \t\n  //Change direction when the stepper reaches the target position\n  if (stepper1.distanceToGo() == 0) {\n  \tSerial.print(\"Stepper Arrived at Destination. MoveTo(\");\n  \tSerial.print(-stepper1.currentPosition());\n  \tSerial.println(\")\");\n    stepper1.moveTo(-stepper1.currentPosition());\n  }\n  stepper1.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "dht11",
        "temperature",
        "humidity",
        "delay"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Start Serial port so we can see the results\n\t\n\tdht11.begin(); // Get the DHT11 class to start reading"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Wait a few seconds between measurements.\n\tdelay(2000);\n\n\t// Reading temperature or humidity takes about 250 milliseconds\n\tfloat h = dht11.readHumidity();\n\t// Read temperature as Celsius (the default)\n\tfloat c = dht11.readTemperatureC();\n\t// Read temperature as Fahrenheit (isFahrenheit = true)\n\tfloat f = dht11.readTemperatureF();\n\n\t// Check if any reads failed and exit early (to try again).\n\tif (isnan(h) || isnan(c) || isnan(f))\n\t{\n\t\tSerial.println(\"Failed to read from DHT sensor!\");\n\t\treturn;\n\t}\n\n\t// Compute heat index in Fahrenheit\n\tfloat hif = dht11.computeHeatIndexF(f, h);\n\t// Compute heat index in Celsius\n\tfloat hic = dht11.computeHeatIndexC(c, h);\n\n\tSerial.print(\"Humidity: \");\n\tSerial.print(h);\n\tSerial.print(\" %\\t\");\n\tSerial.print(\"Temperature: \");\n\tSerial.print(c);\n\tSerial.print(\" *C \");\n\tSerial.print(f);\n\tSerial.print(\" *F\\t\");\n\tSerial.print(\"Heat index: \");\n\tSerial.print(hic);\n\tSerial.print(\" *C \");\n\tSerial.print(hif);\n\tSerial.println(\" *F\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "current",
        "motion",
        "digitalwrite",
        "digitalread",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(tiltPin, INPUT_PULLUP); // Configure Tilt Pin as Input w/ Pullup\n\tpinMode(ledPin, OUTPUT);\t\t// Configure LED pin as Output\n\tdigitalWrite(ledPin, LOW);\t\t// Initially turn off LED"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "tiltValue = digitalRead(tiltPin); // Read current value from digital input\n\t// When the sensor is still, the two pins are connected and \n\t// D2 is pulled LOW.  On motion, the switch opens and the digital input\n\t// will report a High value\n\tif (tiltValue == HIGH) {\n\t\tdigitalWrite(ledPin, HIGH);  // Turn on the LED\n\t\tdelay(1500);\t// Delay 1.5 Seconds so we can see that the LED turned on\n\t\tdigitalWrite(ledPin, LOW);   // Turn off the LED\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "digitalread",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Configure Touch Buttons as Inputs\n\tpinMode(2, INPUT);\n\tpinMode(3, INPUT);\n\tpinMode(4, INPUT);\n\tpinMode(5, INPUT);\n\t\n\tSerial.begin(9600); // Initialize serial communications"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Read buttons (HIGH = button pushed, LOW = button not pushed)\n\tb1 = digitalRead(2);\n\tb2 = digitalRead(3);\n\tb3 = digitalRead(4);\n\tb4 = digitalRead(5);\n\t\n\t// Output values of all buttons to serial port\n\tSerial.print(b1);\n\tSerial.print(\" \");\n\tSerial.print(b2);\n\tSerial.print(\" \");\n\tSerial.print(b3);\n\tSerial.print(\" \");\n\tSerial.println(b4);\n\t\n\tdelay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "digitalread",
        "tone"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Configure Touch Buttons as Inputs\n\tpinMode(2, INPUT);\n\tpinMode(3, INPUT);\n\tpinMode(4, INPUT);\n\tpinMode(5, INPUT);\n\t\n\t// Configure Passive Buzzer pin as Outputs\n\tpinMode(12, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Read buttons (HIGH = button pushed, LOW = button not pushed)\n\tb1 = digitalRead(2);\n\tb2 = digitalRead(3);\n\tb3 = digitalRead(4);\n\tb4 = digitalRead(5);\n\n\tif (b1)\n\t\ttone(12, C4);\n\telse if (b2)\n\t\ttone(12, E4);\n\telse if (b3)\n\t\ttone(12, G4);\n\telse if (b4)\n\t\ttone(12, C5);\n\telse\n\t\tnoTone(12);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "auth",
        "temperature",
        "humidity",
        "wifi",
        "i2c",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "littlefs",
        "spiffs",
        "eeprom",
        "timer",
        "html",
        ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(read_interval, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if (use_littlefs)\n    serial.println(f("
      ],
      "libraries": [
        "defines.h",
        "Ticker.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "static float temperature, humidity;\n\n  temperature = AM2315.readTemperature();\n  humidity    = AM2315.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V1, String(temperature, 1));\n    Blynk.virtualWrite(V2, String(humidity, 1));\n\n#if AM2315_DEBUG\n    Serial.println(\"Temp *C: \" + String(temperature));\n    Serial.println(\"Humid %: \" + String(humidity));\n#endif\n  }\n  else\n  {\n    Blynk.virtualWrite(V1, \"NAN\");\n    Blynk.virtualWrite(V2, \"NAN\");\n  }"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));\n  }\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"AM2315_ESP32_SSL\");\n  Blynk.begin(HOST_NAME);\n#else\n  WiFi.begin(ssid, pass);\n\n#if USE_LOCAL_SERVER\n  Blynk.config(auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.config(auth);\n#endif\n\n  Blynk.connect();\n#endif\n\n  timer.setInterval(READ_INTERVAL, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if (USE_LITTLEFS)\n    Serial.println(F(\"\\nBlynk ESP32 using LittleFS connected\"));\n#elif (USE_SPIFFS)\n    Serial.println(F(\"\\nBlynk ESP32 using SPIFFS connected.\"));\n#else\n    Serial.println(F(\"\\nBlynk ESP32 using EEPROM connected.\"));\n    Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n#endif\n\n#if USE_BLYNK_WM\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n#endif\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "auth",
        "temperature",
        "humidity",
        "wifi",
        "i2c",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "display",
        "eeprom",
        "timer",
        "html",
        ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  if (blynk.connected())\n  {\n#if ( use_littlefs || use_spiffs)\n    serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Ticker.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "parameters": "",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(\"Failed to read data from AM2315\");\n#endif\n\n    return;\n  }\n\n#if AM2315_DEBUG\n  Serial.println(\"Temp *C: \" + String(temperature));\n  Serial.println(\"Humid %: \" + String(humidity));\n#endif\n\n  //V1 and V2 are Blynk Display widgets' VPIN\n  Blynk.virtualWrite(V1, temperature);\n  Blynk.virtualWrite(V2, humidity);"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(\"B\");\n  }\n  else\n  {\n    Serial.print(\"F\");\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP8266 using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(\"\\nStarting AM2315_ESP8266 using EEPROM\");\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));\n  }\n\n#if USE_BLYNK_WM\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"AM2315_ESP8266\");\n  Blynk.begin(HOST_NAME);\n#else\n  WiFi.begin(ssid, pass);\n\n#if USE_LOCAL_SERVER\n  Blynk.config(auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.config(auth);\n#endif\n\n  Blynk.connect();\n#endif\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8288 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8288 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n#if USE_BLYNK_WM\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n#endif\n  }\n\n  timer.setInterval(READ_INTERVAL, ReadData);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "temperature",
        "humidity",
        "i2c",
        "millis",
        "delay",
        "digitalwrite",
        "display",
        "sd",
        "timer"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "parameters": "",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(F(\"Failed to read data from AM2315\"));\n#endif\n\n    return;\n  }\n\n#if AM2315_DEBUG\n  Serial.print(F(\"Temp *C: \"));\n  Serial.println(String(temperature));\n  Serial.print(F(\"Humid %: \"));\n  Serial.println(String(humidity));\n#endif\n\n  //V1 and V2 are Blynk Display widgets' VPIN\n  Blynk.virtualWrite(V1, temperature);\n  Blynk.virtualWrite(V2, humidity);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart AM2315_W5100 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));\n  }\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }\n\n  timer.setInterval(READ_INTERVAL, ReadData);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "buffer",
        "temperature",
        "humidity",
        "spi",
        "i2c",
        "delay",
        "digitalwrite",
        "millis",
        "display",
        "sd",
        "timer"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "SPI.h",
        "Wire.h",
        "Adafruit_AM2315.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "parameters": "",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(F(\"Failed to read data from AM2315\"));\n#endif\n\n    return;\n  }\n\n#if AM2315_DEBUG\n  Serial.print(F(\"Temp *C: \"));\n  Serial.println(String(temperature));\n  Serial.print(F(\"Humid %: \"));\n  Serial.println(String(humidity));\n#endif\n\n  //V1 and V2 are Blynk Display widgets' VPIN\n  Blynk.virtualWrite(V1, temperature);\n  Blynk.virtualWrite(V2, humidity);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart AM2315_W5500 using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart AM2315_W5500 on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif;\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));\n  }\n\n  #if USE_ETHERNET_WRAPPER\n\n    EthernetInit();\n\n  #else\n\n    #if USE_ETHERNET\n      Serial.println(F(\"=========== USE_ETHERNET ===========\"));\n    #elif USE_ETHERNET2\n      Serial.println(F(\"=========== USE_ETHERNET2 ===========\"));\n    #elif USE_ETHERNET3\n      Serial.println(F(\"=========== USE_ETHERNET3 ===========\"));\n    #elif USE_ETHERNET_LARGE\n      Serial.println(F(\"=========== USE_ETHERNET_LARGE ===========\"));\n    #elif USE_ETHERNET_ESP8266\n      Serial.println(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n    #else\n      Serial.println(F(\"=========================\"));\n    #endif\n   \n      Serial.println(F(\"Default SPI pinout:\"));\n      Serial.print(F(\"MOSI:\")); Serial.println(MOSI);\n      Serial.print(F(\"MISO:\")); Serial.println(MISO);\n      Serial.print(F(\"SCK:\"));  Serial.println(SCK);\n      Serial.print(F(\"SS:\"));   Serial.println(SS);\n      Serial.println(F(\"=========================\"));\n       \n    #if defined(ESP8266)\n      // For ESP8266, change for other boards if necessary\n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   D2    // For ESP8266\n      #endif\n      \n      Serial.print(F(\"ESP8266 setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n      \n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // For ESP8266\n        // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n        // Ethernet           0                 X            X            X            X        0\n        // Ethernet2          X                 X            X            X            X        0\n        // Ethernet3          X                 X            X            X            X        0\n        // EthernetLarge      X                 X            X            X            X        0\n        // Ethernet_ESP8266   0                 0            0            0            0        0\n        // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n        // Must use library patch for Ethernet, EthernetLarge libraries\n        //Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n        \n    #elif defined(ESP32)\n  \n      // You can use Ethernet.init(pin) to configure the CS pin\n      //Ethernet.init(10);  // Most Arduino shields\n      //Ethernet.init(5);   // MKR ETH shield\n      //Ethernet.init(0);   // Teensy 2.0\n      //Ethernet.init(20);  // Teensy++ 2.0\n      //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n      //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n      \n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   22    // For ESP32\n      #endif\n      \n      Serial.print(F(\"ESP32 setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n      \n      // For other boards, to change if necessary\n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // Must use library patch for Ethernet, EthernetLarge libraries\n        // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n        // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n           \n        //Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n              \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n  \n    #else   //defined(ESP8266)\n      // unknown board, do nothing, use default SS = 10\n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   10    // For other boards\n      #endif\n           \n      Serial.print(BOARD_NAME); Serial.print(F(\" setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n  \n      // For other boards, to change if necessary\n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n  \n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n                        \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n      \n    #endif    //defined(ESP8266)\n  \n  \n  #endif  //USE_ETHERNET_WRAPPER\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n  #if USE_LOCAL_SERVER\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #else\n    //Blynk.begin(auth);\n    // You can also specify server:\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(BlynkServer);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }\n\n  timer.setInterval(READ_INTERVAL, ReadData);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  // NOTE: moved to ISM band on purpose\n  //       DO NOT transmit in APRS bands without ham radio license!\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize APRS client\n  Serial.print(F(\"[APRS] Initializing ... \"));\n  // symbol:                      '>' (car)\n  state = aprs.begin('>');\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[APRS] Sending Mic-E position ... \"));\n  int state = aprs.sendMicE(49.1945, 16.6000, 120, 10, RADIOLIB_APRS_MIC_E_TYPE_EN_ROUTE);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n  }\n\n  // wait one minute before transmitting again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "timestamp"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  // NOTE: moved to ISM band on purpose\n  //       DO NOT transmit in APRS bands without ham radio license!\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK(434.0);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize APRS client\n  Serial.print(F(\"[APRS] Initializing ... \"));\n  // symbol:                      '>' (car)\n  state = aprs.begin('>');\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(F(\"[APRS] Sending location reports\"));\n  \n  // send a location without message or timestamp\n  char destination[] = \"N0CALL\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  int state = aprs.sendPosition(destination, 0, latitude, longitude);\n  if(state != RADIOLIB_ERR_NONE) {\n    Serial.print(F(\"[APRS] Failed to send location, code \"));\n    Serial.println(state);\n  }\n  delay(500);\n  \n  // send a location with message and without timestamp\n  char message[] = \"I'm here!\";\n  state = aprs.sendPosition(destination, 0, latitude, longitude, message);\n  if(state != RADIOLIB_ERR_NONE) {\n    Serial.print(F(\"[APRS] Failed to send location and message code \"));\n    Serial.println(state);\n  }\n  delay(500);\n\n  // you can also set repeater callsigns and SSIDs\n  // up to 8 repeaters may be used\n  // sendPosition will be sent with \"WIDE2-2\" path\n  char* repeaterCallsigns[] = { \"WIDE2\" };\n  uint8_t repeaterSSIDs[] = { 2 };\n  aprs.useRepeaters(repeaterCallsigns, repeaterSSIDs, 1);\n  \n  // send a location with message and timestamp\n  char timestamp[] = \"093045z\";\n  state = aprs.sendPosition(destination, 0, latitude, longitude, message, timestamp);\n  if(state != RADIOLIB_ERR_NONE) {\n    Serial.print(F(\"[APRS] Failed to send location, message and timestamp code \"));\n    Serial.println(state);\n  }\n  delay(500);\n\n  // when repeaters are no longer needed, they can be dropped\n  aprs.dropRepeaters();\n\n  // wait one minute before transmitting again\n  Serial.println(F(\"[APRS] All done!\"));\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "timestamp"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with the settings necessary for LoRa iGates\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // frequency:                   433.775 MHz\n  // bandwidth:                   125 kHz\n  // spreading factor:            12\n  // coding rate:                 4/5\n  int state = radio.begin(433.775, 125, 12, 5);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize APRS client\n  Serial.print(F(\"[APRS] Initializing ... \"));\n  // symbol:                      '>' (car)\n  // callsign                     \"N7LEM\"\n  // SSID                         1\n  char source[] = \"N7LEM\";\n  state = aprs.begin('>', source, 1);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[APRS] Sending position ... \"));\n  \n  // send a location with message and timestamp\n  // SSID is set to 1, as APRS over LoRa uses WIDE1-1 path by default\n  char destination[] = \"GPS\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  char message[] = \"I'm here!\";\n  char timestamp[] = \"093045z\";\n  int state = aprs.sendPosition(destination, 1, latitude, longitude, message, timestamp);\n  delay(500);\n\n  // you can also send Mic-E encoded messages\n  state |= state = aprs.sendMicE(49.1945, 16.6000, 120, 10, RADIOLIB_APRS_MIC_E_TYPE_EN_ROUTE);\n  delay(500);\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n  }\n\n  // wait one minute before transmitting again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "wifiserver",
        "wificlient",
        "password",
        "key",
        "current",
        "wifi",
        "spi",
        "delay",
        "digitalwrite",
        "led",
        "html",
        "clients"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  Serial.println(\"Access Point Web Server\");\n\n  pinMode(led, OUTPUT);      // set the LED pin mode\n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\");\n    // don't continue\n    while (true);\n  }\n\n  // by default the local IP address of will be 192.168.1.1\n  // you can override it with the following:\n  // WiFi.config(IPAddress(10, 0, 0, 1));\n\n  // print the network name (SSID);\n  Serial.print(\"Creating access point named: \");\n  Serial.println(ssid);\n\n  // Create open network. Change this line if you want to create an WEP network:\n  status = WiFi.beginAP(ssid);\n  if (status != WL_AP_LISTENING) {\n    Serial.println(\"Creating access point failed\");\n    // don't continue\n    while (true);\n  }\n\n  // wait 10 seconds for connection:\n  delay(10000);\n\n  // start the web server on port 80\n  server.begin();\n\n  // you're connected now, so print out the status\n  printWiFiStatus();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// compare the previous status to the current status\n  if (status != WiFi.status()) {\n    // it has changed update the variable\n    status = WiFi.status();\n\n    if (status == WL_AP_CONNECTED) {\n      byte remoteMac[6];\n\n      // a device has connected to the AP\n      Serial.print(\"Device connected to AP, MAC address: \");\n      WiFi.APClientMacAddress(remoteMac);\n      printMacAddress(remoteMac);\n    } else {\n      // a device has disconnected from the AP, and we are back in listening mode\n      Serial.println(\"Device disconnected from AP\");\n    }\n  }\n  \n  WiFiClient client = server.available();   // listen for incoming clients\n\n  if (client) {                             // if you get a client,\n    Serial.println(\"new client\");           // print a message out the serial port\n    String currentLine = \"\";                // make a String to hold incoming data from the client\n    while (client.connected()) {            // loop while the client's connected\n      if (client.available()) {             // if there's bytes to read from the client,\n        char c = client.read();             // read a byte, then\n        Serial.write(c);                    // print it out the serial monitor\n        if (c == '\\n') {                    // if the byte is a newline character\n\n          // if the current line is blank, you got two newline characters in a row.\n          // that's the end of the client HTTP request, so send a response:\n          if (currentLine.length() == 0) {\n            // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)\n            // and a content-type so the client knows what's coming, then a blank line:\n            client.println(\"HTTP/1.1 200 OK\");\n            client.println(\"Content-type:text/html\");\n            client.println();\n\n            // the content of the HTTP response follows the header:\n            client.print(\"Click <a href=\\\"/H\\\">here</a> turn the LED on<br>\");\n            client.print(\"Click <a href=\\\"/L\\\">here</a> turn the LED off<br>\");\n\n            // The HTTP response ends with another blank line:\n            client.println();\n            // break out of the while loop:\n            break;\n          }\n          else {      // if you got a newline, then clear currentLine:\n            currentLine = \"\";\n          }\n        }\n        else if (c != '\\r') {    // if you got anything else but a carriage return character,\n          currentLine += c;      // add it to the end of the currentLine\n        }\n\n        // Check to see if the client request was \"GET /H\" or \"GET /L\":\n        if (currentLine.endsWith(\"GET /H\")) {\n          digitalWrite(led, HIGH);               // GET /H turns the LED on\n        }\n        if (currentLine.endsWith(\"GET /L\")) {\n          digitalWrite(led, LOW);                // GET /L turns the LED off\n        }\n      }\n    }\n    // close the connection:\n    client.stop();\n    Serial.println(\"client disconnected\");\n  }"
        },
        {
          "name": "printWiFiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");\n  // print where to go in a browser:\n  Serial.print(\"To see this page in action, open a browser to http://\");\n  Serial.println(ip);"
        },
        {
          "name": "printMacAddress",
          "parameters": "byte mac[]",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");\n    }\n    Serial.print(mac[i], HEX);\n    if (i > 0) {\n      Serial.print(\":\");\n    }\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "display"
      ],
      "libraries": [
        "ArduinoGraphics.h"
      ],
      "functions": [
        {
          "name": "set",
          "parameters": "int x, int y, uint8_t r, uint8_t g, uint8_t b",
          "body": "// the r parameter is (mis)used to set the character to draw with\n      _canvasBuffer[x][y] = r;\n      // cast unused parameters to void to fix \"unused parameter\" warning\n      (void)g;\n      (void)b;\n    }\n\n    // display the drawing\n    void endDraw() {\n      ArduinoGraphics::endDraw();\n\n      for (byte row = 0; row < canvasHeight; row++) {\n        for (byte column = 0; column < canvasWidth; column++) {\n          // handle unset parts of buffer\n          if (_canvasBuffer[column][row] == 0) {\n            _canvasBuffer[column][row] = ' ';\n          }\n          _printObject->print(_canvasBuffer[column][row]);\n        }\n        _printObject->println();\n      }\n    }\n\n  private:\n    Print *_printObject;\n    char _canvasBuffer[canvasWidth][canvasHeight] = {{0}};"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  ASCIIDraw.beginDraw();\n\n  // configure the character used to fill the background. The second and third parameters are ignored\n  ASCIIDraw.background('+', 0, 0);\n  ASCIIDraw.clear();\n\n  // add the outer border\n  ASCIIDraw.stroke('-', 0, 0);\n  ASCIIDraw.fill('*', 0, 0);\n  const byte outerBorderThickness = 1;\n  ASCIIDraw.rect(outerBorderThickness, outerBorderThickness, canvasWidth - outerBorderThickness * 2, canvasHeight - outerBorderThickness * 2);\n\n  // add the inner border\n  ASCIIDraw.stroke('+', 0, 0);\n  ASCIIDraw.fill('O', 0, 0);\n  const byte borderThickness = outerBorderThickness + 6;\n  ASCIIDraw.rect(borderThickness, borderThickness, canvasWidth - borderThickness * 2, canvasHeight - borderThickness * 2);\n\n  // add the text\n  ASCIIDraw.background(' ', 0, 0);\n  ASCIIDraw.stroke('@', 0, 0);\n  const char text[] = \"ARDUINO\";\n  ASCIIDraw.textFont(Font_5x7);\n  ASCIIDraw.textSize(fontSize);\n  const byte textWidth = strlen(text) * ASCIIDraw.textFontWidth();\n  const byte textHeight = ASCIIDraw.textFontHeight();\n  const byte textX = (canvasWidth - textWidth) / 2;\n  const byte textY = (canvasHeight - textHeight) / 2;\n  ASCIIDraw.text(text, textX, textY);\n\n  // underline the text\n  ASCIIDraw.stroke('-', 0, 0);\n  ASCIIDraw.line(textX, textY + textHeight - 1, textX + textWidth - 1, textY + textHeight - 1);\n\n  // add some accents to the underline\n  ASCIIDraw.stroke('+', 0, 0);\n  ASCIIDraw.point(textX + 4, textY + textHeight - 1);\n  ASCIIDraw.point(textX + textWidth - 1 - 4, textY + textHeight - 1);\n\n  // print the drawing to the Serial Monitor\n  ASCIIDraw.endDraw();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "wifi",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "createPage",
          "parameters": "String &pageInput",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>ATWebServer_BigData-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>ATWebServer_BigData!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, day, hr % 24, min % 60, sec % 60);\n\n  pageInput = temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "//out.reserve(STRING_SIZE);\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < (100 * MULTIPLY_FACTOR); lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"ATWebServer_BigData_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";\n  }\n\n  out += \"</table></body></html>\\r\\n\";\n\n  Serial.print(F(\"String Len = \")); Serial.println(out.length());\n\n  server.send(200, F(\"text/html\"), out);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "out.reserve(STRING_SIZE);\n\n  //Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart ATWebServer_BigData on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);\n  }\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    Serial.print(F(\"Connecting to WPA SSID: \"));\n    Serial.println(ssid);\n    // Connect to WPA/WPA2 network\n    status = WiFi.begin(ssid, pass);\n  }\n\n  server.on(F(\"/\"), handleRoot);\n\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.print(WiFi.localIP());\n  Serial.print(F(\", Port = \"));\n  Serial.println(WEBSERVER_PORT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(6000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (!rate) { rate = TinyGsmAutoBaud(SerialAT); }\n\n  if (!rate) {\n    SerialMon.println(\n        F(\"***********************************************************\"));\n    SerialMon.println(F(\" Module does not respond!\"));\n    SerialMon.println(F(\"   Check your Serial wiring\"));\n    SerialMon.println(\n        F(\"   Check the module is correctly powered and turned on\"));\n    SerialMon.println(\n        F(\"***********************************************************\"));\n    delay(30000L);\n    return;\n  }\n\n  SerialAT.begin(rate);\n\n  // Access AT commands from Serial Monitor\n  SerialMon.println(\n      F(\"***********************************************************\"));\n  SerialMon.println(F(\" You can now send AT commands\"));\n  SerialMon.println(\n      F(\" Enter \\\"AT\\\" (without quotes), and you should see \\\"OK\\\"\"));\n  SerialMon.println(\n      F(\" If it doesn't work, select \\\"Both NL & CR\\\" in Serial Monitor\"));\n  SerialMon.println(\n      F(\"***********************************************************\"));\n\n  while (true) {\n    if (SerialAT.available()) { SerialMon.write(SerialAT.read()); }\n    if (SerialMon.available()) { SerialAT.write(SerialMon.read()); }\n    delay(0);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay"
      ],
      "libraries": [
        "AltSoftSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SPY.begin(115200);\n\n  MODEM_TX.begin(BAUD_RATE);\n  BOARD_TX.begin(BAUD_RATE);\n  delay(6000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "while (MODEM_TX.available()) {\n    SPY.write(MODEM_TX.read());\n  }\n  while (BOARD_TX.available()) {\n    SPY.write(BOARD_TX.read());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "spi",
        "sd"
      ],
      "libraries": [
        "SPI.h",
        "SD.h",
        "Ethernet.h",
        "ArduinoOTA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial:\n  Serial.begin(9600);\n  while (!Serial);\n\n  // setup SD card\n  Serial.print(\"Initializing SD card...\");\n  if (!SD.begin(SDCARD_SS_PIN)) {\n    Serial.println(\"initialization failed!\");\n    // don't continue:\n    while (true);\n  }\n  Serial.println(\"initialization done.\");\n\n  // start the Ethernet connection:\n  Serial.println(\"Initialize Ethernet with DHCP:\");\n  if (Ethernet.begin(mac) == 0) {\n    Serial.println(\"Failed to configure Ethernet using DHCP\");\n  } else {\n    Serial.print(\"  DHCP assigned IP \");\n    Serial.println(Ethernet.localIP());\n  }\n\n  // start the OTEthernet library with SD based storage\n  SDStorage.setUpdateFileName(\"FIRMWARE.BIN\"); // for https://github.com/zevero/avr_boot/\n  SDStorage.clear(); // AVR SD bootloaders don't delete the update file\n  ArduinoOTA.begin(Ethernet.localIP(), \"Arduino\", \"password\", SDStorage);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check for updates\n  ArduinoOTA.poll();\n\n  // add your normal loop code below ..."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "timer"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleStream.h",
        "SoftwareServo.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  // Blynk will work through SoftwareSerial\n  // Do not read or write this serial manually in your sketch\n  SwSerial.begin(9600);\n  Blynk.begin(SwSerial, auth);\n\n  // Sometimes you need to calibrate your ATtiny timer\n  //OSCCAL = 175;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "ATtinySerialOut.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "initTXPin();\n    Serial.println(F(\"START \" __FILE__ \" from \" __DATE__ \"\\r\\nUsing library version \" VERSION_ATTINY_SERIAL_OUT));\n\n    writeString(\"OSCCAL=\");\n#if !defined(__AVR_ATtiny13__) && !defined(__AVR_ATtiny13A__)\n    writeUnsignedByteHexWithPrefix(OSCCAL);\n#endif"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "static uint8_t tIndex = 0;\n    /*\n     * Example of 3 byte output. View in combined ASSCI / HEX View in HTerm (http://www.der-hammer.info/terminal/)\n     * Otherwise use writeUnsignedByteHexWithoutPrefix or writeUnsignedByteHex\n     */\n    write1Start8Data1StopNoParityWithCliSei('I');\n    writeBinary(tIndex);                    // 1 byte binary output\n\n#if !defined(__AVR_ATtiny13__) && !defined(__AVR_ATtiny13A__) // the utoa() function used in writeUnsignedByte etc. requires too much program space!\n    writeUnsignedByte(tIndex);              // 1-3 byte ASCII output\n    writeUnsignedByteHexWithPrefix(tIndex); // 4 byte output\n    writeUnsignedByteHex(tIndex);           // 2 byte output\n    write1Start8Data1StopNoParityWithCliSei('\\n');\n\n    /*\n     * Serial.print usage example\n     */\n    Serial.print(\"I=\");\n    Serial.print((char) tIndex);\n    Serial.print(\" | \");\n    Serial.print(tIndex);\n    Serial.print(\" | \");\n    Serial.print(tIndex, HEX);\n    Serial.print(\" | \");\n    Serial.printHex(tIndex);\n    Serial.print(\" | \");\n    Serial.println(tIndex);\n#endif\n    tIndex++;\n    delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "delay",
        "flash",
        "monitored"
      ],
      "libraries": [
        "AUnitMetaTest.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif\n\n#if USE_AUNIT == 1\n  // These are useful for debugging.\n  //TestRunner::setVerbosity(Verbosity::kAll);\n  //TestRunner::setVerbosity(Verbosity::kTestRunSummary);\n  //TestRunner::list();\n\n  // If set to 0, meaning infinite timeout, some testing() may accidentally run\n  // forever. Default is 10s, let's set it to 5s to verify that it can be\n  // changed.\n  TestRunner::setTimeout(5);\n#else\n  //Test::min_verbosity = TEST_VERBOSITY_ALL;\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if USE_AUNIT == 1\n  // Should get something like:\n  // TestRunner summary:\n  //    10 passed, 0 failed, 2 skipped, 0 timed out, out of 12 test(s).\n  TestRunner::run();\n#else\n  // Should get something like:\n  // Test summary: 6 passed, 1 failed, and 1 skipped, out of 8 test(s).\n  Test::run();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "publish",
        "delay",
        "flash"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "TestRunner::run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "AUnit.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // wait for stability on some boards to prevent garbage Serial\n#endif\n  Serial.begin(115200); // ESP8266 default of 74880 not supported on Linux\n  while(!Serial); // for the Arduino Leonardo/Micro only\n#if defined(EPOXY_DUINO)\n  Serial.setLineModeUnix();\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "aunit::TestRunner::run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "publish",
        "delay",
        "flash",
        "sd"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h",
        "aunit/string_util.h",
        "ArduinoUnit.h"
      ],
      "functions": [
        {
          "name": "testCommon",
          "parameters": "int m",
          "body": "assertLess(m, subject);\n    }\n\n    void assertFailing() {\n      assertEqual(1, 2);\n    }\n\n    int subject;"
        },
        {
          "name": "testCommon",
          "parameters": "int m",
          "body": "assertLess(m, subject);\n    }\n\n    int subject;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif\n\n#if USE_AUNIT == 1\n  // These are useful for debugging.\n  //TestRunner::setVerbosity(Verbosity::kAll);\n  //TestRunner::setVerbosity(Verbosity::kTestRunSummary);\n  //TestRunner::list();\n#else\n  //Test::min_verbosity = TEST_VERBOSITY_ALL;\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if USE_AUNIT == 1\n  // Should get something like:\n  // TestRunner summary:\n  //    21 passed, 0 failed, 0 skipped, 0 timed out, out of 23 test(s).\n  TestRunner::run();\n#else\n  // Should get something like:\n  // Test summary: 12 passed, 0 failed, and 0 skipped, out of 12 test(s).\n  Test::run();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "callback",
        "millis",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Das Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin(MIDI_CHANNEL_OMNI);\n\n  // Normal callbacks - always available\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n/*\n  // Extended callback, only available when defining USE_EXT_CALLBACKS\n  AppleMIDI.setHandleSentRtp([](const APPLEMIDI_NAMESPACE::Rtp_t & rtp) {\n    //  DBG(F(\"an rtpMessage has been sent with sequenceNr\"), rtp.sequenceNr);\n  });\n  AppleMIDI.setHandleSentRtpMidi([](const APPLEMIDI_NAMESPACE::RtpMIDI_t& rtpMidi) {\n    //  DBG(F(\"an rtpMidiMessage has been sent\"), rtpMidi.flags);\n  });\n  AppleMIDI.setHandleReceivedRtp([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const APPLEMIDI_NAMESPACE::Rtp_t & rtp, const int32_t& latency) {\n    //  DBG(F(\"setHandleReceivedRtp\"), ssrc, rtp.sequenceNr , \"with\", latency, \"ms latency\");\n  });\n  AppleMIDI.setHandleStartReceivedMidi([](const APPLEMIDI_NAMESPACE::ssrc_t& ssrc) {\n    //  DBG(F(\"setHandleStartReceivedMidi from SSRC\"), ssrc);\n  });\n  AppleMIDI.setHandleReceivedMidi([](const APPLEMIDI_NAMESPACE::ssrc_t& ssrc, byte value) {\n    //  DBG(F(\"setHandleReceivedMidi from SSRC\"), ssrc, \", value:\", value);\n  });\n  AppleMIDI.setHandleEndReceivedMidi([](const APPLEMIDI_NAMESPACE::ssrc_t& ssrc) {\n    //  DBG(F(\"setHandleEndReceivedMidi from SSRC\"), ssrc);\n  });\n  AppleMIDI.setHandleException(OnAppleMidiException);\n\n  MIDI.setHandleControlChange([](Channel channel, byte v1, byte v2) {\n    DBG(F(\"ControlChange\"), channel, v1, v2);\n  });\n  MIDI.setHandleProgramChange([](Channel channel, byte v1) {\n    DBG(F(\"ProgramChange\"), channel, v1);\n  });\n  MIDI.setHandlePitchBend([](Channel channel, int v1) {\n    DBG(F(\"PitchBend\"), channel, v1);\n  });\n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), channel, note, velocity);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), channel, note, velocity);\n  });\n*/\n  DBG(F(\"Sending MIDI messages every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 100)\n  {\n    t1 = millis();\n\n    byte note = random(15, 80);\n    byte velocity = random(55, 100);\n    byte channel = 1;\n\n    //   DBG(F(\"\\nsendNoteOn\"), note, velocity, channel);\n    MIDI.sendNoteOn(note, velocity, channel);\n    //MIDI.sendNoteOff(note, velocity, channel);\n  }"
        },
        {
          "name": "OnAppleMidiException",
          "parameters": "const APPLEMIDI_NAMESPACE::ssrc_t& ssrc, const APPLEMIDI_NAMESPACE::Exception& e, const int32_t value",
          "body": "switch (e)\n  {\n    case APPLEMIDI_NAMESPACE::Exception::BufferFullException:\n      DBG(F(\"*** BufferFullException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParseException:\n      DBG(F(\"*** ParseException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::TooManyParticipantsException:\n      DBG(F(\"*** TooManyParticipantsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UnexpectedInviteException:\n      DBG(F(\"*** UnexpectedInviteException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParticipantNotFoundException:\n      DBG(F(\"*** ParticipantNotFoundException\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ComputerNotInDirectory:\n      DBG(F(\"*** ComputerNotInDirectory\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NotAcceptingAnyone:\n      DBG(F(\"*** NotAcceptingAnyone\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ListenerTimeOutException:\n      DBG(F(\"*** ListenerTimeOutException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::MaxAttemptsException:\n      DBG(F(\"*** MaxAttemptsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NoResponseFromConnectionRequestException:\n      DBG(F(\"***:yyy did't respond to the connection request. Check the address and port, and any firewall or router settings. (time)\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::SendPacketsDropped:\n      DBG(F(\"*** SendPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ReceivedPacketsDropped:\n      DBG(F(\"*** ReceivedPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UdpBeginPacketFailed:\n      DBG(F(\"*** UdpBeginPacketFailed\"), value);\n      break;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  AppleMIDI.directory.push_back(IPAddress(192, 168, 1, 63));\n  AppleMIDI.directory.push_back(IPAddress(192, 168, 1, 66));\n//  AppleMIDI.whoCanConnectToMe = APPLEMIDI_NAMESPACE::None;\n  AppleMIDI.whoCanConnectToMe = APPLEMIDI_NAMESPACE::OnlyComputersInMyDirectory;\n//  AppleMIDI.whoCanConnectToMe = APPLEMIDI_NAMESPACE::Anyone;\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin();\n\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n\n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });\n\n  DBG(F(\"Sending MIDI messages every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    //    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "millis",
        "delay"
      ],
      "libraries": [
        "Ethernet3.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin();\n\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n  \n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });\n\n  DBG(F(\"Sending MIDI messages every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n//    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "token",
        "wifi",
        "delay"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "onUpdateCallback",
          "parameters": "const char* oldIP, const char* newIP",
          "body": "Serial.print(F(\"DDNSGeneric - IP Change Detected: \"));\n  Serial.println(newIP);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart AVR_ESP_AT_DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n  \n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  }\n\n  WiFi.begin(ssid, password);\n  \n  Serial.println(\"Connecting to WiFi SSID: \" + String(ssid));\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(WiFi.localIP());\n  \n  server.begin();\n\n  DDNSGeneric.service(\"duckdns\");    // Enter your DDNS Service Name - \"duckdns\" / \"noip\"\n\n  /*\n    For DDNS Providers where you get a token:\n    DDNSGeneric.client(\"domain\", \"token\");\n\n    For DDNS Providers where you get username and password: ( Leave the password field empty \"\" if not required )\n    DDNSGeneric.client(\"domain\", \"username\", \"password\");\n  */\n  DDNSGeneric.client(\"account.duckdns.org\", \"12345678-1234-1234-1234-123456789012\");\n\n  DDNSGeneric.onUpdate(onUpdateCallback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "token",
        "password",
        "wifi",
        "spi",
        "millis"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "onUpdateCallback",
          "parameters": "const char* oldIP, const char* newIP",
          "body": "Serial.print(\"DDNSGeneric - IP Change Detected: oldIP = \");\n  Serial.print(oldIP);\n  Serial.print(\", newIP = \");\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));  \n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#elif USE_UIP_ETHERNET\n  ET_LOGWARN(F(\"=========== USE_UIP_ETHERNET ===========\"));  \n#else\n  ET_LOGWARN(F(\"=========== USE_CUSTOM_ETHERNET ===========\"));\n#endif\n\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n\n  // For other boards, to change if necessary\n  #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n    // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n    Ethernet.init (USE_THIS_SS_PIN);\n    \n  #elif USE_CUSTOM_ETHERNET\n    // You have to add initialization for your Custom Ethernet here\n    // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n    //Ethernet.init(USE_THIS_SS_PIN);\n    \n  #endif  //( ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  \n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AVR_Ethernet_DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n  initEthernet();\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());\n\n  server.begin();\n\n  DDNSGeneric.service(\"duckdns\");    // Enter your DDNS Service Name - \"duckdns\" / \"noip\"\n\n  /*\n    For DDNS Providers where you get a token:\n    DDNSGeneric.client(\"domain\", \"token\");\n\n    For DDNS Providers where you get username and password: ( Leave the password field empty \"\" if not required )\n    DDNSGeneric.client(\"domain\", \"username\", \"password\");\n  */\n  DDNSGeneric.client(\"account.duckdns.org\", \"12345678-1234-1234-1234-123456789012\");\n\n  DDNSGeneric.onUpdate(onUpdateCallback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n\n  MIDI.begin();\n\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n\n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });\n\n  // Initiate the session\n  IPAddress remote(192, 168, 1, 65);\n  AppleMIDI.sendInvite(remote, DEFAULT_CONTROL_PORT); // port is 5004 by default\n\n  DBG(F(\"Connecting to \"), remote, \"Port\", DEFAULT_CONTROL_PORT, \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Watch as this session is added to the Participants list\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  DBG(F(\"Sending a random NoteOn/Off every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send note on/off every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "digitalwrite",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  if (Ethernet.begin(mac) == 0)  for (;;);\n\n  MIDI.begin();\n\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char*) {\n    isConnected++;\n    digitalWrite(LED_BUILTIN, HIGH);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    digitalWrite(LED_BUILTIN, LOW);\n  });\n\n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    digitalWrite(LED_BUILTIN, LOW);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    digitalWrite(LED_BUILTIN, HIGH);\n  });"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    MIDI.sendNoteOn(54, 100, 1);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI1.getPort(), \"(Name\", AppleMIDI1.getName(), \")\");\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI2.getPort(), \"(Name\", AppleMIDI2.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  // Listen for MIDI messages on channel 1\n  MIDI1.begin(1);\n  MIDI2.begin(2);\n\n  // Stay informed on connection status\n  AppleMIDI1.setHandleConnected(OnAppleMidiConnected);\n  AppleMIDI1.setHandleDisconnected(OnAppleMidiDisconnected);\n  AppleMIDI2.setHandleConnected(OnAppleMidiConnected);\n  AppleMIDI2.setHandleDisconnected(OnAppleMidiDisconnected);\n\n  // and let us know ehen notes come in\n  MIDI1.setHandleNoteOn(OnMidiNoteOn);\n  MIDI2.setHandleNoteOn(OnMidiNoteOn);\n\n  DBG(F(\"Every second, send a random NoteOn/Off, from multiple sessions\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI1.read();\n  MIDI2.read();\n\n  // send note on/off every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n\n    MIDI1.sendNoteOn(note, velocity, 1);\n    MIDI2.sendNoteOn(note, velocity, 2);\n  }"
        },
        {
          "name": "OnAppleMidiConnected",
          "parameters": "const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name",
          "body": "isConnected++;\n  DBG(F(\"Connected to session\"), ssrc, name);"
        },
        {
          "name": "OnAppleMidiDisconnected",
          "parameters": "const APPLEMIDI_NAMESPACE::ssrc_t & ssrc",
          "body": "isConnected--;\n  DBG(F(\"Disconnected\"), ssrc);"
        },
        {
          "name": "OnMidiNoteOn",
          "parameters": "byte channel, byte note, byte velocity",
          "body": "DBG(F(\"in\\tNote on\"), note, \" Velocity\", velocity, \"\\t\", channel);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin();\n\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n\n  DBG(F(\"Send MIDI messages every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin();\n\n  // Stay informed on connection status\n  AppleMIDI\n  .setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  })\n  .setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n  \n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });\n\n  DBG(F(\"Sending MIDI messages every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n//    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin();\n\n  // check: zien we de connecttion binnenkomen?? Anders terug een ref van maken\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n  AppleMIDI.setHandleStartReceivedMidi(OnAppleMidiStartReceived);\n  AppleMIDI.setHandleReceivedMidi(OnAppleMidiReceivedByte);\n  AppleMIDI.setHandleEndReceivedMidi(OnAppleMidiEndReceive);\n\n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();"
        },
        {
          "name": "OnAppleMidiStartReceived",
          "parameters": "const APPLEMIDI_NAMESPACE::ssrc_t & ssrc",
          "body": "DBG(F(\"Start receiving\"), ssrc);"
        },
        {
          "name": "OnAppleMidiReceivedByte",
          "parameters": "const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, byte data",
          "body": "SerialMon.println(data, HEX);"
        },
        {
          "name": "OnAppleMidiEndReceive",
          "parameters": "const APPLEMIDI_NAMESPACE::ssrc_t & ssrc",
          "body": "DBG(F(\"End receiving\"), ssrc);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "delay",
        "segment"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);\n  }\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n\n  MIDI.begin();\n  MIDI.setHandleSystemExclusive(OnMidiSysEx);\n\n  DBG(F(\"Send SysEx every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n //   MIDI.sendSysEx(sizeof(sysexBig), sysexBig, true);\n    t1 = millis();\n  }"
        },
        {
          "name": "OnMidiSysEx",
          "parameters": "byte* data, unsigned length",
          "body": "SerialMon.print(F(\"SYSEX: (\"));\n  SerialMon.print(getSysExStatus(data, length));\n  SerialMon.print(F(\", \"));\n  SerialMon.print(length);\n  SerialMon.print(F(\" bytes) \"));\n  for (uint16_t i = 0; i < length; i++)\n  {\n    SerialMon.print(data[i], HEX);\n    SerialMon.print(\" \");\n  }\n  SerialMon.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "key",
        "certificate",
        "ssl",
        "tls",
        "callback",
        "publish",
        "subscribe",
        "stream",
        "current",
        "gsm",
        "gprs",
        "millis",
        "delay",
        "clientid"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "MKRGSM.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  // Set a callback to get the current time\n  // used to validate the servers certificate\n  ArduinoBearSSL.onGetTime(getTime);\n\n  // Set the ECCX08 slot to use for the private key\n  // and the accompanying public certificate for it\n  sslClient.setEccSlot(0, certificate);\n\n  // Optional, set the client id used for MQTT,\n  // each device that is connected to the broker\n  // must have a unique client id. The MQTTClient will generate\n  // a client id for you based on the millis() value if not set\n  //\n  // mqttClient.setId(\"clientId\");\n\n  // Set the message callback, this function is\n  // called when the MQTTClient receives a message\n  mqttClient.onMessage(onMessageReceived);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (gsmAccess.status() != GSM_READY || gprs.status() != GPRS_READY) {\n    connectGSM();\n  }\n\n  if (!mqttClient.connected()) {\n    // MQTT client is disconnected, connect\n    connectMQTT();\n  }\n\n  // poll for new MQTT messages and send keep alives\n  mqttClient.poll();\n\n  // publish a message roughly every 5 seconds.\n  if (millis() - lastMillis > 5000) {\n    lastMillis = millis();\n\n    publishMessage();\n  }"
        },
        {
          "name": "connectGSM",
          "parameters": "",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((gsmAccess.begin(pinnumber) != GSM_READY) ||\n         (gprs.attachGPRS(gprs_apn, gprs_login, gprs_password) != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);\n  }\n\n  Serial.println(\"You're connected to the cellular network\");\n  Serial.println();"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the MQTT broker\");\n  Serial.println();\n\n  // subscribe to a topic\n  mqttClient.subscribe(\"arduino/incoming\");"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());\n  }\n  Serial.println();\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "key",
        "certificate",
        "ssl",
        "tls",
        "callback",
        "publish",
        "subscribe",
        "stream",
        "current",
        "lte",
        "gprs",
        "millis",
        "delay",
        "clientid"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "MKRNB.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  // Set a callback to get the current time\n  // used to validate the servers certificate\n  ArduinoBearSSL.onGetTime(getTime);\n\n  // Set the ECCX08 slot to use for the private key\n  // and the accompanying public certificate for it\n  sslClient.setEccSlot(0, certificate);\n\n  // Optional, set the client id used for MQTT,\n  // each device that is connected to the broker\n  // must have a unique client id. The MQTTClient will generate\n  // a client id for you based on the millis() value if not set\n  //\n  // mqttClient.setId(\"clientId\");\n\n  // Set the message callback, this function is\n  // called when the MQTTClient receives a message\n  mqttClient.onMessage(onMessageReceived);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (nbAccess.status() != NB_READY || gprs.status() != GPRS_READY) {\n    connectNB();\n  }\n\n  if (!mqttClient.connected()) {\n    // MQTT client is disconnected, connect\n    connectMQTT();\n  }\n\n  // poll for new MQTT messages and send keep alives\n  mqttClient.poll();\n\n  // publish a message roughly every 5 seconds.\n  if (millis() - lastMillis > 5000) {\n    lastMillis = millis();\n\n    publishMessage();\n  }"
        },
        {
          "name": "connectNB",
          "parameters": "",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((nbAccess.begin(pinnumber) != NB_READY) ||\n         (gprs.attachGPRS() != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);\n  }\n\n  Serial.println(\"You're connected to the cellular network\");\n  Serial.println();"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the MQTT broker\");\n  Serial.println();\n\n  // subscribe to a topic\n  mqttClient.subscribe(\"arduino/incoming\");"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());\n  }\n  Serial.println();\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "certificate",
        "tls",
        "key",
        "publish",
        "subscribe",
        "payload",
        "json",
        "stringify",
        "parse",
        "millis",
        "delay",
        "gatewayip"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "Arduino_ConnectionHandler.h",
        "Arduino_JSON.h",
        "NTPClient.h",
        "mbed_mktime.h",
        "arduino_secrets.h",
        "Ethernet.h",
        "EthernetUdp.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    // Wait for Serial Monitor or start after 2.5s\n    for (const auto startNow = millis() + 2500; !Serial && millis() < startNow; delay(250));\n\n    // Set the callbacks for connectivity management\n    conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n    conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n    conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n    // Check for HSM\n    if (!ECCX08.begin()) {\n        Serial.println(\"No ECCX08 present!\");\n        while (1)\n            ;\n    }\n\n    // Configure TLS to use HSM and the key/certificate pair\n    ArduinoBearSSL.onGetTime(getTime);\n    sslClient.setEccSlot(0, certificate);\n    // mqttClient.setId(\"Your Thing ID\");\n    mqttClient.onMessage(onMessageReceived);\n\n    timeClient.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Automatically manage connectivity\n    const auto conStatus = conMan.check();\n\n    if (conStatus != NetworkConnectionState::CONNECTED)\n        return;\n\n    if (!mqttClient.connected()) {\n        // MQTT client is disconnected, connect\n        connectMQTT();\n    }\n\n    // poll for new MQTT messages and send keep alives\n    mqttClient.poll();\n\n    // publish a message roughly every 5 seconds.\n    if (millis() - lastMillis > 5000) {\n        lastMillis = millis();\n\n        publishMessage();\n    }"
        },
        {
          "name": "setNtpTime",
          "parameters": "",
          "body": "timeClient.forceUpdate();\n    const auto epoch = timeClient.getEpochTime();\n    set_time(epoch);"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n    Serial.print(broker);\n    Serial.print(\":\");\n    Serial.print(port);\n    Serial.println();\n\n    int status;\n    while ((status = mqttClient.connect(broker, port)) == 0) {\n        // failed, retry\n        Serial.println(status);\n        delay(1000);\n    }\n    Serial.println();\n\n    Serial.println(\"You're connected to the MQTT broker\");\n    Serial.println();\n\n    // subscribe to a topic with QoS 1\n    constexpr char incomingTopic[] { \"arduino/incoming\" };\n    constexpr int incomingQoS { 1 };\n    Serial.print(\"Subscribing to topic: \");\n    Serial.print(incomingTopic);\n    Serial.print(\" with QoS \");\n    Serial.println(incomingQoS);\n    mqttClient.subscribe(incomingTopic, incomingQoS);"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n    JSONVar payload;\n    String msg = \"Hello, World! \";\n    msg += millis();\n    payload[\"message\"] = msg;\n\n    JSONVar message;\n    message[\"ts\"] = static_cast<unsigned long>(time(nullptr));\n    message[\"payload\"] = payload;\n\n    String messageString = JSON.stringify(message);\n    Serial.println(messageString);\n\n    // send message, the Print interface can be used to set the message contents\n    constexpr char outgoingTopic[] { \"arduino/outgoing\" };\n\n    mqttClient.beginMessage(outgoingTopic);\n    mqttClient.print(messageString);\n    mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n    Serial.println();\n    Serial.print(\"Received a message with topic '\");\n    Serial.print(mqttClient.messageTopic());\n    Serial.print(\"', length \");\n    Serial.print(messageSize);\n    Serial.println(\" bytes:\");\n\n    /*\n    // Message from AWS MQTT Test Client\n    {\n      \"message\": \"Hello from AWS IoT console\"\n    }\n    */\n\n    char bytes[messageSize] {};\n    for (int i = 0; i < messageSize; i++)\n        bytes[i] = mqttClient.read();\n\n    JSONVar jsonMessage = JSON.parse(bytes);\n    auto text = jsonMessage[\"message\"];\n\n    Serial.print(\"[\");\n    Serial.print(time(nullptr));\n    Serial.print(\"] \");\n    Serial.print(\"Message: \");\n    Serial.println(text);\n\n    Serial.println();"
        },
        {
          "name": "onNetworkConnect",
          "parameters": "",
          "body": "Serial.println(\">>>> CONNECTED to network\");\n    printEthernetStatus();\n\n    setNtpTime();\n    connectMQTT();"
        },
        {
          "name": "onNetworkDisconnect",
          "parameters": "",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "parameters": "",
          "body": "Serial.println(\">>>> ERROR\");"
        },
        {
          "name": "printEthernetStatus",
          "parameters": "",
          "body": "// print your board's IP address:\n    Serial.print(\"Local IP: \");\n    Serial.println(Ethernet.localIP());\n    Serial.print(\"Local GW: \");\n    Serial.println(Ethernet.gatewayIP());\n    Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "mqtt",
        "certificate",
        "tls",
        "key",
        "publish",
        "subscribe",
        "payload",
        "json",
        "stringify",
        "parse",
        "wifi",
        "millis",
        "delay",
        "gatewayip"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "Arduino_ConnectionHandler.h",
        "Arduino_JSON.h",
        "NTPClient.h",
        "mbed_mktime.h",
        "arduino_secrets.h",
        "WiFi.h",
        "WiFiUdp.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    // Wait for Serial Monitor or start after 2.5s\n    for (const auto startNow = millis() + 2500; !Serial && millis() < startNow; delay(250));\n\n    // Set the callbacks for connectivity management\n    conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n    conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n    conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n    // Check for HSM\n    if (!ECCX08.begin()) {\n        Serial.println(\"No ECCX08 present!\");\n        while (1)\n            ;\n    }\n\n    // Configure TLS to use HSM and the key/certificate pair\n    ArduinoBearSSL.onGetTime(getTime);\n    sslClient.setEccSlot(0, certificate);\n    // mqttClient.setId(\"Your Thing ID\");\n    mqttClient.onMessage(onMessageReceived);\n\n    timeClient.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Automatically manage connectivity\n    const auto conStatus = conMan.check();\n\n    if (conStatus != NetworkConnectionState::CONNECTED)\n        return;\n\n    if (!mqttClient.connected()) {\n        // MQTT client is disconnected, connect\n        connectMQTT();\n    }\n\n    // poll for new MQTT messages and send keep alives\n    mqttClient.poll();\n\n    // publish a message roughly every 5 seconds.\n    if (millis() - lastMillis > 5000) {\n        lastMillis = millis();\n\n        publishMessage();\n    }"
        },
        {
          "name": "setNtpTime",
          "parameters": "",
          "body": "timeClient.forceUpdate();\n    const auto epoch = timeClient.getEpochTime();\n    set_time(epoch);"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n    Serial.print(broker);\n    Serial.print(\":\");\n    Serial.print(port);\n    Serial.println();\n\n    int status;\n    while ((status = mqttClient.connect(broker, port)) == 0) {\n        // failed, retry\n        Serial.println(status);\n        delay(1000);\n    }\n    Serial.println();\n\n    Serial.println(\"You're connected to the MQTT broker\");\n    Serial.println();\n\n    // subscribe to a topic with QoS 1\n    constexpr char incomingTopic[] { \"arduino/incoming\" };\n    constexpr int incomingQoS { 1 };\n    Serial.print(\"Subscribing to topic: \");\n    Serial.print(incomingTopic);\n    Serial.print(\" with QoS \");\n    Serial.println(incomingQoS);\n    mqttClient.subscribe(incomingTopic, incomingQoS);"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n    JSONVar payload;\n    String msg = \"Hello, World! \";\n    msg += millis();\n    payload[\"message\"] = msg;\n    payload[\"rssi\"] = WiFi.RSSI();\n\n    JSONVar message;\n    message[\"ts\"] = static_cast<unsigned long>(time(nullptr));\n    message[\"payload\"] = payload;\n\n    String messageString = JSON.stringify(message);\n    Serial.println(messageString);\n\n    // send message, the Print interface can be used to set the message contents\n    constexpr char outgoingTopic[] { \"arduino/outgoing\" };\n\n    mqttClient.beginMessage(outgoingTopic);\n    mqttClient.print(messageString);\n    mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n    Serial.println();\n    Serial.print(\"Received a message with topic '\");\n    Serial.print(mqttClient.messageTopic());\n    Serial.print(\"', length \");\n    Serial.print(messageSize);\n    Serial.println(\" bytes:\");\n\n    /*\n    // Message from AWS MQTT Test Client\n    {\n      \"message\": \"Hello from AWS IoT console\"\n    }\n    */\n\n    char bytes[messageSize] {};\n    for (int i = 0; i < messageSize; i++)\n        bytes[i] = mqttClient.read();\n\n    JSONVar jsonMessage = JSON.parse(bytes);\n    auto text = jsonMessage[\"message\"];\n\n    Serial.print(\"[\");\n    Serial.print(time(nullptr));\n    Serial.print(\"] \");\n    Serial.print(\"Message: \");\n    Serial.println(text);\n\n    Serial.println();"
        },
        {
          "name": "onNetworkConnect",
          "parameters": "",
          "body": "Serial.println(\">>>> CONNECTED to network\");\n\n    printWifiStatus();\n    setNtpTime();\n    connectMQTT();"
        },
        {
          "name": "onNetworkDisconnect",
          "parameters": "",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "parameters": "",
          "body": "Serial.println(\">>>> ERROR\");"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n    Serial.print(\"SSID: \");\n    Serial.println(WiFi.SSID());\n\n    // print the received signal strength:\n    Serial.print(\"signal strength (RSSI):\");\n    Serial.print(WiFi.RSSI());\n    Serial.println(\" dBm\");\n    Serial.println();\n\n    // print your board's IP address:\n    Serial.print(\"Local IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.print(\"Local GW: \");\n    Serial.println(WiFi.gatewayIP());\n    Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "wificlient",
        "key",
        "certificate",
        "ssl",
        "tls",
        "https",
        "callback",
        "publish",
        "subscribe",
        "stream",
        "current",
        "wifi",
        "millis",
        "delay",
        "clientid"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  // Set a callback to get the current time\n  // used to validate the servers certificate\n  ArduinoBearSSL.onGetTime(getTime);\n\n  // Set the ECCX08 slot to use for the private key\n  // and the accompanying public certificate for it\n  sslClient.setEccSlot(0, certificate);\n\n  // Optional, set the client id used for MQTT,\n  // each device that is connected to the broker\n  // must have a unique client id. The MQTTClient will generate\n  // a client id for you based on the millis() value if not set\n  //\n  // mqttClient.setId(\"clientId\");\n\n  // Set the message callback, this function is\n  // called when the MQTTClient receives a message\n  mqttClient.onMessage(onMessageReceived);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    connectWiFi();\n  }\n\n  if (!mqttClient.connected()) {\n    // MQTT client is disconnected, connect\n    connectMQTT();\n  }\n\n  // poll for new MQTT messages and send keep alives\n  mqttClient.poll();\n\n  // publish a message roughly every 5 seconds.\n  if (millis() - lastMillis > 5000) {\n    lastMillis = millis();\n\n    publishMessage();\n  }"
        },
        {
          "name": "connectWiFi",
          "parameters": "",
          "body": "Serial.print(\"Attempting to connect to SSID: \");\n  Serial.print(ssid);\n  Serial.print(\" \");\n\n  while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the network\");\n  Serial.println();"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the MQTT broker\");\n  Serial.println();\n\n  // subscribe to a topic\n  mqttClient.subscribe(\"arduino/incoming\");"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());\n  }\n  Serial.println();\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // carrier frequency:           434.0 MHz\n  // bit rate:                    1.2 kbps (1200 baud 2-FSK AX.25)\n  // frequency deviation:         0.5 kHz  (1200 baud 2-FSK AX.25)\n  int state = radio.beginFSK(434.0, 1.2, 0.5);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// create AX.25 Unnumbered Information frame\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  // source station callsign:          \"N7LEM\"\n  // source station SSID:              0\n  // control field:                    UI, P/F not used, unnumbered frame\n  // protocol identifier:              no layer 3 protocol implemented\n  // information field:                \"Hello World!\"\n  AX25Frame frameUI(\"NJ7P\", 0, \"N7LEM\", 0, RADIOLIB_AX25_CONTROL_U_UNNUMBERED_INFORMATION |\n                    RADIOLIB_AX25_CONTROL_POLL_FINAL_DISABLED | RADIOLIB_AX25_CONTROL_UNNUMBERED_FRAME,\n                    RADIOLIB_AX25_PID_NO_LAYER_3, \"Hello World (unnumbered)!\");\n\n  // send the frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  int state = ax25.sendFrame(&frameUI);\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));\n\n  } else {\n    // some error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }\n\n  delay(1000);\n\n  // create AX.25 Receive Ready frame\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  // source station callsign:          \"N7LEM\"\n  // source station SSID:              0\n  // control field:                    RR, P/F not used, supervisory frame\n  AX25Frame frameRR(\"NJ7P\", 0, \"N7LEM\", 0, RADIOLIB_AX25_CONTROL_S_RECEIVE_READY |\n                    RADIOLIB_AX25_CONTROL_POLL_FINAL_DISABLED | RADIOLIB_AX25_CONTROL_SUPERVISORY_FRAME);\n\n  // set receive sequence number (0 - 7)\n  frameRR.setRecvSequence(0);\n\n  // send the frame\n  Serial.print(F(\"[AX.25] Sending RR frame ... \"));\n  state = ax25.sendFrame(&frameRR);\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));\n\n  } else {\n    // some error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }\n\n  delay(1000);\n\n  // create AX.25 Information frame\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  // source station callsign:          \"N7LEM\"\n  // source station SSID:              0\n  // control field:                    P/F not used, information frame\n  // protocol identifier:              no layer 3 protocol implemented\n  // information field:                \"Hello World (numbered)!\"\n  AX25Frame frameI(\"NJ7P\", 0, \"N7LEM\", 0, RADIOLIB_AX25_CONTROL_POLL_FINAL_DISABLED |\n                   RADIOLIB_AX25_CONTROL_INFORMATION_FRAME, RADIOLIB_AX25_PID_NO_LAYER_3,\n                   \"Hello World (numbered)!\");\n\n  // set receive sequence number (0 - 7)\n  frameI.setRecvSequence(0);\n\n  // set send sequence number (0 - 7)\n  frameI.setSendSequence(0);\n\n  // send the frame\n  Serial.print(F(\"[AX.25] Sending I frame ... \"));\n  state = ax25.sendFrame(&frameI);\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));\n\n  } else {\n    // some error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // carrier frequency:           434.0 MHz\n  // bit rate:                    1.2 kbps (1200 baud 2-FSK AX.25)\n  int state = radio.beginFSK(434.0, 1.2);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// send AX.25 unnumbered information frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  int state = ax25.transmit(\"Hello World!\", \"NJ7P\");\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));\n\n  } else {\n    // some error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // Sometimes, it may be required to adjust audio\n  // frequencies to match the expected 1200/2200 Hz tones.\n  // The following method will offset mark frequency by\n  // 100 Hz up and space frequency by 100 Hz down\n  /*\n    Serial.print(F(\"[AX.25] Setting correction ... \"));\n    state = ax25.setCorrection(100, -100);\n    if(state == RADIOLIB_ERR_NONE) {\n      Serial.println(F(\"success!\"));\n    } else {\n      Serial.print(F(\"failed, code \"));\n      Serial.println(state);\n      while (true) { delay(10); }\n    }\n  */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// send AX.25 unnumbered information frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  int state = ax25.transmit(\"Hello World!\", \"NJ7P\");\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));\n\n  } else {\n    // some error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay"
      ],
      "libraries": [
        "AY3891x.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "byte value;\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 1: Find Chip Address.\");\n\n  psg.begin();\n\n  // Find chip address\n  byte foundAddress;\n  foundAddress = psg.findChipAddress();\n  Serial.print(\"Default Chip Address: \");\n  Serial.println(psg.getChipAddress(), HEX);\n\n  if (foundAddress == 0xFF) {\n    Serial.println(\"ERROR: Unable to detect chip address, check hardware.\");\n  }\n  else {\n    Serial.print(\"Detected Chip Address: \");\n    Serial.println(foundAddress, HEX);\n    delay(500);\n\n    psg.setChipAddress(foundAddress);\n    Serial.println(\"Testing chip by writing to a register.\");\n    psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, 0x5A);\n    Serial.println(\"Write vale to Tone Period Fine register: 0x5A\");\n    delay(500);\n    value = psg.read(AY3891x::ChA_Tone_Period_Fine_Reg);\n    Serial.print(\"Read value from Tone Period Fine register: 0x\");\n    Serial.println(value, HEX);\n    delay(500);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https"
      ],
      "libraries": [
        "AY3891x.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "byte value;\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 2: Test Regsiters.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered with non-default address.\n\n  Serial.println(\"\");\n  Serial.println(\"Note that registers 0x1, 0x3, 0x5, 0xD are only 4 bits wide, and\");\n  Serial.println(\"registers 0x6, 0x8, 0x9, 0xA are only 5 bits wide.\");\n  Serial.println(\"\");\n\n  for (byte i = AY3891x::ChA_Tone_Period_Fine_Reg; i <= AY3891x:: IO_Port_B_Reg; i++) {\n    Serial.print(\"Write value 0x\");\n    Serial.print(0x50 | i, HEX);\n    Serial.print(\" to register:   0x\");\n    Serial.println(i, HEX);\n    psg.write(i, 0x50 | i);\n    value = psg.read(i);\n    Serial.print(\"Read value  0x\");\n    Serial.print(value, HEX);\n    Serial.print(\" from register: 0x\");\n    Serial.println(i, HEX);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "digitalwrite",
        "tone",
        "delay"
      ],
      "libraries": [
        "AY3891x.h",
        "AY3891x_sounds.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "parameters": "",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 3: Simple Tone Generator.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  // Use less than max amplitude, in case external amp can't handle the higher level (start low and increase after testing)\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  psg.write(AY3891x::Enable_Reg, ~(MIXER_TONE_A_DISABLE | MIXER_TONE_B_DISABLE));   // Enable Channel A and B tone generator output\n\n  for (byte i = 0; i < sizeof(notes_to_play) / sizeof(notes_to_play[0]); i++) {\n    Serial.print(\"Playing note freq: \");\n    Serial.println(1000000UL/16/pgm_read_word(&Notes[notes_to_play[i]]));\n    psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[notes_to_play[i]]) >> 8);\n    psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[notes_to_play[i]]) & TONE_GENERATOR_FINE);\n    psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[notes_to_play[i]]) >> 8);\n    psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[notes_to_play[i]]) & TONE_GENERATOR_FINE);\n    delay(1000);\n  }\n\n  psg.write(AY3891x::Enable_Reg, MIXER_ALL_DISABLED);   // Disable Tone Generators"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay"
      ],
      "libraries": [
        "AY3891x.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 4: I/O Ports.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  // By default, the I/O ports are set up as inputs.\n  // There are internal pull-ups connected to the input ports, so if the pins\n  // are left floating, they should read as zero when set to input.\n  psg.write(AY3891x::Enable_Reg, ~(MIXER_INPUTS_DISABLE));  // Disable audio, I/O ports to input mode\n  Serial.println(\"Input Mode has internal pullups.\");\n  Serial.print(\"Input Port A read value: 0x\");\n  Serial.println(psg.read(AY3891x::IO_Port_A_Reg), HEX);\n  Serial.print(\"Input Port B read value: 0x\");\n  Serial.println(psg.read(AY3891x::IO_Port_B_Reg), HEX);\n  delay(1000);\n\n  // Set lines to output with value 0xA5 on Port A and 0x5A on Port B\n  // Measure with a DMM or scope to test\n  Serial.println(\"Setting ports to OUTPUT...\");\n  delay(1000);\n  psg.write(AY3891x::Enable_Reg, MIXER_ALL_DISABLED); // Ports to output mode, audio disabled\n  Serial.println(\"Writing 0xA5 to A and 0x5A to B.\");\n  psg.write(AY3891x::IO_Port_A_Reg, 0xA5);\n  psg.write(AY3891x::IO_Port_B_Reg, 0x5A);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "parse",
        "buffer",
        "tone",
        "digitalwrite"
      ],
      "libraries": [
        "Arduino.h",
        "SerialCommands.h",
        "AY3891x.h",
        "AY3891x_sounds.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "parameters": "",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "cmd_unrecognized",
          "parameters": "SerialCommands* sender, const char* cmd",
          "body": "sender->GetSerial()->print(F(\"Unrecognized command [\"));\n\tsender->GetSerial()->print(cmd);\n\tsender->GetSerial()->println(F(\"]\"));"
        },
        {
          "name": "cmd_enable",
          "parameters": "SerialCommands* sender",
          "body": "// \"enable all\"        -- enables all tone and noise generators\n  // \"enable all tones\"  -- enables all tone generators\n  // \"enable all noises\" -- enables all noise generators\n  // \"enable tone a\"     -- enables tone generator A\n  // \"enable tone b\"     -- enables tone generator A\n  // \"enable tone c\"     -- enables tone generator A\n  // \"enable noise a\"    -- enables noise generator A\n  // \"enable noise b\"    -- enables noise generator B\n  // \"enable noise c\"    -- enables noise generator C\n  enum{ALL, TONE, NOISE, TONES, NOISES, CHANA, CHANB, CHANC, NONE};\n  char* param1 = sender->Next();\n  char* param2 = sender->Next();\n  int p1, p2;\n  byte value;\n\n  if (param1 == NULL) p1 = NONE;\n  else\n  {\n    if (strncmp(param1, \"all\", 3) == 0) p1 = ALL;\n    else\n    {\n      if (strncmp(param1, \"tone\", 4) == 0) p1 = TONE;\n      else\n      {\n        if (strncmp(param1, \"noise\", 5) == 0) p1 = NOISE;\n        else p1 = NONE;\n      }\n    }\n  }\n\n  if (param2 == NULL) p2 = NONE;\n  else\n  {\n    if (strncmp(param2, \"tones\", 5) == 0) p2 = TONES;\n    else\n    {\n      if (strncmp(param2, \"noises\", 6) == 0) p2 = NOISES;\n      else\n      {\n        if (strncmp(param2, \"a\", 1) == 0) p2 = CHANA;\n        else\n        {\n          if (strncmp(param2, \"b\", 1) == 0) p2 = CHANB;\n          else\n          {\n            if (strncmp(param2, \"c\", 1) == 0) p2 = CHANC;\n            else p2 = NONE;\n          }\n        }\n      }\n    }\n  }\n\n  switch (p1)\n  {\n    case ALL:\n      switch (p2)\n      {\n        case NONE:\n          sender->GetSerial()->println(F(\"Enabling all tone and noise generators.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, MIXER_INPUTS_DISABLE & value);\n          break;\n        case TONES:\n          sender->GetSerial()->println(F(\"Enabling all tone generators.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE | MIXER_NOISES_DISABLE) & value);\n          break;\n        case NOISES:\n          sender->GetSerial()->println(F(\"Enabling all noise generators.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE |MIXER_TONES_DISABLE) & value);\n          break;\n        default:\n          cmd_unrecognized(sender, buffer);\n      }\n      break;\n    case TONE:\n      switch (p2)\n      {\n        case CHANA:\n          sender->GetSerial()->println(F(\"Enabling Channel A tone generator.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE | MIXER_NOISES_DISABLE | MIXER_TONE_B_DISABLE | MIXER_TONE_C_DISABLE) & value);\n          break;\n        case CHANB:\n          sender->GetSerial()->println(F(\"Enabling Channel B tone generator.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE | MIXER_NOISES_DISABLE | MIXER_TONE_A_DISABLE | MIXER_TONE_C_DISABLE) & value);\n          break;\n        case CHANC:\n          sender->GetSerial()->println(F(\"Enabling Channel C tone generator.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE | MIXER_NOISES_DISABLE | MIXER_TONE_A_DISABLE | MIXER_TONE_B_DISABLE) & value);\n          break;\n        default:\n          cmd_unrecognized(sender, buffer);\n          break;\n      }\n      break;\n    case NOISE:\n      switch (p2)\n      {\n        case CHANA:\n          sender->GetSerial()->println(F(\"Enabling Channel A noise generator.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE | MIXER_TONES_DISABLE | MIXER_NOISE_B_DISABLE | MIXER_NOISE_C_DISABLE) & value);\n          break;\n        case CHANB:\n          sender->GetSerial()->println(F(\"Enabling Channel B noise generator.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE | MIXER_TONES_DISABLE | MIXER_NOISE_A_DISABLE | MIXER_NOISE_C_DISABLE) & value);\n          break;\n        case CHANC:\n          sender->GetSerial()->println(F(\"Enabling Channel C noise generator.\"));\n          value = psg.read(AY3891x::Enable_Reg);\n          psg.write(AY3891x::Enable_Reg, (MIXER_INPUTS_DISABLE | MIXER_TONES_DISABLE | MIXER_NOISE_A_DISABLE | MIXER_NOISE_B_DISABLE) & value);\n          break;\n        default:\n          cmd_unrecognized(sender, buffer);\n          break;\n      }\n      break;\n    default:\n      cmd_unrecognized(sender, buffer);\n      break;\n  }"
        },
        {
          "name": "cmd_disable",
          "parameters": "SerialCommands* sender",
          "body": "// \"disable\"        -- disables all tone and noise generators\n  byte value;\n\n  sender->GetSerial()->println(F(\"Disabling all tones and noises.\"));\n\n  value = psg.read(AY3891x::Enable_Reg);\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONES_DISABLE | value);"
        },
        {
          "name": "cmd_write",
          "parameters": "SerialCommands* sender",
          "body": "char* param1 = sender->Next();  // Register\n  char* param2 = sender->Next();  // Value\n  byte p1, p2;\n\n  if (param1 == NULL) cmd_unrecognized(sender, buffer);\n  else\n  {\n    p1 = atoi(param1);\n    if (p1 > AY3891x::IO_Port_B_Reg) cmd_unrecognized(sender, buffer);\n    else\n    {\n      if (param2 == NULL) cmd_unrecognized(sender, buffer);\n      else\n      {\n        p2 = atoi(param2);\n        sender->GetSerial()->print(F(\"Writing register 0x\"));\n        sender->GetSerial()->print(p1, HEX);\n        sender->GetSerial()->print(F(\" with value 0x\"));\n        sender->GetSerial()->println(p2, HEX);\n        psg.write(p1, p2);\n      }\n    }\n  }"
        },
        {
          "name": "cmd_read",
          "parameters": "SerialCommands* sender",
          "body": "char* param1 = sender->Next();  // Register\n  byte p1;\n  if (param1 == NULL) cmd_unrecognized(sender, buffer);\n  else\n  {\n    p1 = atoi(param1);\n    if (p1 > AY3891x::IO_Port_B_Reg) cmd_unrecognized(sender, buffer);\n    else\n    {\n      sender->GetSerial()->print(F(\"Reading value from register 0x\"));\n      sender->GetSerial()->print(p1, HEX);\n      sender->GetSerial()->print(F(\": 0x\"));\n      sender->GetSerial()->println(psg.read(p1), HEX);\n    }\n  }"
        },
        {
          "name": "cmd_middlec",
          "parameters": "SerialCommands* sender",
          "body": "sender->GetSerial()->println(\"Enable Middle C on channels A and B\");\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONE_C_DISABLE);    // Disable the noise, enable tones on A and B\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n  psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);"
        },
        {
          "name": "cmd_gunshot",
          "parameters": "SerialCommands* sender",
          "body": "sender->GetSerial()->println(\"Playing gunshot sound on A, B, C\");\n  // Register programming values adopted from AY-3-8910 Data Manual, Secion 6.2\n  psg.write(AY3891x::Noise_Period_Reg, 0xF); // Set Noise period to mid-value\n  psg.write(AY3891x::Enable_Reg, MIXER_TONES_DISABLE); // Enable noise only on A,B,C\n  psg.write(AY3891x::ChA_Amplitude, 0x10); // Set full amplitude range under direct control of Envelope Generator\n  psg.write(AY3891x::ChB_Amplitude, 0x10);\n  psg.write(AY3891x::ChC_Amplitude, 0x10);\n  psg.write(AY3891x::Env_Period_Coarse_Reg, 4); // Set envlope period\n  psg.write(AY3891x::Env_Period_Fine_Reg, 0);\n  psg.write(AY3891x::Env_Shape_Cycle, 0);  // Envelope decay, one cycle only"
        },
        {
          "name": "cmd_explosion",
          "parameters": "SerialCommands* sender",
          "body": "sender->GetSerial()->println(\"Playing explosion sound on A, B, C\");\n  // Register programming values adopted from AY-3-8910 Data Manual, Secion 6.2\n  psg.write(AY3891x::Noise_Period_Reg, 0x0); // Set Noise period to max value\n  psg.write(AY3891x::Enable_Reg, MIXER_TONES_DISABLE); // Enable noise only on A,B,C\n  psg.write(AY3891x::ChA_Amplitude, 0x10); // Set full amplitude range under direct control of Envelope Generator\n  psg.write(AY3891x::ChB_Amplitude, 0x10);\n  psg.write(AY3891x::ChC_Amplitude, 0x10);\n  psg.write(AY3891x::Env_Period_Coarse_Reg, 0x1c); // Set envlope period\n  psg.write(AY3891x::Env_Period_Fine_Reg, 0);\n  psg.write(AY3891x::Env_Shape_Cycle, 0);  // Envelope decay, one cycle only"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\tSerial.begin(38400);\n\n\tserial_commands_.SetDefaultHandler(cmd_unrecognized);\n\tserial_commands_.AddCommand(&cmd_enable_);\n  serial_commands_.AddCommand(&cmd_disable_);\n  serial_commands_.AddCommand(&cmd_write_);\n  serial_commands_.AddCommand(&cmd_read_);\n  serial_commands_.AddCommand(&cmd_middlec_);\n  serial_commands_.AddCommand(&cmd_gunshot_);\n  serial_commands_.AddCommand(&cmd_explosion_);\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n  // Set up a tone on channel A and B to make testing easier.\n  // By default, the tone and noise generators are enabled when the chip comes out of reset, I/O pins are set to INPUT\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONE_C_DISABLE);    // Disable the noise and channel C\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  Serial.print(F(\"Configuring note: C4 (middle C)\"));\n  psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n  psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n\n  Serial.println(F(\"\"));\n  Serial.println(F(\"AY-3-891x Sound Chip Library Example 5: Serial Commands.\"));\n  Serial.println(F(\"\"));\n  Serial.println(F(\"Available commands:\"));\n  Serial.println(F(\"  enable all [tones|noises]\"));\n  Serial.println(F(\"  enable tone a|b|c\"));\n  Serial.println(F(\"  enable noise a|b|c\"));\n  Serial.println(F(\"  disable\"));\n  Serial.println(F(\"  write register value\"));\n  Serial.println(F(\"  read register\"));\n  Serial.println(F(\"  middlec\"));\n  Serial.println(F(\"  gunshot\"));\n  Serial.println(F(\"  explosion\"));\n  Serial.println(F(\"Enter command: \"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "serial_commands_.ReadSerial();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "digitalwrite",
        "flash"
      ],
      "libraries": [
        "Arduino.h",
        "AY3891x.h",
        "chiptunes.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "parameters": "",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "byte i;\n\n  if (micros() - prev_micros > INTERVAL)\n  {\n    prev_micros = micros();\n\n    for (i= 0; i < 14; i++) {\n      psg.write(i, pgm_read_byte(&psg_data[data_index++]));\n    }\n\n    if (data_index >= sizeof(psg_data)) {\n      psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONES_DISABLE | psg.read(AY3891x::Enable_Reg));\n      while (1);\n      // Or... you can re-start the song:\n      //  data_index = 0;\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "digitalwrite",
        "digitalread",
        "millis",
        "sd"
      ],
      "libraries": [
        "Arduino.h",
        "AY3891x.h",
        "SD.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "parameters": "",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\n  pinMode(CS, OUTPUT);\n  pinMode(NEXT_BUTTON, INPUT_PULLUP);\n  Serial.begin(9600);\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  Serial.println(F(\"\"));\n  Serial.println(F(\"AY-3-891x Sound Chip Library Example 7: Sound Chip YM data player.\"));\n  Serial.print(F(\"Press button on pin \"));\n  Serial.print(NEXT_BUTTON);\n  Serial.println(F(\" to advance to next song on SD card.\"));\n  Serial.println(F(\"\"));\n\n  if (!SD.begin(CS))\n  {\n    Serial.println(F(\"SD Initialization Failed: program stopped.\"));\n    while (1); // Infinite loop here\n  }\n  else\n  {\n    Serial.println(\"SD Initialization OK\");\n    Serial.println(\"\");\n    root = SD.open(\"/\");\n    state = GETNEXT;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int i;\n  byte register_data[14];\n\n  switch (state) {\n\n    case PLAYING:\n      if (micros() - prev_micros > INTERVAL)\n      {\n        prev_micros = micros();\n        if (current_song.available())\n        {\n          for (i = 0; i < 14; i++) {\n            register_data[i] = current_song.read();\n          }\n          for (i = 0; i < 14; i++) {\n            psg.write( i, register_data[i]);\n          }\n        }\n        else\n        {\n          current_song.close();\n          state = GETNEXT;\n        }\n      }\n      if (digitalRead(NEXT_BUTTON) == LOW)\n      {\n        if (millis() - last_button > KEYBOUNCE_DELAY)\n        {\n          last_button = millis();\n          state = BUTTONRELEASE;\n          // Turn off audio if button is pressed\n          psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONES_DISABLE | psg.read(AY3891x::Enable_Reg));\n        }\n      }\n      break;\n\n    case BUTTONRELEASE:\n      if (digitalRead(NEXT_BUTTON) == HIGH)\n      {\n        if (millis() - last_button > KEYBOUNCE_DELAY)\n        {\n          last_button = millis();\n          current_song.close();\n          state = GETNEXT;\n        }\n      }\n      break;\n\n    case GETNEXT:\n      current_song = root.openNextFile();\n\n      if (!current_song)\n      {\n        // No more files on the SD card\n        state = NOMOREFILES;\n        // When no more song files, turn off audio\n        psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONES_DISABLE | psg.read(AY3891x::Enable_Reg));\n        Serial.println(\"No more files found. Press button to start again.\");\n      }\n      else\n      {\n        if ( (strncmp(current_song.name(), \"SYSTEM\", 6) == 0) || (strncmp(current_song.name(), \"TRASH\", 5) == 0) )\n        {\n          // Windows creates a folder that is difficult to remove, so just ignore it.\n          Serial.print(\"Skipping file: \");\n          Serial.println(current_song.name());\n          current_song.close();\n          // state will stil be GETNEXT for next iteration through loop()\n        }\n        else\n        {\n          Serial.print(\"File opened: \");\n          Serial.println(current_song.name());\n          Serial.print(\"File size (bytes): \");\n          Serial.println(current_song.size());\n          Serial.print(\"Duration: \");\n          Serial.print(current_song.size() / 50UL / 14UL);\n          Serial.println(\" seconds\");\n          state = PLAYING;\n        }\n      }\n      break;\n\n    case NOMOREFILES:\n      if (digitalRead(NEXT_BUTTON) == LOW)\n      {\n        if (millis() - last_button > KEYBOUNCE_DELAY)\n        {\n          last_button = millis();\n          state = BUTTONRELEASE;\n          root.rewindDirectory();\n        }\n      }\n      break;\n\n    default:\n      state = NOMOREFILES;\n      break;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "sensorid",
        "sensorxyz",
        "sensor_id_acc",
        "sensor_id_gyro"
      ],
      "libraries": [
        "Arduino_BHY2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  BHY2.begin();\n  accel.begin();\n  gyro.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "static auto printTime = millis();\n\n  // Update function should be continuously polled\n  BHY2.update();\n\n  if (millis() - printTime >= 50) {\n    printTime = millis();\n\n    // Accelerometer values\n    Serial.print(\"acc_X:\");\n    Serial.print(accel.x());\n    Serial.print(\",\");\n    Serial.print(\"acc_Y:\");\n    Serial.print(accel.y());\n    Serial.print(\",\");\n    Serial.print(\"acc_Z:\");\n    Serial.print(accel.z());\n    Serial.print(\",\");\n\n    // Gyroscope values\n    Serial.print(\"gyro_X:\");\n    Serial.print(gyro.x());\n    Serial.print(\",\");\n    Serial.print(\"gyro_Y:\");\n    Serial.print(gyro.y());\n    Serial.print(\",\");\n    Serial.print(\"gyro_Z:\");\n    Serial.println(gyro.z());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "current",
        "spi",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h",
        "AccelStepper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "SPI.begin();\n  stepper.init(amisSlaveSelect);\n  delay(1);\n\n  stepper.resetSettings();\n  stepper.setCurrentMilliamps(132);\n  stepper.setStepMode(32);\n  stepper.enableDriver();\n\n  accelStepper.setMaxSpeed(2000.0);\n  accelStepper.setAcceleration(500.0);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "accelStepper.runToNewPosition(0);\n  delay(500);\n  accelStepper.runToNewPosition(10000);\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "i2c"
      ],
      "libraries": [
        "AccelStepper.h",
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "parameters": "",
          "body": "myStepper1->onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "parameters": "",
          "body": "myStepper1->onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n   Serial.println(\"Stepper test!\");\n\n  if (!AFMS.begin()) {         // create with the default frequency 1.6KHz\n  // if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz\n    Serial.println(\"Could not find Motor Shield. Check wiring.\");\n    while (1);\n  }\n  Serial.println(\"Motor Shield found.\");\n\n  Astepper1.setSpeed(50);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Astepper1.runSpeed();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https"
      ],
      "libraries": [
        "AccelStepper.h",
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "parameters": "",
          "body": "myStepper1->onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "parameters": "",
          "body": "myStepper1->onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "forwardstep2",
          "parameters": "",
          "body": "myStepper2->onestep(FORWARD, DOUBLE);"
        },
        {
          "name": "backwardstep2",
          "parameters": "",
          "body": "myStepper2->onestep(BACKWARD, DOUBLE);"
        },
        {
          "name": "forwardstep3",
          "parameters": "",
          "body": "myStepper3->onestep(FORWARD, INTERLEAVE);"
        },
        {
          "name": "backwardstep3",
          "parameters": "",
          "body": "myStepper3->onestep(BACKWARD, INTERLEAVE);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "AFMSbot.begin(); // Start the bottom shield\n  AFMStop.begin(); // Start the top shield\n\n  stepper1.setMaxSpeed(100.0);\n  stepper1.setAcceleration(100.0);\n  stepper1.moveTo(24);\n\n  stepper2.setMaxSpeed(200.0);\n  stepper2.setAcceleration(100.0);\n  stepper2.moveTo(50000);\n\n  stepper3.setMaxSpeed(300.0);\n  stepper3.setAcceleration(100.0);\n  stepper3.moveTo(1000000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Change direction at the limits\n    if (stepper1.distanceToGo() == 0)\n\tstepper1.moveTo(-stepper1.currentPosition());\n\n    if (stepper2.distanceToGo() == 0)\n\tstepper2.moveTo(-stepper2.currentPosition());\n\n    if (stepper3.distanceToGo() == 0)\n\tstepper3.moveTo(-stepper3.currentPosition());\n\n    stepper1.run();\n    stepper2.run();\n    stepper3.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Arduino_SensorKit.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);\n  while(!Serial);\n  \n  Accelerometer.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  // 3 axis\n  Serial.print(\"x:\"); \n  Serial.print(Accelerometer.readX()); \n  Serial.print(\"  \");\n  Serial.print(\"y:\"); \n  Serial.print(Accelerometer.readY());        \n  Serial.print(\"  \");\n  Serial.print(\"z:\"); \n  Serial.println(Accelerometer.readZ());\n \n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "acceleration",
        "i2c",
        "delay",
        "sensor_float_vec_t"
      ],
      "libraries": [
        "MPU6000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 bits per second for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n    accelerometer.initialize(); // Set-up for MPU \n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelrometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "acc = accelerometer.getSample(); // Gets and saves 3-axis acceleration reading (G)\n\n    Serial.print(\"Acceleration in Gs, X-Axis: \"); Serial.print(acc.x, 8); // Prints out 3-axis acceleration (G)\n    Serial.print(\" Y-Axis: \"); Serial.print(acc.y, 8);\n    Serial.print(\" Z-Axis: \"); Serial.print(acc.z, 8);\n    Serial.println();\n    \n    delay(500); // Waits 500ms (half a second)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "acceleration",
        "current",
        "i2c",
        "delay",
        "millis",
        "digitalwrite",
        "led",
        "sensor_float_vec_t",
        "meters",
        "sensor_int16_vec_t"
      ],
      "libraries": [
        "MPU6000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n\n    accelerometer.initialize(); // Set-up for MPU \n\n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelrometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G\n\n    pinMode(LED, OUTPUT); // Sets LED\n    \n    delay(50); // Allow time for sensor initialization to complete\n\n    for(int i = 0; i < 3; i++){ // Calibration period of 3 seconds\n        startTime = millis(); // Keeps track of start time before getting measurements\n\n        accelRaw = accelerometer.getRawAcc(); // Gets and saves raw acceleration \n        accelG = accelerometer.getGAccel(accelRaw); // Gets and saves acceleration in G's\n        accelMPS = accelerometer.getMPSAccel(accelG); // Gets and saves acceleration in MPS\n        \n        Serial.print(\"MPS, X-Axis: \"); // Prints out 3-axis acceleration (MPS)\n        Serial.println(accelMPS.x, 8);\n        Serial.print(\"MPS, Y-Axis: \");\n        Serial.println(accelMPS.y, 8);\n        Serial.print(\"MPS, Z-Axis: \");\n        Serial.println(accelMPS.z, 8);\n        Serial.println();\n    \n        staticAcceleration = staticAcceleration + sqrt(pow(accelMPS.x,2) + pow(accelMPS.y,2) + pow(accelMPS.z,2)); // Adds up magnitude of \n                                                                                                                   // current acceleration\n        endTime = millis(); // Keeps track of end time after getting measurements \n        delay(1000 - (endTime - startTime)); // Change of time factored into a one second delay\n    };\n    \n    staticAcceleration = staticAcceleration/3; // Calculates and saves average of the sum of the magnitude of current acceleration from above\n    Serial.print(F(\"Calculated Static Acceleration: \")); Serial.println(staticAcceleration); // Prints out static acceleration"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "startTime = millis(); // Keeps track of start time before getting measurements\n\n    accelRaw = accelerometer.getRawAcc(); // Gets and saves raw acceleration\n    accelG = accelerometer.getGAccel(accelRaw); // Gets and saves acceleration in G's\n    accelMPS = accelerometer.getMPSAccel(accelG); // Gets and saves acceleration in MPS\n\n    Serial.print(\"MPS, X-Axis: \"); // Prints out 3-axis acceleration (MPS)\n    Serial.println(accelMPS.x, 8);\n    Serial.print(\"MPS, Y-Axis: \");\n    Serial.println(accelMPS.y, 8);\n    Serial.print(\"MPS, Z-Axis: \");\n    Serial.println(accelMPS.z, 8);\n    Serial.println();\n\n    dynamicAcceleration = sqrt(pow(accelMPS.x,2) + pow(accelMPS.y,2) + pow(accelMPS.z,2)); // Adds up magnitude of current acceleration\n\n    accelDif = abs(dynamicAcceleration - staticAcceleration); // Subtracts and saves static acceleration from dynamic acceleration\n\n    Serial.print(F(\"Calculated Difference in Acceleration: \")); Serial.println(accelDif); // Print out difference in acceleration\n\n    if(accelDif >= impactThreshold){ // If the difference in acceleration is greater than or equal to the threshhold set above\n        Serial.println(\"Impact detected\"); // Notify impact has been detected\n\n        digitalWrite(LED, HIGH); // LEDs blink\n        delay(500);\n        digitalWrite(LED, LOW);\n    };\n    \n    endTime = millis(); // Keeps track of end time after getting measurements \n    delay(100); // Gets measurements every 0.1 second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "acceleration",
        "current",
        "i2c",
        "delay",
        "sensor_float_vec_t",
        "meters"
      ],
      "libraries": [
        "MPU6000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n    accelerometer.initialize(); // Set-up for MPU \n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelerometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G\n\n    // Calibration (LunaSat flat on table)\n    sensor_float_vec_t calibrationPoints[calibrationSize];  // Array of vectors for storing calibration points  \n    for(int i = 0; i < calibrationSize; i++){\n        calibrationPoints[i] = accelerometer.getSample();\n    }\n\n    // Get sums of axes measurements\n    for(int j = 0; j < calibrationSize; j++){\n        avgX = avgX + calibrationPoints[j].x;\n        avgY = avgY + calibrationPoints[j].y;\n    }\n\n    // Find average axes measurements\n    avgX = avgX/calibrationSize;\n    avgY = avgY/calibrationSize;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "acc = accelerometer.getSample(); // Gets and saves 3-axis acceleration reading (G)\n\n    accMPS = accelerometer.getMPSAccel(acc); // Converts acceleration measurements from G's to meters per second squared\n\n    // Subtract baseline values from current sample\n\n    accMPS.x = accMPS.x - avgX*9.81; // Multiply by 9.81 to convert G's to m/s^2\n    accMPS.y = accMPS.y - avgY*9.81;\n    \n    // Find the net acceleration for each pair of axes\n    yzAcceleration = sqrt(pow(accMPS.y,2) + pow(accMPS.z,2)); \n    xzAcceleration = sqrt(pow(accMPS.x,2) + pow(accMPS.z,2)); \n    xyAcceleration = sqrt(pow(accMPS.x,2) + pow(accMPS.y,2)); \n\n    // Calculate x angle (roll)\n    xAngle = accMPS.x/yzAcceleration;\n    xAngle = atan(xAngle)*(180/3.141);\n    Serial.print(\"X Angle (Roll): \");\n    Serial.print(xAngle);\n    Serial.println(\"º\");\n\n    // Calculate y angle (pitch)\n    yAngle = accMPS.y/xzAcceleration;\n    yAngle = atan(yAngle)*(180/3.141);\n    Serial.print(\"Y Angle (Pitch): \");\n    Serial.print(yAngle);\n    Serial.println(\"º\");\n\n    // Calculate z angle (yaw)\n    zAngle = accMPS.z/xyAcceleration;\n    zAngle = (atan(zAngle)*(180/3.141));\n    Serial.print(\"Z Angle (Yaw): \");\n    Serial.print(zAngle);\n    Serial.println(\"º\");\n    Serial.println();\n    \n    delay(500); // Waits half a second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "token",
        "auth",
        "key",
        "https",
        "payload",
        "wifi",
        "delay",
        "millis",
        "client_id",
        "client_secret",
        "clientid",
        "clientsecret"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    // Initialize the FirebaseApp or auth task handler.\n    // To deinitialize, use deinitializeApp(app).\n    initializeApp(aClient, app, getAuth(access_token), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "https",
        "token",
        "auth",
        "certificate",
        "ssl",
        "payload",
        "json",
        "callback",
        "buffer",
        "ntp",
        "wifi",
        "delay",
        "millis",
        "flash",
        "sd",
        "timestamp",
        "rtc"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the certificate file (optional) */\n  /** From the test as of July 2021, GlobalSign Root CA was missing from Google server\n   * when checking with https://www.sslchecker.com/sslchecker.\n   * The certificate chain, GTS Root R1 can be used instead.\n   *\n   * ESP32 Arduino SDK supports PEM format only even mBedTLS supports DER format too.\n   * ESP8266 SDK supports both PEM and DER format certificates.\n   */\n  config.cert.file = \"/gtsr1.pem\";\n  config.cert.file_storage = StorageType::FLASH; // or StorageType::SD\n\n  /* The file systems for flash and SD/SDMMC can be changed in FirebaseFS.h. */\n\n  /* Assign the sevice account JSON file and the file storage type (required) */\n  config.service_account.json.path = \"/service_account_file.json\"; // change this for your json file\n  config.service_account.json.storage_type = StorageType::FLASH;   // or StorageType::SD\n\n  /** The user UID set to empty to sign in as admin */\n  // auth.token.uid.clear();\n\n  /* Assign the RTDB URL */\n  config.database_url = DATABASE_URL;\n\n  /** The scope of the OAuth2.0 authentication\n   * If you wan't this access token for others Google Cloud Services.\n   */\n  // config.signer.tokens.scope = \"Google Scope 1 Url, Google Scope 2 Url,..\";\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  /** To set system time with the timestamp from RTC\n   * The internal NTP server time acquisition\n   * of token generation process will be skipped,\n   * if the system time is already set.\n   *\n   * sec is the seconds from midnight Jan 1, 1970\n   */\n  // Firebase.setSystemTime(sec);\n\n  /* Now we start to signin using access token */\n\n  /** Initialize the library with the Firebase authen and config.\n   *\n   * The device time will be set by sending request to the NTP server\n   * befor token generation and exchanging.\n   *\n   * The signed RSA256 jwt token will be created and used for access token exchanging.\n   *\n   * Theses process may take time to complete.\n   */\n  Firebase.begin(&config, &auth);\n\n  /* The access token can be accessed from Firebase.getToken(). */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && millis() - dataMillis > 5000)\n  {\n    dataMillis = millis();\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count++) ? \"ok\" : fbdo.errorReason().c_str());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "distance",
        "delay"
      ],
      "libraries": [
        "AccessoryShield.h",
        "Mouse.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the Accessory Shield library\n  accessoryShield.begin();\n  // initialize mouse control:\n  Mouse.begin();\n  \n#ifdef SKETCH_DEBUG\n  Serial.begin(9600);\n  while(!Serial) ;\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read a new value from th joystick\n  JoystickMode joystickValue = accessoryShield.getJoystickValue();\n  \n  // set the distance offset using the pot trimmer of Accessory Shield\n  unsigned int distanceOffset = accessoryShield.readPot();\n  // calibrate and map the pot value \n  distanceOffset = map(distanceOffset, 0, 1023, minDistanceOffset, maxDistanceOffset);\n  // set the X and Y distance :\n  // xDistance and yDistance are used to set how the mouse sould be moved\n  // in orizontal (X axis) or in vertical (Y axis) \n  xDistance = yDistance = distanceOffset;\n\n  // check if the joystick has been moved\n#if (defined(_VARIANT_ARDUINO_101_X_) || defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAMD))\n  if(joystickValue != JOYSTICK_NONE_OR_DOWN) {\n#else\n  if(joystickValue != JOYSTICK_NONE) {\n#endif\n    // print values of X and Y distance\n#ifdef SKETCH_DEBUG\n    Serial.print(\"X distance offset= \");\n    Serial.println(xDistance);\n    Serial.print(\"Y distance offset= \");\n    Serial.println(yDistance);\n#endif\n    \n    switch(joystickValue) {\n      // if the joystick has been pushed, click with mouse left button\n      case JOYSTICK_PUSH :\n        Mouse.click(MOUSE_LEFT);\n        break;\n      // if the joystick has been moved up, move up the mouse cursor\n      case JOYSTICK_UP :\n        Mouse.move(0, -yDistance, 0);\n        break;\n#if !(defined(_VARIANT_ARDUINO_101_X_) || defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAMD))\n      // if the joystick has been moved down, move down the mouse cursor\n      case JOYSTICK_DOWN :\n        Mouse.move(0, yDistance, 0);\n        break;\n#endif\n      // if the joystick has been moved right, move right the mouse cursor\n      case JOYSTICK_RIGHT :\n        Mouse.move(xDistance, 0, 0);\n        break;\n      // if the joystick has been moved left, move left the mouse cursor\n      case JOYSTICK_LEFT :\n        Mouse.move(-xDistance, 0, 0);\n        break;\n      \n    }\n  }\n  // wait for a small delay time so the mouse doesn't move too fast:\n  delay(responseDelay);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "sensoractivity",
        "sensor_id_ar"
      ],
      "libraries": [
        "Arduino_BHY2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  BHY2.begin();\n  active.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "BHY2.update();\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis >= interval) {\n    previousMillis = currentMillis;\n    Serial.println(String(\"Activity info: \") + active.toString());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "http",
        "https",
        "password",
        "ssl",
        "publish",
        "subscribe",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "power",
        "lte",
        "nb-iot",
        "gprs",
        "delay",
        "digitalwrite",
        "led",
        "sensor_val"
      ],
      "libraries": [
        "BotleticsSIM7000.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_FONA.h",
        "SoftwareSerial.h",
        "HardwareSerial.h",
        "Wire.h",
        "Adafruit_MCP9808.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Serial.println(F(\"*** SIMCom Module MQTT Example ***\"));\n\n  #ifdef LED\n    pinMode(LED, OUTPUT);\n    digitalWrite(LED, LOW);\n  #endif\n  \n  pinMode(RST, OUTPUT);\n  digitalWrite(RST, HIGH); // Default state\n\n  modem.powerOn(BOTLETICS_PWRKEY); // Power on the module\n  moduleSetup(); // Establishes first-time serial comm and prints IMEI\n\n  if (!tempsensor.begin()) {\n    Serial.println(\"Couldn't find the MCP9808!\");\n    tempsensor.wake(); // Wake up the MCP9808 if it was sleeping and retry\n    if (!tempsensor.begin()) while (1);\n  }\n\n  // Unlock SIM card if needed\n  // Remember to uncomment the \"PIN\" variable definition above\n  /*\n  if (!modem.unlockSIM(PIN)) {\n    Serial.println(F(\"Failed to unlock SIM card\"));\n  }\n  */\n\n  // Set modem to full functionality\n  modem.setFunctionality(1); // AT+CFUN=1\n\n  // Configure a GPRS APN, username, and password.\n  // You might need to do this to access your network's GPRS/data\n  // network.  Contact your provider for the exact APN, username,\n  // and password values.  Username and password are optional and\n  // can be removed, but APN is required.\n  //modem.setNetworkSettings(F(\"your APN\"), F(\"your username\"), F(\"your password\"));\n  //modem.setNetworkSettings(F(\"m2m.com.attz\")); // For AT&T IoT SIM card\n  //modem.setNetworkSettings(F(\"telstra.internet\")); // For Telstra (Australia) SIM card - CAT-M1 (Band 28)\n  modem.setNetworkSettings(F(\"hologram\")); // For Hologram SIM card\n\n  // Optionally configure HTTP gets to follow redirects over SSL.\n  // Default is not to follow SSL redirects, however if you uncomment\n  // the following line then redirects over SSL will be followed.\n  //modem.setHTTPSRedirect(true);\n\n  /*\n  // Other examples of some things you can set:\n  modem.setPreferredMode(38); // Use LTE only, not 2G\n  modem.setPreferredLTEMode(1); // Use LTE CAT-M only, not NB-IoT\n  modem.setOperatingBand(\"CAT-M\", 12); // AT&T uses band 12\n//  modem.setOperatingBand(\"CAT-M\", 13); // Verizon uses band 13\n  modem.enableRTC(true);\n  \n  modem.enableSleepMode(true);\n  modem.set_eDRX(1, 4, \"0010\");\n  modem.enablePSM(true);\n\n  // Set the network status LED blinking pattern while connected to a network (see AT+SLEDS command)\n  modem.setNetLED(true, 2, 64, 3000); // on/off, mode, timer_on, timer_off\n  modem.setNetLED(false); // Disable network status LED\n  */\n\n  // Perform first-time GPS/data setup if the shield is going to remain on,\n  // otherwise these won't be enabled in loop() and it won't work!\n  // Enable GPS\n  while (!modem.enableGPS(true)) {\n    Serial.println(F(\"Failed to turn on GPS, retrying...\"));\n    delay(2000); // Retry every 2s\n  }\n  Serial.println(F(\"Turned on GPS!\"));\n\n  #if !defined(SIMCOM_3G) && !defined(SIMCOM_7500) && !defined(SIMCOM_7600)\n    // Disable data just to make sure it was actually off so that we can turn it on\n    if (!modem.enableGPRS(false)) Serial.println(F(\"Failed to disable data!\"));\n    \n    // Turn on data\n    while (!modem.enableGPRS(true)) {\n      Serial.println(F(\"Failed to enable data, retrying...\"));\n      delay(2000); // Retry every 2s\n    }\n    Serial.println(F(\"Enabled data!\"));\n  #endif\n\n  mqtt.subscribe(&feed_command); // Only if you're using MQTT"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Connect to cell network and verify connection\n  // If unsuccessful, keep retrying every 2s until a connection is made\n  while (!netStatus()) {\n    Serial.println(F(\"Failed to connect to cell network, retrying...\"));\n    delay(2000); // Retry every 2s\n  }\n  Serial.println(F(\"Connected to cell network!\"));\n  \n  // Disable data just to make sure it was actually off so that we can turn it on\n  // modem.openWirelessConnection(false);\n  \n  // Open wireless connection if not already activated\n  if (!modem.wirelessConnStatus()) {\n    while (!modem.openWirelessConnection(true)) {\n      Serial.println(F(\"Failed to enable connection, retrying...\"));\n      delay(2000); // Retry every 2s\n    }\n    Serial.println(F(\"Enabled data!\"));\n  }\n  else {\n    Serial.println(F(\"Data already enabled!\"));\n  }\n\n  // Measure battery voltage in mV\n  battLevel = readVcc();\n\n  // Measure temperature\n  tempsensor.wake(); // Wake up the MCP9808 if it was sleeping\n  float tempC = tempsensor.readTempC();\n  float tempF = tempC * 9.0 / 5.0 + 32;\n  Serial.print(\"Temp: \"); Serial.print(tempC); Serial.print(\"*C\\t\"); \n  Serial.print(tempF); Serial.println(\"*F\");\n  \n  Serial.println(\"Shutting down the MCP9808...\");\n  tempsensor.shutdown(); // In this mode the MCP9808 draws only about 0.1uA\n\n  float temperature = tempC; // Select what unit you want to use for this example\n\n  // Turn on GPS if it wasn't on already (e.g., if the module wasn't turned off)\n#ifdef turnOffShield\n  while (!modem.enableGPS(true)) {\n    Serial.println(F(\"Failed to turn on GPS, retrying...\"));\n    delay(2000); // Retry every 2s\n  }\n  Serial.println(F(\"Turned on GPS!\"));\n#endif\n\n  // Get a fix on location, try every 2s\n  // Use the top line if you want to parse UTC time data as well, the line below it if you don't care\n//  while (!modem.getGPS(&latitude, &longitude, &speed_kph, &heading, &altitude, &year, &month, &day, &hour, &minute, &second)) {\n  while (!modem.getGPS(&latitude, &longitude, &speed_kph, &heading, &altitude)) {\n    Serial.println(F(\"Failed to get GPS location, retrying...\"));\n    delay(2000); // Retry every 2s\n  }\n  Serial.println(F(\"Found 'eeeeem!\"));\n  Serial.println(F(\"---------------------\"));\n  Serial.print(F(\"Latitude: \")); Serial.println(latitude, 6);\n  Serial.print(F(\"Longitude: \")); Serial.println(longitude, 6);\n  Serial.print(F(\"Speed: \")); Serial.println(speed_kph);\n  Serial.print(F(\"Heading: \")); Serial.println(heading);\n  Serial.print(F(\"Altitude: \")); Serial.println(altitude);\n  /*\n  // Uncomment this if you care about parsing UTC time\n  Serial.print(F(\"Year: \")); Serial.println(year);\n  Serial.print(F(\"Month: \")); Serial.println(month);\n  Serial.print(F(\"Day: \")); Serial.println(day);\n  Serial.print(F(\"Hour: \")); Serial.println(hour);\n  Serial.print(F(\"Minute: \")); Serial.println(minute);\n  Serial.print(F(\"Second: \")); Serial.println(second);\n  */\n  Serial.println(F(\"---------------------\"));\n\n  // Format the floating point numbers\n  dtostrf(latitude, 1, 6, latBuff); // float_val, min_width, digits_after_decimal, char_buffer\n  dtostrf(longitude, 1, 6, longBuff);\n  dtostrf(speed_kph, 1, 0, speedBuff);\n  dtostrf(heading, 1, 0, headBuff);\n  dtostrf(altitude, 1, 1, altBuff);\n  dtostrf(temperature, 1, 2, tempBuff);\n  dtostrf(battLevel, 1, 0, battBuff);\n\n  // Also construct a combined, comma-separated location array\n  // (many platforms require this for dashboards, like Adafruit IO):\n  sprintf(locBuff, \"%s,%s,%s,%s\", speedBuff, latBuff, longBuff, altBuff); // This could look like \"10,33.123456,-85.123456,120.5\"\n  \n  // Ensure the connection to the MQTT server is alive (this will make the first\n  // connection and automatically reconnect when disconnected). See the MQTT_connect\n  // function definition further below.\n  MQTT_connect();\n\n  // Now publish all the data to different feeds!\n  // The MQTT_publish_checkSuccess handles repetitive stuff.\n  // You can see the function near the end of this sketch.\n  // For the Adafruit IO dashboard map we send the combined lat/long buffer\n  MQTT_publish_checkSuccess(feed_location, locBuff);\n//  MQTT_publish_checkSuccess(feed_speed, speedBuff); // Included in \"location\" feed\n  MQTT_publish_checkSuccess(feed_head, headBuff);\n//  MQTT_publish_checkSuccess(feed_alt, altBuff); // Included in \"location\" feed\n  MQTT_publish_checkSuccess(feed_temp, tempBuff);\n  MQTT_publish_checkSuccess(feed_voltage, battBuff);\n \n  // This is our 'wait for incoming subscription packets' busy subloop\n  Adafruit_MQTT_Subscribe *subscription;\n  while ((subscription = mqtt.readSubscription(5000))) {\n    if (subscription == &feed_command) {\n      Serial.print(F(\"*** Got: \"));\n      Serial.println((char *)feed_command.lastread);\n    }\n  }\n\n  // Control an LED based on what we receive from the command feed subscription!\n  if (strcmp(feed_command.lastread, \"ON\") == 0) {\n    Serial.println(F(\"*** Commanded to turn on LED!\"));\n    digitalWrite(LED, HIGH);\n  }\n  else if (strcmp(feed_command.lastread, \"OFF\") == 0) {\n    Serial.println(F(\"*** Commanded to turn off LED!\"));\n    digitalWrite(LED, LOW);\n  }\n\n  // Delay until next post\n  Serial.print(F(\"Waiting for \")); Serial.print(samplingRate); Serial.println(F(\" seconds\\r\\n\"));\n  delay(samplingRate * 1000UL); // Delay"
        },
        {
          "name": "moduleSetup",
          "parameters": "",
          "body": "// SIM7000 takes about 3s to turn on and SIM7500 takes about 15s\n  // Press Arduino reset button if the module is still turning on and the board doesn't find it.\n  // When the module is on it should communicate right after pressing reset\n\n  // Software serial:\n  modemSS.begin(115200); // Default SIM7000 shield baud rate\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modemSS.println(\"AT+IPR=9600\"); // Set baud rate\n  delay(100); // Short pause to let the command run\n  modemSS.begin(9600);\n  if (! modem.begin(modemSS)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while (1); // Don't proceed if it couldn't find the device\n  }\n\n  // Hardware serial:\n  /*\n  modemSerial->begin(115200); // Default SIM7000 baud rate\n\n  if (! modem.begin(*modemSerial)) {\n    DEBUG_PRINTLN(F(\"Couldn't find SIM7000\"));\n  }\n  */\n\n  // The commented block of code below is an alternative that will find the module at 115200\n  // Then switch it to 9600 without having to wait for the module to turn on and manually\n  // press the reset button in order to establish communication. However, once the baud is set\n  // this method will be much slower.\n  /*\n  modemSerial->begin(115200); // Default LTE shield baud rate\n  modem.begin(*modemSerial); // Don't use if statement because an OK reply could be sent incorrectly at 115200 baud\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modem.setBaudrate(9600); // Set to 9600 baud\n  modemSerial->begin(9600);\n  if (!modem.begin(*modemSerial)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while(1); // Don't proceed if it couldn't find the device\n  }\n  */\n\n  type = modem.type();\n  Serial.println(F(\"Modem is OK\"));\n  Serial.print(F(\"Found \"));\n  switch (type) {\n    case SIM800L:\n      Serial.println(F(\"SIM800L\")); break;\n    case SIM800H:\n      Serial.println(F(\"SIM800H\")); break;\n    case SIM808_V1:\n      Serial.println(F(\"SIM808 (v1)\")); break;\n    case SIM808_V2:\n      Serial.println(F(\"SIM808 (v2)\")); break;\n    case SIM5320A:\n      Serial.println(F(\"SIM5320A (American)\")); break;\n    case SIM5320E:\n      Serial.println(F(\"SIM5320E (European)\")); break;\n    case SIM7000:\n      Serial.println(F(\"SIM7000\")); break;\n    case SIM7070:\n      Serial.println(F(\"SIM7070\")); break;\n    case SIM7500:\n      Serial.println(F(\"SIM7500\")); break;\n    case SIM7600:\n      Serial.println(F(\"SIM7600\")); break;\n    default:\n      Serial.println(F(\"???\")); break;\n  }\n  \n  // Print module IMEI number.\n  uint8_t imeiLen = modem.getIMEI(imei);\n  if (imeiLen > 0) {\n    Serial.print(\"Module IMEI: \"); Serial.println(imei);\n  }"
        },
        {
          "name": "readVcc",
          "parameters": "",
          "body": "// Read battery voltage\n  if (!modem.getBattVoltage(&battLevel)) Serial.println(F(\"Failed to read batt\"));\n  else Serial.print(F(\"battery = \")); Serial.print(battLevel); Serial.println(F(\" mV\"));\n\n  // Read LiPo battery percentage\n  // Note: This will NOT work properly on the LTE shield because the voltage\n  // is regulated to 3.6V so you will always read about the same value!\n//  if (!modem.getBattPercent(&battLevel)) Serial.println(F(\"Failed to read batt\"));\n//  else Serial.print(F(\"BAT % = \")); Serial.print(battLevel); Serial.println(F(\"%\"));\n\n  return battLevel;"
        },
        {
          "name": "netStatus",
          "parameters": "",
          "body": "int n = modem.getNetworkStatus();\n  \n  Serial.print(F(\"Network status \")); Serial.print(n); Serial.print(F(\": \"));\n  if (n == 0) Serial.println(F(\"Not registered\"));\n  if (n == 1) Serial.println(F(\"Registered (home)\"));\n  if (n == 2) Serial.println(F(\"Not registered (searching)\"));\n  if (n == 3) Serial.println(F(\"Denied\"));\n  if (n == 4) Serial.println(F(\"Unknown\"));\n  if (n == 5) Serial.println(F(\"Registered roaming\"));\n\n  if (!(n == 1 || n == 5)) return false;\n  else return true;"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  // Stop if already connected.\n  if (mqtt.connected()) {\n    return;\n  }\n\n  Serial.println(\"Connecting to MQTT... \");\n\n  while ((ret = mqtt.connect()) != 0) { // connect will return 0 for connected\n    Serial.println(mqtt.connectErrorString(ret));\n    Serial.println(\"Retrying MQTT connection in 5 seconds...\");\n    mqtt.disconnect();\n    delay(5000);  // wait 5 seconds\n  }\n  Serial.println(\"MQTT Connected!\");"
        },
        {
          "name": "MQTT_publish_checkSuccess",
          "parameters": "Adafruit_MQTT_Publish &feed, const char *feedContent",
          "body": "Serial.println(F(\"Sending data...\"));\n  if (! feed.publish(feedContent)) {\n    Serial.println(F(\"Failed\"));\n    txfailures++;\n  }\n  else {\n    Serial.println(F(\"OK!\"));\n    txfailures = 0;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "ble",
        "spi"
      ],
      "libraries": [
        "BlynkSimpleBLEPeripheral.h",
        "BLEPeripheral.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  SerialBLE.setLocalName(\"Blynk\");\n  SerialBLE.setDeviceName(\"Blynk\");\n  SerialBLE.setAppearance(0x0080);\n  SerialBLE.begin();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(SerialBLE, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SerialBLE.poll();\n\n  if (SerialBLE) {    // If BLE is connected...\n    Blynk.run();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "ble",
        "spi"
      ],
      "libraries": [
        "BlynkSimpleSerialBLE.h",
        "Adafruit_BLE.h",
        "Adafruit_BluefruitLE_SPI.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  ble.begin(BLUEFRUIT_VERBOSE_MODE);\n  ble.factoryReset(); // Optional\n  ble.setMode(BLUEFRUIT_MODE_DATA);\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(auth, ble);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "wifi",
        "blynk.cloud"
      ],
      "libraries": [
        "WiFi101.h",
        "BlynkSimpleWiFiShield101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  WiFi.setPins(8, 7, 4, 2);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "voltage",
        "digitalwrite",
        "delay",
        "analogread",
        "interrupt"
      ],
      "libraries": [
        "ArduinoLowPower.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(pin, INPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for (int i = 0; i < repetitions; i++) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(500);\n    digitalWrite(LED_BUILTIN, LOW);\n    delay(500);\n  }\n\n  // Read the voltage at the ADC pin\n  int value = analogRead(pin);\n\n  // Define a window around that value\n  uint16_t lo = max(value - margin, 0);\n  uint16_t hi = min(value + margin, UINT16_MAX); \n\n  // Attach an ADC interrupt on pin A0, calling repetitionsIncrease when the voltage is outside the given range.\n  // This should be called immediately before LowPower.sleep() because it reconfigures the ADC internally.\n  LowPower.attachAdcInterrupt(pin, repetitionsIncrease, ADC_INT_OUTSIDE, lo, hi);\n\n  // Triggers an infinite sleep (the device will be woken up only by the registered wakeup sources)\n  // The power consumption of the chip will drop consistently\n  LowPower.sleep();\n\n  // Detach the ADC interrupt. This should be called immediately after LowPower.sleep() because it restores the ADC configuration after waking up.\n  LowPower.detachAdcInterrupt();"
        },
        {
          "name": "repetitionsIncrease",
          "parameters": "",
          "body": "// This function will be called once on device wakeup\n  // You can do some little operations here (like changing variables which will be used in the loop)\n  // Remember to avoid calling delay() and long running functions since this functions executes in interrupt context\n  repetitions ++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Checking Connection\");\n  if (WifiConnection::isConnected()) {\n    \n    // add that value to array in the server\n    bool isOk = storage.add(\"times_alive\", millis());\n    \n    // notify if error occurred\n    if(isOk == false) {\n      Serial.println(\"Something went wrong...\");  \n    }\n\n  } else {\n    Serial.println(\"No Connection\");\n  }\n\n  delay(5 * 1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "i2c",
        "digitalwrite",
        "led",
        "interrupt",
        "timestamp"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Begin Serial communication\n    Serial.begin(9600);\n    while (!Serial);\n\n    // Set the DS3231 clock mode to 24-hour\n    myRTC.setClockMode(false); // false = not using the alternate, 12-hour mode\n\n    // Set the clock to an arbitrarily chosen time of\n    // 00:00:00 midnight the morning of January 1, 2020\n    // using a suitable Unix-style timestamp\n    myRTC.setEpoch(1640995200);\n\n    // Assign parameter values for Alarm 1\n    alarmDay = myRTC.getDate();\n    alarmHour = myRTC.getHour(alarmH12, alarmPM);\n    alarmMinute = myRTC.getMinute();\n    alarmSecond = INT_FREQ; // initialize to the interval length\n    alarmBits = 0b00001110; // Alarm 1 when seconds match\n    alarmDayIsDay = false; // using date of month\n\n    // Upload initial parameters of Alarm 1\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(\n       alarmDay, alarmHour, alarmMinute, alarmSecond,\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // clear Alarm 1 flag after setting the alarm time\n    myRTC.checkIfAlarm(1);\n    // now it is safe to enable interrupt output\n    myRTC.turnOnAlarm(1);\n\n    // When using interrupt with only one of the DS3231 alarms, as in this example,\n    // it may be possible to prevent the other alarm entirely,\n    // so it will not covertly block the outgoing interrupt signal.\n\n    // Try to prevent Alarm 2 altogether by assigning a \n    // nonsensical alarm minute value that cannot match the clock time,\n    // and an alarmBits value to activate \"when minutes match\".\n    alarmMinute = 0xFF; // a value that will never match the time\n    alarmBits = 0b01100000; // Alarm 2 when minutes match, i.e., never\n    \n    // Upload the parameters to prevent Alarm 2 entirely\n    myRTC.setA2Time(\n        alarmDay, alarmHour, alarmMinute,\n        alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // disable Alarm 2 interrupt\n    myRTC.turnOffAlarm(2);\n    // clear Alarm 2 flag\n    myRTC.checkIfAlarm(2);\n\n    // NOTE: both of the alarm flags must be clear\n    // to enable output of a FALLING interrupt\n\n    // attach clock interrupt\n    pinMode(CLINT, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(CLINT), isr_TickTock, FALLING);\n\n    // Configure the LED for blinking\n    pinMode(LED_BUILTIN, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // Do when alarm interrupt received:\n    if (tick) {\n        // right away, capture the current time in a DateTime variable\n        // for later processing\n        DateTime alarmDT = RTClib::now();\n\n        // disable Alarm 1 interrupt\n        myRTC.turnOffAlarm(1);\n        \n        // Clear Alarm 1 flag\n        myRTC.checkIfAlarm(1);\n        \n        tick = 0; // reset the local interrupt-received flag\n        state = ~state; // reverse the state of the LED\n        digitalWrite(LED_BUILTIN, state);\n\n        // optional serial output\n        Serial.print(\"Turning LED \");\n        Serial.print((state ? \"ON\" : \"OFF\"));\n        Serial.print(\" at \");\n        Serial.print(alarmDT.hour());\n        Serial.print(\":\");\n        Serial.print(alarmDT.minute());\n        Serial.print(\":\");\n        Serial.println(alarmDT.second());\n\n        // extract the DateTime values as a timestamp \n        uint32_t nextAlarm = alarmDT.unixtime();\n        // add the INT_FREQ number of seconds\n        nextAlarm += INT_FREQ;\n        // update the DateTime with the new timestamp\n        alarmDT = DateTime(nextAlarm);\n\n        // upload the new time to Alarm 1\n       myRTC.setA1Time(\n         alarmDT.day(), alarmDT.hour(), alarmDT.minute(), alarmDT.second(),\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n       \n       // enable Alarm 1 interrupts\n       myRTC.turnOnAlarm(1);\n      // clear Alarm 1 flag again after enabling interrupts\n        myRTC.checkIfAlarm(1);\n    }"
        },
        {
          "name": "isr_TickTock",
          "parameters": "",
          "body": "// interrupt signals to loop\n    tick = 1;\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "callback",
        "wifi",
        "dns",
        "delay",
        "esp.restart",
        "digitalread",
        "debounce",
        "html"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP  \n  Serial.begin(115200);\n  Serial.setDebugOutput(true);  \n  delay(3000);\n  Serial.println(\"\\n Starting\");\n\n  pinMode(TRIGGER_PIN, INPUT);\n  \n  // wm.resetSettings(); // wipe settings\n\n  if(wm_nonblocking) wm.setConfigPortalBlocking(false);\n\n  // add a custom input field\n  int customFieldLength = 40;\n\n\n  // new (&custom_field) WiFiManagerParameter(\"customfieldid\", \"Custom Field Label\", \"Custom Field Value\", customFieldLength,\"placeholder=\\\"Custom Field Placeholder\\\"\");\n  \n  // test custom html input type(checkbox)\n  // new (&custom_field) WiFiManagerParameter(\"customfieldid\", \"Custom Field Label\", \"Custom Field Value\", customFieldLength,\"placeholder=\\\"Custom Field Placeholder\\\" type=\\\"checkbox\\\"\"); // custom html type\n  \n  // test custom html(radio)\n  const char* custom_radio_str = \"<br/><label for='customfieldid'>Custom Field Label</label><input type='radio' name='customfieldid' value='1' checked> One<br><input type='radio' name='customfieldid' value='2'> Two<br><input type='radio' name='customfieldid' value='3'> Three\";\n  new (&custom_field) WiFiManagerParameter(custom_radio_str); // custom html input\n  \n  wm.addParameter(&custom_field);\n  wm.setSaveParamsCallback(saveParamCallback);\n\n  // custom menu via array or vector\n  // \n  // menu tokens, \"wifi\",\"wifinoscan\",\"info\",\"param\",\"close\",\"sep\",\"erase\",\"restart\",\"exit\" (sep is seperator) (if param is in menu, params will not show up in wifi page!)\n  // const char* menu[] = {\"wifi\",\"info\",\"param\",\"sep\",\"restart\",\"exit\"}; \n  // wm.setMenu(menu,6);\n  std::vector<const char *> menu = {\"wifi\",\"info\",\"param\",\"sep\",\"restart\",\"exit\"};\n  wm.setMenu(menu);\n\n  // set dark theme\n  wm.setClass(\"invert\");\n\n\n  //set static ip\n  // wm.setSTAStaticIPConfig(IPAddress(10,0,1,99), IPAddress(10,0,1,1), IPAddress(255,255,255,0)); // set static ip,gw,sn\n  // wm.setShowStaticFields(true); // force show static ip fields\n  // wm.setShowDnsFields(true);    // force show dns field always\n\n  // wm.setConnectTimeout(20); // how long to try to connect for before continuing\n  wm.setConfigPortalTimeout(30); // auto close configportal after n seconds\n  // wm.setCaptivePortalEnable(false); // disable captive portal redirection\n  // wm.setAPClientCheck(true); // avoid timeout if client connected to softap\n\n  // wifi scan settings\n  // wm.setRemoveDuplicateAPs(false); // do not remove duplicate ap names (true)\n  // wm.setMinimumSignalQuality(20);  // set min RSSI (percentage) to show in scans, null = 8%\n  // wm.setShowInfoErase(false);      // do not show erase button on info page\n  // wm.setScanDispPerc(true);       // show RSSI as percentage not graph icons\n  \n  // wm.setBreakAfterConfig(true);   // always exit configportal even if wifi save fails\n\n  bool res;\n  // res = wm.autoConnect(); // auto generated AP name from chipid\n  // res = wm.autoConnect(\"AutoConnectAP\"); // anonymous ap\n  res = wm.autoConnect(\"AutoConnectAP\",\"password\"); // password protected ap\n\n  if(!res) {\n    Serial.println(\"Failed to connect or hit timeout\");\n    // ESP.restart();\n  } \n  else {\n    //if you get here you have connected to the WiFi    \n    Serial.println(\"connected...yeey :)\");\n  }"
        },
        {
          "name": "checkButton",
          "parameters": "",
          "body": "// check for button press\n  if ( digitalRead(TRIGGER_PIN) == LOW ) {\n    // poor mans debounce/press-hold, code not ideal for production\n    delay(50);\n    if( digitalRead(TRIGGER_PIN) == LOW ){\n      Serial.println(\"Button Pressed\");\n      // still holding button for 3000 ms, reset settings, code not ideaa for production\n      delay(3000); // reset delay hold\n      if( digitalRead(TRIGGER_PIN) == LOW ){\n        Serial.println(\"Button Held\");\n        Serial.println(\"Erasing Config, restarting\");\n        wm.resetSettings();\n        ESP.restart();\n      }\n      \n      // start portal w delay\n      Serial.println(\"Starting config portal\");\n      wm.setConfigPortalTimeout(120);\n      \n      if (!wm.startConfigPortal(\"OnDemandAP\",\"password\")) {\n        Serial.println(\"failed to connect or hit timeout\");\n        delay(3000);\n        // ESP.restart();\n      } else {\n        //if you get here you have connected to the WiFi\n        Serial.println(\"connected...yeey :)\");\n      }\n    }\n  }"
        },
        {
          "name": "getParam",
          "parameters": "String name",
          "body": "//read parameter from server, for customhmtl input\n  String value;\n  if(wm.server->hasArg(name)) {\n    value = wm.server->arg(name);\n  }\n  return value;"
        },
        {
          "name": "saveParamCallback",
          "parameters": "",
          "body": "Serial.println(\"[CALLBACK] saveParamCallback fired\");\n  Serial.println(\"PARAM customfieldid = \" + getParam(\"customfieldid\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if(wm_nonblocking) wm.process(); // avoid delays() in loop when non-blocking and other long running code  \n  checkButton();\n  // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "clients"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the Ethernet device\n  Ethernet.begin(ip, subnet, gateway, myDns);\n  // start listening for clients\n  server.begin();\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n\n  Serial.print(\"Chat server address:\");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// wait for a new client:\n  EthernetClient client = server.available();\n\n  // when the client sends the first byte, say hello:\n  if (client) {\n\n    bool newClient = true;\n    for (byte i = 0; i < 4; i++) {\n      //check whether this client refers to the same socket as one of the existing instances:\n      if (clients[i] == client) {\n        newClient = false;\n        break;\n      }\n    }\n\n    if (newClient) {\n      //check which of the existing clients can be overridden:\n      for (byte i = 0; i < 4; i++) {\n        if (!clients[i] && clients[i] != client) {\n          clients[i] = client;\n          // clear out the input buffer:\n          client.flush();\n          Serial.println(\"We have a new client\");\n          client.print(\"Hello, client number: \");\n          client.print(i);\n          client.println();\n          break;\n        }\n      }\n    }\n\n    if (client.available() > 0) {\n      // read the bytes incoming from the client:\n      char thisChar = client.read();\n      // echo the bytes back to all other connected clients:\n      for (byte i = 0; i < 4; i++) {\n        if (clients[i] && (clients[i] != client)) {\n          clients[i].write(thisChar);\n        }\n      }\n      // echo the bytes to the server as well:\n      Serial.write(thisChar);\n    }\n  }\n  for (byte i = 0; i < 4; i++) {\n    if (!(clients[i].connected())) {\n      // client.stop() invalidates the internal socket-descriptor, so next use of == will always return false;\n      clients[i].stop();\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "spi"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "wifi",
        "digitalwrite",
        "millis",
        "delay",
        "led",
        "rgb",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "#define BUFFER_SIZE     512\n\n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h3>running WiFiWebServer</h3>\\\n<h3>on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  server.send(200, F(\"text/html\"), temp);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "digitalWrite(led, 1);\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, F(\"text/plain\"), message);\n\n  digitalWrite(led, 0);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    WS_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n#if (MULTIPLY_FACTOR == 1)\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n#elif (MULTIPLY_FACTOR == 2)\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"610\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"610\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n#elif (MULTIPLY_FACTOR == 4)\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1210\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"1210\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n#endif\n\n  char temp[70];\n\n  int y = rand() % 130;\n\n  for (int x = 10; x < (300 * MULTIPLY_FACTOR); x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += F(\"</g>\\n</svg>\\n\");\n\n  WS_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    WS_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n\n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server.send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//out.reserve(ORIGINAL_STR_LEN);\n\n  pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AdvancedWebServer on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if ! (ESP32 || ESP8266)\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);\n  }\n\n#endif\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n\n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n\n#endif\n\n#if (ESP32 || ESP8266)\n  WiFi.mode(WIFI_STA);\n\n  Serial.print(F(\"Connecting to WPA SSID: \"));\n  Serial.println(ssid);\n\n  if (WiFi.status() != WL_CONNECTED)\n  {\n    if (strlen(pass) >= 8)\n    {\n      WiFi.begin(ssid, pass);\n    }\n    else\n    {\n      WiFi.begin(ssid);\n    }\n  }\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n  }\n\n#else\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    //delay(500);\n    Serial.print(F(\"Connecting to WPA SSID: \"));\n    Serial.println(ssid);\n    // Connect to WPA/WPA2 network\n    status = WiFi.begin(ssid, pass);\n  }\n\n#endif\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "spi",
        "millis",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h3>running EthernetWebServer</h3>\\\n<h3>on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  server.send(200, F(\"text/html\"), temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n  char temp[70];\n\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += F(\"</g>\\n</svg>\\n\");\n\n  ET_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    ET_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n\n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server.send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_ESP32_SPI2 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ETG_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  Serial.println(\"=========================\");\n  Serial.println(\"Currently Used SPI pinout:\");\n  Serial.print(\"MOSI:\");\n  Serial.println(PIN_MOSI);\n  Serial.print(\"MISO:\");\n  Serial.println(PIN_MISO);\n  Serial.print(\"SCK:\");\n  Serial.println(PIN_SCK);\n  Serial.print(\"SS:\");\n  Serial.println(USE_THIS_SS_PIN);\n  Serial.println(F(\"=========================\"));\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  if (Ethernet.getChip() == w5500)\n  {\n    Serial.print(F(\"Speed: \"));\n    Serial.print(Ethernet.speedReport());\n    Serial.print(F(\", Duplex: \"));\n    Serial.print(Ethernet.duplexReport());\n    Serial.print(F(\", Link status: \"));\n    Serial.println(Ethernet.linkReport());\n  }\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "digitalwrite",
        "millis",
        "delay",
        "led",
        "rgb",
        "flash",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "digitalWrite(led, 1);\n\n#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AdvancedWebServer %s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>Hi from EthernetWebServer!</h2>\\\n<h3>on %s using LAN8720</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, day, hr % 24, min % 60, sec % 60);\n\n  server.send(200, \"text/html\", temp);\n\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += server.uri();\n  message += \"\\nMethod: \";\n  message += (server.method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += server.args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, \"text/plain\", message);\n  digitalWrite(led, 0);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n  char temp[70];\n  \n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n  \n  out += F(\"</g>\\n</svg>\\n\");\n\n  ET_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    ET_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n    \n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server.send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  \n  delay(2000);\n \n  Serial.println(\"\\nStart AdvancedWebServer_LAN8720 on \" + String(BOARD_NAME) + \", using \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n  \n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  server.on(\"/\", handleRoot);\n  server.on(\"/test.svg\", drawGraph);\n  server.on(\"/inline\", []()\n  {\n    server.send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "spi",
        "millis",
        "delay",
        "digitalwrite",
        "rgb",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h3>running EthernetWebServer</h3>\\\n<h3>on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  server->send(200, F(\"text/html\"), temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server->uri();\n  message += F(\"\\nMethod: \");\n  message += (server->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server->args(); i++)\n  {\n    message += \" \" + server->argName(i) + \": \" + server->arg(i) + \"\\n\";\n  }\n\n  server->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n  char temp[70];\n\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += F(\"</g>\\n</svg>\\n\");\n\n  ET_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    ET_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n\n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server->send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "SerialDebug.begin(115200);\n\n  while (!SerialDebug && millis() < 5000);\n\n  delay(1000);\n\n  SerialDebug.print(\"\\nStarting AdvancedWebServer_Ptr on \");\n  SerialDebug.print(BOARD_NAME);\n  SerialDebug.print(F(\" with \"));\n  SerialDebug.println(SHIELD_TYPE);\n  SerialDebug.println(ETHERNET_WEBSERVER_VERSION);\n\n#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    SerialDebug.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware\n    }\n  }\n\n  if (Ethernet.linkStatus() == LinkOFF)\n  {\n    SerialDebug.println(\"Not connected Ethernet cable\");\n  }\n\n#endif\n\n  SerialDebug.print(F(\"Using mac index = \"));\n  SerialDebug.println(index);\n\n  SerialDebug.print(F(\"Connected! IP address: \"));\n  SerialDebug.println(Ethernet.localIP());\n\n  server = new EthernetWebServer(WEBSERVER_PORT);\n\n  server->on(F(\"/\"), handleRoot);\n  server->on(F(\"/test.svg\"), drawGraph);\n  server->on(F(\"/inline\"), []()\n  {\n    server->send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server->onNotFound(handleNotFound);\n  server->begin();\n\n  SerialDebug.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  SerialDebug.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  SerialDebug.print(F(\".\"));\n\n  if (num == 80)\n  {\n    SerialDebug.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    SerialDebug.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server->handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "spi",
        "millis",
        "digitalwrite",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h3>running EthernetWebServer on custom SPI</h3>\\\n<h3>on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  server.send(200, F(\"text/html\"), temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n  char temp[70];\n\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += F(\"</g>\\n</svg>\\n\");\n\n  ET_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    ET_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n\n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server.send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    Serial.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware\n    }\n  }\n\n  if (Ethernet.linkStatus() == LinkOFF)\n  {\n    Serial.println(\"Not connected Ethernet cable\");\n  }\n\n#endif\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_RP2040_SPI1 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "wifi",
        "digitalwrite",
        "millis",
        "led",
        "rgb",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "#define BUFFER_SIZE     512\n  \n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf_P(temp, BUFFER_SIZE - 1,\n           PSTR(\"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h3>running AdvancedWebServer_STM32</h3>\\\n<h3>on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\"), BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  server.send(200, F(\"text/html\"), temp);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "digitalWrite(led, 1);\n  \n  String message = F(\"File Not Found\\n\\n\");\n  \n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n  \n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n  \n  server.send(404, F(\"text/plain\"), message);\n  \n  digitalWrite(led, 0);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    AT_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n  char temp[70];\n  \n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n  \n  out += F(\"</g>\\n</svg>\\n\");\n\n  AT_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    AT_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n    \n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server.send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n  \n  Serial.print(F(\"\\nStarting AdvancedWebServer_STM32 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE); \n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  }\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    Serial.print(F(\"Connecting to WPA SSID: \"));\n    Serial.println(ssid);\n    // Connect to WPA/WPA2 network\n    status = WiFi.begin(ssid, pass);\n  }\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n  server.begin();\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "spi",
        "millis",
        "digitalwrite",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h3>running EthernetWebServer on custom SPI</h3>\\\n<h3>on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  server.send(200, F(\"text/html\"), temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n  char temp[70];\n\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += F(\"</g>\\n</svg>\\n\");\n\n  ET_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    ET_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n\n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server.send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    Serial.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware\n    }\n  }\n\n  if (Ethernet.linkStatus() == LinkOFF)\n  {\n    Serial.println(\"Not connected Ethernet cable\");\n  }\n\n#endif\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_Teensy4x_SPI1 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "wifi",
        "digitalwrite",
        "millis",
        "delay",
        "led",
        "rgb",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "isWiFiConnected",
          "parameters": "",
          "body": "// You can change longer or shorter depending on your network response\n  // Shorter => more responsive, but more ping traffic\n  static uint8_t theTTL = 10;\n\n  // Use ping() to test TCP connections\n  if (WiFi.ping(WiFi.gatewayIP(), theTTL) == theTTL)\n  {\n    WFM_LOGINFO1(\"Client connected, Local IP = \", WiFi.localIP());\n    WiFiConnected = true;\n\n    return true;\n  }\n\n  WFM_LOGINFO1(\"Connection failed. Local IP = \", WiFi.localIP());\n  WiFiConnected = false;\n\n  return false;"
        },
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "#define BUFFER_SIZE     512\n\n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h3>running WiFiWebServer WiFiMulti</h3>\\\n<h3>on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  server.send(200, F(\"text/html\"), temp);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "digitalWrite(led, 1);\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, F(\"text/plain\"), message);\n\n  digitalWrite(led, 0);"
        },
        {
          "name": "drawGraph",
          "parameters": "",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    WS_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);\n  }\n\n  out = F( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\" \\\n           \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"3\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\" \\\n           \"<g stroke=\\\"blue\\\">\\n\");\n\n  char temp[70];\n\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += F(\"</g>\\n</svg>\\n\");\n\n  WS_LOGDEBUG1(F(\"String Len = \"), out.length());\n\n  if (out.length() > previousStrLen)\n  {\n    WS_LOGERROR3(F(\"String Len > \"), previousStrLen, F(\", extend to\"), out.length() + 48);\n\n    previousStrLen = out.length() + 48;\n\n    out.reserve(previousStrLen);\n  }\n  else\n  {\n    server.send(200, \"image/svg+xml\", out);\n  }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "#if ( defined(ARDUINO_PORTENTA_H7_M7) || defined(ARDUINO_PORTENTA_H7_M4) )\n\n  // Workaround for bug in https://github.com/arduino/ArduinoCore-mbed/issues/381\n  if ( (WiFi.status() != WL_CONNECTED) || (WiFi.RSSI() == 0) )\n#elif ( defined(ARDUINO_RASPBERRY_PI_PICO_W) )\n  if (!isWiFiConnected())\n#else\n  if ( (WiFi.status() != WL_CONNECTED) )\n#endif\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AdvancedWebServer_WiFiMulti on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFIMULTI_GENERIC_VERSION);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if ! (ESP32 || ESP8266)\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);\n  }\n\n#endif\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n\n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n\n#endif\n\n  wifiMulti.addAP(your_ssid1, your_pass1);\n  wifiMulti.addAP(your_ssid2, your_pass2);\n  //wifiMulti.addAP(\"ssid_from_AP_1\", \"your_password_for_AP_1\");\n  //wifiMulti.addAP(\"ssid_from_AP_2\", \"your_password_for_AP_2\");\n  //wifiMulti.addAP(\"ssid_from_AP_3\", \"your_password_for_AP_3\");\n\n  Serial.println(\"Connecting WiFi...\");\n\n  if (wifiMulti.run() == WL_CONNECTED)\n  {\n    Serial.print(\"\\nWiFi connected, IP address: \");\n    Serial.println(WiFi.localIP());\n  }\n\n  // you're connected now, so print out the data\n  printWifiStatus();\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n\n  if (WiFiConnected)\n#else\n  if (WiFi.status() == WL_CONNECTED)\n#endif\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static uint32_t checkstatus_timeout  = 0;\n  static uint32_t checkwifi_timeout    = 0;\n\n  static uint32_t current_millis;\n\n#if ( defined(ARDUINO_RASPBERRY_PI_PICO_W) )\n#define WIFICHECK_INTERVAL    10000L\n#else\n#define WIFICHECK_INTERVAL    1000L\n#endif\n\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n#if defined(CONFIG_PLATFORM_8721D)\n  // Important delay() for RTL8720DN\n  delay(200);\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "wifi",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Checking Connection\");\n  if (WifiConnection::isConnected()) {\n    \n    float averageTemperture = storage.avg(\"today_temperture_samples\");\n    float highestTemperture = storage.max<float>(\"today_temperture_samples\");\n    float lowestTemperture = storage.min<float>(\"today_temperture_samples\");\n    int numSamples = storage.count(\"today_temperture_samples\");\n\n    Serial.print(\"Today's tempertures ranged from \");\n    Serial.print(lowestTemperture); \n    Serial.print(\" degrees to \");\n    Serial.print(highestTemperture);\n    Serial.println(\" degrees celsius.\");\n\n    Serial.print(\"With the average \");\n    Serial.print(averageTemperture);\n    Serial.println(\" degrees celsius.\");\n\n    Serial.print(\"Total of \");\n    Serial.print(numSamples);\n    Serial.println(\" samples.\");\n\n  } else {\n    Serial.println(\"No Connection\");\n  }\n\n  delay(5 * 1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "callback",
        "pm10",
        "wifi",
        "millis",
        "delay",
        "nodebug_websockets",
        "device_id"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "SinricPro_Generic.h",
        "SinricProAirQualitySensor.h"
      ],
      "functions": [
        {
          "name": "setupWiFi",
          "parameters": "",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);\n  }\n  \n  Serial.print(\"\\n[WiFi]: IP-Address is \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "setupSinricPro",
          "parameters": "",
          "body": "// add device to SinricPro\n  SinricProAirQualitySensor& mySinricProAirQualitySensor = SinricPro[DEVICE_ID];\n\n  // set callback function to device\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");\n  });\n  \n  SinricPro.onDisconnected([]() \n  {\n    Serial.println(\"Disconnected from SinricPro\");\n  });\n  \n  SinricPro.begin(APP_KEY, APP_SECRET);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting AirQualitySensor on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SinricPro.handle();\n\n  if ((long)(millis() - dispatchTime) >= 0) \n  {\n    SinricProAirQualitySensor &mySinricProAirQualitySensor = SinricPro[DEVICE_ID]; // get sensor device\n\n    int pm1   = 0;\n    int pm2_5 = 0;\n    int pm10  = 0;\n\n    mySinricProAirQualitySensor.sendAirQualityEvent(pm1, pm2_5, pm10, \"PERIODIC_POLL\");\n    dispatchTime += MIN;\n    \n    Serial.println(\"Sending Air Quality event ..\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "callback",
        "voltage",
        "pm10",
        "wifi",
        "millis",
        "delay",
        "nodebug_websockets",
        "device_id"
      ],
      "libraries": [
        "GP2YDustSensor.h",
        "ESP8266WiFi.h",
        "WiFi.h",
        "SinricPro_Generic.h",
        "SinricProAirQualitySensor.h"
      ],
      "functions": [
        {
          "name": "setupWiFi",
          "parameters": "",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);\n  }\n  \n  Serial.print(\"\\n[WiFi]: IP-Address is \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "setupSinricPro",
          "parameters": "",
          "body": "// add device to SinricPro\n  SinricProAirQualitySensor& mySinricProAirQualitySensor = SinricPro[DEVICE_ID];\n\n  // set callback function to device\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");\n  });\n  \n  SinricPro.onDisconnected([]() \n  {\n    Serial.println(\"Disconnected from SinricPro\");\n  });\n  \n  SinricPro.begin(APP_KEY, APP_SECRET);"
        },
        {
          "name": "setupDustSensor",
          "parameters": "",
          "body": "//dustSensor.setBaseline(0.4); // set no dust voltage according to your own experiments\n  //dustSensor.setCalibrationFactor(1.1); // calibrate against precision instrument\n  dustSensor.begin();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting AirQualitySensor_GP2Y1014AU0F on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SinricPro.handle();\n\n  if ((long)(millis() - dispatchTime) >= 0) \n  {\n    Serial.print(\"Dust density: \");\n    Serial.print(dustSensor.getDustDensity());\n    Serial.print(\" ug/m3; Running average: \");\n    Serial.print(dustSensor.getRunningAverage());\n    Serial.println(\" ug/m3\");\n\n    SinricProAirQualitySensor &mySinricProAirQualitySensor = SinricPro[DEVICE_ID]; // get air q sensor device\n\n    int pm1 = 0;\n    int pm2_5 = dustSensor.getRunningAverage();\n    int pm10 = 0;\n\n    mySinricProAirQualitySensor.sendAirQualityEvent(pm1, pm2_5, pm10, \"PERIODIC_POLL\");\n    dispatchTime += MIN;\n\n    Serial.println(\"Sending Air Quality event ..\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "dht22",
        "soil",
        "moisture",
        "ph",
        "temperature",
        "wifi",
        "delay",
        "analogread",
        "digitalwrite"
      ],
      "libraries": [
        "Wire.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  pinMode(heaterPin, OUTPUT);\n  pinMode(fanPin, OUTPUT);\n  pinMode(soilMoisturePin, INPUT);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  dhtSensor.begin();\n  \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.println(\"Connecting to WiFi...\");\n  }\n\n  Serial.println(\"Connected to WiFi\");\n  Serial.print(\"Alamat IP: \");\n  Serial.println(WiFi.localIP());\n\n  net_ssl.setCACert(TELEGRAM_CERTIFICATE_ROOT);\n\n  bot.sendMessage(CHAT_ID, \"Bot telah diaktifkan dan siap menerima perintah. Ketik /start untuk melihat perintah yang tersedia.\", \"\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Baca kelembapan tanah\n  int soilMoistureValue = analogRead(soilMoisturePin);\n  Serial.print(\"Soil Moisture Value: \");\n  Serial.println(soilMoistureValue);\n\n  // Tentukan kondisi kelembapan tanah\n  String soilCondition;\n  float soil_ph = 7.0; // Default nilai pH netral\n  if (soilMoistureValue < 300) {\n    soilCondition = \"Dry\";\n    soil_ph += 0.5; // Menambahkan 0.5 untuk kondisi tanah kering\n  } else if (soilMoistureValue >= 300 && soilMoistureValue < 700) {\n    soilCondition = \"Moist\";\n    // Nilai pH tetap netral\n  } else {\n    soilCondition = \"Wet\";\n    soil_ph -= 0.5; // Mengurangi 0.5 untuk kondisi tanah basah\n  }\n  Serial.print(\"Soil Condition: \");\n  Serial.println(soilCondition);\n  Serial.print(\"Adjusted Soil pH: \");\n  Serial.println(soil_ph, 1);\n\n  float temperature = readTemperature();\n  if (isnan(temperature)) {\n    Serial.println(\"Failed to read from DHT sensor!\");\n    return;\n  }\n\n  Serial.print(\"Temperature: \");\n  Serial.print(temperature);\n  Serial.println(\"°C\");\n\n  if (temperature < 40.0) { // Set point temperature to turn on the heater\n    digitalWrite(heaterPin, LOW);\n    bot.sendMessage(CHAT_ID, \"Suhu terlalu rendah! Pemanas dinyalakan.\", \"\");\n  } else if (temperature >= 40.0) { // Set point temperature to turn off the heater\n    digitalWrite(heaterPin, HIGH);\n    bot.sendMessage(CHAT_ID, \"Suhu cukup hangat. Pemanas dimatikan.\", \"\");\n  }\n\n  // Periksa pesan dari bot\n  int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n  while (numNewMessages) {\n    Serial.println(\"Got response\");\n    handAKMMes(numNewMessages, soil_ph, temperature);\n    numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n  }"
        },
        {
          "name": "readTemperature",
          "parameters": "",
          "body": "return dhtSensor.readTemperature();"
        },
        {
          "name": "handAKMMes",
          "parameters": "int numNewMessages, float pH, float temperature",
          "body": "for (int i = 0; i < numNewMessages; i++) {\n    String chat_id = String(bot.messages[i].chat_id);\n    String text = bot.messages[i].text;\n\n    if (text == \"/start@AkseleratorHumanisasiKomposBot\") {\n      String welcome_message = \n          \"Selamat datang di grup! Berikut adalah perintah yang tersedia:\\n\"\n          \"/kondisi - Menampilkan kondisi suhu dan pH saat ini\\n\"\n          \"/on - Menyalakan pemanas\\n\";\n      bot.sendMessage(chat_id, welcome_message, \"\");\n    }else if (text == \"/start\") {\n      String welcome_message = \n          \"Selamat datang di grup! Berikut adalah perintah yang tersedia:\\n\"\n          \"/kondisi - Menampilkan kondisi suhu dan pH saat ini\\n\"\n          \"/on - Menyalakan pemanas\\n\";\n      bot.sendMessage(chat_id, welcome_message, \"\");\n    }else if (text == \"/kondisi\") {\n      String kondisi_suhu = (temperature > 40.0) ? \"Terlalu panas\" : (temperature < 20.0) ? \"Terlalu dingin\" : \"Normal\";\n      String kondisi_pH = (pH < 7) ? \"Asam\" : (pH > 7) ? \"Basa\" : \"Netral\";\n      String response = \"Kondisi suhu terkini: \" + kondisi_suhu + \"\\n\"\n                        \"Kondisi suhu: \" + String(temperature) + \"°C\\n\"\n                        \"Kondisi pH: \" + String(pH) + \"\\n\";\n      bot.sendMessage(chat_id, response, \"\");\n    } else if (text == \"/kondisi@AkseleratorHumanisasiKomposBot\") {\n      String kondisi_suhu = (temperature > 40.0) ? \"Terlalu panas\" : (temperature < 20.0) ? \"Terlalu dingin\" : \"Normal\";\n      String kondisi_pH = (pH < 7) ? \"Asam\" : (pH > 7) ? \"Basa\" : \"Netral\";\n      String response = \"Kondisi suhu terkini: \" + kondisi_suhu + \"\\n\"\n                        \"Kondisi suhu: \" + String(temperature) + \"°C\\n\"\n                        \"Kondisi pH: \" + String(pH) + \"\\n\";\n      bot.sendMessage(chat_id, response, \"\");\n    }else if (text == \"/on\") {\n      digitalWrite(heaterPin, LOW);\n      bot.sendMessage(chat_id, \"Pemanas dinyalakan!\", \"\");\n    }\n    else if (text == \"/off\") {\n      digitalWrite(heaterPin, HIGH);\n      bot.sendMessage(chat_id, \"Pemanas dimatikan!\", \"\");\n    }\n    else if (text == \"/on@AkseleratorHumanisasiKomposBot\") {\n      digitalWrite(heaterPin, LOW);\n      bot.sendMessage(chat_id, \"Pemanas dinyalakan!\", \"\");\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "i2c",
        "digitalwrite",
        "delay",
        "led",
        "interrupt"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Begin Serial communication\n    Serial.begin(9600);\n    while (!Serial);\n    Serial.println();\n    Serial.println(\"Starting Serial\");\n\n    // Assign parameter values for Alarm 1\n    alarmDay = 0;\n    alarmHour = 0;\n    alarmMinute = 0;\n    alarmSecond = 0;\n    alarmBits = 0b00001111; // Alarm 1 every second\n    alarmDayIsDay = false;\n    alarmH12 = false;\n    alarmPM = false;    \n\n    // Set alarm 1 to fire at one-second intervals\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(\n       alarmDay, alarmHour, alarmMinute, alarmSecond,\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // enable Alarm 1 interrupts\n    myRTC.turnOnAlarm(1);\n    // clear Alarm 1 flag\n    myRTC.checkIfAlarm(1);\n\n    // When using interrupt with only one of the DS3231 alarms, as in this example,\n    // it may be advisable to prevent the other alarm entirely,\n    // so it will not covertly block the outgoing interrupt signal.\n\n    // Prevent Alarm 2 altogether by assigning a \n    // nonsensical alarm minute value that cannot match the clock time,\n    // and an alarmBits value to activate \"when minutes match\".\n    alarmMinute = 0xFF; // a value that will never match the time\n    alarmBits = 0b01100000; // Alarm 2 when minutes match, i.e., never\n    \n    // Upload the parameters to prevent Alarm 2 entirely\n    myRTC.setA2Time(\n        alarmDay, alarmHour, alarmMinute,\n        alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // disable Alarm 2 interrupt\n    myRTC.turnOffAlarm(2);\n    // clear Alarm 2 flag\n    myRTC.checkIfAlarm(2);\n\n    // NOTE: both of the alarm flags must be clear\n    // to enable output of a FALLING interrupt\n\n    // attach clock interrupt\n    pinMode(CLINT, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(CLINT), isr_TickTock, FALLING);\n\n    // Use builtin LED to blink\n    pinMode(LED_BUILTIN, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // if alarm went of, do alarm stuff\n    if (tick) {\n        tick = 0;\n        state = ~state;\n        digitalWrite(LED_BUILTIN, state);\n\n        // optional serial output\n        Serial.print(\"Turning LED \");\n        Serial.println((state ? \"ON\" : \"OFF\"));\n\n        // Clear Alarm 1 flag\n        myRTC.checkIfAlarm(1);\n    }\n\n    // Loop delay to emulate other running code\n    delay(10);"
        },
        {
          "name": "isr_TickTock",
          "parameters": "",
          "body": "// interrupt signals to loop\n    tick = 1;\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "i2c",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Setup alarm one to fire every second\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(0, 0, 0, 0, 0b01111111, false, false, false);\n    myRTC.turnOnAlarm(1);\n    myRTC.checkIfAlarm(1);\n\n    // Use builtin LED to blink\n    pinMode(LED_BUILTIN, OUTPUT);\n    digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // if alarm went of, do alarm stuff\n    // first call to checkIFAlarm does not clear alarm flag\n    if (myRTC.checkIfAlarm(1, false)) {\n        state = ~state;\n        digitalWrite(LED_BUILTIN, state);\n        // Clear alarm state\n        myRTC.checkIfAlarm(1, true);\n    }\n\n    // Loop delay to emulate other running code\n    delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "ssl",
        "password",
        "stream",
        "power",
        "current",
        "voltage",
        "temperature",
        "gsm",
        "gprs",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "tone"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h",
        "StreamDebugger.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // !!!!!!!!!!!\n  // Set your reset, enable, power pins here\n  // !!!!!!!!!!!\n\n  DBG(\"Wait...\");\n  delay(6000L);\n\n  // Set GSM module baud rate\n  TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n  // SerialAT.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  DBG(\"Initializing modem...\");\n  if (!modem.restart()) {\n    // if (!modem.init()) {\n    DBG(\"Failed to restart modem, delaying 10s and retrying\");\n    // restart autobaud in case GSM just rebooted\n    // TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n    return;\n  }\n\n  String modemInfo = modem.getModemInfo();\n  DBG(\"Modem Info:\", modemInfo);\n\n  String name = modem.getModemName();\n  DBG(\"Modem Name:\", name);\n\n  String manufacturer = modem.getModemManufacturer();\n  DBG(\"Modem Manufacturer:\", manufacturer);\n\n  String hw_ver = modem.getModemModel();\n  DBG(\"Modem Hardware Version:\", hw_ver);\n\n  String fv_ver = modem.getModemRevision();\n  DBG(\"Modem Firware Version:\", fv_ver);\n\n#if not defined(TINY_GSM_MODEM_ESP8266) && not defined(TINY_GSM_MODEM_ESP32)\n  String mod_sn = modem.getModemSerialNumber();\n  DBG(\"Modem Serial Number (may be SIM CCID):\", mod_sn);\n#endif\n\n#if TINY_GSM_TEST_GPRS\n  // Unlock your SIM card with a PIN if needed\n  if (GSM_PIN && modem.getSimStatus() != 3) { modem.simUnlock(GSM_PIN); }\n#endif\n\n#if TINY_GSM_TEST_WIFI && defined(TINY_GSM_MODEM_HAS_WIFI)\n  DBG(\"Setting SSID/password...\");\n  if (!modem.networkConnect(wifiSSID, wifiPass)) {\n    DBG(\" fail\");\n    delay(10000);\n    return;\n  }\n  SerialMon.println(\" success\");\n#endif\n\n#if TINY_GSM_TEST_GPRS && defined(TINY_GSM_MODEM_XBEE)\n  // The XBee must run the gprsConnect function BEFORE waiting for network!\n  modem.gprsConnect(apn, gprsUser, gprsPass);\n#endif\n\n  DBG(\"Waiting for network...\");\n  if (!modem.waitForNetwork(600000L, true)) {\n    delay(10000);\n    return;\n  }\n\n  if (modem.isNetworkConnected()) { DBG(\"Network connected\"); }\n\n#if TINY_GSM_TEST_GPRS\n  DBG(\"Connecting to\", apn);\n  if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {\n    delay(10000);\n    return;\n  }\n\n  bool res = modem.isGprsConnected();\n  DBG(\"GPRS status:\", res ? \"connected\" : \"not connected\");\n\n  String ccid = modem.getSimCCID();\n  DBG(\"CCID:\", ccid);\n\n  String imei = modem.getIMEI();\n  DBG(\"IMEI:\", imei);\n\n  String imsi = modem.getIMSI();\n  DBG(\"IMSI:\", imsi);\n\n  String cop = modem.getOperator();\n  DBG(\"Operator:\", cop);\n\n  // String prov = modem.getProvider();\n  // DBG(\"Provider:\", prov);\n\n  IPAddress local = modem.localIP();\n  DBG(\"Local IP:\", local);\n\n  int csq = modem.getSignalQuality();\n  DBG(\"Signal quality:\", csq);\n#endif\n\n#if TINY_GSM_TEST_USSD && defined TINY_GSM_MODEM_HAS_SMS\n  String ussd_balance = modem.sendUSSD(\"*111#\");\n  DBG(\"Balance (USSD):\", ussd_balance);\n\n  String ussd_phone_num = modem.sendUSSD(\"*161#\");\n  DBG(\"Phone number (USSD):\", ussd_phone_num);\n#endif\n\n#if TINY_GSM_TEST_TCP && defined TINY_GSM_MODEM_HAS_TCP\n  TinyGsmClient client(modem, 0);\n  const int     port = 80;\n  DBG(\"Connecting to\", server);\n  if (!client.connect(server, port)) {\n    DBG(\"... failed\");\n  } else {\n    // Make a HTTP GET request:\n    client.print(String(\"GET \") + resource + \" HTTP/1.0\\r\\n\");\n    client.print(String(\"Host: \") + server + \"\\r\\n\");\n    client.print(\"Connection: close\\r\\n\\r\\n\");\n\n    // Wait for data to arrive\n    uint32_t start = millis();\n    while (client.connected() && !client.available() &&\n           millis() - start < 30000L) {\n      delay(100);\n    };\n\n    // Read data\n    start          = millis();\n    char logo[640] = {\n        '\\0',\n    };\n    int read_chars = 0;\n    while (client.connected() && millis() - start < 10000L) {\n      while (client.available()) {\n        logo[read_chars]     = client.read();\n        logo[read_chars + 1] = '\\0';\n        read_chars++;\n        start = millis();\n      }\n    }\n    SerialMon.println(logo);\n    DBG(\"#####  RECEIVED:\", strlen(logo), \"CHARACTERS\");\n    client.stop();\n  }\n#endif\n\n#if TINY_GSM_TEST_SSL && defined TINY_GSM_MODEM_HAS_SSL\n  // TODO: Add test of adding certificcate\n  TinyGsmClientSecure secureClient(modem, 1);\n  const int           securePort = 443;\n  DBG(\"Connecting securely to\", server);\n  if (!secureClient.connect(server, securePort)) {\n    DBG(\"... failed\");\n  } else {\n    // Make a HTTP GET request:\n    secureClient.print(String(\"GET \") + resource + \" HTTP/1.0\\r\\n\");\n    secureClient.print(String(\"Host: \") + server + \"\\r\\n\");\n    secureClient.print(\"Connection: close\\r\\n\\r\\n\");\n\n    // Wait for data to arrive\n    uint32_t startS = millis();\n    while (secureClient.connected() && !secureClient.available() &&\n           millis() - startS < 30000L) {\n      delay(100);\n    };\n\n    // Read data\n    startS          = millis();\n    char logoS[640] = {\n        '\\0',\n    };\n    int read_charsS = 0;\n    while (secureClient.connected() && millis() - startS < 10000L) {\n      while (secureClient.available()) {\n        logoS[read_charsS]     = secureClient.read();\n        logoS[read_charsS + 1] = '\\0';\n        read_charsS++;\n        startS = millis();\n      }\n    }\n    SerialMon.println(logoS);\n    DBG(\"#####  RECEIVED:\", strlen(logoS), \"CHARACTERS\");\n    secureClient.stop();\n  }\n#endif\n\n#if TINY_GSM_TEST_CALL && defined(TINY_GSM_MODEM_HAS_CALLING) && \\\n    defined(CALL_TARGET)\n  DBG(\"Calling:\", CALL_TARGET);\n\n  // This is NOT supported on M590\n  res = modem.callNumber(CALL_TARGET);\n  DBG(\"Call:\", res ? \"OK\" : \"fail\");\n\n  if (res) {\n    delay(1000L);\n\n    // Play DTMF A, duration 1000ms\n    modem.dtmfSend('A', 1000);\n\n    // Play DTMF 0..4, default duration (100ms)\n    for (char tone = '0'; tone <= '4'; tone++) { modem.dtmfSend(tone); }\n\n    delay(5000);\n\n    res = modem.callHangup();\n    DBG(\"Hang up:\", res ? \"OK\" : \"fail\");\n  }\n#endif\n\n// Test the SMS functions\n#if TINY_GSM_TEST_SMS && defined TINY_GSM_MODEM_HAS_SMS && defined SMS_TARGET\n  res = modem.sendSMS(SMS_TARGET, String(\"Hello from \") + imei);\n  DBG(\"SMS:\", res ? \"OK\" : \"fail\");\n\n  // This is only supported on SIMxxx series\n  res = modem.sendSMS_UTF8_begin(SMS_TARGET);\n  if (res) {\n    auto stream = modem.sendSMS_UTF8_stream();\n    stream.print(F(\"Привіііт! Print number: \"));\n    stream.print(595);\n    res = modem.sendSMS_UTF8_end();\n  }\n  DBG(\"UTF8 SMS:\", res ? \"OK\" : \"fail\");\n\n#endif\n\n// Test the GSM location functions\n#if TINY_GSM_TEST_GSM_LOCATION && defined TINY_GSM_MODEM_HAS_GSM_LOCATION\n  float gsm_latitude  = 0;\n  float gsm_longitude = 0;\n  float gsm_accuracy  = 0;\n  int   gsm_year      = 0;\n  int   gsm_month     = 0;\n  int   gsm_day       = 0;\n  int   gsm_hour      = 0;\n  int   gsm_minute    = 0;\n  int   gsm_second    = 0;\n  for (int8_t i = 15; i; i--) {\n    DBG(\"Requesting current GSM location\");\n    if (modem.getGsmLocation(&gsm_latitude, &gsm_longitude, &gsm_accuracy,\n                             &gsm_year, &gsm_month, &gsm_day, &gsm_hour,\n                             &gsm_minute, &gsm_second)) {\n      DBG(\"Latitude:\", String(gsm_latitude, 8),\n          \"\\tLongitude:\", String(gsm_longitude, 8));\n      DBG(\"Accuracy:\", gsm_accuracy);\n      DBG(\"Year:\", gsm_year, \"\\tMonth:\", gsm_month, \"\\tDay:\", gsm_day);\n      DBG(\"Hour:\", gsm_hour, \"\\tMinute:\", gsm_minute, \"\\tSecond:\", gsm_second);\n      break;\n    } else {\n      DBG(\"Couldn't get GSM location, retrying in 15s.\");\n      delay(15000L);\n    }\n  }\n  DBG(\"Retrieving GSM location again as a string\");\n  String location = modem.getGsmLocation();\n  DBG(\"GSM Based Location String:\", location);\n#endif\n\n// Test the GPS functions\n#if TINY_GSM_TEST_GPS && defined TINY_GSM_MODEM_HAS_GPS\n  DBG(\"Enabling GPS/GNSS/GLONASS and waiting 15s for warm-up\");\n#if !defined(TINY_GSM_MODEM_SARAR5)  // not needed for this module\n  modem.enableGPS();\n#endif\n  delay(15000L);\n  float gps_latitude  = 0;\n  float gps_longitude = 0;\n  float gps_speed     = 0;\n  float gps_altitude  = 0;\n  int   gps_vsat      = 0;\n  int   gps_usat      = 0;\n  float gps_accuracy  = 0;\n  int   gps_year      = 0;\n  int   gps_month     = 0;\n  int   gps_day       = 0;\n  int   gps_hour      = 0;\n  int   gps_minute    = 0;\n  int   gps_second    = 0;\n  for (int8_t i = 15; i; i--) {\n    DBG(\"Requesting current GPS/GNSS/GLONASS location\");\n    if (modem.getGPS(&gps_latitude, &gps_longitude, &gps_speed, &gps_altitude,\n                     &gps_vsat, &gps_usat, &gps_accuracy, &gps_year, &gps_month,\n                     &gps_day, &gps_hour, &gps_minute, &gps_second)) {\n      DBG(\"Latitude:\", String(gps_latitude, 8),\n          \"\\tLongitude:\", String(gps_longitude, 8));\n      DBG(\"Speed:\", gps_speed, \"\\tAltitude:\", gps_altitude);\n      DBG(\"Visible Satellites:\", gps_vsat, \"\\tUsed Satellites:\", gps_usat);\n      DBG(\"Accuracy:\", gps_accuracy);\n      DBG(\"Year:\", gps_year, \"\\tMonth:\", gps_month, \"\\tDay:\", gps_day);\n      DBG(\"Hour:\", gps_hour, \"\\tMinute:\", gps_minute, \"\\tSecond:\", gps_second);\n      break;\n    } else {\n      DBG(\"Couldn't get GPS/GNSS/GLONASS location, retrying in 15s.\");\n      delay(15000L);\n    }\n  }\n  DBG(\"Retrieving GPS/GNSS/GLONASS location again as a string\");\n  String gps_raw = modem.getGPSraw();\n#if !defined(TINY_GSM_MODEM_SARAR5)  // not available for this module\n  DBG(\"GPS/GNSS Based Location String:\", gps_raw);\n  DBG(\"Disabling GPS\");\n  modem.disableGPS();\n#endif\n#endif\n\n// Test the Network time functions\n#if TINY_GSM_TEST_NTP && defined TINY_GSM_MODEM_HAS_NTP\n  DBG(\"Asking modem to sync with NTP\");\n  modem.NTPServerSync(\"pool.ntp.org\", 20);\n#endif\n\n#if TINY_GSM_TEST_TIME && defined TINY_GSM_MODEM_HAS_TIME\n  int   ntp_year     = 0;\n  int   ntp_month    = 0;\n  int   ntp_day      = 0;\n  int   ntp_hour     = 0;\n  int   ntp_min      = 0;\n  int   ntp_sec      = 0;\n  float ntp_timezone = 0;\n  for (int8_t i = 5; i; i--) {\n    DBG(\"Requesting current network time\");\n    if (modem.getNetworkTime(&ntp_year, &ntp_month, &ntp_day, &ntp_hour,\n                             &ntp_min, &ntp_sec, &ntp_timezone)) {\n      DBG(\"Year:\", ntp_year, \"\\tMonth:\", ntp_month, \"\\tDay:\", ntp_day);\n      DBG(\"Hour:\", ntp_hour, \"\\tMinute:\", ntp_min, \"\\tSecond:\", ntp_sec);\n      DBG(\"Timezone:\", ntp_timezone);\n      break;\n    } else {\n      DBG(\"Couldn't get network time, retrying in 15s.\");\n      delay(15000L);\n    }\n  }\n  DBG(\"Retrieving time again as a string\");\n  String time = modem.getGSMDateTime(DATE_FULL);\n  DBG(\"Current Network Time:\", time);\n#endif\n\n// Test Battery functions\n#if TINY_GSM_TEST_BATTERY && defined TINY_GSM_MODEM_HAS_BATTERY\n  int8_t  chargeState   = -99;\n  int8_t  chargePercent = -99;\n  int16_t milliVolts    = -9999;\n  modem.getBattStats(chargeState, chargePercent, milliVolts);\n  DBG(\"Battery charge state:\", chargeState);\n  DBG(\"Battery charge 'percent':\", chargePercent);\n  DBG(\"Battery voltage:\", milliVolts / 1000.0F);\n#endif\n\n// Test temperature functions\n#if TINY_GSM_TEST_TEMPERATURE && defined TINY_GSM_MODEM_HAS_TEMPERATURE\n  float temp = modem.getTemperature();\n  DBG(\"Chip temperature:\", temp);\n#endif\n\n#if TINY_GSM_POWERDOWN\n\n#if TINY_GSM_TEST_GPRS\n  modem.gprsDisconnect();\n  delay(5000L);\n  if (!modem.isGprsConnected()) {\n    DBG(\"GPRS disconnected\");\n  } else {\n    DBG(\"GPRS disconnect: Failed.\");\n  }\n#endif\n\n#if TINY_GSM_TEST_WIFI\n  modem.networkDisconnect();\n  DBG(\"WiFi disconnected\");\n#endif\n\n  // Try to power-off (modem may decide to restart automatically)\n  // To turn off modem completely, please use Reset/Enable pins\n  modem.poweroff();\n  DBG(\"Poweroff.\");\n#endif\n\n  DBG(\"End of tests.\");\n\n  // Do nothing forevermore\n  while (true) { modem.maintain(); }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "analogread",
        "digitalread",
        "digitalwrite"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // open the serial port to send the information of what you are reading\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read all the D inputs at the Motor Board as analog\n  //analogReadB_Ds();\n\n  // read all the D inputs at the Motor Board as digital\n  //digitalReadB_Ds();\n\n  // read all the M inputs at the Control Board as analog\n  //analogReadMs();\n\n  // read all the M inputs at the Control Board as digital\n  //digitalReadMs();\n\n  // read all the D inputs at the Control Board as analog\n  analogReadT_Ds();\n\n  // read all the D inputs at the Control Board as digital\n  //digitalReadT_Ds();\n\n  // write all the D outputs at the Motor Board as digital\n  //digitalWriteB_Ds();\n\n  // write all the D outputs at the Control Board as digital\n  //digitalWriteT_Ds();\n  delay(40);"
        },
        {
          "name": "analogReadMs",
          "parameters": "",
          "body": "for (int i = 0; i < 8; i++) {\n    Serial.print(Robot.analogRead(arr[i]));\n    Serial.print(\",\");\n  }\n  Serial.println(\"\");"
        },
        {
          "name": "digitalReadMs",
          "parameters": "",
          "body": "for (int i = 0; i < 8; i++) {\n    Serial.print(Robot.digitalRead(arr[i]));\n    Serial.print(\",\");\n  }\n  Serial.println(\"\");"
        },
        {
          "name": "analogReadT_Ds",
          "parameters": "",
          "body": "for (int i = 0; i < 6; i++) {\n    Serial.print(Robot.analogRead(arr2[i]));\n    Serial.print(\",\");\n  }\n  Serial.println(\"\");"
        },
        {
          "name": "digitalReadT_Ds",
          "parameters": "",
          "body": "for (int i = 0; i < 6; i++) {\n    Serial.print(Robot.digitalRead(arr2[i]));\n    Serial.print(\",\");\n  }\n  Serial.println(\"\");"
        },
        {
          "name": "digitalWriteT_Ds",
          "parameters": "",
          "body": "// turn all the pins on\n  for (int i = 0; i < 6; i++) {\n    Robot.digitalWrite(arr2[i], HIGH);\n  }\n  delay(500);\n\n  // turn all the pins off\n  for (int i = 0; i < 6; i++) {\n    Robot.digitalWrite(arr2[i], LOW);\n  }\n  delay(500);"
        },
        {
          "name": "digitalWriteB_Ds",
          "parameters": "",
          "body": "// turn all the pins on\n  for (int i = 0; i < 4; i++) {\n    Robot.digitalWrite(arr3[i], HIGH);\n  }\n  delay(500);\n\n  // turn all the pins off\n  for (int i = 0; i < 4; i++) {\n    Robot.digitalWrite(arr3[i], LOW);\n  }\n  delay(500);"
        },
        {
          "name": "analogReadB_Ds",
          "parameters": "",
          "body": "for (int i = 0; i < 4; i++) {\n    Serial.print(Robot.analogRead(arr3[i]));\n    Serial.print(\",\");\n  }\n  Serial.println(\"\");"
        },
        {
          "name": "digitalReadB_Ds",
          "parameters": "",
          "body": "for (int i = 0; i < 4; i++) {\n    Serial.print(Robot.digitalRead(arr3[i]));\n    Serial.print(\",\");\n  }\n  Serial.println(\"\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "current",
        "millis",
        "analogread",
        "timer"
      ],
      "libraries": [
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "sendPort",
          "parameters": "byte portNumber, byte portValue",
          "body": "portValue = portValue & portStatus[portNumber];\n  if (previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "byte i, port, status;\n\n  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n\n  for (pin = 0; pin < TOTAL_PINS; pin++) {\n    if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT);\n  }\n\n  for (port = 0; port < TOTAL_PORTS; port++) {\n    status = 0;\n    for (i = 0; i < 8; i++) {\n      if (IS_PIN_DIGITAL(port * 8 + i)) status |= (1 << i);\n    }\n    portStatus[port] = status;\n  }\n\n  Firmata.begin(57600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "byte i;\n\n  for (i = 0; i < TOTAL_PORTS; i++) {\n    sendPort(i, readPort(i, 0xff));\n  }\n  /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you\n     get long, random delays.  So only read analogs every 20ms or so */\n  currentMillis = millis();\n  if (currentMillis - previousMillis > samplingInterval) {\n    previousMillis += samplingInterval;\n    while (Firmata.available()) {\n      Firmata.processInput();\n    }\n    for (pin = 0; pin < TOTAL_ANALOG_PINS; pin++) {\n      analogValue = analogRead(pin);\n      if (analogValue != previousAnalogValues[pin]) {\n        Firmata.sendAnalog(pin, analogValue);\n        previousAnalogValues[pin] = analogValue;\n      }\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  MIDI.begin(4);                    // Launch MIDI and listen to channel 4"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (MIDI.read())                  // If we have received a message\n  {\n    digitalWrite(LED_BUILTIN, HIGH);\n    MIDI.sendNoteOn(42, 127, 1);    // Send a Note (pitch 42, velo 127 on channel 1)\n    delay(1000);                    // Wait for a second\n    MIDI.sendNoteOff(42, 0, 1);     // Stop the note\n    digitalWrite(LED_BUILTIN, LOW);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "tls",
        "dns",
        "millis",
        "gatewayip"
      ],
      "libraries": [
        "QNEthernet.h",
        "lwip/altcp_tcp.h",
        "mbedtls.h",
        "lwip/altcp_tls.h",
        "lwip/apps/altcp_proxyconnect.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial\n  }\n  printf(\"Starting...\\r\\n\");\n\n  uint8_t mac[6];\n  Ethernet.macAddress(mac);  // This is informative; it retrieves, not sets\n  printf(\"MAC = %02x:%02x:%02x:%02x:%02x:%02x\\r\\n\",\n         mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n\n  // Get an IP address\n  printf(\"Starting Ethernet with DHCP...\\r\\n\");\n  if (!Ethernet.begin()) {\n    printf(\"Failed to start Ethernet\\r\\n\");\n    return;\n  }\n  if (!Ethernet.waitForLocalIP(kDHCPTimeout)) {\n    printf(\"Failed to get IP address from DHCP\\r\\n\");\n    return;\n  }\n\n  IPAddress ip = Ethernet.localIP();\n  printf(\"    Local IP    = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n  ip = Ethernet.subnetMask();\n  printf(\"    Subnet mask = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n  ip = Ethernet.gatewayIP();\n  printf(\"    Gateway     = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n  ip = Ethernet.dnsServerIP();\n  printf(\"    DNS         = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n\n  // Connect and send the request\n  printf(\"Connecting and sending request...\\r\\n\");\n#if LWIP_ALTCP\n  if (kUseProxy) {\n    client.setConnectionTimeout(30'000);  // Proxies can take longer, maybe\n  }\n#endif  // LWIP_ALTCP\n  if (!client.connect(kHost, kPort)) {\n    printf(\"Failed to connect\\r\\n\");\n    disconnectedPrintLatch = true;\n  } else {\n    client.writeFully(kRequest);\n    client.flush();\n    dataCount = 0;\n    printf(\"[Awaiting response...]\\r\\n\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Read the response\n  if (client.connected()) {\n    int avail = client.available();\n    if (avail > 0) {\n      dataCount += avail;\n      for (int i = 0; i < avail; i++) {\n        putc(client.read(), stdout);\n      }\n    }\n  } else {\n    if (!disconnectedPrintLatch) {\n      disconnectedPrintLatch = true;\n      printf(\"[Client disconnected]\\r\\n\"\n             \"[Data count = %zu]\\r\\n\", dataCount);\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "delay",
        "rgb"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor.\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check if a color reading is available\n  while (! APDS.colorAvailable()) {\n    delay(5);\n  }\n  int r, g, b;\n\n  // read the color\n  APDS.readColor(r, g, b);\n\n  // print the values\n  Serial.print(\"r = \");\n  Serial.println(r);\n  Serial.print(\"g = \");\n  Serial.println(g);\n  Serial.print(\"b = \");\n  Serial.println(b);\n  Serial.println();\n\n  // wait a bit before reading again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor!\");\n  }\n\n  // for setGestureSensitivity(..) a value between 1 and 100 is required.\n  // Higher values make the gesture recognition more sensitive but less accurate\n  // (a wrong gesture may be detected). Lower values makes the gesture recognition\n  // more accurate but less sensitive (some gestures may be missed).\n  // Default is 80\n  //APDS.setGestureSensitivity(80);\n\n  Serial.println(\"Detecting gestures ...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (APDS.gestureAvailable()) {\n    // a gesture was detected, read and print to Serial Monitor\n    int gesture = APDS.readGesture();\n\n    switch (gesture) {\n      case GESTURE_UP:\n        Serial.println(\"Detected UP gesture\");\n        break;\n\n      case GESTURE_DOWN:\n        Serial.println(\"Detected DOWN gesture\");\n        break;\n\n      case GESTURE_LEFT:\n        Serial.println(\"Detected LEFT gesture\");\n        break;\n\n      case GESTURE_RIGHT:\n        Serial.println(\"Detected RIGHT gesture\");\n        break;\n\n      default:\n        // ignore\n        break;\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "delay"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor!\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check if a proximity reading is available\n  if (APDS.proximityAvailable()) {\n    // read the proximity\n    // - 0   => close\n    // - 255 => far\n    // - -1  => error\n    int proximity = APDS.readProximity();\n\n    // print value to the Serial Monitor\n    Serial.println(proximity);\n  }\n\n  // wait a bit before reading again\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "sd"
      ],
      "libraries": [
        "ArduinoSound.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Open serial communications and wait for port to open:\n  // A baud rate of 115200 is used instead of 9600 for a faster data rate\n  // on non-native USB ports\n  Serial.begin(115200);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // setup the I2S audio input for 44.1 kHz with 32-bits per sample\n  if (!AudioInI2S.begin(44100, 32)) {\n    Serial.println(\"Failed to initialize I2S input!\");\n    while (1); // do nothing\n  }\n\n  // configure the I2S input as the input for the amplitude analyzer\n  if (!amplitudeAnalyzer.input(AudioInI2S)) {\n    Serial.println(\"Failed to set amplitude analyzer input!\");\n    while (1); // do nothing\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check if a new analysis is available\n  if (amplitudeAnalyzer.available()) {\n    // read the new amplitude\n    int amplitude = amplitudeAnalyzer.read();\n\n    // print out the amplititude to the serial monitor\n    Serial.println(amplitude);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "rest",
        "buffer",
        "voltage",
        "power",
        "current",
        "light",
        "spi",
        "millis",
        "digitalwrite",
        "delay",
        "analogread",
        "yield",
        "led",
        "sd",
        "flash",
        "interrupt",
        "timer",
        "fetch"
      ],
      "libraries": [
        "SPI.h",
        "SdFat.h",
        "FreeStack.h",
        "AnalogBinLogger.h"
      ],
      "functions": [
        {
          "name": "fatalBlink",
          "parameters": "",
          "body": "while (true) {\n    if (ERROR_LED_PIN >= 0) {\n      digitalWrite(ERROR_LED_PIN, HIGH);\n      delay(200);\n      digitalWrite(ERROR_LED_PIN, LOW);\n      delay(200);\n    }\n  }"
        },
        {
          "name": "adcInit",
          "parameters": "metadata_t* meta",
          "body": "uint8_t adps;  // prescaler bits for ADCSRA\n  uint32_t ticks = F_CPU*SAMPLE_INTERVAL + 0.5;  // Sample interval cpu cycles.\n\n  if (ADC_REF & ~((1 << REFS0) | (1 << REFS1))) {\n    error(\"Invalid ADC reference\");\n  }\n#ifdef ADC_PRESCALER\n  if (ADC_PRESCALER > 7 || ADC_PRESCALER < 2) {\n    error(\"Invalid ADC prescaler\");\n  }\n  adps = ADC_PRESCALER;\n#else  // ADC_PRESCALER\n  // Allow extra cpu cycles to change ADC settings if more than one pin.\n  int32_t adcCycles = (ticks - ISR_TIMER0)/PIN_COUNT - ISR_SETUP_ADC;\n\n  for (adps = 7; adps > 0; adps--) {\n    if (adcCycles >= (MIN_ADC_CYCLES << adps)) {\n      break;\n    }\n  }\n#endif  // ADC_PRESCALER\n  meta->adcFrequency = F_CPU >> adps;\n  if (meta->adcFrequency > (RECORD_EIGHT_BITS ? 2000000 : 1000000)) {\n    error(\"Sample Rate Too High\");\n  }\n#if ROUND_SAMPLE_INTERVAL\n  // Round so interval is multiple of ADC clock.\n  ticks += 1 << (adps - 1);\n  ticks >>= adps;\n  ticks <<= adps;\n#endif  // ROUND_SAMPLE_INTERVAL\n\n  if (PIN_COUNT > sizeof(meta->pinNumber)/sizeof(meta->pinNumber[0])) {\n    error(\"Too many pins\");\n  }\n  meta->pinCount = PIN_COUNT;\n  meta->recordEightBits = RECORD_EIGHT_BITS;\n\n  for (int i = 0; i < PIN_COUNT; i++) {\n    uint8_t pin = PIN_LIST[i];\n    if (pin >= NUM_ANALOG_INPUTS) {\n      error(\"Invalid Analog pin number\");\n    }\n    meta->pinNumber[i] = pin;\n\n    // Set ADC reference and low three bits of analog pin number.\n    adcmux[i] = (pin & 7) | ADC_REF;\n    if (RECORD_EIGHT_BITS) {\n      adcmux[i] |= 1 << ADLAR;\n    }\n\n    // If this is the first pin, trigger on timer/counter 1 compare match B.\n    adcsrb[i] = i == 0 ? (1 << ADTS2) | (1 << ADTS0) : 0;\n#ifdef MUX5\n    if (pin > 7) {\n      adcsrb[i] |= (1 << MUX5);\n    }\n#endif  // MUX5\n    adcsra[i] = (1 << ADEN) | (1 << ADIE) | adps;\n    adcsra[i] |= i == 0 ? 1 << ADATE : 1 << ADSC;\n  }\n\n  // Setup timer1\n  TCCR1A = 0;\n  uint8_t tshift;\n  if (ticks < 0X10000) {\n    // no prescale, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS10);\n    tshift = 0;\n  } else if (ticks < 0X10000*8) {\n    // prescale 8, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);\n    tshift = 3;\n  } else if (ticks < 0X10000*64) {\n    // prescale 64, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11) | (1 << CS10);\n    tshift = 6;\n  } else if (ticks < 0X10000*256) {\n    // prescale 256, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS12);\n    tshift = 8;\n  } else if (ticks < 0X10000*1024) {\n    // prescale 1024, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS12) | (1 << CS10);\n    tshift = 10;\n  } else {\n    error(\"Sample Rate Too Slow\");\n  }\n  // divide by prescaler\n  ticks >>= tshift;\n  // set TOP for timer reset\n  ICR1 = ticks - 1;\n  // compare for ADC start\n  OCR1B = 0;\n\n  // multiply by prescaler\n  ticks <<= tshift;\n\n  // Sample interval in CPU clock ticks.\n  meta->sampleInterval = ticks;\n  meta->cpuFrequency = F_CPU;\n  float sampleRate = (float)meta->cpuFrequency/meta->sampleInterval;\n  Serial.print(F(\"Sample pins:\"));\n  for (uint8_t i = 0; i < meta->pinCount; i++) {\n    Serial.print(' ');\n    Serial.print(meta->pinNumber[i], DEC);\n  }\n  Serial.println();\n  Serial.print(F(\"ADC bits: \"));\n  Serial.println(meta->recordEightBits ? 8 : 10);\n  Serial.print(F(\"ADC clock kHz: \"));\n  Serial.println(meta->adcFrequency/1000);\n  Serial.print(F(\"Sample Rate: \"));\n  Serial.println(sampleRate);\n  Serial.print(F(\"Sample interval usec: \"));\n  Serial.println(1000000.0/sampleRate, 4);"
        },
        {
          "name": "adcStart",
          "parameters": "",
          "body": "// initialize ISR\n  isrBufNeeded = true;\n  isrOver = 0;\n  adcindex = 1;\n\n  // Clear any pending interrupt.\n  ADCSRA |= 1 << ADIF;\n\n  // Setup for first pin.\n  ADMUX = adcmux[0];\n  ADCSRB = adcsrb[0];\n  ADCSRA = adcsra[0];\n\n  // Enable timer1 interrupts.\n  timerError = false;\n  timerFlag = false;\n  TCNT1 = 0;\n  TIFR1 = 1 << OCF1B;\n  TIMSK1 = 1 << OCIE1B;"
        },
        {
          "name": "adcStop",
          "parameters": "",
          "body": "TIMSK1 = 0;\n  ADCSRA = 0;"
        },
        {
          "name": "binaryToCsv",
          "parameters": "",
          "body": "uint8_t lastPct = 0;\n  block_t buf;\n  metadata_t* pm;\n  uint32_t t0 = millis();\n  char csvName[13];\n  StdioStream csvStream;\n\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;\n  }\n  binFile.rewind();\n  if (binFile.read(&buf , 512) != 512) {\n    error(\"Read metadata failed\");\n  }\n  // Create a new csv file.\n  strcpy(csvName, binName);\n  strcpy(&csvName[BASE_NAME_SIZE + 3], \"csv\");\n\n  if (!csvStream.fopen(csvName, \"w\")) {\n    error(\"open csvStream failed\");\n  }\n  Serial.println();\n  Serial.print(F(\"Writing: \"));\n  Serial.print(csvName);\n  Serial.println(F(\" - type any character to stop\"));\n  pm = (metadata_t*)&buf;\n  csvStream.print(F(\"Interval,\"));\n  float intervalMicros = 1.0e6*pm->sampleInterval/(float)pm->cpuFrequency;\n  csvStream.print(intervalMicros, 4);\n  csvStream.println(F(\",usec\"));\n  for (uint8_t i = 0; i < pm->pinCount; i++) {\n    if (i) {\n      csvStream.putc(',');\n    }\n    csvStream.print(F(\"pin\"));\n    csvStream.print(pm->pinNumber[i]);\n  }\n  csvStream.println();\n  uint32_t tPct = millis();\n  while (!Serial.available() && binFile.read(&buf, 512) == 512) {\n    if (buf.count == 0) {\n      break;\n    }\n    if (buf.overrun) {\n      csvStream.print(F(\"OVERRUN,\"));\n      csvStream.println(buf.overrun);\n    }\n    for (uint16_t j = 0; j < buf.count; j += PIN_COUNT) {\n      for (uint16_t i = 0; i < PIN_COUNT; i++) {\n        if (i) {\n          csvStream.putc(',');\n        }\n        csvStream.print(buf.data[i + j]);\n      }\n      csvStream.println();\n    }\n    if ((millis() - tPct) > 1000) {\n      uint8_t pct = binFile.curPosition()/(binFile.fileSize()/100);\n      if (pct != lastPct) {\n        tPct = millis();\n        lastPct = pct;\n        Serial.print(pct, DEC);\n        Serial.println('%');\n      }\n    }\n    if (Serial.available()) {\n      break;\n    }\n  }\n  csvStream.fclose();\n  Serial.print(F(\"Done: \"));\n  Serial.print(0.001*(millis() - t0));\n  Serial.println(F(\" Seconds\"));"
        },
        {
          "name": "checkOverrun",
          "parameters": "",
          "body": "bool headerPrinted = false;\n  block_t buf;\n  uint32_t bgnBlock, endBlock;\n  uint32_t bn = 0;\n\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;\n  }\n  if (!binFile.contiguousRange(&bgnBlock, &endBlock)) {\n    error(\"contiguousRange failed\");\n  }\n  binFile.rewind();\n  Serial.println();\n  Serial.println(F(\"Checking overrun errors - type any character to stop\"));\n  if (binFile.read(&buf , 512) != 512) {\n    error(\"Read metadata failed\");\n  }\n  bn++;\n  while (binFile.read(&buf, 512) == 512) {\n    if (buf.count == 0) {\n      break;\n    }\n    if (buf.overrun) {\n      if (!headerPrinted) {\n        Serial.println();\n        Serial.println(F(\"Overruns:\"));\n        Serial.println(F(\"fileBlockNumber,sdBlockNumber,overrunCount\"));\n        headerPrinted = true;\n      }\n      Serial.print(bn);\n      Serial.print(',');\n      Serial.print(bgnBlock + bn);\n      Serial.print(',');\n      Serial.println(buf.overrun);\n    }\n    bn++;\n  }\n  if (!headerPrinted) {\n    Serial.println(F(\"No errors found\"));\n  } else {\n    Serial.println(F(\"Done\"));\n  }"
        },
        {
          "name": "dumpData",
          "parameters": "",
          "body": "block_t buf;\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;\n  }\n  binFile.rewind();\n  if (binFile.read(&buf , 512) != 512) {\n    error(\"Read metadata failed\");\n  }\n  Serial.println();\n  Serial.println(F(\"Type any character to stop\"));\n  delay(1000);\n  while (!Serial.available() && binFile.read(&buf , 512) == 512) {\n    if (buf.count == 0) {\n      break;\n    }\n    if (buf.overrun) {\n      Serial.print(F(\"OVERRUN,\"));\n      Serial.println(buf.overrun);\n    }\n    for (uint16_t i = 0; i < buf.count; i++) {\n      Serial.print(buf.data[i], DEC);\n      if ((i+1)%PIN_COUNT) {\n        Serial.print(',');\n      } else {\n        Serial.println();\n      }\n    }\n  }\n  Serial.println(F(\"Done\"));"
        },
        {
          "name": "logData",
          "parameters": "",
          "body": "uint32_t bgnBlock, endBlock;\n\n  // Allocate extra buffer space.\n  block_t block[BUFFER_BLOCK_COUNT];\n\n  Serial.println();\n\n  // Initialize ADC and timer1.\n  adcInit((metadata_t*) &block[0]);\n\n  // Find unused file name.\n  if (BASE_NAME_SIZE > 6) {\n    error(\"FILE_BASE_NAME too long\");\n  }\n  while (sd.exists(binName)) {\n    if (binName[BASE_NAME_SIZE + 1] != '9') {\n      binName[BASE_NAME_SIZE + 1]++;\n    } else {\n      binName[BASE_NAME_SIZE + 1] = '0';\n      if (binName[BASE_NAME_SIZE] == '9') {\n        error(\"Can't create file name\");\n      }\n      binName[BASE_NAME_SIZE]++;\n    }\n  }\n  // Delete old tmp file.\n  if (sd.exists(TMP_FILE_NAME)) {\n    Serial.println(F(\"Deleting tmp file\"));\n    if (!sd.remove(TMP_FILE_NAME)) {\n      error(\"Can't remove tmp file\");\n    }\n  }\n  // Create new file.\n  Serial.println(F(\"Creating new file\"));\n  binFile.close();\n  if (!binFile.createContiguous(TMP_FILE_NAME, 512 * FILE_BLOCK_COUNT)) {\n    error(\"createContiguous failed\");\n  }\n  // Get the address of the file on the SD.\n  if (!binFile.contiguousRange(&bgnBlock, &endBlock)) {\n    error(\"contiguousRange failed\");\n  }\n  // Use SdFat's internal buffer.\n  uint8_t* cache = (uint8_t*)sd.vol()->cacheClear();\n  if (cache == 0) {\n    error(\"cacheClear failed\");\n  }\n\n  // Flash erase all data in the file.\n  Serial.println(F(\"Erasing all data\"));\n  uint32_t bgnErase = bgnBlock;\n  uint32_t endErase;\n  while (bgnErase < endBlock) {\n    endErase = bgnErase + ERASE_SIZE;\n    if (endErase > endBlock) {\n      endErase = endBlock;\n    }\n    if (!sd.card()->erase(bgnErase, endErase)) {\n      error(\"erase failed\");\n    }\n    bgnErase = endErase + 1;\n  }\n  // Start a multiple block write.\n  if (!sd.card()->writeStart(bgnBlock, FILE_BLOCK_COUNT)) {\n    error(\"writeBegin failed\");\n  }\n  // Write metadata.\n  if (!sd.card()->writeData((uint8_t*)&block[0])) {\n    error(\"Write metadata failed\");\n  }\n  // Initialize queues.\n  emptyHead = emptyTail = 0;\n  fullHead = fullTail = 0;\n\n  // Use SdFat buffer for one block.\n  emptyQueue[emptyHead] = (block_t*)cache;\n  emptyHead = queueNext(emptyHead);\n\n  // Put rest of buffers in the empty queue.\n  for (uint8_t i = 0; i < BUFFER_BLOCK_COUNT; i++) {\n    emptyQueue[emptyHead] = &block[i];\n    emptyHead = queueNext(emptyHead);\n  }\n  // Give SD time to prepare for big write.\n  delay(1000);\n  Serial.println(F(\"Logging - type any character to stop\"));\n  // Wait for Serial Idle.\n  Serial.flush();\n  delay(10);\n  uint32_t bn = 1;\n  uint32_t t0 = millis();\n  uint32_t t1 = t0;\n  uint32_t overruns = 0;\n  uint32_t count = 0;\n  uint32_t maxLatency = 0;\n\n  // Start logging interrupts.\n  adcStart();\n  while (1) {\n    if (fullHead != fullTail) {\n      // Get address of block to write.\n      block_t* pBlock = fullQueue[fullTail];\n\n      // Write block to SD.\n      uint32_t usec = micros();\n      if (!sd.card()->writeData((uint8_t*)pBlock)) {\n        error(\"write data failed\");\n      }\n      usec = micros() - usec;\n      t1 = millis();\n      if (usec > maxLatency) {\n        maxLatency = usec;\n      }\n      count += pBlock->count;\n\n      // Add overruns and possibly light LED.\n      if (pBlock->overrun) {\n        overruns += pBlock->overrun;\n        if (ERROR_LED_PIN >= 0) {\n          digitalWrite(ERROR_LED_PIN, HIGH);\n        }\n      }\n      // Move block to empty queue.\n      emptyQueue[emptyHead] = pBlock;\n      emptyHead = queueNext(emptyHead);\n      fullTail = queueNext(fullTail);\n      bn++;\n      if (bn == FILE_BLOCK_COUNT) {\n        // File full so stop ISR calls.\n        adcStop();\n        break;\n      }\n    }\n    if (timerError) {\n      error(\"Missed timer event - rate too high\");\n    }\n    if (Serial.available()) {\n      // Stop ISR calls.\n      adcStop();\n      if (isrBuf != 0 && isrBuf->count >= PIN_COUNT) {\n        // Truncate to last complete sample.\n        isrBuf->count = PIN_COUNT*(isrBuf->count/PIN_COUNT);\n        // Put buffer in full queue.\n        fullQueue[fullHead] = isrBuf;\n        fullHead = queueNext(fullHead);\n        isrBuf = 0;\n      }\n      if (fullHead == fullTail) {\n        break;\n      }\n    }\n  }\n  if (!sd.card()->writeStop()) {\n    error(\"writeStop failed\");\n  }\n  // Truncate file if recording stopped early.\n  if (bn != FILE_BLOCK_COUNT) {\n    Serial.println(F(\"Truncating file\"));\n    if (!binFile.truncate(512L * bn)) {\n      error(\"Can't truncate file\");\n    }\n  }\n  if (!binFile.rename(binName)) {\n    error(\"Can't rename file\");\n  }\n  Serial.print(F(\"File renamed: \"));\n  Serial.println(binName);\n  Serial.print(F(\"Max block write usec: \"));\n  Serial.println(maxLatency);\n  Serial.print(F(\"Record time sec: \"));\n  Serial.println(0.001*(t1 - t0), 3);\n  Serial.print(F(\"Sample count: \"));\n  Serial.println(count/PIN_COUNT);\n  Serial.print(F(\"Samples/sec: \"));\n  Serial.println((1000.0/PIN_COUNT)*count/(t1-t0));\n  Serial.print(F(\"Overruns: \"));\n  Serial.println(overruns);\n  Serial.println(F(\"Done\"));"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);\n  }\n  Serial.begin(9600);\n\n  // Read the first sample pin to init the ADC.\n  analogRead(PIN_LIST[0]);\n\n  Serial.print(F(\"FreeStack: \"));\n  Serial.println(FreeStack());\n\n  // Initialize at the highest speed supported by the board that is\n  // not over 50 MHz. Try a lower speed if SPI errors occur.\n  if (!sd.begin(SD_CS_PIN, SD_SCK_MHZ(50))) {\n    sd.initErrorPrint();\n    fatalBlink();\n  }"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "// Read any Serial data.\n  do {\n    delay(10);\n  } while (Serial.available() && Serial.read() >= 0);\n  Serial.println();\n  Serial.println(F(\"type:\"));\n  Serial.println(F(\"c - convert file to csv\"));\n  Serial.println(F(\"d - dump data to Serial\"));\n  Serial.println(F(\"e - overrun error details\"));\n  Serial.println(F(\"r - record ADC data\"));\n\n  while(!Serial.available()) {\n    yield();\n  }\n  char c = tolower(Serial.read());\n  if (ERROR_LED_PIN >= 0) {\n    digitalWrite(ERROR_LED_PIN, LOW);\n  }\n  // Read any Serial data.\n  do {\n    delay(10);\n  } while (Serial.available() && Serial.read() >= 0);\n\n  if (c == 'c') {\n    binaryToCsv();\n  } else if (c == 'd') {\n    dumpData();\n  } else if (c == 'e') {\n    checkOverrun();\n  } else if (c == 'r') {\n    logData();\n  } else {\n    Serial.println(F(\"Invalid entry\"));\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "current",
        "servo",
        "millis",
        "analogwrite",
        "analogread",
        "eeprom",
        "pwm",
        "timer"
      ],
      "libraries": [
        "Servo.h",
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "analogWriteCallback",
          "parameters": "byte pin, int value",
          "body": "switch (pin) {\n    case 9: servo9.write(value); break;\n    case 10: servo10.write(value); break;\n    case 3:\n    case 5:\n    case 6:\n    case 11: // PWM pins\n      analogWrite(pin, value);\n      break;\n  }"
        },
        {
          "name": "reportAnalogCallback",
          "parameters": "byte pin, int value",
          "body": "if (value == 0) {\n    analogInputsToReport = analogInputsToReport & ~ (1 << pin);\n  }\n  else { // everything but 0 enables reporting of that pin\n    analogInputsToReport = analogInputsToReport | (1 << pin);\n  }\n  // TODO: save status to EEPROM here, if changed"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);\n\n  servo9.attach(9);\n  servo10.attach(10);\n  Firmata.begin(57600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "while (Firmata.available())\n    Firmata.processInput();\n  currentMillis = millis();\n  if (currentMillis - previousMillis > 20) {\n    previousMillis += 20;                   // run this every 20ms\n    for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) {\n      if ( analogInputsToReport & (1 << analogPin) )\n        Firmata.sendAnalog(analogPin, analogRead(analogPin));\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "stream",
        "buffer",
        "callback",
        "current",
        "spi",
        "delay",
        "yield",
        "millis",
        "analogread",
        "sd",
        "flash",
        "rtc",
        "sensor_count",
        "sensors"
      ],
      "libraries": [
        "SPI.h",
        "SdFat.h",
        "sdios.h",
        "FreeStack.h",
        "Wire.h",
        "RTClib.h"
      ],
      "functions": [
        {
          "name": "dateTime",
          "parameters": "uint16_t* date, uint16_t* time",
          "body": "DateTime now = RTC.now();\n\n  // return date using FAT_DATE macro to format fields\n  *date = FAT_DATE(now.year(), now.month(), now.day());\n\n  // return time using FAT_TIME macro to format fields\n  *time = FAT_TIME(now.hour(), now.minute(), now.second());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial.\n  while (!Serial) {\n    yield();\n  }\n  // F() stores strings in flash to save RAM\n  cout << endl << F(\"FreeStack: \") << FreeStack() << endl;\n\n#if WAIT_TO_START\n  cout << F(\"Type any character to start\\n\");\n  while (!Serial.available()) {\n    yield();\n  }\n  // Discard input.\n  do {\n    delay(10);\n  } while(Serial.available() && Serial.read() >= 0);\n#endif  // WAIT_TO_START\n\n#if USE_DS1307\n  // connect to RTC\n  Wire.begin();\n  if (!RTC.begin()) {\n    error(\"RTC failed\");\n  }\n\n  // set date time callback function\n  SdFile::dateTimeCallback(dateTime);\n  DateTime now = RTC.now();\n  cout  << now << endl;\n#endif  // USE_DS1307\n\n  // Initialize at the highest speed supported by the board that is\n  // not over 50 MHz. Try a lower speed if SPI errors occur.\n  if (!sd.begin(SD_CHIP_SELECT, SD_SCK_MHZ(50))) {\n    sd.initErrorHalt();\n  }\n\n  // create a new file in root, the current working directory\n  char name[] = \"logger00.csv\";\n\n  for (uint8_t i = 0; i < 100; i++) {\n    name[6] = i/10 + '0';\n    name[7] = i%10 + '0';\n    if (sd.exists(name)) {\n      continue;\n    }\n    logfile.open(name);\n    break;\n  }\n  if (!logfile.is_open()) {\n    error(\"file.open\");\n  }\n\n  cout << F(\"Logging to: \") << name << endl;\n  cout << F(\"Type any character to stop\\n\\n\");\n\n  // format header in buffer\n  obufstream bout(buf, sizeof(buf));\n\n  bout << F(\"millis\");\n\n#if USE_DS1307\n  bout << F(\",date,time\");\n#endif  // USE_DS1307\n\n  for (uint8_t i = 0; i < SENSOR_COUNT; i++) {\n    bout << F(\",sens\") << int(i);\n  }\n  logfile << buf << endl;\n\n#if ECHO_TO_SERIAL\n  cout << buf << endl;\n#endif  // ECHO_TO_SERIAL"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "uint32_t m;\n\n  // wait for time to be a multiple of interval\n  do {\n    m = millis();\n  } while (m % LOG_INTERVAL);\n\n  // use buffer stream to format line\n  obufstream bout(buf, sizeof(buf));\n\n  // start with time in millis\n  bout << m;\n\n#if USE_DS1307\n  DateTime now = RTC.now();\n  bout << ',' << now;\n#endif  // USE_DS1307\n\n  // read analog pins and format data\n  for (uint8_t ia = 0; ia < SENSOR_COUNT; ia++) {\n#if ADC_DELAY\n    analogRead(ia);\n    delay(ADC_DELAY);\n#endif  // ADC_DELAY\n    bout << ',' << analogRead(ia);\n  }\n  bout << endl;\n\n  // log data and flush to SD\n  logfile << buf << flush;\n\n  // check for error\n  if (!logfile) {\n    error(\"write data failed\");\n  }\n\n#if ECHO_TO_SERIAL\n  cout << buf;\n#endif  // ECHO_TO_SERIAL\n\n  // don't log two points in the same millis\n  if (m == millis()) {\n    delay(1);\n  }\n\n  if (!Serial.available()) {\n    return;\n  }\n  logfile.close();\n  cout << F(\"Done!\");\n  while (true) {}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "voltage",
        "delay",
        "pwm"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//analog_out.period_ms(CHANNEL, PERIOD_MILLISECONDS);\n  analog_out.period_ms(0, 4);\n  analog_out.period_ms(1, 4);\n  analog_out.period_ms(2, 4);\n  analog_out.period_ms(3, 4);\n  \n  Serial.begin(9600);\n  Serial.println(\"Analog out test\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//analog_out.write(CHANNEL, OUTPUT_VOLTAGE_VALUE);\n  analog_out.write(0, counter);\n  analog_out.write(1, counter);\n  analog_out.write(2, counter);\n  analog_out.write(3, counter);\n  Serial.println(\"All channels set at \"+String(counter)+\"V\");\n  \n  counter = counter + 0.1;\n  //Maximum output value is 10.4V\n  if (counter >= 10.5)\n  {\n    counter = 0;\n    //Additional 100 ms delay introduced to manage 10.5V -> 0V fall time of 150 ms\n    delay(100);\n  }\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "voltage",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.set0_10V();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH0: \");\n  Serial.print(voltage_ch0, 3);\n  Serial.println(\"V\");\n\n  float raw_voltage_ch1 = analog_in.read(1);\n  float voltage_ch1 = (raw_voltage_ch1 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH1: \");\n  Serial.print(voltage_ch1, 3);\n  Serial.println(\"V\");\n\n  float raw_voltage_ch2 = analog_in.read(2);\n  float voltage_ch2 = (raw_voltage_ch2 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH2: \");\n  Serial.print(voltage_ch2, 3);\n  Serial.println(\"V\");\n  Serial.println();\n  delay(250);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "voltage",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.set4_20mA();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535;\n  float current_ch0 = (voltage_ch0 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH0: \");\n  Serial.print(current_ch0);\n  Serial.println(\"mA\");\n\n  float raw_voltage_ch1 = analog_in.read(1);\n  float voltage_ch1 = (raw_voltage_ch1 * reference) / 65535;\n  float current_ch1 = (voltage_ch1 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH1: \");\n  Serial.print(current_ch1);\n  Serial.println(\"mA\");\n  float raw_voltage_ch2 = analog_in.read(2);\n  float voltage_ch2 = (raw_voltage_ch2 * reference) / 65535;\n  float current_ch2 = (voltage_ch2 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH2: \");\n  Serial.print(current_ch2);\n  Serial.println(\"mA\");\n\n  Serial.println();\n  delay(250);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "voltage",
        "current",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.setNTC();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535;\n  float resistance_ch0;\n  Serial.print(\"Resistance CH0: \");\n  if (voltage_ch0 < lowest_voltage) {\n    resistance_ch0 = ((-REFERENCE_RES) * voltage_ch0) / (voltage_ch0 - reference);\n    Serial.print(resistance_ch0);\n    Serial.println(\" ohm\");\n  } else {\n    resistance_ch0 = -1;\n    Serial.println(\"NaN\");\n  }\n\n  float raw_voltage_ch1 = analog_in.read(1);\n  float voltage_ch1 = (raw_voltage_ch1 * reference) / 65535;\n  float resistance_ch1;\n  Serial.print(\"Resistance CH1: \");\n  if (voltage_ch1 < lowest_voltage) {\n    resistance_ch1 = ((-REFERENCE_RES) * voltage_ch1) / (voltage_ch1 - reference);\n    Serial.print(resistance_ch1);\n    Serial.println(\" ohm\");\n  } else {\n    resistance_ch1 = -1;\n    Serial.println(\"NaN\");\n  }\n\n  float raw_voltage_ch2 = analog_in.read(2);\n  float voltage_ch2 = (raw_voltage_ch2 * reference) / 65535;\n  float resistance_ch2;\n  Serial.print(\"Resistance CH2: \");\n  if (voltage_ch2 < lowest_voltage) {\n    resistance_ch2 = ((-REFERENCE_RES) * voltage_ch2) / (voltage_ch2 - reference);\n    Serial.print(resistance_ch2);\n    Serial.println(\" ohm\");\n  } else {\n    resistance_ch2 = -1;\n    Serial.println(\"NaN\");\n  }\n\n  Serial.println();\n  delay(250);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "auth",
        "https",
        "key",
        "token",
        "payload",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    UserAccount user(API_KEY);\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    Serial.println(\"Anonymous signing up...\");\n\n    // For anonymous sign up.\n    signup(aClient, app, getAuth(user), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    if (app.ready() && (millis() - ms > 30 * 1000 || ms == 0))\n    {\n        cnt++;\n        ms = millis();\n\n        Serial.println(\"App is authenticated as anonymous...\");\n        Firebase.printf(\"User UID: %s\\n\", app.getUid().c_str());\n\n        app.isAuthenticated();\n\n        if (cnt == 3)\n        {\n            Serial.println(\"Deleting anonymous user...\");\n            UserAccount user(API_KEY);\n            deleteUser(aClient, app, getAuth(user.idToken(app.getToken())), aResult_no_callback);\n        }\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "esp.restart",
        "delay"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\tWiFiManager wifiManager;\n\n\t// wifiManager.setAPCallback([this](WiFiManager* wifiManager) {\n\twifiManager.setAPCallback([&](WiFiManager* wifiManager) {\n\t\tSerial.printf(\"Entered config mode:ip=%s, ssid='%s'\\n\", \n                        WiFi.softAPIP().toString().c_str(), \n                        wifiManager->getConfigPortalSSID().c_str());\n\t\t_enteredConfigMode = true;\n\t});\n\twifiManager.resetSettings();\n\tif (!wifiManager.autoConnect()) {\n\t\tSerial.printf(\"*** Failed to connect and hit timeout\\n\");\n\t\tESP.restart();\n\t\tdelay(1000);\n\t}"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "auth",
        "ssl",
        "password",
        "payload",
        "buffer",
        "database",
        "callback",
        "current",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    /* Assign the API key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the RTDB URL */\n    config.database_url = DATABASE_URL;\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    /** To sign in as anonymous user, just sign up as anonymous user\n     * with blank email and password.\n     *\n     * The Anonymous provider must be enabled.\n     *\n     * To enable Anonymous provider,\n     * from Firebase console, select Authentication, select Sign-in method tab,\n     * under the Sign-in providers list, enable Anonymous provider.\n     *\n     * Warning: this will create anonymous user everytime you called this function and your user list\n     * will grow up and the anonymous users stay in the user list after it created, we recommend to delete\n     * this user after used.\n     *\n     * https://stackoverflow.com/questions/38694015/what-happens-to-firebase-anonymous-users\n     * https://stackoverflow.com/questions/39640574/how-to-bulk-delete-firebase-anonymous-users\n     */\n\n    Serial.print(\"Sign up new user... \");\n\n    /*░D░O░ ░N░O░T░ ░U░S░E░ ░T░H░I░S░ ░I░N░ ░P░R░O░D░U░T░I░O░N░*/\n\n    /* Sign up */\n    if (Firebase.signUp(&config, &auth, \"\", \"\"))\n    {\n        Serial.println(\"ok\");\n        signupOK = true;\n\n        /** if the database rules were set as in the example \"EmailPassword.ino\"\n         * This new user can be access the following location.\n         *\n         * \"/UserData/<user uid>\"\n         *\n         * The new user UID or <user uid> can be taken from auth.token.uid\n         */\n    }\n    else\n        Serial.printf(\"%s\\n\", config.signer.signupError.message.c_str());\n\n    // If the signupError.message showed \"ADMIN_ONLY_OPERATION\", you need to enable Anonymous provider in project's Authentication.\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    /** The id token (C++ string) will be available from config.signer.tokens.id_token\n     * if the sig-up was successful.\n     *\n     * Now you can initialize the library using the internal created credentials.\n     *\n     * If the sign-up was failed, the following function will initialize because\n     * the internal authentication credentials are not created.\n     */\n    Firebase.begin(&config, &auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && signupOK && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = auth.token.uid.c_str(); //<- user uid\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());\n\n        if (count == 10)\n        {\n            Serial.print(\"Delete user... \");\n            if (Firebase.deleteUser(&config, &auth /* third argument can be the id token of active user to delete or leave it blank to delete current user */))\n            {\n                Serial.println(\"ok\");\n            }\n            else\n                Serial.printf(\"%s\\n\", config.signer.deleteError.message.c_str());\n        }\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "i2c"
      ],
      "libraries": [
        "Arduino_BHY2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "#if DEBUG\n  Serial.begin(115200);\n  BHY2.debug(Serial);\n#endif\n\n  BHY2.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Update and then sleep\n  BHY2.update(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "password",
        "wifi",
        "devices",
        "blynk-cloud.com"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 31, 140), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "ssl",
        "buffer",
        "payload",
        "wifi",
        "millis",
        "delay",
        "device_registration_id_token",
        "device_token"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    Firebase.FCM.setServerKey(FIREBASE_FCM_SERVER_KEY);\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    // The WiFi credentials are required for Pico W\n    // due to it does not have reconnect feature.\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    config.wifi.clearAP();\n    config.wifi.addAP(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Get the app instance info... \");\n\n    // The subscribed topic also included in the info\n    if (Firebase.FCM.appInstanceInfo(&fbdo, DEVICE_REGISTRATION_ID_TOKEN))\n        Serial.printf(\"ok\\n%s\\n\\n\", Firebase.FCM.payload(&fbdo).c_str());\n    else\n        Serial.println(fbdo.errorReason());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "i2c"
      ],
      "libraries": [
        "Arduino_BHY2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "#if DEBUG\n  Serial.begin(115200);\n  BHY2.debug(Serial);\n#endif\n\n  BHY2.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Update and then sleep only for 1ms\n  BHY2.update(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "dns",
        "millis",
        "delay",
        "monitors",
        "gatewayip",
        "clients"
      ],
      "libraries": [
        "QNEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize Serial output\n  Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial\n  }\n  delay(1500);  // Give external monitors a chance to start\n#ifdef TEENSYDUINO\n  if (CrashReport) {  // Print any crash report\n    Serial.println(CrashReport);\n    CrashReport.clear();\n  }\n#endif  // TEENSYDUINO\n  printf(\"Starting...\\r\\n\");\n\n  // Unlike the Arduino API (which you can still use), QNEthernet uses\n  // the Teensy's internal MAC address by default, so we can retrieve\n  // it here\n  uint8_t mac[6];\n  Ethernet.macAddress(mac);  // This is informative; it retrieves, not sets\n  printf(\"MAC = %02x:%02x:%02x:%02x:%02x:%02x\\r\\n\",\n         mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n\n  // Add listeners\n  // It's important to add these before doing anything with Ethernet\n  // so no events are missed.\n\n  // Listen for link changes\n  Ethernet.onLinkState([](bool state) {\n    printf(\"[Ethernet] Link %s\\r\\n\", state ? \"ON\" : \"OFF\");\n\n    // When setting a static IP, the address will be set but a link\n    // might not yet exist\n    bool hasIP = (Ethernet.localIP() != INADDR_NONE);\n    setNetworkReady(hasIP, state, Ethernet.interfaceStatus());\n  });\n\n  // Listen for address changes\n  Ethernet.onAddressChanged([]() {\n    IPAddress ip = Ethernet.localIP();\n    bool hasIP = (ip != INADDR_NONE);\n    if (hasIP) {\n      IPAddress subnet = Ethernet.subnetMask();\n      IPAddress gw = Ethernet.gatewayIP();\n      IPAddress dns = Ethernet.dnsServerIP();\n      // Note: In order for the DNS address to not be INADDR_NONE\n      //       (zero) when setting a static IP, it must be set first\n\n      printf(\n          \"[Ethernet] Address changed:\\r\\n\"\n          \"    Local IP = %u.%u.%u.%u\\r\\n\"\n          \"    Subnet   = %u.%u.%u.%u\\r\\n\"\n          \"    Gateway  = %u.%u.%u.%u\\r\\n\"\n          \"    DNS      = %u.%u.%u.%u\\r\\n\",\n          ip[0], ip[1], ip[2], ip[3],\n          subnet[0], subnet[1], subnet[2], subnet[3],\n          gw[0], gw[1], gw[2], gw[3],\n          dns[0], dns[1], dns[2], dns[3]);\n    } else {\n      printf(\"[Ethernet] Address changed: No IP address\\r\\n\");\n    }\n\n    // Tell interested parties the state of the IP address and system\n    // readiness, for example, servers, SNTP clients, and other\n    // sub-programs that need to know whether to stop/start/restart/etc\n    // Note: When setting a static IP, the address will be set but a\n    //       link might not yet exist\n    setNetworkReady(hasIP, Ethernet.linkState(), Ethernet.interfaceStatus());\n  });\n\n  // Listen for network interface status changes\n  Ethernet.onInterfaceStatus([](bool status) {\n    // When setting a static IP, the address will be set but the\n    // network interface might not yet be up\n    bool hasIP = (Ethernet.localIP() != INADDR_NONE);\n    setNetworkReady(hasIP, Ethernet.linkState(), status);\n  });\n\n  bool startWithStatic = false;\n\n  // This code shows a few ways you might want to set an IP address.\n  // **It's just for illustration. Your program doesn't need to\n  // include everything here.**\n  if (kStartWithDHCP) {\n    // Option 1 - Always start with DHCP\n\n    printf(\"Starting Ethernet with DHCP...\\r\\n\");\n    if (Ethernet.begin()) {\n      if (kWaitForDHCP) {\n        // Option 1.1 - Wait for a DHCP-assigned address\n\n        if (!Ethernet.waitForLocalIP(kDHCPTimeout)) {\n          printf(\"No address from DHCP; setting static IP...\\r\\n\");\n          startWithStatic = true;\n        }\n      } else {\n        // Option 1.2 - Don't wait for DHCP\n      }\n    } else {\n      printf(\"Error: DHCP not started\\r\\n\");\n      startWithStatic = true;\n    }\n\n    if (startWithStatic && staticIP == INADDR_NONE) {\n      printf(\"Error: No static IP\\r\\n\");\n      return;\n    }\n  } else {\n    // Option 2 - staticIP determines\n\n    if (staticIP == INADDR_NONE) {\n      printf(\"Starting Ethernet with DHCP...\\r\\n\");\n      if (!Ethernet.begin()) {\n        printf(\"Error: DHCP not started\\r\\n\");\n        return;\n      }\n\n      if (kWaitForDHCP) {\n        if (!Ethernet.waitForLocalIP(kDHCPTimeout)) {\n          printf(\"Warning: No address from DHCP\\r\\n\");\n          // An address could still come in later\n        }\n      }\n    } else {\n      startWithStatic = true;\n    }\n  }\n\n  // At this point, a static IP is set to a valid value\n  if (startWithStatic) {\n    printf(\"Starting Ethernet with static IP...\\r\\n\");\n    Ethernet.setDNSServerIP(dnsServer);  // Set first so that the\n                                         // listener sees it\n    Ethernet.begin(staticIP, subnetMask, gateway);\n\n    // When setting a static IP, the address is changed immediately,\n    // but the link may not be up; optionally wait for the link here\n    if (kLinkTimeout > 0) {\n      if (!Ethernet.waitForLink(kLinkTimeout)) {\n        printf(\"Warning: No link detected\\r\\n\");\n        // We may still see a link later, after the timeout, so\n        // continue instead of returning\n      }\n    }\n  }\n\n  // *** Additional setup code goes here"
        },
        {
          "name": "setNetworkReady",
          "parameters": "bool hasIP, bool hasLink, bool interfaceUp",
          "body": "networkReadyLatch = hasIP && hasLink && interfaceUp;\n\n  printf(\"Network is%s READY\\r\\n\", networkReadyLatch ? \"\" : \" NOT\");\n\n  // To successfully perform network startup tasks, test the latch\n  // somewhere in the main loop, and, if it is true, perform any\n  // network tasks and then set the latch to false. No network calls\n  // should be done from inside a listener.\n\n  // Similar logic could be applied for when the network is not ready.\n\n  // Servers technically only need the address state because they can\n  // be brought up and active even when there's no link or no active\n  // network interface, unlike clients and connections, which require\n  // all of an address, link, and active network interface."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// *** Main program code goes here\n\n  // Perform any network startup:\n  if (networkReadyLatch) {\n    // *** Do any network startup tasks that must run when the network\n    // *** comes up\n    networkReadyLatch = false;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "password",
        "token",
        "database",
        "payload",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Docs.resetApp();\n    app.getApp<Firestore::Documents>(Docs);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append array)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document\";\n        String fieldPath = \"appended_data\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // array value to append\n        Values::ArrayValue arrV(Values::IntegerValue((int)rand()));\n        arrV.add(Values::StringValue(\"word don't come easy \" + String(counter)));\n\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue(arrV);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, appendValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        Writes writes(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // Another array value to append\n        Values::ArrayValue arrV2(Values::DoubleValue((int)rand() * 1.234));\n        arrV2.add(Values::StringValue(\"never gonna give you up \" + String(counter)));\n        // Another append array object\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue2(arrV2);\n        // Another field transform\n        FieldTransform::FieldTransform fieldTransforms2(fieldPath, appendValue2);\n        // Another doc transform\n        DocumentTransform transform2(documentPath, fieldTransforms2);\n        // Add another Write object of another transform to the Writes object\n        writes.add(Write(transform2, Precondition()));\n\n        // All Writes, Write, DocumentTransform FieldTransform::xxx, and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "password",
        "token",
        "database",
        "payload",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Docs.resetApp();\n    app.getApp<Firestore::Documents>(Docs);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append map value in document)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // Map value to append\n        Values::MapValue mapV(\"key\" + String(counter), Values::IntegerValue(counter));\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV));\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */));\n\n        // All Writes, Document and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "password",
        "token",
        "database",
        "payload",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Docs.resetApp();\n    app.getApp<Firestore::Documents>(Docs);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append array)... \");\n\n        String documentPath = \"test_collection/test_document\";\n        String fieldPath = \"appended_map_array\";\n\n        // map in array value to append\n        Values::MapValue mapV(\"id\", Values::StringValue(\"item\" + String(counter)));\n        mapV.add(\"status\", Values::BooleanValue(counter % 2 == 0));\n\n        Values::ArrayValue arrV(mapV);\n\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue(arrV);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, appendValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        Writes writes(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // All Writes, Write, DocumentTransform FieldTransform::xxx, and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "rest",
        "https",
        "key",
        "password",
        "token",
        "database",
        "payload",
        "wifi",
        "delay",
        "millis",
        "timestamp"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Docs.resetApp();\n    app.getApp<Firestore::Documents>(Docs);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append map value in document)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document_map_value_timestamp\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // Map value to append\n        Values::MapValue mapV(\"name\", Values::StringValue(\"value\" + String(counter)));\n        mapV.add(\"count\", Values::StringValue(String(counter)));\n\n        Values::MapValue mapV2(\"key\" + String(counter), mapV);\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV2));\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */));\n\n        String fieldPath = \"myMap.key\" + String(counter) + \".timestamp\";\n        // See https://firebase.google.com/docs/firestore/reference/rest/v1/Write#servervalue\n        FieldTransform::SetToServerValue setValue(FieldTransform::REQUEST_TIME);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, setValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        writes.add(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // All Writes, DocumentTransform and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "eeprom"
      ],
      "libraries": [
        "Arduino.h",
        "AT24CM01.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); \n\n  EEPROM.begin();                                               \n\n  EEPROM.write(0, test);                              // write data to address 0\n  test_recieve = EEPROM.read(0, test_size);           // read data from address 0, of ul size\n  Serial.println(test_recieve);\n\n  EEPROM.write(0 + test_size, test);                  // repeat, adding size to last address\n  test_recieve = EEPROM.read(0, test_size);\n  Serial.print(test_recieve);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "current",
        "delay",
        "tone",
        "display",
        "eeprom",
        "flash"
      ],
      "libraries": [
        "MicroGamer.h",
        "MicroGamerMemoryCard.h",
        "MicroGamerTones.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "mg.begin();\n  mg.setFrameRate(40);\n  mg.initRandomSeed();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// pause render until it's time for the next frame\n  if (!(mg.nextFrame()))\n    return;\n\n  //Title screen loop switches from title screen\n  //and high scores until FIRE is pressed\n  while (!start)\n  {\n    start = titleScreen();\n    if (!start)\n    {\n      start = displayHighScores(EE_FILE);\n    }\n  }\n\n  //Initial level draw\n  if (!initialDraw)\n  {\n    //Clears the screen\n    mg.clear();\n    //Selects Font\n    //Draws the new level\n    level = 1;\n    newLevel();\n    score = 0;\n    initialDraw=true;\n  }\n\n  if (lives>0)\n  {\n    drawPaddle();\n\n    //Pause game if FIRE pressed\n    pad = mg.pressed(Y_BUTTON) || mg.pressed(X_BUTTON);\n\n    if(pad == true && oldpad == false && released)\n    {\n      oldpad2 = false; //Forces pad loop 2 to run once\n      pause();\n    }\n\n    oldpad = pad;\n    drawBall();\n\n    if(brickCount == ROWS * COLUMNS)\n    {\n      level++;\n      newLevel();\n    }\n  }\n  else\n  {\n    drawGameOver();\n    if (score > 0)\n    {\n      enterHighScore(EE_FILE);\n    }\n\n    mg.clear();\n    initialDraw=false;\n    start=false;\n    lives=3;\n    newLevel();\n  }\n\n  mg.display();"
        },
        {
          "name": "movePaddle",
          "parameters": "",
          "body": "//Move right\n  if(xPaddle < WIDTH - 12)\n  {\n    if (mg.pressed(RIGHT_BUTTON))\n    {\n      xPaddle+=2;\n    }\n  }\n\n  //Move left\n  if(xPaddle > 0)\n  {\n    if (mg.pressed(LEFT_BUTTON))\n    {\n      xPaddle-=2;\n    }\n  }"
        },
        {
          "name": "moveBall",
          "parameters": "",
          "body": "tick++;\n  if(released)\n  {\n    //Move ball\n    if (abs(dx)==2) {\n      xb += dx/2;\n      // 2x speed is really 1.5 speed\n      if (tick%2==0)\n        xb += dx/2;\n    } else {\n      xb += dx;\n    }\n    yb=yb + dy;\n\n    //Set bounds\n    leftBall = xb;\n    rightBall = xb + 2;\n    topBall = yb;\n    bottomBall = yb + 2;\n\n    //Bounce off top edge\n    if (yb <= 0)\n    {\n      yb = 2;\n      dy = -dy;\n      playTone(523, 250);\n    }\n\n    //Lose a life if bottom edge hit\n    if (yb >= 64)\n    {\n      mg.drawRect(xPaddle, 63, 11, 1, 0);\n      xPaddle = 54;\n      yb=60;\n      released = false;\n      lives--;\n      playTone(175, 250);\n      if (random(0, 2) == 0)\n      {\n        dx = 1;\n      }\n      else\n      {\n        dx = -1;\n      }\n    }\n\n    //Bounce off left side\n    if (xb <= 0)\n    {\n      xb = 2;\n      dx = -dx;\n      playTone(523, 250);\n    }\n\n    //Bounce off right side\n    if (xb >= WIDTH - 2)\n    {\n      xb = WIDTH - 4;\n      dx = -dx;\n      playTone(523, 250);\n    }\n\n    //Bounce off paddle\n    if (xb+1>=xPaddle && xb<=xPaddle+12 && yb+2>=63 && yb<=64)\n    {\n      dy = -dy;\n      dx = ((xb-(xPaddle+6))/3); //Applies spin on the ball\n      // prevent straight bounce\n      if (dx == 0) {\n        dx = (random(0,2) == 1) ? 1 : -1;\n      }\n      playTone(200, 250);\n    }\n\n    //Bounce off Bricks\n    for (byte row = 0; row < ROWS; row++)\n    {\n      for (byte column = 0; column < COLUMNS; column++)\n      {\n        if (!isHit[row][column])\n        {\n          //Sets Brick bounds\n          leftBrick = 10 * column;\n          rightBrick = 10 * column + 10;\n          topBrick = 6 * row + 1;\n          bottomBrick = 6 * row + 7;\n\n          //If A collison has occured\n          if (topBall <= bottomBrick && bottomBall >= topBrick &&\n              leftBall <= rightBrick && rightBall >= leftBrick)\n          {\n            Score();\n            brickCount++;\n            isHit[row][column] = true;\n            mg.drawRect(10*column, 2+6*row, 8, 4, 0);\n\n            //Vertical collision\n            if (bottomBall > bottomBrick || topBall < topBrick)\n            {\n              //Only bounce once each ball move\n              if(!bounced)\n              {\n                dy =- dy;\n                yb += dy;\n                bounced = true;\n                playTone(261, 250);\n              }\n            }\n\n            //Hoizontal collision\n            if (leftBall < leftBrick || rightBall > rightBrick)\n            {\n              //Only bounce once brick each ball move\n              if(!bounced)\n              {\n                dx =- dx;\n                xb += dx;\n                bounced = true;\n                playTone(261, 250);\n              }\n            }\n          }\n        }\n      }\n    }\n    //Reset Bounce\n    bounced = false;\n  }\n  else\n  {\n    //Ball follows paddle\n    xb=xPaddle + 5;\n\n    //Release ball if FIRE pressed\n    pad3 = mg.pressed(Y_BUTTON) || mg.pressed(X_BUTTON);\n    if (pad3 == true && oldpad3 == false)\n    {\n      released = true;\n\n      //Apply random direction to ball on release\n      if (random(0, 2) == 0)\n      {\n        dx = 1;\n      }\n      else\n      {\n        dx = -1;\n      }\n      //Makes sure the ball heads upwards\n      dy = -1;\n    }\n    oldpad3 = pad3;\n  }"
        },
        {
          "name": "drawBall",
          "parameters": "",
          "body": "// mg.setCursor(0,0);\n  // mg.print(mg.cpuLoad());\n  // mg.print(\"  \");\n  mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n\n  moveBall();\n\n  mg.drawPixel(xb,   yb,   1);\n  mg.drawPixel(xb+1, yb,   1);\n  mg.drawPixel(xb,   yb+1, 1);\n  mg.drawPixel(xb+1, yb+1, 1);"
        },
        {
          "name": "drawPaddle",
          "parameters": "",
          "body": "mg.drawRect(xPaddle, 63, 11, 1, 0);\n  movePaddle();\n  mg.drawRect(xPaddle, 63, 11, 1, 1);"
        },
        {
          "name": "drawGameOver",
          "parameters": "",
          "body": "mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n  mg.setCursor(37, 42);\n  mg.print(\"Game Over\");\n  mg.setCursor(31, 56);\n  mg.print(\"Score: \");\n  mg.print(score);\n  mg.display();\n  delay(4000);"
        },
        {
          "name": "pause",
          "parameters": "",
          "body": "paused = true;\n  //Draw pause to the screen\n  mg.setCursor(52, 45);\n  mg.print(\"PAUSE\");\n  mg.display();\n  while (paused)\n  {\n    delay(150);\n    //Unpause if FIRE is pressed\n    pad2 = mg.pressed(Y_BUTTON) || mg.pressed(X_BUTTON);\n    if (pad2 == true && oldpad2 == false && released)\n    {\n        mg.fillRect(52, 45, 30, 11, 0);\n\n        paused=false;\n    }\n    oldpad2 = pad2;\n  }"
        },
        {
          "name": "Score",
          "parameters": "",
          "body": "score += (level*10);"
        },
        {
          "name": "newLevel",
          "parameters": "",
          "body": "//Undraw paddle\n  mg.drawRect(xPaddle, 63, 11, 1, 0);\n\n  //Undraw ball\n  mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n\n  //Alter various variables to reset the game\n  xPaddle = 54;\n  yb = 60;\n  brickCount = 0;\n  released = false;\n\n  //Draws new bricks and resets their values\n  for (byte row = 0; row < 4; row++) {\n    for (byte column = 0; column < 13; column++)\n    {\n      isHit[row][column] = false;\n      mg.drawRect(10*column, 2+6*row, 8, 4, 1);\n    }\n  }\n\n  mg.display();"
        },
        {
          "name": "enterInitials",
          "parameters": "",
          "body": "byte index = 0;\n\n  mg.clear();\n\n  initials[0] = ' ';\n  initials[1] = ' ';\n  initials[2] = ' ';\n\n  while (true)\n  {\n    mg.display();\n    mg.clear();\n\n    mg.setCursor(16,0);\n    mg.print(\"HIGH SCORE\");\n    sprintf(text_buffer, \"%u\", score);\n    mg.setCursor(88, 0);\n    mg.print(text_buffer);\n    mg.setCursor(56, 20);\n    mg.print(initials[0]);\n    mg.setCursor(64, 20);\n    mg.print(initials[1]);\n    mg.setCursor(72, 20);\n    mg.print(initials[2]);\n    for(byte i = 0; i < 3; i++)\n    {\n      mg.drawLine(56 + (i*8), 27, 56 + (i*8) + 6, 27, 1);\n    }\n    mg.drawLine(56, 28, 88, 28, 0);\n    mg.drawLine(56 + (index*8), 28, 56 + (index*8) + 6, 28, 1);\n    delay(150);\n\n    if (mg.pressed(LEFT_BUTTON) || mg.pressed(X_BUTTON))\n    {\n      if (index > 0)\n      {\n        index--;\n        playTone(1046, 250);\n      }\n    }\n\n    if (mg.pressed(RIGHT_BUTTON))\n    {\n      if (index < 2)\n      {\n        index++;\n        playTone(1046, 250);\n      }\n    }\n\n    if (mg.pressed(DOWN_BUTTON))\n    {\n      initials[index]++;\n      playTone(523, 250);\n      // A-Z 0-9 :-? !-/ ' '\n      if (initials[index] == '0')\n      {\n        initials[index] = ' ';\n      }\n      if (initials[index] == '!')\n      {\n        initials[index] = 'A';\n      }\n      if (initials[index] == '[')\n      {\n        initials[index] = '0';\n      }\n      if (initials[index] == '@')\n      {\n        initials[index] = '!';\n      }\n    }\n\n    if (mg.pressed(UP_BUTTON))\n    {\n      initials[index]--;\n      playTone(523, 250);\n      if (initials[index] == ' ') {\n        initials[index] = '?';\n      }\n      if (initials[index] == '/') {\n        initials[index] = 'Z';\n      }\n      if (initials[index] == 31) {\n        initials[index] = '/';\n      }\n      if (initials[index] == '@') {\n        initials[index] = ' ';\n      }\n    }\n\n    if (mg.pressed(Y_BUTTON))\n    {\n      if (index < 2)\n      {\n        index++;\n        playTone(1046, 250);\n      } else {\n        playTone(1046, 250);\n        return;\n      }\n    }\n  }"
        },
        {
          "name": "enterHighScore",
          "parameters": "byte file",
          "body": "// Each block of EEPROM has 7 high scores, and each high score entry\n  // is 5 bytes long:  3 bytes for initials and two bytes for score.\n  int address = file * 7 * 5 + EEPROM_STORAGE_SPACE_START;\n  byte hi, lo;\n  char tmpInitials[3];\n  unsigned int tmpScore = 0;\n\n  mem.load();\n\n  // High score processing\n  for(byte i = 0; i < 7; i++)\n  {\n    hi = mem.read(address + (5 * i));\n    lo = mem.read(address + (5 * i) + 1);\n    if ((hi == 0xFF) && (lo == 0xFF))\n    {\n      // The values are uninitialized, so treat this entry\n      // as a score of 0.\n      tmpScore = 0;\n    } else\n    {\n      tmpScore = (hi << 8) | lo;\n    }\n    if (score > tmpScore)\n    {\n      enterInitials();\n      for(byte j = i; j < 7; j++)\n      {\n        hi = mem.read(address + (5 * j));\n        lo = mem.read(address + (5 * j) + 1);\n\n        if ((hi == 0xFF) && (lo == 0xFF))\n        {\n        tmpScore = 0;\n        }\n        else\n        {\n          tmpScore = (hi << 8) | lo;\n        }\n\n        tmpInitials[0] = (char)mem.read(address + (5 * j) + 2);\n        tmpInitials[1] = (char)mem.read(address + (5 * j) + 3);\n        tmpInitials[2] = (char)mem.read(address + (5 * j) + 4);\n\n        // write score and initials to current slot\n        mem.write(address + (5 * j), ((score >> 8) & 0xFF));\n        mem.write(address + (5 * j) + 1, (score & 0xFF));\n        mem.write(address + (5 * j) + 2, initials[0]);\n        mem.write(address + (5 * j) + 3, initials[1]);\n        mem.write(address + (5 * j) + 4, initials[2]);\n\n        // tmpScore and tmpInitials now hold what we want to\n        //write in the next slot.\n        score = tmpScore;\n        initials[0] = tmpInitials[0];\n        initials[1] = tmpInitials[1];\n        initials[2] = tmpInitials[2];\n      }\n\n      score = 0;\n      initials[0] = ' ';\n      initials[1] = ' ';\n      initials[2] = ' ';\n      mem.save();\n\n      return;\n    }\n  }"
        },
        {
          "name": "playTone",
          "parameters": "unsigned int frequency, unsigned long duration",
          "body": "if (mg.audio.enabled() == true)\n  {\n    audio.tone( frequency, duration);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "ble"
      ],
      "libraries": [
        "ArduTFLite.h",
        "model.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize serial communications and wait for Serial Monitor to be opened\n  Serial.begin(9600);\n  while(!Serial);\n\n  Serial.println(\"Sine(x) function inference example.\");\n  Serial.println(\"Initializing TensorFlow Lite Micro Interpreter...\");\n  if (!modelInit(model, tensor_arena, kTensorArenaSize)){\n    Serial.println(\"Model initialization failed!\");\n    while(true);\n  }\n  Serial.println(\"Model initialization done.\");\n\n  Serial.println(\"\");\n  Serial.println(\"Please, input a float number between 0 and 6.28\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check if a value was sent from Serial Monitor\n  // if so, 'sanitize' the input and perform inference\n  if (Serial.available()){\n    String inputValue = Serial.readString();\n    float x = inputValue.toFloat(); // evaluates to zero if the user input is not a valid number\n    Serial.print(\"Your input value: \");\n    Serial.println(x);\n    // The model was trained in range 0 to 2*Pi\n    // if the value provided by user is not in this range\n    // the value is corrected substituting edge values\n    if (x<0) x = 0;\n    if (x >6.28) x = 6.28;\n    Serial.print(\"Adapted input value: \");\n    Serial.println(x);\n  \n    // Place the value in the model's input tensor\n    modelSetInput(x,0);\n\n    // Run inference, and report if an error occurs\n    if(!modelRunInference()){\n          Serial.println(\"RunInference Failed!\");\n          return;\n        }\n\n    // Obtain the output from model's output tensor\n    \n    float y = modelGetOutput(0);\n\n    Serial.print(\"Inferred Sin of \");\n    Serial.print(x);\n    Serial.print(\" = \");\n    Serial.println(y,2);\n    Serial.print(\"Actual Sin of \");\n    Serial.print(x);\n    Serial.print(\" = \");\n    Serial.println(sin(x),2);\n\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "dht11",
        "temperature",
        "humidity"
      ],
      "libraries": [
        "AccessoryShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize Serial comunication\n  Serial.begin(9600);\n  // wait for the serial port to connect, Needed for USB native only\n  while(!Serial) ;\n  // initialize the Accessory Shield library\n  accessoryShield.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// get temperarture in degrees Celsius\n  tempC = accessoryShield.getTemperature(DHT11_TEMP_CELSIUS);\n  // convert temperature from Celsius to Fareneith \n  tempF = accessoryShield.convertTempCtoF(tempC);\n  // convert temperature from Celsius to Kelvin\n  tempK = accessoryShield.convertTempCtoK(tempC);\n  // check if we have got valid values\n  if((tempC != NAN) && (tempF != NAN) && (tempK != NAN)) {\n    // print temperature in degrees Celsius\n    Serial.print(\"Temperature in Celsius degrees : \");\n    Serial.print(tempC);\n    Serial.println(\" C\");\n    // print temperature in degrees Fareneith\n    Serial.print(\"Temperature in Fareneith degrees : \");\n    Serial.print(tempF);\n    Serial.println(\" F\");\n    // print temperature in degrees Kelvin\n    Serial.print(\"Temperature in Kelvin degrees : \");\n    Serial.print(tempK);\n    Serial.println(\" K\");\n  }\n  else {\n    Serial.println(\"Impossible to get temperature from DHT11 sensor\");\n  }\n  // get humidity from DHT11\n  humidity = accessoryShield.getHumidity();\n  // check if we got a valid value (humidity value must not be NaN)\n  if(humidity != NAN) {\n    // print relative humidity value\n    Serial.print(\"Relative humidity : \");\n    Serial.print(humidity);\n    Serial.println(\" %\");\n  }\n  else {\n    Serial.println(\"Impossible to get humidity from DHT11 sensor\");\n  }\n  // compute and print the Heat Index in the Serial monitor\n  // For more info about the heat index, see the documentation\n  // in source code or follow this link :\n  // https://en.wikipedia.org/wiki/Heat_index\n  heatIndex = accessoryShield.computeHeatIndex(DHT11_TEMP_CELSIUS);\n  Serial.print(\"Heat index measured in Celsius degrees : \");\n  Serial.println(heatIndex);\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "gsm",
        "lora",
        "millis"
      ],
      "libraries": [
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n\n  /* This function takes care of connecting your sketch variables to the ArduinoIoTCloud object */\n  initProperties();\n\n  /* Initialize Arduino IoT Cloud library */\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onSwitchButtonChange",
          "parameters": "",
          "body": "if (switchButton)\n  {\n    location = Location(latMov, lonMov);\n    color    = Color(hueRed, satRed, briRed);\n  }\n  else\n  {\n    location = Location(latArd, lonArd);\n    color    = Color(hueGreen, satGreen, briGreen);\n  }"
        },
        {
          "name": "onColorChange",
          "parameters": "",
          "body": "Serial.print(\"Hue = \");\n  Serial.println(color.getValue().hue);\n  Serial.print(\"Sat = \");\n  Serial.println(color.getValue().sat);\n  Serial.print(\"Bri = \");\n  Serial.println(color.getValue().bri);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "gsm",
        "lora",
        "millis",
        "analogread",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n\n  /* Configure LED pin as an output */\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  /* This function takes care of connecting your sketch variables to the ArduinoIoTCloud object */\n  initProperties();\n\n  /* Initialize Arduino IoT Cloud library */\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoCloud.update();\n  potentiometer = analogRead(A0);\n  seconds = millis() / 1000;"
        },
        {
          "name": "onLedChange",
          "parameters": "",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "rest",
        "https",
        "callback",
        "wifi",
        "gsm",
        "lora",
        "millis",
        "analogread",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "onOTARequestCallback",
          "parameters": "",
          "body": "block_for_ota = true;\n  ota_started = true;\n  return true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_VERBOSE);\n\n  /* Configure LED pin as an output */\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  /* This function takes care of connecting your sketch variables to the ArduinoIoTCloud object */\n  initProperties();\n\n  /* Initialize Arduino IoT Cloud library */\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  /* Setup OTA callback */\n  ArduinoCloud.onOTARequestCb(onOTARequestCallback);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// When OTA is available, stay there until it completes.\n  // The rest of the loop() does not run and the sketch\n  // restarts automatically at the end of the OTA process.\n  while (block_for_ota) {\n    ArduinoCloud.update();\n    if (ota_started) {\n      Serial.print(\"Waiting for OTA to finish...\");\n      ota_started = false;\n    }\n    if (millis() > printNow) {\n      Serial.print(\".\");\n      printNow = millis() + printInterval;\n    }    \n  }\n\n  ArduinoCloud.update();\n  potentiometer = analogRead(A0);\n  seconds = millis() / 1000;\n\n  if (millis() > printNow) {\n    Serial.println(millis());\n    printNow = millis() + printInterval;\n  }"
        },
        {
          "name": "onLedChange",
          "parameters": "",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "subscribe",
        "wifi",
        "gsm",
        "lora",
        "millis"
      ],
      "libraries": [
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n\n  /* This function takes care of connecting your sketch variables to the ArduinoIoTCloud object */\n  initProperties();\n\n  /* Initialize Arduino IoT Cloud library */\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  /*\n      Invoking `addCallback` on the ArduinoCloud object allows you to subscribe\n      to any of the available events and decide which functions to call when they are fired.\n\n      The functions `doThisOnConnect`, `doThisOnSync`, `doThisOnDisconnect`\n      are custom functions and can be named to your likings and for this example\n      they are defined/implemented at the bottom of the Sketch\n  */\n  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::CONNECT, doThisOnConnect);\n  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::SYNC, doThisOnSync);\n  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::DISCONNECT, doThisOnDisconnect);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "doThisOnConnect",
          "parameters": "",
          "body": "/* add your custom code here */\n  Serial.println(\"Board successfully connected to Arduino IoT Cloud\");"
        },
        {
          "name": "doThisOnSync",
          "parameters": "",
          "body": "/* add your custom code here */\n  Serial.println(\"Thing Properties synchronised\");"
        },
        {
          "name": "doThisOnDisconnect",
          "parameters": "",
          "body": "/* add your custom code here */\n  Serial.println(\"Board disconnected from Arduino IoT Cloud\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "callback",
        "wifi",
        "millis",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "always_deny",
          "parameters": "",
          "body": "return false;"
        },
        {
          "name": "always_allow",
          "parameters": "",
          "body": "return true;"
        },
        {
          "name": "ask_user_via_serial",
          "parameters": "",
          "body": "if (ask_user_via_serial_first_run) {\n    Serial.println(\"Apply OTA? y / [n]\");\n    ask_user_via_serial_first_run = false;\n  }\n  if (Serial.available()) {\n    char c = Serial.read();\n    if (c == 'y' || c == 'Y') {\n      return true;\n    }\n  }\n  return false;"
        },
        {
          "name": "onOTARequestCallback",
          "parameters": "",
          "body": "/* Select the preferred behaviour changing the called function */\n  //return always_deny();\n  //return always_allow();\n  return ask_user_via_serial();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n\n  /* Configure LED pin as an output */\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  /* This function takes care of connecting your sketch variables to the ArduinoIoTCloud object */\n  initProperties();\n\n  /* Initialize Arduino IoT Cloud library */\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  /* Setup OTA callback */\n  ArduinoCloud.onOTARequestCb(onOTARequestCallback);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onLedChange",
          "parameters": "",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "lora",
        "millis",
        "analogread",
        "digitalwrite",
        "led",
        "interrupt"
      ],
      "libraries": [
        "Notecard.h",
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n\n  /* Configure LED pin as an output */\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  /* This function takes care of connecting your sketch variables to the ArduinoIoTCloud object */\n  initProperties();\n\n  /* Initialize Arduino IoT Cloud library */\n#ifndef ATTN_PIN\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n  ArduinoCloud.setNotecardPollingInterval(3000);  // default: 1000ms, min: 250ms\n#else\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection, ATTN_PIN);\n#endif\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoCloud.update();\n  potentiometer = analogRead(A0);\n  seconds = millis() / 1000;"
        },
        {
          "name": "onLedChange",
          "parameters": "",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wifi",
        "gsm",
        "millis",
        "digitalwrite",
        "led",
        "schedule"
      ],
      "libraries": [
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize the serial port and wait up to 5 seconds for a connection */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n\n  /* Configure LED pin as an output */\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  /* This function takes care of connecting your sketch variables to the ArduinoIoTCloud object */\n  initProperties();\n\n  /* Initialize Arduino IoT Cloud library */\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  ArduinoCloud.printDebugInfo();\n\n  /* Setup one shot schedule example */\n  setupOneShotSchedule();\n\n  /* Setup per minute schedule example */\n  setupMinuteSchedule();\n\n  /* Setup hourly schedule example */\n  setupHourlySchedule();\n\n  /* Setup daily schedule example */\n  setupDailySchedule();\n\n  /* Setup weekly schedule example */\n  setupWeeklySchedule();\n\n  /* Setup monthly schedule example */\n  setupMonthlySchedule();\n\n  /* Setup yearly schedule example */\n  setupYearlySchedule();"
        },
        {
          "name": "setupOneShotSchedule",
          "parameters": "",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = startingFrom + ( DAYS * 1 );\n  ScheduleTimeType activePeriod = MINUTES * 5;\n\n  /* Warning: there is no cross check between until and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createOneShotScheduleConfiguration();\n\n  oneShot = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupMinuteSchedule",
          "parameters": "",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = startingFrom + ( DAYS * 1 );\n  ScheduleTimeType activePeriod = SECONDS * 15;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Minutes, repetitionPeriod);\n\n  minute = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupHourlySchedule",
          "parameters": "",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = MINUTES * 20;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Hours, repetitionPeriod);\n\n  hourly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupDailySchedule",
          "parameters": "",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = HOURS * 2;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Days, repetitionPeriod);\n\n  daily = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupWeeklySchedule",
          "parameters": "",
          "body": "unsigned int startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  unsigned int until = startingFrom + ( DAYS * 30 );\n  unsigned int executionPeriod = MINUTES * 3;\n\n  ScheduleWeeklyMask WeeklyMask = {\n    ScheduleState::Inactive,   /* Sunday */\n    ScheduleState::Active,     /* Monday */\n    ScheduleState::Inactive,   /* Tuesday */\n    ScheduleState::Active,     /* Wednesday */\n    ScheduleState::Inactive,   /* Thursday */\n    ScheduleState::Active,     /* Friday */\n    ScheduleState::Inactive,   /* Saturday */\n  };\n\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createWeeklyScheduleConfiguration(WeeklyMask);\n\n  weekly = Schedule(startingFrom, until, executionPeriod, scheduleConfiguration);"
        },
        {
          "name": "setupMonthlySchedule",
          "parameters": "",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = DAYS * 1;\n  int dayOfMonth = 3;\n\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createMonthlyScheduleConfiguration(dayOfMonth);\n\n  monthly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupYearlySchedule",
          "parameters": "",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 06 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2041 Nov 06 13:00:00\");\n  ScheduleTimeType activePeriod = DAYS * 2;\n  int dayOfMonth = 6;\n\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createYearlyScheduleConfiguration(ScheduleMonth::Nov, dayOfMonth);\n\n  yearly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoCloud.update();\n\n  /* Print a message when the oneShot schedule is active */\n  if(oneShot.isActive()) {\n    Serial.println(\"One shot schedule is active\");\n  }\n\n  /* Print a message when the per minute schedule is active */\n  if(minute.isActive()) {\n    Serial.println(\"Per minute schedule is active\");\n  }\n\n  /* Print a message when the hourly schedule is active */\n  if(hourly.isActive()) {\n    Serial.println(\"Hourly schedule is active\");\n  }\n\n  /* Print a message when the daily schedule is active */\n  if(daily.isActive()) {\n    Serial.println(\"Daily schedule is active\");\n  }\n\n  /* Activate LED when the weekly schedule is active */\n  digitalWrite(LED_BUILTIN, weekly.isActive());\n\n  /* Print a message when the monthly schedule is active */\n  if(monthly.isActive()) {\n    Serial.println(\"Monthly schedule is active\");\n  }\n\n  /* Print a message when the yearly schedule is active */\n  if(yearly.isActive()) {\n    Serial.println(\"Yearly schedule is active\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "wifi",
        "gsm",
        "lora",
        "millis"
      ],
      "libraries": [
        "thingProperties.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  unsigned long serialBeginTime = millis();\n  while (!Serial && (millis() - serialBeginTime <= 5000));\n\n  Serial.println(\"Starting Arduino IoT Cloud Example\");\n\n  initProperties();\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onBoolPropertyChange",
          "parameters": "",
          "body": "Serial.println(\"'onBoolPropertyChange'\");"
        },
        {
          "name": "onIntPropertyChange",
          "parameters": "",
          "body": "Serial.println(\"'onIntPropertyChange'\");"
        },
        {
          "name": "onFloatPropertyChange",
          "parameters": "",
          "body": "Serial.println(\"'onFloatPropertyChange'\");"
        },
        {
          "name": "onStringPropertyChange",
          "parameters": "",
          "body": "Serial.println(\"'onStringPropertyChange'\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "display"
      ],
      "libraries": [
        "Arduino_H7_Video.h",
        "ArduinoGraphics.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Display.begin();\n  \n  Display.beginDraw();\n  Display.background(255, 255, 255);\n  Display.clear();\n  Display.fill(0x008184);\n  Display.circle(Display.width()/2, Display.height()/2, 300);\n  Display.stroke(255, 255, 255);\n  Display.noFill();\n  for (int i=0; i<30; i++) {\n    Display.circle((Display.width()/2)-55+5, Display.height()/2, 110-i);\n    Display.circle((Display.width()/2)+55-5, Display.height()/2, 110-i);\n  }\n  Display.fill(255, 255, 255);\n  Display.rect((Display.width()/2)-55-16+5, (Display.height()/2)-5, 32, 10);\n  Display.fill(255, 255, 255);\n  Display.rect((Display.width()/2)+55-16-5, (Display.height()/2)-5, 32, 10);\n  Display.fill(255, 255, 255);\n  Display.rect((Display.width()/2)+55-5-5, (Display.height()/2)-16, 10, 32);\n  Display.endDraw();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mosquitto",
        "mqtt",
        "wificlient",
        "https",
        "json",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "ArduinoMqttClient.h",
        "Arduino.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "ESP8266WiFi.h",
        "WiFi.h",
        "FirebaseJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.print(\"Attempting to connect to the MQTT broker: \");\n    Serial.println(broker);\n\n    if (!mqttClient.connect(broker, port))\n    {\n        Serial.print(\"MQTT connection failed! Error code = \");\n        Serial.println(mqttClient.connectError());\n        return;\n    }\n    mqttReady = true;\n\n    Serial.println(\"You're connected to the MQTT broker!\");\n    Serial.println();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (!mqttReady)\n        return;\n\n    mqttClient.poll();\n\n    if (millis() - lastMillis > 1000)\n    {\n        lastMillis = millis();\n\n        Serial.print(\"Sending message to topic: \");\n\n        Serial.println(topic);\n\n        FirebaseJson json;\n        json.add(\"abc\", count);\n        json.add(\"def\", count % 5 == 0);\n\n        json.toString(Serial);\n        Serial.println();\n\n        // send message, the Print interface can be used to set the message contents\n        mqttClient.beginMessage(topic);\n\n        json.toString(mqttClient);\n\n        mqttClient.endMessage();\n        count++;\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "spi",
        "millis",
        "delay",
        "digitalwrite",
        "display",
        "led",
        "tft",
        "pwm",
        "nodes",
        "devices"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "TFT_eSPI.h",
        "Button2.h",
        "bmp.h",
        "menu.h",
        "menuIO/serialIO.h",
        "menuIO/TFT_eSPIOut.h",
        "menuIO/chainStream.h",
        "menuIO/esp8266Out.h"
      ],
      "functions": [
        {
          "name": "button_init",
          "parameters": "",
          "body": "btnUp.setLongClickHandler([](Button2 & b) {\n        // Select\n        unsigned int time = b.wasPressedFor();\n        if (time >= 1000) {\n          nav.doNav(enterCmd);\n        }\n    });\n\n    btnUp.setClickHandler([](Button2 & b) {\n       // Up\n       nav.doNav(downCmd); // It's called downCmd because it decreases the index of an array. Visually that would mean the selector goes upwards.\n    });\n\n    btnDwn.setLongClickHandler([](Button2 & b) {\n        // Exit\n        unsigned int time = b.wasPressedFor();\n        if (time >= 1000) {\n          nav.doNav(escCmd);\n        }\n    });\n\n    btnDwn.setClickHandler([](Button2 & b) {\n        // Down\n        nav.doNav(upCmd); // It's called upCmd because it increases the index of an array. Visually that would mean the selector goes downwards.\n    });"
        },
        {
          "name": "button_loop",
          "parameters": "",
          "body": "// Check for button presses\n    btnUp.loop();\n    btnDwn.loop();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//options=&myOptions;//can customize options\n  Serial.begin(115200); // Set Serial baudrate at 115200\n  while(!Serial);\n  Serial.flush();\n  Serial.println();\n  Serial.print(\"ARDUINOMENU DEMO V\");\n  Serial.print(PROG_VERSION);\n  Serial.println(\" FOR LILYGO TTGO T-DISPLAY\");\n\n  nav.idleTask=idle;//point a function to be used when menu is suspended\n  mainMenu[1].disable();\n  //outGfx.usePreview=true;//reserve one panel for preview?\n  //nav.showTitle=false;//show menu title?\n\n  //SPI.begin(); // Leave this commented or else there will be nothing shown on the screen.\n  gfx.init(); // Initialize the screen.\n\n  Serial.print(\"Configuring PWM for TFT backlight... \");\n  ledcSetup(pwmLedChannelTFT, pwmFreq, pwmResolution);\n  ledcAttachPin(TFT_BL, pwmLedChannelTFT);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Setting PWM for TFT backlight to default intensity... \");\n  ledcWrite(pwmLedChannelTFT, ledBacklight);\n  Serial.println(\"DONE\");\n\n  gfx.setRotation(1); // Rotate display a quarter clockwise\n\n  gfx.setTextSize(2);\n  gfx.setTextWrap(false);\n  gfx.fillScreen(Black);\n\n  Serial.print(\"Showing bootlogo... \");\n  gfx.setSwapBytes(true);\n  gfx.pushImage(0, 0,  240, 135, bootlogo);\n  delay(1000);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Initialize buttons... \");\n  button_init();\n  delay(1000);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Initialize external led... \");\n  if(LED_CTRL > 0){\n    pinMode(LED_CTRL,OUTPUT);\n    digitalWrite(LED_CTRL,ledCtrl);\n    delay(500);\n    Serial.println(\"DONE\");\n  }\n  else{\n    delay(500);\n    Serial.println(\"NOT SET UP\");\n  }\n\n  delay(2000); // A little bit more delay so that you will be able to see the bootlogo.\n\n  Serial.println(\"- READY -\");\n\n  gfx.fillScreen(Black); // Clear the screen to be ready to draw the menu"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "button_loop();\n  nav.poll();//this device only draws when needed\n\n  // External connected led\n  if(LED_CTRL > 0){ // Only set led state when a pinnumber for the external led has been provided.\n    digitalWrite(LED_CTRL,ledCtrl);\n  }\n\n  // Set blacklight intenisty of screen\n  ledcWrite(pwmLedChannelTFT, ledBacklight);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "acceleration",
        "current",
        "ble"
      ],
      "libraries": [
        "Arduino_LSM9DS1.h",
        "Arduino_BMI270_BMM150.h",
        "ArduTFLite.h",
        "model.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  // init IMU sensor\n  if (!IMU.begin()) {\n    Serial.println(\"IMU sensor init failed!\");\n    while (true); // stop program here.\n  }\n\n  // print IMU sampling frequencies\n  Serial.print(\"Accelerometer sampling frequency = \");\n  Serial.print(IMU.accelerationSampleRate());\n  Serial.println(\" Hz\");\n  Serial.print(\"Gyroscope sampling frequency = \");\n  Serial.print(IMU.gyroscopeSampleRate());\n  Serial.println(\" Hz\");\n\n  Serial.println();\n  Serial.println(\"Init model..\");\n  if (!modelInit(model, tensorArena, tensorArenaSize)){\n    Serial.println(\"Model initialization failed!\");\n    while(true);\n  }\n  Serial.println(\"Model initialization done.\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float aX, aY, aZ, gX, gY, gZ;\n\n  // wait for a significant movement\n  while (true) {\n    if (IMU.accelerationAvailable()) {\n      // read linear acceleration\n      IMU.readAcceleration(aX, aY, aZ);\n\n      // compute absolute value of total acceleration\n      float aSum = fabs(aX) + fabs(aY) + fabs(aZ);\n\n      // if total absolute acceleration is over the threshold a gesture has started\n      if (aSum >= accelerationThreshold) {\n        samplesRead = 0; // init samples counter\n        break; // exit from waiting cycle\n      }\n    }\n  }\n\n  // reading cycle of all samples for current gesture\n  while (samplesRead < numSamples) {\n    // check if a sample is available\n    if (IMU.accelerationAvailable() && IMU.gyroscopeAvailable()) {\n      // read acceleration and gyroscope values\n      IMU.readAcceleration(aX, aY, aZ);\n      IMU.readGyroscope(gX, gY, gZ);\n\n      // normalize sensor data because model was trained using normalized data\n      aX = (aX + 4.0) / 8.0;\n      aY = (aY + 4.0) / 8.0;\n      aZ = (aZ + 4.0) / 8.0;\n      gX = (gX + 2000.0) / 4000.0;\n      gY = (gY + 2000.0) / 4000.0;\n      gZ = (gZ + 2000.0) / 4000.0;\n      \n      // put the 6 values of current sample in the proper position\n      // in the input tensor of the model\n      modelSetInput(aX,samplesRead * 6 + 0);\n      modelSetInput(aY,samplesRead * 6 + 1);\n      modelSetInput(aZ,samplesRead * 6 + 2); \n      modelSetInput(gX,samplesRead * 6 + 3);\n      modelSetInput(gY,samplesRead * 6 + 4);\n      modelSetInput(gZ,samplesRead * 6 + 5); \n      \n      samplesRead++;\n      \n      // if all samples are got, run inference\n      if (samplesRead == numSamples) {\n        if(!modelRunInference()){\n          Serial.println(\"RunInference Failed!\");\n          return;\n        }\n\n        // get output values and print as percentage\n        for (int i = 0; i < NUM_GESTURES; i++) {\n          Serial.print(GESTURES[i]);\n          Serial.print(\": \");\n          Serial.print(modelGetOutput(i)*100, 2);\n          Serial.println(\"%\");\n        }\n        Serial.println();\n      }\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "wifi",
        "deviceid"
      ],
      "libraries": [
        "RedkeaWiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    redkea.begin(ssid, pass, deviceID);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "redkea.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "wifi",
        "deviceid"
      ],
      "libraries": [
        "RedkeaWiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    redkea.begin(ssid, pass, deviceID);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "redkea.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "bluetooth",
        "delay"
      ],
      "libraries": [
        "BlynkSimpleCurieBLE.h",
        "CurieBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  delay(1000);\n\n  blePeripheral.setLocalName(\"Blynk\");\n  blePeripheral.setDeviceName(\"Blynk\");\n  blePeripheral.setAppearance(384);\n\n  Blynk.begin(blePeripheral, auth);\n\n  blePeripheral.begin();\n\n  Serial.println(\"Waiting for connections...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "blePeripheral.poll();\n  Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "nodes"
      ],
      "libraries": [
        "Arduino_DebugUtils.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "mySerial.begin(9600);\n  Debug.setDebugOutputStream(&mySerial);\n  Debug.setDebugLevel(DBG_VERBOSE);\n  Debug.timestampOn();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "DEBUG_VERBOSE(\"i = %d\", i);\n  i++;\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Arduino_DebugUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Debug.timestampOn();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "DEBUG_INFO(\"i = %d\", i);\n  i++;\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "spi",
        "digitalwrite",
        "sd",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "spi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet2.h",
        "BlynkSimpleEthernet2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, \"blynk-cloud.com\", 80);\n  //Blynk.begin(auth, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "spi",
        "digitalwrite",
        "sd",
        "gateway_ip",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, server_ip, 8080, arduino_ip, dns_ip, gateway_ip, subnet_mask, arduino_mac);\n  // Or like this:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80, arduino_ip, dns_ip, gateway_ip, subnet_mask, arduino_mac);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "api",
        "https",
        "password",
        "token",
        "json",
        "gsm",
        "gprs",
        "delay",
        "millis",
        "display"
      ],
      "libraries": [
        "GSM.h"
      ],
      "functions": [
        {
          "name": "connectNetwork",
          "parameters": "",
          "body": "Serial.println(\"Connecting to GSM...\");\n  bool status = false;\n\n  // After starting the modem with GSM.begin()\n  // attach the shield to the GPRS network with the APN, login and password\n  while (status == false) {\n    if ((gsmAccess.begin(PINNUMBER) == GSM_READY) &\n        (gprs.attachGPRS(GPRS_APN, GPRS_LOGIN, GPRS_PASSWORD) == GPRS_READY)) {\n      status = true;\n    } else {\n      Serial.print(\".\");\n      delay(1000);\n    }\n  }\n\n  Serial.println();\n  Serial.println(\"GSM connected\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  delay(10);\n  Serial.println();\n  Serial.println();\n\n  connectNetwork();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "String response;\n\n  unsigned long value = millis();\n\n  // Send value to the cloud\n  // similar to Blynk.virtualWrite()\n\n  Serial.print(\"Sending value: \");\n  Serial.println(value);\n\n  if (httpRequest(\"GET\", String(\"/external/api/update?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2&value=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);\n    }\n  }\n\n  // Read the value back\n  // similar to Blynk.syncVirtual()\n\n  Serial.println(\"Reading value\");\n\n  if (httpRequest(\"GET\", String(\"/external/api/get?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2\", \"\", response)) {\n    Serial.print(\"Value from server: \");\n    Serial.println(response);\n  }\n\n  // Set Property\n  Serial.println(\"Setting property\");\n\n  if (httpRequest(\"GET\", String(\"/external/api/update/property?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2&label=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);\n    }\n  }\n\n  // For more HTTP API, see https://docs.blynk.io/en/blynk.cloud/https-api-overview\n\n  // Wait\n  delay(30000L);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "spi",
        "wifi",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "BlynkSimpleMKR1000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "spi",
        "wifi",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "WiFiNINA.h",
        "BlynkSimpleWiFiNINA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "gsm",
        "gprs",
        "spi",
        "millis",
        "delay",
        "digitalwrite",
        "sd"
      ],
      "libraries": [
        "BlynkMultiClient.h",
        "SPI.h",
        "Ethernet.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "connectEthernet",
          "parameters": "",
          "body": "if (Ethernet.begin(ETH_MAC, 5000L, 500L)) {\n    Serial.print(\"Ethernet IP: \");\n    Serial.println(Ethernet.localIP());\n  } else if (Ethernet.hardwareStatus() == EthernetNoHardware) {\n    Serial.println(\"Ethernet shield was not found.\");\n  } else if (Ethernet.linkStatus() == LinkOFF) {\n    Serial.println(\"Ethernet cable is not connected.\");\n  } else {\n    Serial.println(\"Ethernet: DHCP configuration failed.\");\n  }"
        },
        {
          "name": "connectGPRS",
          "parameters": "",
          "body": "bool gsmConnected = false;\n  bool gprsConnected = false;\n\n  const uint32_t tstart = millis();\n  while (millis() - tstart < 20000) {\n    if (gsmAccess.begin(SIM_PIN) == GSM_READY) {\n      gsmConnected = true;\n      break;\n    }\n    delay(1000);\n  }\n  while (gsmConnected && millis() - tstart < 20000) {\n    if (gprs.attachGPRS(GPRS_APN, GPRS_USER, GPRS_PASS) == GPRS_READY) {\n      gprsConnected = true;\n      break;\n    }\n    delay(1000);\n  }\n\n  if (!gsmConnected) {\n    Serial.println(\"GSM not connected.\");\n  } else if (!gprsConnected) {\n    Serial.println(\"GPRS not connected.\");\n  } else {\n    Serial.print(\"GPRS IP: \");\n    Serial.println(gprs.getIPAddress());\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n\n  // Deselect the SD card\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH);\n\n  // Initialize Ethernet shield\n  Ethernet.init(MKRETH_CS);\n\n  connectEthernet();\n  connectGPRS();\n\n  // Setup Blynk\n  Blynk.addClient(\"ETH\", blynkEthernetClient, 80);\n  Blynk.addClient(\"GSM\", blynkGsmClient,      80);\n  Blynk.config(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  Ethernet.maintain();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "buffer",
        "gsm",
        "gprs",
        "spi",
        "ntp",
        "millis",
        "delay",
        "digitalwrite",
        "sd",
        "timestamp"
      ],
      "libraries": [
        "BlynkMultiClient.h",
        "SPI.h",
        "Ethernet.h",
        "ArduinoECCX08.h",
        "ArduinoBearSSL.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "connectEthernet",
          "parameters": "",
          "body": "if (Ethernet.begin(ETH_MAC, 5000L, 500L)) {\n    Serial.print(\"Ethernet IP: \");\n    Serial.println(Ethernet.localIP());\n  } else if (Ethernet.hardwareStatus() == EthernetNoHardware) {\n    Serial.println(\"Ethernet shield was not found.\");\n  } else if (Ethernet.linkStatus() == LinkOFF) {\n    Serial.println(\"Ethernet cable is not connected.\");\n  } else {\n    Serial.println(\"Ethernet: DHCP configuration failed.\");\n  }"
        },
        {
          "name": "connectGPRS",
          "parameters": "",
          "body": "bool gsmConnected = false;\n  bool gprsConnected = false;\n\n  const uint32_t tstart = millis();\n  while (millis() - tstart < 20000) {\n    if (gsmAccess.begin(SIM_PIN) == GSM_READY) {\n      gsmConnected = true;\n      break;\n    }\n    delay(1000);\n  }\n  while (gsmConnected && millis() - tstart < 20000) {\n    if (gprs.attachGPRS(GPRS_APN, GPRS_USER, GPRS_PASS) == GPRS_READY) {\n      gprsConnected = true;\n      break;\n    }\n    delay(1000);\n  }\n\n  if (!gsmConnected) {\n    Serial.println(\"GSM not connected.\");\n  } else if (!gprsConnected) {\n    Serial.println(\"GPRS not connected.\");\n  } else {\n    Serial.print(\"GPRS IP: \");\n    Serial.println(gprs.getIPAddress());\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n\n  // Deselect the SD card\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH);\n\n  // Initialize Ethernet shield\n  Ethernet.init(MKRETH_CS);\n\n  // Enable NTP time helper (needed for SSL authentiction)\n  ArduinoBearSSL.onGetTime(ntpGetTime);\n\n  connectEthernet();\n  connectGPRS();\n\n  // Setup Blynk\n  Blynk.addClient(\"ETH\", blynkEthernetClientSSL,  443);\n  Blynk.addClient(\"GSM\", blynkGsmClientSSL,       443);\n\n  Blynk.config(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  Ethernet.maintain();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "spi",
        "gprs",
        "gsm"
      ],
      "libraries": [
        "SPI.h",
        "MKRGSM.h",
        "BlynkSimpleMKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, gsmAccess, gprs, client, pin, apn, user, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "gprs"
      ],
      "libraries": [
        "MKRNB.h",
        "BlynkSimpleMKRNB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n  Blynk.begin(BLYNK_AUTH_TOKEN, nbAccess, gprs, client, pin);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "spi",
        "digitalwrite",
        "sd",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Ethernet.init(MKRETH_CS);      // Init MKR ETH shield\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "spi",
        "ntp",
        "digitalwrite",
        "sd",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "ArduinoECCX08.h",
        "ArduinoBearSSL.h",
        "BlynkSimpleEthernetSSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Ethernet.init(MKRETH_CS);      // Init MKR ETH shield\n\n  // Enable NTP time helper (needed for SSL authentiction)\n  ArduinoBearSSL.onGetTime(ntpGetTime);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token"
      ],
      "libraries": [
        "BlynkSimpleStream.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Blynk will work through SoftwareSerial\n  // Do not read or write this serial manually in your sketch\n  SwSerial.begin(9600);\n  Blynk.begin(SwSerial, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "wifi",
        "spi",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "WiFi.h",
        "BlynkSimpleWifi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "wifi",
        "spi",
        "blynk.cloud"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "BlynkSimpleWiFiShield101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "blynk.cloud"
      ],
      "libraries": [
        "Bridge.h",
        "BlynkSimpleYun.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token"
      ],
      "libraries": [
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  SerialUSB.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "wifi",
        "blynk.cloud"
      ],
      "libraries": [
        "WiFiLink.h",
        "BlynkSimpleWiFiLink.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer"
      ],
      "libraries": [
        "CircularBuffer.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// start serial\n    Serial.begin(9600);\n    while(!Serial); // Wait for the serial port to come online\n\n    // Add some values to the buffer\n    for (int i = 65; i < 65 + 6; i++) {\n        buffer.push(i);\n    }\n    \n    Serial.print(\"Size:\");\n    Serial.println(buffer.size());\n\n    // Create an array to hold the buffer's contents\n    int subArray[buffer.size()];\n\n    // Copy the buffer's contents to the array\n    buffer.copyToArray(subArray);\n\n    // Now array contains the same values as the buffer\n    for (int i = 0; i < buffer.size(); ++i) {\n        Serial.print(\"Buffer: \");\n        Serial.print(buffer[i]); \n        Serial.print(\", Array: \");\n        Serial.println(subArray[i]);\n    }\n\n    // Add some more values to the buffer\n    for (int i = 65 + 6; i < 65 + 14; i++) {\n        buffer.push(i);\n    }\n\n    Serial.print(\"Size:\");\n    Serial.println(buffer.size());\n\n    // Create an array to hold the buffer's contents\n    int array[buffer.size()];\n\n    // Copy the buffer's contents to the array\n    buffer.copyToArray(array);\n\n    // Now array contains the same values as the buffer\n    for (int i = 0; i < buffer.size(); ++i) {\n        Serial.print(\"Buffer: \");\n        Serial.print(buffer[i]); \n        Serial.print(\", Array: \");\n        Serial.println(array[i]);\n    }\n\n    // Create an array to hold the buffer's contents as chars\n    char chars[buffer.size()];\n\n    // Copy and convert the buffer's contents to the array\n    buffer.copyToArray(chars, convert);\n\n     // Now array contains the same values as the buffer\n    for (int i = 0; i < buffer.size(); ++i) {\n        Serial.print(\"Buffer: \");\n        Serial.print((char)buffer[i]); \n        Serial.print(\", Array: \");\n        Serial.println(chars[i]);\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Nothing to do here"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "wifi",
        "dns",
        "millis",
        "delay",
        "html",
        "clients"
      ],
      "libraries": [
        "defines.h",
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCaptivePortal on \");  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);\n  }\n#endif  \n\n  ///////////////////////////////////\n  \n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n   \n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n        \n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n  \n  server.begin();\n  \n  Serial.print(F(\"HTTP DNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "wifi",
        "dns",
        "millis",
        "delay",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "defines.h",
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>RP2040W-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using CYW43439 WiFi</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCaptivePortalAdvanced on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);\n  }\n#endif  \n\n  \n  ///////////////////////////////////\n  \n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n   \n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n        \n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n  \n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"HTTP DNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "wifi",
        "millis",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>ESP32_ENC-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using LAN8720A</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "wifi",
        "millis",
        "delay",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>ESP32_SC_SNC-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using ENC28J60</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "wifi",
        "millis",
        "delay",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>ESP32_SC_W5500-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using W5500</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "wifi",
        "millis",
        "delay",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>ESP32_SC_W6100-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using W6100</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "wifi",
        "millis",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>ESP32_W5500-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using W5500</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "wifi",
        "millis",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>ESP32_W6100-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using W6100</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "power",
        "dns",
        "wifi",
        "millis",
        "html",
        "clients",
        "detectors"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "isIp",
          "parameters": "String str",
          "body": "for (size_t i = 0; i < str.length(); i++)\n  {\n    int c = str.charAt(i);\n\n    if (c != '.' && (c < '0' || c > '9'))\n    {\n      return false;\n    }\n  }\n\n  return true;"
        },
        {
          "name": "toStringIp",
          "parameters": "IPAddress ip",
          "body": "String res = \"\";\n\n  for (int i = 0; i < 3; i++)\n  {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n\n  res += String(((ip >> 8 * 3)) & 0xFF);\n\n  return res;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;\n  }\n\n  String Page = F(\n                  \"<!DOCTYPE html><html lang='en'><head>\"\n                  \"<meta name='viewport' content='width=device-width'>\"\n                  \"<title>WT32_ETH01-CaptivePortal</title></head><body>\"\n                  \"<h1>HELLO WORLD!!</h1>\");\n\n  Page +=   \"<h2>From \" + String(BOARD_NAME) + \" using LAN8720A</h2>\";\n\n  AsyncWebServerResponse *response = request->beginResponse(200, \"text/html\", Page);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "captivePortal",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (!isIp(request->host()))\n  {\n    Serial.println(\"Request redirected to captive portal\");\n\n    // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    AsyncWebServerResponse *response = request->beginResponse(302, \"text/plain\", \"\");\n    response->addHeader(\"Location\", String(\"http://\") + toStringIp(request->client()->localIP()));\n\n    request->send(response);\n\n    request->client()->stop(); // Stop is needed because we sent no content length\n\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;\n  }\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += String(F(\" \")) + request->argName(i) + F(\": \") + request->arg(i) + F(\"\\n\");\n  }\n\n  AsyncWebServerResponse *response = request->beginResponse(404, \"text/plain\", message);\n  response->addHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n  response->addHeader(\"Pragma\", \"no-cache\");\n  response->addHeader(\"Expires\", \"-1\");\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncCaptivePortalAdvanced_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Android captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/generate_204\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //Microsoft captive portal. Maybe not needed. Might be handled by notFound handler.\n  server.on(\"/fwlink\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin(); // Web server start\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "html",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "html",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "html",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "html",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "html",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "html",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "power",
        "dns",
        "millis",
        "html",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncCaptivePortal_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "api",
        "https",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    Serial.println(\"\\nSending GET Request to \" + String(GET_ServerAddress));\n\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    //request.setReqHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCustomHeader on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN);\n  }\n\n#endif\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  request.setDebug(false);\n\n  // 5s timeout\n  request.setTimeout(5);\n\n  request.onReadyStateChange(requestCB);"
        },
        {
          "name": "sendRequestRepeat",
          "parameters": "",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "void",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    Serial.println(\"\\nSending GET Request to \" + String(GET_ServerAddress));\n\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    //request.setReqHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n    else\n    {\n      AHTTP_LOGERROR(F(\"Response error\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCustomHeader_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(Ethernet.localIP());\n  Serial.println();\n\n  request.setDebug(false);\n\n  // 5s timeout\n  request.setTimeout(5);\n\n  request.onReadyStateChange(requestCB);\n\n  sendHTTPRequest.start(); //start the ticker.\n\n  // Send first request now\n  delay(10000);\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "wifi",
        "dns",
        "millis",
        "delay",
        "clients"
      ],
      "libraries": [
        "defines.h",
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME) + \" using CYW43439 WiFi\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDNSServer on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);\n  }\n#endif  \n\n  ///////////////////////////////////\n  \n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n   \n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n        \n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains \n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "power",
        "dns",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncDNSServer_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "wifi",
        "dns",
        "millis",
        "delay",
        "clients"
      ],
      "libraries": [
        "defines.h",
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME) + \" using CYW43439 WiFi\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDNSServerFull on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);\n  }\n#endif  \n\n  ///////////////////////////////////\n  \n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n   \n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n        \n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello from DNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n  \n  server.begin();\n  \n  Serial.print(F(\"HTTP DNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "power",
        "dns",
        "millis",
        "clients"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncDNSServerFull_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "parse",
        "wifi",
        "millis",
        "delay",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + dweetName + String(millis() / 1000)).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "parseResponse",
          "parameters": "String responseText",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456}}]}\n\n    You want \"content\": numberValue\n  */\n  // now parse the response looking for \"content\":\n  int labelStart = responseText.indexOf(\"content\\\":\");\n  // find the first { after \"content\":\n  int contentStart = responseText.indexOf(\"{\", labelStart);\n  // find the following } and get what's between the braces:\n  int contentEnd = responseText.indexOf(\"}\", labelStart);\n  String content = responseText.substring(contentStart + 1, contentEnd);\n\n  Serial.println(content);\n\n  // now get the value after the colon, and convert to an int:\n  int valueStart = content.indexOf(\":\");\n  String valueString = content.substring(valueStart + 1);\n  int number = valueString.toInt();\n\n  Serial.print(\"Value string: \");\n  Serial.println(valueString);\n  Serial.print(\"Actual value: \");\n  Serial.println(number);"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n    }\n\n    request->setDebug(false);\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetGET on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);"
        },
        {
          "name": "sendRequestRepeat",
          "parameters": "",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "parse",
        "millis",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_Generic.h",
        "AsyncHTTPRequest_Impl_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "void",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + dweetName + String(millis() / 1000)).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "parseResponse",
          "parameters": "String responseText",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456}}]}\n\n    You want \"content\": numberValue\n  */\n  // now parse the response looking for \"content\":\n  int labelStart = responseText.indexOf(\"content\\\":\");\n  // find the first { after \"content\":\n  int contentStart = responseText.indexOf(\"{\", labelStart);\n  // find the following } and get what's between the braces:\n  int contentEnd = responseText.indexOf(\"}\", labelStart);\n  String content = responseText.substring(contentStart + 1, contentEnd);\n\n  Serial.println(content);\n\n  // now get the value after the colon, and convert to an int:\n  int valueStart = content.indexOf(\":\");\n  String valueString = content.substring(valueStart + 1);\n  int number = valueString.toInt();\n\n  Serial.print(\"Value string: \");\n  Serial.println(valueString);\n  Serial.print(\"Actual value: \");\n  Serial.println(number);"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      //Serial.println(request->responseText());\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n\n      request->setDebug(false);\n    }\n    else\n    {\n      AHTTP_LOGERROR(F(\"Response error\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetGET_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(Ethernet.localIP());\n  Serial.println();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  sendHTTPRequest.start(); //start the ticker."
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "parse",
        "wifi",
        "analogread",
        "millis",
        "delay",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    String postData = \"sensorValue=\";\n    postData += analogRead(A0);\n\n    Serial.println(\"\\nMaking new POST request\");\n\n    requestOpenResult = request.open(\"POST\", (POST_ServerAddress + dweetName + postData).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "parseResponse",
          "parameters": "String responseText",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456}}]}\n\n    You want \"content\": numberValue\n  */\n  // now parse the response looking for \"content\":\n  int labelStart = responseText.indexOf(\"content\\\":\");\n  // find the first { after \"content\":\n  int contentStart = responseText.indexOf(\"{\", labelStart);\n  // find the following } and get what's between the braces:\n  int contentEnd = responseText.indexOf(\"}\", labelStart);\n  String content = responseText.substring(contentStart + 1, contentEnd);\n\n  Serial.println(content);\n\n  // now get the value after the colon, and convert to an int:\n  int valueStart = content.indexOf(\":\");\n  String valueString = content.substring(valueStart + 1);\n  int number = valueString.toInt();\n\n  Serial.print(\"Value string: \");\n  Serial.println(valueString);\n  Serial.print(\"Actual value: \");\n  Serial.println(number);"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n    }\n\n    request->setDebug(false);\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetPOST on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);"
        },
        {
          "name": "sendRequestRepeat",
          "parameters": "",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "parse",
        "millis",
        "analogread",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "void",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    String postData = \"sensorValue=\";\n    postData += analogRead(A0);\n\n    Serial.println(\"\\nMaking new POST request\");\n\n    requestOpenResult = request.open(\"POST\", (POST_ServerAddress + dweetName + postData).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "parseResponse",
          "parameters": "String responseText",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456}}]}\n\n    You want \"content\": numberValue\n  */\n  // now parse the response looking for \"content\":\n  int labelStart = responseText.indexOf(\"content\\\":\");\n  // find the first { after \"content\":\n  int contentStart = responseText.indexOf(\"{\", labelStart);\n  // find the following } and get what's between the braces:\n  int contentEnd = responseText.indexOf(\"}\", labelStart);\n  String content = responseText.substring(contentStart + 1, contentEnd);\n\n  Serial.println(content);\n\n  // now get the value after the colon, and convert to an int:\n  int valueStart = content.indexOf(\":\");\n  String valueString = content.substring(valueStart + 1);\n  int number = valueString.toInt();\n\n  Serial.print(\"Value string: \");\n  Serial.println(valueString);\n  Serial.print(\"Actual value: \");\n  Serial.println(number);"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      //Serial.println(request->responseText());\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n\n      request->setDebug(false);\n    }\n    else\n    {\n      AHTTP_LOGERROR(F(\"Response error\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetPOST_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(Ethernet.localIP());\n  Serial.println();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  sendHTTPRequest.start(); //start the ticker."
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "delay",
        "millis",
        "flash"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if (type == WS_EVT_CONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n       \n    client->printf(\"Hello Client %lu :)\", client->id());\n    client->ping();\n  } \n  else if (type == WS_EVT_DISCONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] disconnect\\n\", server->url(), client->id());\n  } \n  else if (type == WS_EVT_ERROR) \n  {\n    Serial.printf(\"ws[%s][%u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\n  } \n  else if (type == WS_EVT_PONG) \n  {\n    Serial.printf(\"ws[%s][%u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len) ? (char*)data : \"\");\n  } \n  else if (type == WS_EVT_DATA) \n  {\n    AwsFrameInfo * info = (AwsFrameInfo*)arg;\n    String msg = \"\";\n    \n    if (info->final && info->index == 0 && info->len == len) \n    {\n      //the whole message is in a single frame and we got all of it's data\n      Serial.printf(\"ws[%s][%u] %s-message[%llu]: \", server->url(), client->id(), (info->opcode == WS_TEXT) ? \"text\" : \"binary\", info->len);\n\n      if (info->opcode == WS_TEXT) \n      {\n        for (size_t i = 0; i < info->len; i++) \n        {\n          msg += (char) data[i];\n        }\n      } \n      else \n      {\n        char buff[6];\n        \n        for (size_t i = 0; i < info->len; i++) \n        {\n          sprintf(buff, \"%02x \", (uint8_t) data[i]);\n          msg += buff ;\n        }\n      }\n      \n      Serial.printf(\"%s\\n\", msg.c_str());\n\n      if (info->opcode == WS_TEXT)\n        client->text(\"I got your text message\");\n      else\n        client->binary(\"I got your binary message\");\n    } \n    else \n    {\n      //message is comprised of multiple frames or the frame is split into multiple packets\n      \n      if (info->index == 0) \n      {\n        if (info->num == 0)\n          Serial.printf(\"ws[%s][%u] %s-message start\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n          \n        Serial.printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n      }\n\n      Serial.printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(), info->num, (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\", info->index, info->index + len);\n\n      if (info->opcode == WS_TEXT) \n      {\n        for (size_t i = 0; i < len; i++) \n        {\n          msg += (char) data[i];\n        }\n      } \n      else \n      {\n        char buff[6];\n        \n        for (size_t i = 0; i < len; i++) \n        {\n          sprintf(buff, \"%02x \", (uint8_t) data[i]);\n          msg += buff ;\n        }\n      }\n      \n      Serial.printf(\"%s\\n\", msg.c_str());\n\n      if ((info->index + len) == info->len) \n      {\n        Serial.printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n        \n        if (info->final) \n        {\n          Serial.printf(\"ws[%s][%u] %s-message end\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n          \n          if (info->message_opcode == WS_TEXT)\n            client->text(\"I got your text message\");\n          else\n            client->binary(\"I got your binary message\");\n        }\n      }\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n \n  Serial.printf(\"\\nStarting AsyncFSBrowser_STM32 on %s with %s\\n\", BOARD_NAME, SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n \n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n \n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);\n  });\n  \n  server.addHandler(&events);\n\n  server.on(\"/board\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", String(BOARD_NAME));\n  });\n\n  server.onNotFound([](AsyncWebServerRequest * request) \n  {\n    Serial.printf(\"NOT_FOUND: \");\n    if (request->method() == HTTP_GET)\n      Serial.printf(\"GET\");\n    else if (request->method() == HTTP_POST)\n      Serial.printf(\"POST\");\n    else if (request->method() == HTTP_DELETE)\n      Serial.printf(\"DELETE\");\n    else if (request->method() == HTTP_PUT)\n      Serial.printf(\"PUT\");\n    else if (request->method() == HTTP_PATCH)\n      Serial.printf(\"PATCH\");\n    else if (request->method() == HTTP_HEAD)\n      Serial.printf(\"HEAD\");\n    else if (request->method() == HTTP_OPTIONS)\n      Serial.printf(\"OPTIONS\");\n    else\n      Serial.printf(\"UNKNOWN\");\n    Serial.printf(\" http://%s%s\\n\", request->host().c_str(), request->url().c_str());\n\n    if (request->contentLength()) \n    {\n      Serial.printf(\"_CONTENT_TYPE: %s\\n\", request->contentType().c_str());\n      Serial.printf(\"_CONTENT_LENGTH: %u\\n\", request->contentLength());\n    }\n\n    int headers = request->headers();\n    int i;\n    \n    for (i = 0; i < headers; i++) \n    {\n      AsyncWebHeader* h = request->getHeader(i);\n      Serial.printf(\"_HEADER[%s]: %s\\n\", h->name().c_str(), h->value().c_str());\n    }\n\n    int params = request->params();\n    \n    for (i = 0; i < params; i++) \n    {\n      AsyncWebParameter* p = request->getParam(i);\n      \n      if (p->isPost()) \n      {\n        Serial.printf(\"_POST[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n      } \n      else \n      {\n        Serial.printf(\"_GET[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n      }\n    }\n\n    request->send(404);\n  });\n   \n  server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total) \n  {\n    AWS_STM32_UNUSED(request);\n    \n    if (!index)\n      Serial.printf(\"BodyStart: %u\\n\", total);\n      \n    Serial.printf(\"%s\", (const char*)data);\n    \n    if (index + len == total)\n      Serial.printf(\"BodyEnd: %u\\n\", total);\n  });\n  \n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "delay",
        "millis",
        "flash"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if (type == WS_EVT_CONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n    client->printf(\"Hello Client %lu :)\", client->id());\n    client->ping();\n  } \n  else if (type == WS_EVT_DISCONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] disconnect\\n\", server->url(), client->id());\n  } \n  else if (type == WS_EVT_ERROR) \n  {\n    Serial.printf(\"ws[%s][%u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\n  } \n  else if (type == WS_EVT_PONG) \n  {\n    Serial.printf(\"ws[%s][%u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len) ? (char*)data : \"\");\n  } \n  else if (type == WS_EVT_DATA) \n  {\n    AwsFrameInfo * info = (AwsFrameInfo*)arg;\n    String msg = \"\";\n    \n    if (info->final && info->index == 0 && info->len == len) \n    {\n      //the whole message is in a single frame and we got all of it's data\n      Serial.printf(\"ws[%s][%u] %s-message[%llu]: \", server->url(), client->id(), (info->opcode == WS_TEXT) ? \"text\" : \"binary\", info->len);\n\n      if (info->opcode == WS_TEXT) \n      {\n        for (size_t i = 0; i < info->len; i++) \n        {\n          msg += (char) data[i];\n        }\n      } \n      else \n      {\n        char buff[6];\n        \n        for (size_t i = 0; i < info->len; i++) \n        {\n          sprintf(buff, \"%02x \", (uint8_t) data[i]);\n          msg += buff ;\n        }\n      }\n      \n      Serial.printf(\"%s\\n\", msg.c_str());\n\n      if (info->opcode == WS_TEXT)\n        client->text(\"I got your text message\");\n      else\n        client->binary(\"I got your binary message\");\n    } \n    else \n    {\n      //message is comprised of multiple frames or the frame is split into multiple packets\n      \n      if (info->index == 0) \n      {\n        if (info->num == 0)\n          Serial.printf(\"ws[%s][%u] %s-message start\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n          \n        Serial.printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n      }\n\n      Serial.printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(), info->num, (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\", info->index, info->index + len);\n\n      if (info->opcode == WS_TEXT) \n      {\n        for (size_t i = 0; i < len; i++) \n        {\n          msg += (char) data[i];\n        }\n      } \n      else \n      {\n        char buff[6];\n        \n        for (size_t i = 0; i < len; i++) \n        {\n          sprintf(buff, \"%02x \", (uint8_t) data[i]);\n          msg += buff ;\n        }\n      }\n      \n      Serial.printf(\"%s\\n\", msg.c_str());\n\n      if ((info->index + len) == info->len) \n      {\n        Serial.printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n        \n        if (info->final) \n        {\n          Serial.printf(\"ws[%s][%u] %s-message end\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n          \n          if (info->message_opcode == WS_TEXT)\n            client->text(\"I got your text message\");\n          else\n            client->binary(\"I got your binary message\");\n        }\n      }\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart AsyncFSBrowser_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n \n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n \n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);\n  });\n  \n  server.addHandler(&events);\n\n  server.on(\"/board\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", String(BOARD_NAME));\n  });\n\n  server.onNotFound([](AsyncWebServerRequest * request) \n  {\n    Serial.printf(\"NOT_FOUND: \");\n    if (request->method() == HTTP_GET)\n      Serial.printf(\"GET\");\n    else if (request->method() == HTTP_POST)\n      Serial.printf(\"POST\");\n    else if (request->method() == HTTP_DELETE)\n      Serial.printf(\"DELETE\");\n    else if (request->method() == HTTP_PUT)\n      Serial.printf(\"PUT\");\n    else if (request->method() == HTTP_PATCH)\n      Serial.printf(\"PATCH\");\n    else if (request->method() == HTTP_HEAD)\n      Serial.printf(\"HEAD\");\n    else if (request->method() == HTTP_OPTIONS)\n      Serial.printf(\"OPTIONS\");\n    else\n      Serial.printf(\"UNKNOWN\");\n    Serial.printf(\" http://%s%s\\n\", request->host().c_str(), request->url().c_str());\n\n    if (request->contentLength()) \n    {\n      Serial.printf(\"_CONTENT_TYPE: %s\\n\", request->contentType().c_str());\n      Serial.printf(\"_CONTENT_LENGTH: %u\\n\", request->contentLength());\n    }\n\n    int headers = request->headers();\n    int i;\n    \n    for (i = 0; i < headers; i++) \n    {\n      AsyncWebHeader* h = request->getHeader(i);\n      Serial.printf(\"_HEADER[%s]: %s\\n\", h->name().c_str(), h->value().c_str());\n    }\n\n    int params = request->params();\n    \n    for (i = 0; i < params; i++) \n    {\n      AsyncWebParameter* p = request->getParam(i);\n      \n      if (p->isPost()) \n      {\n        Serial.printf(\"_POST[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n      } \n      else \n      {\n        Serial.printf(\"_GET[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n      }\n    }\n\n    request->send(404);\n  });\n   \n  server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total) \n  {\n    AWS_STM32_UNUSED(request);\n    \n    if (!index)\n      Serial.printf(\"BodyStart: %u\\n\", total);\n      \n    Serial.printf(\"%s\", (const char*)data);\n    \n    if (index + len == total)\n      Serial.printf(\"BodyEnd: %u\\n\", total);\n  });\n  \n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "power",
        "dns",
        "millis",
        "delay"
      ],
      "libraries": [
        "mbedtls/version.h",
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\n\t\tclient->printf(\"Hello Client %u :)\", client->id());\n\t\tclient->ping();\n\t}\n\telse if (type == WS_EVT_DISCONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] disconnect\\n\", server->url(), client->id());\n\t}\n\telse if (type == WS_EVT_ERROR)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\n\t}\n\telse if (type == WS_EVT_PONG)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len) ? (char*)data : \"\");\n\t}\n\telse if (type == WS_EVT_DATA)\n\t{\n\t\tAwsFrameInfo * info = (AwsFrameInfo*)arg;\n\t\tString msg = \"\";\n\n\t\tif (info->final && info->index == 0 && info->len == len)\n\t\t{\n\t\t\t//the whole message is in a single frame and we got all of it's data\n\t\t\tSerial.printf(\"ws[%s][%u] %s-message[%llu]: \", server->url(), client->id(), (info->opcode == WS_TEXT) ? \"text\" : \"binary\", info->len);\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < info->len; i++)\n\t\t\t\t{\n\t\t\t\t\tmsg += (char) data[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar buff[6];\n\n\t\t\t\tfor (size_t i = 0; i < info->len; i++)\n\t\t\t\t{\n\t\t\t\t\tsprintf(buff, \"%02x \", (uint8_t) data[i]);\n\t\t\t\t\tmsg += buff ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSerial.printf(\"%s\\n\", msg.c_str());\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t\tclient->text(\"I got your text message\");\n\t\t\telse\n\t\t\t\tclient->binary(\"I got your binary message\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//message is comprised of multiple frames or the frame is split into multiple packets\n\n\t\t\tif (info->index == 0)\n\t\t\t{\n\t\t\t\tif (info->num == 0)\n\t\t\t\t\tSerial.printf(\"ws[%s][%u] %s-message start\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\n\t\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\t\t\t}\n\n\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(), info->num, (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\", info->index, info->index + len);\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tmsg += (char) data[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar buff[6];\n\n\t\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tsprintf(buff, \"%02x \", (uint8_t) data[i]);\n\t\t\t\t\tmsg += buff ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSerial.printf(\"%s\\n\", msg.c_str());\n\n\t\t\tif ((info->index + len) == info->len)\n\t\t\t{\n\t\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\n\t\t\t\tif (info->final)\n\t\t\t\t{\n\t\t\t\t\tSerial.printf(\"ws[%s][%u] %s-message end\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\n\t\t\t\t\tif (info->message_opcode == WS_TEXT)\n\t\t\t\t\t\tclient->text(\"I got your text message\");\n\t\t\t\t\telse\n\t\t\t\t\t\tclient->binary(\"I got your binary message\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(F(\"\\nStart AsyncFSBrowser_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);\n\t});\n\n\tserver.addHandler(&events);\n\n\tserver.on(\"/board\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", String(BOARD_NAME));\n\t});\n\n\tserver.onNotFound([](AsyncWebServerRequest * request)\n\t{\n\t\tSerial.printf(\"NOT_FOUND: \");\n\n\t\tif (request->method() == HTTP_GET)\n\t\t\tSerial.printf(\"GET\");\n\t\telse if (request->method() == HTTP_POST)\n\t\t\tSerial.printf(\"POST\");\n\t\telse if (request->method() == HTTP_DELETE)\n\t\t\tSerial.printf(\"DELETE\");\n\t\telse if (request->method() == HTTP_PUT)\n\t\t\tSerial.printf(\"PUT\");\n\t\telse if (request->method() == HTTP_PATCH)\n\t\t\tSerial.printf(\"PATCH\");\n\t\telse if (request->method() == HTTP_HEAD)\n\t\t\tSerial.printf(\"HEAD\");\n\t\telse if (request->method() == HTTP_OPTIONS)\n\t\t\tSerial.printf(\"OPTIONS\");\n\t\telse\n\t\t\tSerial.printf(\"UNKNOWN\");\n\n\t\tSerial.printf(\" http://%s%s\\n\", request->host().c_str(), request->url().c_str());\n\n\t\tif (request->contentLength())\n\t\t{\n\t\t\tSerial.printf(\"_CONTENT_TYPE: %s\\n\", request->contentType().c_str());\n\t\t\tSerial.printf(\"_CONTENT_LENGTH: %u\\n\", request->contentLength());\n\t\t}\n\n\t\tint headers = request->headers();\n\t\tint i;\n\n\t\tfor (i = 0; i < headers; i++)\n\t\t{\n\t\t\tAsyncWebHeader* h = request->getHeader(i);\n\t\t\tSerial.printf(\"_HEADER[%s]: %s\\n\", h->name().c_str(), h->value().c_str());\n\t\t}\n\n\t\tint params = request->params();\n\n\t\tfor (i = 0; i < params; i++)\n\t\t{\n\t\t\tAsyncWebParameter* p = request->getParam(i);\n\n\t\t\tif (p->isPost())\n\t\t\t{\n\t\t\t\tSerial.printf(\"_POST[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSerial.printf(\"_GET[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n\t\t\t}\n\t\t}\n\n\t\trequest->send(404);\n\t});\n\n\tserver.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total)\n\t{\n\t\t(void) request;\n\n\t\tif (!index)\n\t\t\tSerial.printf(\"BodyStart: %u\\n\", total);\n\n\t\tSerial.printf(\"%s\", (const char*)data);\n\n\t\tif (index + len == total)\n\t\t\tSerial.printf(\"BodyEnd: %u\\n\", total);\n\t});\n\n\tserver.begin();\n\n\tSerial.print(\"Server started @ \");\n\tSerial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "password",
        "key",
        "wifi",
        "delay",
        "millis",
        "littlefs",
        "spiffs"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "LittleFS.h",
        "AsyncFSEditor_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\t\tclient->printf(\"Hello Client %ld :)\", client->id());\n\t\tclient->ping();\n\t}\n\telse if (type == WS_EVT_DISCONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] disconnect\\n\", server->url(), client->id());\n\t}\n\telse if (type == WS_EVT_ERROR)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\n\t}\n\telse if (type == WS_EVT_PONG)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len) ? (char*)data : \"\");\n\t}\n\telse if (type == WS_EVT_DATA)\n\t{\n\t\tAwsFrameInfo * info = (AwsFrameInfo*)arg;\n\t\tString msg = \"\";\n\n\t\tif (info->final && info->index == 0 && info->len == len)\n\t\t{\n\t\t\t//the whole message is in a single frame and we got all of it's data\n\t\t\tSerial.printf(\"ws[%s][%u] %s-message[%llu]: \", server->url(), client->id(), (info->opcode == WS_TEXT) ? \"text\" : \"binary\", info->len);\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < info->len; i++)\n\t\t\t\t{\n\t\t\t\t\tmsg += (char) data[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar buff[3];\n\n\t\t\t\tfor (size_t i = 0; i < info->len; i++)\n\t\t\t\t{\n\t\t\t\t\tsprintf(buff, \"%02x \", (uint8_t) data[i]);\n\t\t\t\t\tmsg += buff ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSerial.printf(\"%s\\n\", msg.c_str());\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t\tclient->text(\"I got your text message\");\n\t\t\telse\n\t\t\t\tclient->binary(\"I got your binary message\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//message is comprised of multiple frames or the frame is split into multiple packets\n\t\t\tif (info->index == 0)\n\t\t\t{\n\t\t\t\tif (info->num == 0)\n\t\t\t\t\tSerial.printf(\"ws[%s][%u] %s-message start\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\n\t\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\t\t\t}\n\n\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(), info->num, (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\", info->index, info->index + len);\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tmsg += (char) data[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar buff[3];\n\n\t\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tsprintf(buff, \"%02x \", (uint8_t) data[i]);\n\t\t\t\t\tmsg += buff ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSerial.printf(\"%s\\n\", msg.c_str());\n\n\t\t\tif ((info->index + len) == info->len)\n\t\t\t{\n\t\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\n\t\t\t\tif (info->final)\n\t\t\t\t{\n\t\t\t\t\tSerial.printf(\"ws[%s][%u] %s-message end\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\n\t\t\t\t\tif (info->message_opcode == WS_TEXT)\n\t\t\t\t\t\tclient->text(\"I got your text message\");\n\t\t\t\t\telse\n\t\t\t\t\t\tclient->binary(\"I got your binary message\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
        },
        {
          "name": "initFS",
          "parameters": "",
          "body": "// Initialize LittleFS/SPIFFS file-system\n\tif (!LittleFS.begin())\n\t{\n\t\tLittleFS.format();\n\n\t\tif (!LittleFS.begin())\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tSerial.println(F(\"LittleFS failed!\"));\n\n\t\t\t\t// Stay forever here as useless to go further\n\t\t\t\tdelay(5000);\n\t\t\t}\n\t\t}\n\t}"
        },
        {
          "name": "initWebServer",
          "parameters": "",
          "body": "ws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);\n\t});\n\n\tserver.addHandler(&events);\n\n\tserver.addHandler(new AsyncFSEditor(http_username, http_password));\n\n\tserver.serveStatic(\"/\", LittleFS, \"/\").setDefaultFile(\"index.htm\");\n\n\tserver.onNotFound([](AsyncWebServerRequest * request)\n\t{\n\t\tSerial.printf(\"NOT_FOUND: \");\n\n\t\tif (request->method() == HTTP_GET)\n\t\t\tSerial.printf(\"GET\");\n\t\telse if (request->method() == HTTP_POST)\n\t\t\tSerial.printf(\"POST\");\n\t\telse if (request->method() == HTTP_DELETE)\n\t\t\tSerial.printf(\"DELETE\");\n\t\telse if (request->method() == HTTP_PUT)\n\t\t\tSerial.printf(\"PUT\");\n\t\telse if (request->method() == HTTP_PATCH)\n\t\t\tSerial.printf(\"PATCH\");\n\t\telse if (request->method() == HTTP_HEAD)\n\t\t\tSerial.printf(\"HEAD\");\n\t\telse if (request->method() == HTTP_OPTIONS)\n\t\t\tSerial.printf(\"OPTIONS\");\n\t\telse\n\t\t\tSerial.printf(\"UNKNOWN\");\n\n\t\tSerial.printf(\" http://%s%s\\n\", request->host().c_str(), request->url().c_str());\n\n\t\tif (request->contentLength())\n\t\t{\n\t\t\tSerial.printf(\"_CONTENT_TYPE: %s\\n\", request->contentType().c_str());\n\t\t\tSerial.printf(\"_CONTENT_LENGTH: %u\\n\", request->contentLength());\n\t\t}\n\n\t\tint headers = request->headers();\n\t\tint i;\n\n\t\tfor (i = 0; i < headers; i++)\n\t\t{\n\t\t\tAsyncWebHeader* h = request->getHeader(i);\n\t\t\tSerial.printf(\"_HEADER[%s]: %s\\n\", h->name().c_str(), h->value().c_str());\n\t\t}\n\n\t\tint params = request->params();\n\n\t\tfor (i = 0; i < params; i++)\n\t\t{\n\t\t\tAsyncWebParameter* p = request->getParam(i);\n\n\t\t\tif (p->isFile())\n\t\t\t{\n\t\t\t\tSerial.printf(\"_FILE[%s]: %s, size: %u\\n\", p->name().c_str(), p->value().c_str(), p->size());\n\t\t\t}\n\t\t\telse if (p->isPost())\n\t\t\t{\n\t\t\t\tSerial.printf(\"_POST[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSerial.printf(\"_GET[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n\t\t\t}\n\t\t}\n\n\t\trequest->send(404);\n\t});\n\n\tserver.onFileUpload([](AsyncWebServerRequest * request, const String & filename, size_t index, uint8_t *data, size_t len, bool final)\n\t{\n\t\tif (!index)\n\t\t\tSerial.printf(\"UploadStart: %s\\n\", filename.c_str());\n\n\t\tSerial.printf(\"%s\", (const char*)data);\n\n\t\tif (final)\n\t\t\tSerial.printf(\"UploadEnd: %s (%u)\\n\", filename.c_str(), index + len);\n\t});\n\n\tserver.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total)\n\t{\n\t\tif (!index)\n\t\t\tSerial.printf(\"BodyStart: %u\\n\", total);\n\n\t\tSerial.printf(\"%s\", (const char*)data);\n\n\t\tif (index + len == total)\n\t\t\tSerial.printf(\"BodyEnd: %u\\n\", total);\n\t});\n\n\tserver.begin();"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart AsyncFSWebServer on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);\n\t}\n\n\tSerial.print(F(\"Connecting to SSID: \"));\n\tSerial.println(ssid);\n\n\tstatus = WiFi.begin(ssid, pass);\n\n\tdelay(1000);\n\n\t// attempt to connect to WiFi network\n\twhile ( status != WL_CONNECTED)\n\t{\n\t\tdelay(500);\n\n\t\t// Connect to WPA/WPA2 network\n\t\tstatus = WiFi.status();\n\t}\n\n\tprintWifiStatus();\n\n\t///////////////////////////////////\n\n\tinitFS();\n\n\tinitWebServer();\n\n\tSerial.print(\"AsyncWebServer started @\");\n\tSerial.println(WiFi.localIP());\n\n\tSerial.print(F(\"Open http://\"));\n\tSerial.print(WiFi.localIP());\n\tSerial.println(F(\"/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "asyncwebserver",
        "https",
        "password",
        "key",
        "wifi",
        "delay",
        "millis",
        "littlefs",
        "spiffs"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "LittleFS.h",
        "AsyncFSEditor_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\t\tclient->printf(\"Hello Client %ld :)\", client->id());\n\t\tclient->ping();\n\t}\n\telse if (type == WS_EVT_DISCONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] disconnect\\n\", server->url(), client->id());\n\t}\n\telse if (type == WS_EVT_ERROR)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\n\t}\n\telse if (type == WS_EVT_PONG)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len) ? (char*)data : \"\");\n\t}\n\telse if (type == WS_EVT_DATA)\n\t{\n\t\tAwsFrameInfo * info = (AwsFrameInfo*)arg;\n\t\tString msg = \"\";\n\n\t\tif (info->final && info->index == 0 && info->len == len)\n\t\t{\n\t\t\t//the whole message is in a single frame and we got all of it's data\n\t\t\tSerial.printf(\"ws[%s][%u] %s-message[%llu]: \", server->url(), client->id(), (info->opcode == WS_TEXT) ? \"text\" : \"binary\", info->len);\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < info->len; i++)\n\t\t\t\t{\n\t\t\t\t\tmsg += (char) data[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar buff[3];\n\n\t\t\t\tfor (size_t i = 0; i < info->len; i++)\n\t\t\t\t{\n\t\t\t\t\tsprintf(buff, \"%02x \", (uint8_t) data[i]);\n\t\t\t\t\tmsg += buff ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSerial.printf(\"%s\\n\", msg.c_str());\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t\tclient->text(\"I got your text message\");\n\t\t\telse\n\t\t\t\tclient->binary(\"I got your binary message\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//message is comprised of multiple frames or the frame is split into multiple packets\n\t\t\tif (info->index == 0)\n\t\t\t{\n\t\t\t\tif (info->num == 0)\n\t\t\t\t\tSerial.printf(\"ws[%s][%u] %s-message start\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\n\t\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\t\t\t}\n\n\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(), info->num, (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\", info->index, info->index + len);\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tmsg += (char) data[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar buff[3];\n\n\t\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tsprintf(buff, \"%02x \", (uint8_t) data[i]);\n\t\t\t\t\tmsg += buff ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSerial.printf(\"%s\\n\", msg.c_str());\n\n\t\t\tif ((info->index + len) == info->len)\n\t\t\t{\n\t\t\t\tSerial.printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\n\t\t\t\tif (info->final)\n\t\t\t\t{\n\t\t\t\t\tSerial.printf(\"ws[%s][%u] %s-message end\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\n\t\t\t\t\tif (info->message_opcode == WS_TEXT)\n\t\t\t\t\t\tclient->text(\"I got your text message\");\n\t\t\t\t\telse\n\t\t\t\t\t\tclient->binary(\"I got your binary message\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
        },
        {
          "name": "initFS",
          "parameters": "",
          "body": "// Initialize LittleFS/SPIFFS file-system\n\tif (!LittleFS.begin())\n\t{\n\t\tLittleFS.format();\n\n\t\tif (!LittleFS.begin())\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tSerial.println(F(\"LittleFS failed!\"));\n\n\t\t\t\t// Stay forever here as useless to go further\n\t\t\t\tdelay(5000);\n\t\t\t}\n\t\t}\n\t}"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024)\n\t{\n\t\treturn String(bytes) + \"B\";\n\t}\n\telse if (bytes < (1024 * 1024))\n\t{\n\t\treturn String(bytes / 1024.0) + \"KB\";\n\t}\n\telse if (bytes < (1024 * 1024 * 1024))\n\t{\n\t\treturn String(bytes / 1024.0 / 1024.0) + \"MB\";\n\t}\n\telse\n\t{\n\t\treturn String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n\t}"
        },
        {
          "name": "listDir",
          "parameters": "",
          "body": "Dir dir = LittleFS.openDir(\"/\");\n\tSerial.println(F(\"Opening / directory\"));\n\n\twhile (dir.next())\n\t{\n\t\tString fileName = dir.fileName();\n\t\tsize_t fileSize = dir.fileSize();\n\t\tSerial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n\t}\n\n\tSerial.println();"
        },
        {
          "name": "initWebServer",
          "parameters": "",
          "body": "ws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);\n\t});\n\n\tserver.addHandler(&events);\n\n\tserver.addHandler(new AsyncFSEditor(http_username, http_password));\n\n\tserver.serveStatic(\"/\", LittleFS, \"/\").setDefaultFile(\"index.htm\");\n\n\tserver.onNotFound([](AsyncWebServerRequest * request)\n\t{\n\t\tSerial.printf(\"NOT_FOUND: \");\n\n\t\tif (request->method() == HTTP_GET)\n\t\t\tSerial.printf(\"GET\");\n\t\telse if (request->method() == HTTP_POST)\n\t\t\tSerial.printf(\"POST\");\n\t\telse if (request->method() == HTTP_DELETE)\n\t\t\tSerial.printf(\"DELETE\");\n\t\telse if (request->method() == HTTP_PUT)\n\t\t\tSerial.printf(\"PUT\");\n\t\telse if (request->method() == HTTP_PATCH)\n\t\t\tSerial.printf(\"PATCH\");\n\t\telse if (request->method() == HTTP_HEAD)\n\t\t\tSerial.printf(\"HEAD\");\n\t\telse if (request->method() == HTTP_OPTIONS)\n\t\t\tSerial.printf(\"OPTIONS\");\n\t\telse\n\t\t\tSerial.printf(\"UNKNOWN\");\n\n\t\tSerial.printf(\" http://%s%s\\n\", request->host().c_str(), request->url().c_str());\n\n\t\tif (request->contentLength())\n\t\t{\n\t\t\tSerial.printf(\"_CONTENT_TYPE: %s\\n\", request->contentType().c_str());\n\t\t\tSerial.printf(\"_CONTENT_LENGTH: %u\\n\", request->contentLength());\n\t\t}\n\n\t\tint headers = request->headers();\n\t\tint i;\n\n\t\tfor (i = 0; i < headers; i++)\n\t\t{\n\t\t\tAsyncWebHeader* h = request->getHeader(i);\n\t\t\tSerial.printf(\"_HEADER[%s]: %s\\n\", h->name().c_str(), h->value().c_str());\n\t\t}\n\n\t\tint params = request->params();\n\n\t\tfor (i = 0; i < params; i++)\n\t\t{\n\t\t\tAsyncWebParameter* p = request->getParam(i);\n\n\t\t\tif (p->isFile())\n\t\t\t{\n\t\t\t\tSerial.printf(\"_FILE[%s]: %s, size: %u\\n\", p->name().c_str(), p->value().c_str(), p->size());\n\t\t\t}\n\t\t\telse if (p->isPost())\n\t\t\t{\n\t\t\t\tSerial.printf(\"_POST[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSerial.printf(\"_GET[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n\t\t\t}\n\t\t}\n\n\t\trequest->send(404);\n\t});\n\n\tserver.onFileUpload([](AsyncWebServerRequest * request, const String & filename, size_t index, uint8_t *data, size_t len, bool final)\n\t{\n\t\tif (!index)\n\t\t\tSerial.printf(\"UploadStart: %s\\n\", filename.c_str());\n\n\t\tSerial.printf(\"%s\", (const char*)data);\n\n\t\tif (final)\n\t\t\tSerial.printf(\"UploadEnd: %s (%u)\\n\", filename.c_str(), index + len);\n\t});\n\n\tserver.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total)\n\t{\n\t\tif (!index)\n\t\t\tSerial.printf(\"BodyStart: %u\\n\", total);\n\n\t\tSerial.printf(\"%s\", (const char*)data);\n\n\t\tif (index + len == total)\n\t\t\tSerial.printf(\"BodyEnd: %u\\n\", total);\n\t});\n\n\tserver.begin();"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart AsyncFSWebServer_Complex on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);\n\t}\n\n\tSerial.print(F(\"Connecting to SSID: \"));\n\tSerial.println(ssid);\n\n\tstatus = WiFi.begin(ssid, pass);\n\n\tdelay(1000);\n\n\t// attempt to connect to WiFi network\n\twhile ( status != WL_CONNECTED)\n\t{\n\t\tdelay(500);\n\n\t\t// Connect to WPA/WPA2 network\n\t\tstatus = WiFi.status();\n\t}\n\n\tprintWifiStatus();\n\n\t///////////////////////////////////\n\n\tinitFS();\n\tlistDir();\n\tinitWebServer();\n\n\tSerial.print(\"AsyncWebServer started @\");\n\tSerial.println(WiFi.localIP());\n\n\tSerial.print(F(\"Open http://\"));\n\tSerial.print(WiFi.localIP());\n\tSerial.println(F(\"/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "password",
        "payload",
        "callback",
        "current",
        "wifi",
        "millis",
        "delay",
        "display",
        "javascript"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(F(\"Can't send bad request\"));\n    }\n  }\n  else\n  {\n    Serial.println(F(\"Can't send request\"));\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n\n#if 1\n\n    // Bypass hourly\n    if (requestIndex == 1)\n      requestIndex = 3;\n    else\n      requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n\n#else\n    // hourly too long, not display anyway. Not enough heap.\n    requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n#endif\n\n    request->setDebug(false);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPMultiRequests using \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(F(\"Warning. Must use this example on Version equal or later than : \"));\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  WiFi.mode(WIFI_STA);\n\n  WiFi.begin(ssid, password);\n\n  Serial.print(F(\"Connecting to WiFi SSID: \"));\n  Serial.println(ssid);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(WiFi.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "current",
        "dns",
        "wifi",
        "spi",
        "millis",
        "delay",
        "display",
        "javascript"
      ],
      "libraries": [
        "WebServer_ESP32_ENC.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (ESP32_ENC_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n\n#if 1\n\n    // Bypass hourly\n    if (requestIndex == 1)\n      requestIndex = 3;\n    else\n      requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n\n#else\n    // hourly too long, not display anyway. Not enough heap.\n    requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n#endif\n\n    request->setDebug(false);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_ENC on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  AHTTP_LOGWARN(F(\"Default SPI pinout:\"));\n  AHTTP_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AHTTP_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AHTTP_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AHTTP_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AHTTP_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AHTTP_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AHTTP_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "current",
        "dns",
        "wifi",
        "spi",
        "millis",
        "delay",
        "display",
        "javascript"
      ],
      "libraries": [
        "WebServer_ESP32_W5500.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (ESP32_W5500_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n\n#if 1\n\n    // Bypass hourly\n    if (requestIndex == 1)\n      requestIndex = 3;\n    else\n      requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n\n#else\n    // hourly too long, not display anyway. Not enough heap.\n    requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n#endif\n\n    request->setDebug(false);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_W5500 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  AHTTP_LOGWARN(F(\"Default SPI pinout:\"));\n  AHTTP_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AHTTP_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AHTTP_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AHTTP_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AHTTP_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AHTTP_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AHTTP_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AHTTP_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "current",
        "dns",
        "wifi",
        "spi",
        "millis",
        "delay",
        "display",
        "javascript"
      ],
      "libraries": [
        "WebServer_ESP32_W6100.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n\n#if 1\n\n    // Bypass hourly\n    if (requestIndex == 1)\n      requestIndex = 3;\n    else\n      requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n\n#else\n    // hourly too long, not display anyway. Not enough heap.\n    requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n#endif\n\n    request->setDebug(false);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_W6100 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  AHTTP_LOGWARN(F(\"Default SPI pinout:\"));\n  AHTTP_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AHTTP_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AHTTP_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AHTTP_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AHTTP_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AHTTP_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AHTTP_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AHTTP_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "current",
        "power",
        "dns",
        "wifi",
        "millis",
        "delay",
        "display",
        "javascript"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (WT32_ETH01_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void* optParm, AsyncHTTPRequest* request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n\n#if 1\n\n    // Bypass hourly\n    if (requestIndex == 1)\n      requestIndex = 3;\n    else\n      requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n\n#else\n    // hourly too long, not display anyway. Not enough heap.\n    requestIndex = (requestIndex + 1) % NUM_REQUESTS;\n#endif\n\n    request->setDebug(false);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_WT32_ETH01 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "wifi",
        "millis",
        "delay",
        "javascript"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n    //requestOpenResult = request.open(\"GET\", \"http://213.188.196.246/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      Serial.println(\"Request sent\");\n\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);"
        },
        {
          "name": "sendRequestRepeat",
          "parameters": "",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "password",
        "payload",
        "callback",
        "wifi",
        "millis",
        "delay",
        "javascript"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(F(\"Can't send bad request\"));\n    }\n  }\n  else\n  {\n    Serial.println(F(\"Can't send request\"));\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPRequest_ESP using \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  WiFi.mode(WIFI_STA);\n\n  WiFi.begin(ssid, password);\n\n  Serial.print(F(\"Connecting to WiFi SSID: \"));\n  Serial.println(ssid);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n\n  Serial.print(F(\"\\nAsyncHTTPRequest @ IP : \"));\n  Serial.println(WiFi.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "dns",
        "spi",
        "millis",
        "delay",
        "javascript"
      ],
      "libraries": [
        "WebServer_ESP32_ENC.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (ESP32_ENC_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_ENC on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  AHTTP_LOGWARN(F(\"Default SPI pinout:\"));\n  AHTTP_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AHTTP_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AHTTP_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AHTTP_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AHTTP_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AHTTP_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AHTTP_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(F(\"\\nHTTP WebClient is @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "dns",
        "spi",
        "millis",
        "delay",
        "javascript"
      ],
      "libraries": [
        "WebServer_ESP32_W5500.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (ESP32_W5500_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_W5500 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  AHTTP_LOGWARN(F(\"Default SPI pinout:\"));\n  AHTTP_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AHTTP_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AHTTP_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AHTTP_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AHTTP_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AHTTP_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AHTTP_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AHTTP_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(F(\"\\nHTTP WebClient is @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "dns",
        "spi",
        "millis",
        "delay",
        "javascript"
      ],
      "libraries": [
        "WebServer_ESP32_W6100.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_W6100 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  AHTTP_LOGWARN(F(\"Default SPI pinout:\"));\n  AHTTP_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AHTTP_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AHTTP_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AHTTP_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AHTTP_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AHTTP_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AHTTP_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AHTTP_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(F(\"\\nHTTP WebClient is @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "wificlient",
        "api",
        "https",
        "payload",
        "callback",
        "spi",
        "delay",
        "millis",
        "javascript"
      ],
      "libraries": [
        "SPI.h",
        "W5500lwIP.h",
        "W5100lwIP.h",
        "ENC28J60lwIP.h",
        "WiFiClient.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (eth.connected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(F(\"Can't send bad request\"));\n    }\n  }\n  else\n  {\n    Serial.println(F(\"Can't send request\"));\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n  eth.setDefault();\n\n  if (!eth.begin())\n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n\n    while (true)\n    {\n      delay(1000);\n    }\n  }\n  else\n  {\n    Serial.print(\"Connecting to network : \");\n\n    while (!eth.connected())\n    {\n      Serial.print(\".\");\n      delay(1000);\n    }\n  }\n\n  Serial.println();\n  Serial.print(\"Ethernet IP address: \");\n  Serial.println(eth.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP8266_Ethernet on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" using \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  initEthernet();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "password",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "uint16_t index",
          "body": "static bool requestOpenResult;\n\n  reqCount[index]--;\n  readySend[index] = false;\n\n  requestOpenResult = request[index].open(\"GET\", addreses[index][reqCount[index]]);\n\n  if (requestOpenResult)\n  {\n    // Only send() if open() returns true, or crash\n    Serial.print(\"\\nSending request: \");\n    request[index].send();\n  }\n  else\n  {\n    Serial.print(\"\\nCan't send bad request : \");\n  }\n\n  Serial.println(addreses[index][reqCount[index]]);"
        },
        {
          "name": "sendRequest0",
          "parameters": "",
          "body": "sendRequest(0);"
        },
        {
          "name": "sendRequest1",
          "parameters": "",
          "body": "sendRequest(1);"
        },
        {
          "name": "sendRequests",
          "parameters": "",
          "body": "reqCount[0] = NUM_ENTRIES_SITE_0;\n  reqCount[1] = NUM_ENTRIES_SITE_1;"
        },
        {
          "name": "requestCB0",
          "parameters": "void* optParm, AsyncHTTPRequest* thisRequest, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n    else\n    {\n      AHTTP_LOGERROR(F(\"Response error\"));\n    }\n\n    thisRequest->setDebug(false);\n    readySend[0] = true;\n  }"
        },
        {
          "name": "requestCB1",
          "parameters": "void* optParm, AsyncHTTPRequest* thisRequest, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n    else\n    {\n      AHTTP_LOGERROR(F(\"Response error\"));\n    }\n\n    thisRequest->setDebug(false);\n    readySend[1] = true;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP_Multi on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  WiFi.mode(WIFI_STA);\n\n  WiFi.begin(ssid, password);\n\n  Serial.println(\"Connecting to WiFi SSID: \" + String(ssid));\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(1000);\n    Serial.print(\".\");\n  }\n\n  Serial.print(F(\"\\nAsyncHTTPSRequest @ IP : \"));\n  Serial.println(WiFi.localIP());\n\n  for (int index = 0; index < NUM_DIFFERENT_SITES; index++)\n  {\n    request[index].setDebug(false);\n\n    request[index].onReadyStateChange(requestCB[index]);\n  }\n\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequests);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for (int index = 0; index < NUM_DIFFERENT_SITES; index++)\n  {\n    if ((reqCount[index] > 0) && readySend[index])\n    {\n      sendRequestCB[index]();\n\n      // Don't send too fast\n      delay(1000);\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "wificlient",
        "asyncwebserver",
        "api",
        "https",
        "password",
        "payload",
        "callback",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "display",
        "littlefs",
        "spiffs",
        "flash",
        "eeprom",
        "javascript",
        "gatewayip"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "AsyncHTTPRequest_Generic.h",
        "AsyncHTTPRequest_Impl_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn,\n              in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset(&WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  //memset(&WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  // New in v1.8.2\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    file.write((uint8_t*) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(F(\"Can't send bad request\"));\n    }\n  }\n  else\n  {\n    Serial.println(F(\"Can't send request\"));\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPRequest_ESP_WiFiManager using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(F(\"Warning. Must use this example on Version later than : \"));\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(F(\"Warning. Must use this example on Version equal or later than : \"));\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n    Serial.print(FS_Name);\n    Serial.println(F(\" failed! AutoFormatting.\"));\n\n#ifdef ESP8266\n    FileFS.format();\n#endif\n  }\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AutoConnectAP\");\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AutoConnectAP\");\n#else\n  AsyncDNSServer dnsServer;\n\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AutoConnectAP\");\n#endif\n\n  //ESPAsync_wifiManager.setDebugOutput(true);\n\n  //reset settings - for testing\n  //ESPAsync_wifiManager.resetSettings();\n\n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n  // New in v1.4.0\n  ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n  //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.print(F(\"Stored: SSID = \"));\n  Serial.print(Router_SSID);\n  Serial.print(F(\", Pass = \"));\n  Serial.println(Router_Pass);\n\n  if (Router_SSID != \"\")\n  {\n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    Serial.println(F(\"No stored Credentials. No timeout\"));\n  }\n\n  String chipID = String(ESP_getChipId(), HEX);\n  chipID.toUpperCase();\n\n  // SSID and PW for Config Portal\n  String AP_SSID = \"ESP_\" + chipID + \"_AutoConnectAP\";\n  String AP_PASS = \"MyESP_\" + chipID;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID == \"\") || (Router_Pass == \"\") )\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    initialConfig = true;\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n\n#if USE_CUSTOM_AP_IP\n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(AP_SSID);\n    Serial.print(F(\", PASS = \"));\n    Serial.println(AP_PASS);\n\n    // Starts an access point\n    //if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    if ( !ESPAsync_wifiManager.startConfigPortal(AP_SSID.c_str(), AP_PASS.c_str()) )\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n\n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);\n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\")\n           && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    saveConfigData();\n  }\n  else\n  {\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\")\n           && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED )\n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n\n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "millis",
        "delay",
        "javascript"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(Ethernet.localIP());\n  Serial.println();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  sendHTTPRequest.start(); //start the ticker.\n\n  // Send first request now\n  //delay(60);\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "payload",
        "callback",
        "power",
        "dns",
        "millis",
        "delay",
        "javascript"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (WT32_ETH01_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_WT32_ETH01 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  Serial.print(F(\"\\nHTTP WebClient is @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "spi",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "defines.h",
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "createBuffer",
          "parameters": "",
          "body": "char temp[BUFFER_SIZE];\n\n  memset(temp, 0, sizeof(temp));\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h2>running AsyncWebServer_Ethernet</h2>\\\n<h3>on %s</h3>\\\n<h3>Uptime: %d d %02d:%02d:%02d</h3>\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  return temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "createNotFoundBuffer",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message;\n\n  message.reserve(500);\n\n  message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  return message;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);\n    }\n  } \n  else \n  {\n    Serial.print(\"Connecting to network : \");\n    \n    while (!eth.connected()) \n    {\n      Serial.print(\".\");\n      delay(1000);\n    }\n  }\n \n  Serial.println();\n\n#if USING_DHCP  \n  Serial.print(\"Ethernet DHCP IP address: \");\n#else\n  Serial.print(\"Ethernet Static IP address: \");\n#endif\n  \n  Serial.println(eth.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n  \n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);\n    }\n    else\n    {\n      Serial.printf(\"Error initialize multiServer, serverIndex = %d\\n\", serverIndex);\n\n      while(1);\n    }\n\n    multiServer[serverIndex]->on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      handleRoot(request);\n    });\n\n    multiServer[serverIndex]->on(\"/hello\", HTTP_GET, [](AsyncWebServerRequest * request) \n    {     \n      String message = F(\"Hello from AsyncWebServer using built-in LAN8742A Ethernet, running on \");\n      message       += BOARD_NAME;\n      \n      request->send(200, \"text/plain\", message);\n    });\n      \n    multiServer[serverIndex]->onNotFound([](AsyncWebServerRequest * request) \n    {\n      handleNotFound(request);\n    });\n\n    multiServer[serverIndex]->begin();\n\n    Serial.printf(\"HTTP server started at ports %d\\n\", http_port[serverIndex]);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "createBuffer",
          "parameters": "",
          "body": "char temp[BUFFER_SIZE];\n\n  memset(temp, 0, sizeof(temp));\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h2>running AsyncMultiWebServer_ESP32_SC_ENC</h2>\\\n<h3>on %s</h3>\\\n<h3>Uptime: %d d %02d:%02d:%02d</h3>\\\n</body>\\\n</html>\", ARDUINO_BOARD, ARDUINO_BOARD, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  return temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "createNotFoundBuffer",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message;\n\n  message.reserve(500);\n\n  message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  return message;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);\n    }\n    else\n    {\n      Serial.printf(\"Error initialize multiServer, serverIndex = %d\\n\", serverIndex);\n\n      while (1);\n    }\n\n    multiServer[serverIndex]->on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      handleRoot(request);\n    });\n\n    multiServer[serverIndex]->on(\"/hello\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      String message = F(\"Hello from AsyncMultiWebServer_ESP32_ENC using ENC28J60 Ethernet, running on \");\n      message       += ARDUINO_BOARD;\n\n      request->send(200, \"text/plain\", message);\n    });\n\n    multiServer[serverIndex]->onNotFound([](AsyncWebServerRequest * request)\n    {\n      handleNotFound(request);\n    });\n\n    multiServer[serverIndex]->begin();\n\n    Serial.printf(\"HTTP server started at ports %d\\n\", http_port[serverIndex]);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "createBuffer",
          "parameters": "",
          "body": "char temp[BUFFER_SIZE];\n\n  memset(temp, 0, sizeof(temp));\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h2>running AsyncMultiWebServer_ESP32_SC_W5500</h2>\\\n<h3>on %s</h3>\\\n<h3>Uptime: %d d %02d:%02d:%02d</h3>\\\n</body>\\\n</html>\", ARDUINO_BOARD, ARDUINO_BOARD, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  return temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "createNotFoundBuffer",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message;\n\n  message.reserve(500);\n\n  message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  return message;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);\n    }\n    else\n    {\n      Serial.printf(\"Error initialize multiServer, serverIndex = %d\\n\", serverIndex);\n\n      while (1);\n    }\n\n    multiServer[serverIndex]->on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      handleRoot(request);\n    });\n\n    multiServer[serverIndex]->on(\"/hello\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      String message = F(\"Hello from AsyncMultiWebServer_ESP32_W5500 using W5500 Ethernet, running on \");\n      message       += ARDUINO_BOARD;\n\n      request->send(200, \"text/plain\", message);\n    });\n\n    multiServer[serverIndex]->onNotFound([](AsyncWebServerRequest * request)\n    {\n      handleNotFound(request);\n    });\n\n    multiServer[serverIndex]->begin();\n\n    Serial.printf(\"HTTP server started at ports %d\\n\", http_port[serverIndex]);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "createBuffer",
          "parameters": "",
          "body": "char temp[BUFFER_SIZE];\n\n  memset(temp, 0, sizeof(temp));\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h2>running AsyncMultiWebServer_ESP32_SC_W6100</h2>\\\n<h3>on %s</h3>\\\n<h3>Uptime: %d d %02d:%02d:%02d</h3>\\\n</body>\\\n</html>\", ARDUINO_BOARD, ARDUINO_BOARD, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  return temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "createNotFoundBuffer",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message;\n\n  message.reserve(500);\n\n  message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  return message;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);\n    }\n    else\n    {\n      Serial.printf(\"Error initialize multiServer, serverIndex = %d\\n\", serverIndex);\n\n      while (1);\n    }\n\n    multiServer[serverIndex]->on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      handleRoot(request);\n    });\n\n    multiServer[serverIndex]->on(\"/hello\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      String message = F(\"Hello from AsyncMultiWebServer_ESP32_W6100 using W6100 Ethernet, running on \");\n      message       += ARDUINO_BOARD;\n\n      request->send(200, \"text/plain\", message);\n    });\n\n    multiServer[serverIndex]->onNotFound([](AsyncWebServerRequest * request)\n    {\n      handleNotFound(request);\n    });\n\n    multiServer[serverIndex]->begin();\n\n    Serial.printf(\"HTTP server started at ports %d\\n\", http_port[serverIndex]);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "millis",
        "delay",
        "flash",
        "html"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "createBuffer",
          "parameters": "",
          "body": "char temp[BUFFER_SIZE];\n\n  memset(temp, 0, sizeof(temp));\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h2>running AsyncWebServer_STM32</h2>\\\n<h3>on %s</h3>\\\n<h3>Uptime: %d d %02d:%02d:%02d</h3>\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  return temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "createNotFoundBuffer",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message;\n\n  message.reserve(500);\n\n  message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  return message;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(Ethernet.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);\n    }\n    else\n    {\n      Serial.printf(\"Error initialize multiServer, serverIndex = %d\\n\", serverIndex);\n\n      while(1);\n    }\n\n    multiServer[serverIndex]->on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      handleRoot(request);\n    });\n\n    multiServer[serverIndex]->on(\"/hello\", HTTP_GET, [](AsyncWebServerRequest * request) \n    {     \n      String message = F(\"Hello from AsyncWebServer using built-in LAN8742A Ethernet, running on \");\n      message       += BOARD_NAME;\n      \n      request->send(200, \"text/plain\", message);\n    });\n      \n    multiServer[serverIndex]->onNotFound([](AsyncWebServerRequest * request) \n    {\n      handleNotFound(request);\n    });\n\n    multiServer[serverIndex]->begin();\n\n    Serial.printf(\"HTTP server started at ports %d\\n\", http_port[serverIndex]);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "millis",
        "delay",
        "flash",
        "html"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "createBuffer",
          "parameters": "",
          "body": "char temp[BUFFER_SIZE];\n\n  memset(temp, 0, sizeof(temp));\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h2>running AsyncWebServer_STM32_LAN8720</h2>\\\n<h3>on %s</h3>\\\n<h3>Uptime: %d d %02d:%02d:%02d</h3>\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n  return temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "createNotFoundBuffer",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message;\n\n  message.reserve(500);\n\n  message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += request->url();\n  message += F(\"\\nMethod: \");\n  message += (request->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += request->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  return message;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(Ethernet.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);\n    }\n    else\n    {\n      Serial.printf(\"Error initialize multiServer, serverIndex = %d\\n\", serverIndex);\n\n      while(1);\n    }\n\n    multiServer[serverIndex]->on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n    {\n      handleRoot(request);\n    });\n\n    multiServer[serverIndex]->on(\"/hello\", HTTP_GET, [](AsyncWebServerRequest * request) \n    {     \n      String message = F(\"Hello from AsyncWebServer using LAN8720 Ethernet, running on \");\n      message       += BOARD_NAME;\n      \n      request->send(200, \"text/plain\", message);\n    });\n      \n    multiServer[serverIndex]->onNotFound([](AsyncWebServerRequest * request) \n    {\n      handleNotFound(request);\n    });\n\n    multiServer[serverIndex]->begin();\n\n    Serial.printf(\"HTTP server started at ports %d\\n\", http_port[serverIndex]);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "power",
        "dns",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "createBuffer",
          "parameters": "",
          "body": "char temp[BUFFER_SIZE];\n\n\tmemset(temp, 0, sizeof(temp));\n\n\tint sec = millis() / 1000;\n\tint min = sec / 60;\n\tint hr = min / 60;\n\tint day = hr / 24;\n\n\tsnprintf(temp, BUFFER_SIZE - 1,\n\t         \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h1>Hello from %s</h1>\\\n<h2>running AsyncMultiWebServer_WT32_ETH01</h2>\\\n<h3>on %s</h3>\\\n<h3>Uptime: %d d %02d:%02d:%02d</h3>\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, SHIELD_TYPE, day, hr, min % 60, sec % 60);\n\n\treturn temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createBuffer();\n\trequest->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "createNotFoundBuffer",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message;\n\n\tmessage.reserve(500);\n\n\tmessage = F(\"File Not Found\\n\\n\");\n\n\tmessage += F(\"URI: \");\n\tmessage += request->url();\n\tmessage += F(\"\\nMethod: \");\n\tmessage += (request->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n\tmessage += F(\"\\nArguments: \");\n\tmessage += request->args();\n\tmessage += F(\"\\n\");\n\n\tfor (uint8_t i = 0; i < request->args(); i++)\n\t{\n\t\tmessage += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n\t}\n\n\treturn message;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest * request",
          "body": "String message = createNotFoundBuffer(request);\n\trequest->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(F(\"\\nStart AsyncMultiWebServer_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tSerial.print(\"\\nConnected to network. IP = \");\n\tSerial.println(ETH.localIP());\n\n\tfor (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n\t{\n\t\tmultiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n\t\tif (multiServer[serverIndex])\n\t\t{\n\t\t\tSerial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSerial.printf(\"Error initialize multiServer, serverIndex = %d\\n\", serverIndex);\n\n\t\t\twhile (1);\n\t\t}\n\n\t\tmultiServer[serverIndex]->on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t\t{\n\t\t\thandleRoot(request);\n\t\t});\n\n\t\tmultiServer[serverIndex]->on(\"/hello\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t\t{\n\t\t\tString message = F(\"Hello from AsyncMultiWebServer_WT32_ETH01 using LAN8720 Ethernet, running on \");\n\t\t\tmessage       += BOARD_NAME;\n\n\t\t\trequest->send(200, \"text/plain\", message);\n\t\t});\n\n\t\tmultiServer[serverIndex]->onNotFound([](AsyncWebServerRequest * request)\n\t\t{\n\t\t\thandleNotFound(request);\n\t\t});\n\n\t\tmultiServer[serverIndex]->begin();\n\n\t\tSerial.printf(\"HTTP server started at ports %d\\n\", http_port[serverIndex]);\n\t}"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "api",
        "https",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncSimpleGET on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);"
        },
        {
          "name": "sendRequestRepeat",
          "parameters": "",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "api",
        "https",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncSimpleGET_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(Ethernet.localIP());\n  Serial.println();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  sendHTTPRequest.start(); //start the ticker.\n\n  // Send first request now\n  delay(10000);\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_ENC\");\n  });\n\n  // Send a GET request to <IP>/get?message=<message>\n  server.on(\"/get\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String message;\n\n    if (request->hasParam(PARAM_MESSAGE))\n    {\n      message = request->getParam(PARAM_MESSAGE)->value();\n    }\n    else\n    {\n      message = \"No message sent\";\n    }\n\n    request->send(200, \"text/plain\", \"Hello, GET: \" + message);\n  });\n\n  // Send a POST request to <IP>/post with a form field message set to <message>\n  server.on(\"/post\", HTTP_POST, [](AsyncWebServerRequest * request)\n  {\n    String message;\n\n    if (request->hasParam(PARAM_MESSAGE, true))\n    {\n      message = request->getParam(PARAM_MESSAGE, true)->value();\n    }\n    else\n    {\n      message = \"No message sent\";\n    }\n\n    request->send(200, \"text/plain\", \"Hello, POST: \" + message);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_W5500\");\n  });\n\n  // Send a GET request to <IP>/get?message=<message>\n  server.on(\"/get\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String message;\n\n    if (request->hasParam(PARAM_MESSAGE))\n    {\n      message = request->getParam(PARAM_MESSAGE)->value();\n    }\n    else\n    {\n      message = \"No message sent\";\n    }\n\n    request->send(200, \"text/plain\", \"Hello, GET: \" + message);\n  });\n\n  // Send a POST request to <IP>/post with a form field message set to <message>\n  server.on(\"/post\", HTTP_POST, [](AsyncWebServerRequest * request)\n  {\n    String message;\n\n    if (request->hasParam(PARAM_MESSAGE, true))\n    {\n      message = request->getParam(PARAM_MESSAGE, true)->value();\n    }\n    else\n    {\n      message = \"No message sent\";\n    }\n\n    request->send(200, \"text/plain\", \"Hello, POST: \" + message);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_W6100\");\n  });\n\n  // Send a GET request to <IP>/get?message=<message>\n  server.on(\"/get\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String message;\n\n    if (request->hasParam(PARAM_MESSAGE))\n    {\n      message = request->getParam(PARAM_MESSAGE)->value();\n    }\n    else\n    {\n      message = \"No message sent\";\n    }\n\n    request->send(200, \"text/plain\", \"Hello, GET: \" + message);\n  });\n\n  // Send a POST request to <IP>/post with a form field message set to <message>\n  server.on(\"/post\", HTTP_POST, [](AsyncWebServerRequest * request)\n  {\n    String message;\n\n    if (request->hasParam(PARAM_MESSAGE, true))\n    {\n      message = request->getParam(PARAM_MESSAGE, true)->value();\n    }\n    else\n    {\n      message = \"No message sent\";\n    }\n\n    request->send(200, \"text/plain\", \"Hello, POST: \" + message);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "power",
        "dns",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tSerial.print(F(\"\\nStart AsyncSimpleServer_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tIPAddress localIP = ETH.localIP();\n\n\tSerial.print(F(\"IP address: \"));\n\tSerial.println(localIP);\n\n\tserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_WT32_ETH01\");\n\t});\n\n\t// Send a GET request to <IP>/get?message=<message>\n\tserver.on(\"/get\", HTTP_GET, [] (AsyncWebServerRequest * request)\n\t{\n\t\tString message;\n\n\t\tif (request->hasParam(PARAM_MESSAGE))\n\t\t{\n\t\t\tmessage = request->getParam(PARAM_MESSAGE)->value();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmessage = \"No message sent\";\n\t\t}\n\n\t\trequest->send(200, \"text/plain\", \"Hello, GET: \" + message);\n\t});\n\n\t// Send a POST request to <IP>/post with a form field message set to <message>\n\tserver.on(\"/post\", HTTP_POST, [](AsyncWebServerRequest * request)\n\t{\n\t\tString message;\n\n\t\tif (request->hasParam(PARAM_MESSAGE, true))\n\t\t{\n\t\t\tmessage = request->getParam(PARAM_MESSAGE, true)->value();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmessage = \"No message sent\";\n\t\t}\n\n\t\trequest->send(200, \"text/plain\", \"Hello, POST: \" + message);\n\t});\n\n\tserver.onNotFound(notFound);\n\n\tserver.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "digitalwrite"
      ],
      "libraries": [
        "AsyncStepperLib.h",
        "Stepper.h"
      ],
      "functions": [
        {
          "name": "clockwise",
          "parameters": "",
          "body": "stepCounter++;\n\tif (stepCounter >= numSteps) stepCounter = 0;\n\tsetOutput(stepCounter);"
        },
        {
          "name": "anticlockwise",
          "parameters": "",
          "body": "stepCounter--;\n\tif (stepCounter < 0) stepCounter = numSteps - 1;\n\tsetOutput(stepCounter);"
        },
        {
          "name": "setOutput",
          "parameters": "int step",
          "body": "digitalWrite(motorPin1, bitRead(stepsLookup[step], 0));\n\tdigitalWrite(motorPin2, bitRead(stepsLookup[step], 1));\n\tdigitalWrite(motorPin3, bitRead(stepsLookup[step], 2));\n\tdigitalWrite(motorPin4, bitRead(stepsLookup[step], 3));"
        },
        {
          "name": "rotateCW",
          "parameters": "",
          "body": "stepper1.Rotate(90, AsyncStepper::CW, rotateCCW);"
        },
        {
          "name": "rotateCCW",
          "parameters": "",
          "body": "stepper1.Rotate(90, AsyncStepper::CCW, rotateCW);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n\tpinMode(motorPin1, OUTPUT);\n\tpinMode(motorPin2, OUTPUT);\n\tpinMode(motorPin3, OUTPUT);\n\tpinMode(motorPin4, OUTPUT);\n\n\tstepper1.SetSpeedRpm(10);\n\tstepper1.RotateContinuos(AsyncStepper::CCW);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "stepper1.Update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "ssl",
        "key",
        "password",
        "callback",
        "payload",
        "buffer",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ENABLE_ASYNC_TCP_CLIENT)\n    initializeApp(aClient, app, getAuth(user_auth), asyncCB, \"authTask\");\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// The async task handler should run inside the main loop\n    // without blocking delay or bypassing with millis code blocks.\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "asyncCB",
          "parameters": "AsyncResult &aResult",
          "body": "// WARNING!\n    // Do not put your codes inside the callback and printResult.\n\n    printResult(aResult);"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "AsyncTCPConnectCB",
          "parameters": "const char *host, uint16_t port",
          "body": ""
        },
        {
          "name": "AsyncTCPStatusCB",
          "parameters": "bool &status",
          "body": "// Some asyn TCP client provides the server connected callback, you have to collect the required status from its callback\n    // and set it to status variable."
        },
        {
          "name": "AsyncTCPSendCB",
          "parameters": "uint8_t *data, size_t size, uint32_t &sent",
          "body": ""
        },
        {
          "name": "AsyncTCPReceiveCB",
          "parameters": "uint8_t *buff, size_t buffSize, int32_t &filledSize, uint32_t &available",
          "body": "// Some asyn TCP client provides the data available callback, you have to collect the required data and status from its callback\n    // and provide the data here in case of data is ready and available to read.\n\n    // Please don't reallocate the buff, just copy data from async TCP client buffer to buff.\n    // After buff was set, set the filledSize and available."
        },
        {
          "name": "AsyncTCPStop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "key",
        "wifi",
        "delay",
        "millis",
        "clientconnected"
      ],
      "libraries": [
        "AsyncTCP_RP2040W.h"
      ],
      "functions": [
        {
          "name": "replyToServer",
          "parameters": "void* arg",
          "body": "(void) arg;\n\n  Serial.println(\"\\n********************\");\n  Serial.println(\"New replyToServer\");\n\n  AsyncClient* client = reinterpret_cast<AsyncClient*>(arg);\n\n  // send reply\n  if (client->space() > REPLY_SIZE && client->canSend())\n  {\n    char message[REPLY_SIZE];\n    sprintf(message, \"This is from AsyncTCPClient @ %s\", WiFi.localIP().toString().c_str());\n    client->add(message, strlen(message));\n    client->send();\n\n    dataReceived = false;\n  }"
        },
        {
          "name": "handleData",
          "parameters": "void* arg, AsyncClient* client, void *data, size_t len",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nData received from %s \\n\", client->remoteIP().toString().c_str());\n  Serial.write((uint8_t*)data, len);\n\n  lastCheck = millis();\n\n  dataReceived = true;"
        },
        {
          "name": "onConnect",
          "parameters": "void* arg, AsyncClient* client",
          "body": "(void) arg;\n\n  clientConnected = true;\n\n  Serial.printf(\"\\nAsyncTCPClient has been connected to Server %s, port %d \\n\", serverIP.toString().c_str(), TCP_PORT);\n\n  replyToServer(client);"
        },
        {
          "name": "onDisconnect",
          "parameters": "void* arg, AsyncClient* client",
          "body": "(void) arg;\n  (void) client;\n\n  Serial.printf(\"\\nAsyncTCPClient has been disconnected from Server %s, port %d \\n\", serverIP.toString().c_str(), TCP_PORT);\n\n  clientConnected = false;"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "connectServer",
          "parameters": "",
          "body": "if (client)\n    delete(client);\n\n  client = new AsyncClient;\n\n  if (client)\n  {\n    client->onData(&handleData, client);\n    client->onConnect(&onConnect, client);\n\n    client->onDisconnect(&onDisconnect, client);\n\n    client->connect(serverIP, TCP_PORT);\n\n    return true;\n  }\n  else\n  {\n    Serial.println(\"\\nError, NULL client\");\n\n    return false;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncTCP_Client on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  connectServer();\n\n  lastCheck = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "static unsigned long lastConnectCheck = CHECK_INTERVAL_MS;\n  \n  if (millis() - lastCheck > SEND_INTERVAL_MS)\n  {\n    if (clientConnected && dataReceived)\n    {\n      replyToServer(client);\n    }\n    else if ( !clientConnected || !dataReceived )\n    {\n      Serial.printf(\"\\nReconnecting to Server %s, port %d \\n\", serverIP.toString().c_str(), TCP_PORT);\n\n      connectServer();\n    }\n\n    lastCheck = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "key",
        "wifi",
        "millis",
        "delay",
        "clients"
      ],
      "libraries": [
        "AsyncTCP_RP2040W.h",
        "vector"
      ],
      "functions": [
        {
          "name": "handleError",
          "parameters": "void* arg, AsyncClient* client, int8_t error",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nConnection error %s from client %s \\n\", client->errorToString(error), client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleData",
          "parameters": "void* arg, AsyncClient* client, void *data, size_t len",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nData received from client %s \\n\", client->remoteIP().toString().c_str());\n  Serial.write((uint8_t*)data, len);\n\n  // reply to client\n  if (client->space() > REPLY_SIZE && client->canSend())\n  {\n    char reply[REPLY_SIZE];\n    sprintf(reply, \"You've connected to AsyncTCPServer @ %s\", serverIP.toString().c_str());\n    client->add(reply, strlen(reply));\n    client->send();\n  }"
        },
        {
          "name": "handleDisconnect",
          "parameters": "void* arg, AsyncClient* client",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nClient %s disconnected\\n\", client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleTimeOut",
          "parameters": "void* arg, AsyncClient* client, uint32_t time",
          "body": "(void) arg;\n  (void) time;\n\n  Serial.printf(\"\\nClient ACK timeout ip: %s\\n\", client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleNewClient",
          "parameters": "void* arg, AsyncClient* client",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nNew client has been connected to server, IP: %s\", client->remoteIP().toString().c_str());\n\n  // add to list\n  clients.push_back(client);\n\n  // register events\n  client->onData(&handleData, NULL);\n  client->onError(&handleError, NULL);\n  client->onDisconnect(&handleDisconnect, NULL);\n  client->onTimeout(&handleTimeOut, NULL);"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  serverIP = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(serverIP);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncTCP_Server on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  AsyncServer* server = new AsyncServer(TCP_PORT); // start listening on tcp port 7050\n\n  server->onClient(&handleNewClient, server);\n  server->begin();\n\n  Serial.print(F(\"AsyncTCPServer is @ IP: \"));\n  Serial.print(serverIP);\n  Serial.print(F(\", port: \"));\n  Serial.println(TCP_PORT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "parsePacket",
          "parameters": "AsyncUDPPacket packet",
          "body": "Serial.print(\"UDP Packet Type: \");\n  Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\", From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.print(\", Data: \");\n  Serial.write(packet.data(), packet.length());\n  Serial.println();\n  //reply to the client\n  packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart Async_UDPClient on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"Async_UDPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  if (udp.connect(remoteIPAddress, UDP_REMOTE_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket( packet);\n    });\n\n    //Send unicast\n    udp.print(\"Hello Server!\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(10000);\n  //Send broadcast on port UDP_REMOTE_PORT = 1234\n  udp.broadcastTo(\"Anyone here?\", UDP_REMOTE_PORT);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "parsePacket",
          "parameters": "AsyncUDPPacket packet",
          "body": "Serial.print(\"UDP Packet Type: \");\n  Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\", From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.print(\", Data: \");\n  Serial.write(packet.data(), packet.length());\n  Serial.println();\n  //reply to the client\n  packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUDPMulticastServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"Async_UDPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n\n  if (udp.listenMulticast(IPAddress(239, 1, 2, 3), 1234))\n  {\n    Serial.print(\"UDP Listening on IP: \");\n    Serial.println(ETH.localIP());\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);\n    });\n\n    //Send multicast\n    udp.print(\"Hello!\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(1000);\n  //Send multicast\n  udp.print(\"Anyone here?\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart Async_UdpServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUDPServer started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  if (udp.listen(1234))\n  {\n    Serial.print(\"UDP Listening on IP: \");\n    Serial.println(ETH.localIP());\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      Serial.print(\"UDP Packet Type: \");\n      Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n      Serial.print(\", From: \");\n      Serial.print(packet.remoteIP());\n      Serial.print(\":\");\n      Serial.print(packet.remotePort());\n      Serial.print(\", To: \");\n      Serial.print(packet.localIP());\n      Serial.print(\":\");\n      Serial.print(packet.localPort());\n      Serial.print(\", Length: \");\n      Serial.print(packet.length());\n      Serial.print(\", Data: \");\n      Serial.write(packet.data(), packet.length());\n      Serial.println();\n      //reply to the client\n      packet.printf(\"Got %u bytes of data\", packet.length());\n    });\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(1000);\n  //Send broadcast\n  udp.broadcast(\"Anyone here?\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "dns",
        "ntp",
        "spi",
        "millis",
        "delay",
        "timestamp"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h",
        "time.h"
      ],
      "functions": [
        {
          "name": "createNTPpacket",
          "parameters": "void",
          "body": "Serial.println(\"============= createNTPpacket =============\");\n\n  // set all bytes in the buffer to 0\n  memset(packetBuffer, 0, NTP_PACKET_SIZE);\n  // Initialize values needed to form NTP request\n  // (see URL above for details on the packets)\n\n  packetBuffer[0]   = 0b11100011;   // LI, Version, Mode\n  packetBuffer[1]   = 0;     // Stratum, or type of clock\n  packetBuffer[2]   = 6;     // Polling Interval\n  packetBuffer[3]   = 0xEC;  // Peer Clock Precision\n\n  // 8 bytes of zero for Root Delay & Root Dispersion\n  packetBuffer[12]  = 49;\n  packetBuffer[13]  = 0x4E;\n  packetBuffer[14]  = 49;\n  packetBuffer[15]  = 52;"
        },
        {
          "name": "parsePacket",
          "parameters": "AsyncUDPPacket packet",
          "body": "struct tm  ts;\n  char       buf[80];\n\n  memcpy(packetBuffer, packet.data(), sizeof(packetBuffer));\n\n  Serial.print(\"Received UDP Packet Type: \");\n  Serial.println(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\"From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.println();\n\n  unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);\n  unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);\n\n  // combine the four bytes (two words) into a long integer\n  // this is NTP time (seconds since Jan 1 1900):\n  unsigned long secsSince1900 = highWord << 16 | lowWord;\n\n  Serial.print(F(\"Seconds since Jan 1 1900 = \"));\n  Serial.println(secsSince1900);\n\n  // now convert NTP time into )everyday time:\n  Serial.print(F(\"Epoch/Unix time = \"));\n\n  // Unix time starts on Jan 1 1970. In seconds, that's 2208988800:\n  const unsigned long seventyYears = 2208988800UL;\n\n  // subtract seventy years:\n  unsigned long epoch = secsSince1900 - seventyYears;\n  time_t epoch_t = epoch;   //secsSince1900 - seventyYears;\n\n  // print Unix time:\n  Serial.println(epoch);\n\n  // print the hour, minute and second:\n  Serial.print(F(\"The UTC/GMT time is \"));       // UTC is the time at Greenwich Meridian (GMT)\n\n  ts = *localtime(&epoch_t);\n  strftime(buf, sizeof(buf), \"%a %Y-%m-%d %H:%M:%S %Z\", &ts);\n  Serial.println(buf);"
        },
        {
          "name": "sendNTPPacket",
          "parameters": "void",
          "body": "createNTPpacket();\n  //Send unicast\n  Udp.write(packetBuffer, sizeof(packetBuffer));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUdpNTPClient on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUdpNTPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  //NTP requests are to port NTP_REQUEST_PORT = 123\n  if (Udp.connect(timeServerIP, NTP_REQUEST_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    Udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);\n    });\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendNTPPacket();\n\n  // wait 60 seconds before asking for the time again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "dns",
        "ntp",
        "spi",
        "millis",
        "delay",
        "timestamp"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h",
        "time.h"
      ],
      "functions": [
        {
          "name": "sendACKPacket",
          "parameters": "void",
          "body": "Serial.println(\"============= sendACKPacket =============\");\n\n  // Send unicast ACK to the same remoteIP and remotePort we received the packet\n  // The AsyncUDP_STM32 library will take care of the correct IP and port based on pcb\n  Udp.write((uint8_t *) ReplyBuffer, sizeof(ReplyBuffer));"
        },
        {
          "name": "createNTPpacket",
          "parameters": "void",
          "body": "Serial.println(\"============= createNTPpacket =============\");\n\n  // set all bytes in the buffer to 0\n  memset(packetBuffer, 0, NTP_PACKET_SIZE);\n  // Initialize values needed to form NTP request\n  // (see URL above for details on the packets)\n\n  packetBuffer[0]   = 0b11100011;   // LI, Version, Mode\n  packetBuffer[1]   = 0;     // Stratum, or type of clock\n  packetBuffer[2]   = 6;     // Polling Interval\n  packetBuffer[3]   = 0xEC;  // Peer Clock Precision\n\n  // 8 bytes of zero for Root Delay & Root Dispersion\n  packetBuffer[12]  = 49;\n  packetBuffer[13]  = 0x4E;\n  packetBuffer[14]  = 49;\n  packetBuffer[15]  = 52;"
        },
        {
          "name": "sendNTPPacket",
          "parameters": "void",
          "body": "createNTPpacket();\n  //Send unicast\n  Udp.write(packetBuffer, sizeof(packetBuffer));"
        },
        {
          "name": "parsePacket",
          "parameters": "AsyncUDPPacket packet",
          "body": "struct tm  ts;\n  char       buf[80];\n\n  memcpy(packetBuffer, packet.data(), sizeof(packetBuffer));\n\n  Serial.print(\"Received UDP Packet Type: \");\n  Serial.println(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\"From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.println();\n\n  unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);\n  unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);\n\n  // combine the four bytes (two words) into a long integer\n  // this is NTP time (seconds since Jan 1 1900):\n  unsigned long secsSince1900 = highWord << 16 | lowWord;\n\n  Serial.print(F(\"Seconds since Jan 1 1900 = \"));\n  Serial.println(secsSince1900);\n\n  // now convert NTP time into )everyday time:\n  Serial.print(F(\"Epoch/Unix time = \"));\n\n  // Unix time starts on Jan 1 1970. In seconds, that's 2208988800:\n  const unsigned long seventyYears = 2208988800UL;\n\n  // subtract seventy years:\n  unsigned long epoch = secsSince1900 - seventyYears;\n  time_t epoch_t = epoch;   //secsSince1900 - seventyYears;\n\n  // print Unix time:\n  Serial.println(epoch);\n\n  // print the hour, minute and second:\n  Serial.print(F(\"The UTC/GMT time is \"));       // UTC is the time at Greenwich Meridian (GMT)\n\n  ts = *localtime(&epoch_t);\n  strftime(buf, sizeof(buf), \"%a %Y-%m-%d %H:%M:%S %Z\", &ts);\n  Serial.println(buf);\n\n  // send a reply, to the IP address and port that sent us the packet we received\n  sendACKPacket();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUDPSendReceive on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUDPSendReceive started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  Serial.println(F(\"\\nStarting connection to server...\"));\n\n  //NTP requests are to port NTP_REQUEST_PORT = 123\n  if (Udp.connect(timeServerIP, NTP_REQUEST_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    Udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);\n    });\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendNTPPacket();\n\n  // wait 60 seconds before asking for the time again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + GET_Location).c_str());\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncWebClientRepeating on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);\n  }\n\n#endif\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  printWifiStatus();\n\n  ///////////////////////////////////\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);"
        },
        {
          "name": "sendRequestRepeat",
          "parameters": "",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "millis"
      ],
      "libraries": [
        "defines.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "parameters": "",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + GET_Location).c_str());\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();\n    }\n    else\n    {\n      Serial.println(\"Can't send bad request\");\n    }\n  }\n  else\n  {\n    Serial.println(\"Can't send request\");\n  }"
        },
        {
          "name": "requestCB",
          "parameters": "void *optParm, AsyncHTTPRequest *request, int readyState",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncWebClientRepeating_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);\n  }\n\n#endif\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"AsyncHTTPRequest @ IP : \"));\n  Serial.println(Ethernet.localIP());\n  Serial.println();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  sendHTTPRequest.start(); //start the ticker\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "asyncwebserver",
        "https",
        "publish",
        "subscribe",
        "payload",
        "current",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "freertos/FreeRTOS.h",
        "freertos/timers.h",
        "AsyncMqtt_Generic.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "connectToWifi",
          "parameters": "",
          "body": "Serial.println(\"Connecting to Wi-Fi...\");\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);"
        },
        {
          "name": "connectToMqtt",
          "parameters": "",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "WiFiEvent",
          "parameters": "WiFiEvent_t event",
          "body": "switch (event)\n  {\n#if USING_CORE_ESP32_CORE_V200_PLUS\n\n    case ARDUINO_EVENT_WIFI_READY:\n      Serial.println(\"WiFi ready\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_START:\n      Serial.println(\"WiFi STA starting\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_CONNECTED:\n      Serial.println(\"WiFi STA connected\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP6:\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP:\n      Serial.println(\"WiFi connected\");\n      Serial.print(\"IP address: \");\n      Serial.println(WiFi.localIP());\n      connectToMqtt();\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_LOST_IP:\n      Serial.println(\"WiFi lost IP\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:\n      Serial.println(\"WiFi lost connection\");\n      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi\n      xTimerStart(wifiReconnectTimer, 0);\n      break;\n#else\n\n    case SYSTEM_EVENT_STA_GOT_IP:\n      Serial.println(\"WiFi connected\");\n      Serial.println(\"IP address: \");\n      Serial.println(WiFi.localIP());\n      connectToMqtt();\n      break;\n\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n      Serial.println(\"WiFi lost connection\");\n      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi\n      xTimerStart(wifiReconnectTimer, 0);\n      break;\n#endif\n\n    default:\n      break;\n  }"
        },
        {
          "name": "connectToMqttLoop",
          "parameters": "",
          "body": "if (WiFi.status() == WL_CONNECTED)\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();\n    }\n  }\n  else\n  {\n    Serial.println(\"WiFi disconnected\");\n  }"
        },
        {
          "name": "printSeparationLine",
          "parameters": "",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "parameters": "bool sessionPresent",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"ESP32 Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"ESP32 Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"ESP32 Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "parameters": "AsyncMqttClientDisconnectReason reason",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "parameters": "const uint16_t& packetId, const uint8_t& qos",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "parameters": "const uint16_t& packetId",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "parameters": "const uint16_t& packetId",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MQTT on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  mqttReconnectTimer = xTimerCreate(\"mqttTimer\", pdMS_TO_TICKS(2000), pdFALSE, (void*)0,\n                                    reinterpret_cast<TimerCallbackFunction_t>(connectToMqtt));\n  wifiReconnectTimer = xTimerCreate(\"wifiTimer\", pdMS_TO_TICKS(10000), pdFALSE, (void*)0,\n                                    reinterpret_cast<TimerCallbackFunction_t>(connectToWifi));\n\n  WiFi.onEvent(WiFiEvent);\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToWifi();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from ESP32!\");\n  });\n\n  server.begin();"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) /*|| (checkstatus_timeout == 0)*/)\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "asyncwebserver",
        "https",
        "publish",
        "subscribe",
        "payload",
        "current",
        "wifi",
        "millis",
        "delay",
        "gatewayip"
      ],
      "libraries": [
        "WiFi.h",
        "Ticker.h",
        "AsyncMqtt_Generic.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"Connected to SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"Signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "connectToWifi",
          "parameters": "",
          "body": "// check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(WIFI_SSID);\n\n#define MAX_NUM_WIFI_CONNECT_TRIES_PER_LOOP       20\n\n  uint8_t numWiFiConnectTries = 0;\n\n  // attempt to connect to WiFi network\n  while ( (status != WL_CONNECTED) && (numWiFiConnectTries++ < MAX_NUM_WIFI_CONNECT_TRIES_PER_LOOP) )\n  {\n    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    delay(500);\n  }\n\n  if (status != WL_CONNECTED)\n  {\n    // Restart for Portenta as something is very wrong\n    Serial.println(\"Resetting. Can't connect to any WiFi\");\n\n    NVIC_SystemReset();\n  }\n\n  printWifiStatus();\n\n  connectedWiFi = (status == WL_CONNECTED);\n\n  return (status == WL_CONNECTED);"
        },
        {
          "name": "isWiFiConnected",
          "parameters": "",
          "body": "// You can change longer or shorter depending on your network response\n  // Shorter => more responsive, but more ping traffic\n  static uint8_t theTTL = 10;\n\n  // Use ping() to test TCP connections\n  if (WiFi.ping(WiFi.gatewayIP(), theTTL) == theTTL)\n  {\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "connectToMqttLoop",
          "parameters": "",
          "body": "//if ( (WiFi.status() == WL_CONNECTED) && (WiFi.RSSI() != 0) )      // temporary workaround\n  if (isWiFiConnected())\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();\n    }\n\n    if (!connectedWiFi)\n    {\n      Serial.println(\"WiFi reconnected\");\n      connectedWiFi = true;\n    }\n  }\n  else\n  {\n    if (connectedWiFi)\n    {\n      Serial.println(\"WiFi disconnected. Reconnecting\");\n      connectedWiFi = false;\n\n      connectToWifi();\n    }\n  }"
        },
        {
          "name": "connectToMqtt",
          "parameters": "",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "parameters": "",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "parameters": "bool sessionPresent",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"RP2040W Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"RP2040W Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"RP2040W Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "parameters": "AsyncMqttClientDisconnectReason reason",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "parameters": "const uint16_t& packetId, const uint8_t& qos",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "parameters": "const uint16_t& packetId",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "parameters": "const uint16_t& packetId",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MQTT_RP2040W on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  ///////////////////////////////////\n\n  connectToWifi();\n\n  ///////////////////////////////////\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToMqttTicker.start(); //start the ticker.\n\n  connectToMqtt();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from RP2040W!\");\n  });\n\n  server.begin();"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) /*|| (checkstatus_timeout == 0)*/)\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "connectToMqttTicker.update(); //update the ticker.\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "buffer",
        "dns",
        "spi",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "createPage",
          "parameters": "String &pageInput",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_SendChunked_ESP32_ENC!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n</body>\\\n</html>\", ARDUINO_BOARD, ARDUINO_BOARD, day, hr % 24, min % 60, sec % 60);\n\n  pageInput = temp;"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < 500; lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"ESP32_ENC_AsyncWebServer_SendChunked_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";\n  }\n\n  out += \"</table></body></html>\\r\\n\";\n\n  AWS_LOGDEBUG1(\"Total length to send in chunks =\", out.length());\n\n  AsyncWebServerResponse *response = request->beginChunkedResponse(\"text/html\", [](uint8_t *buffer, size_t maxLen,\n                                                                                   size_t filledLength) -> size_t\n  {\n    size_t len = min(maxLen, out.length() - filledLength);\n    memcpy(buffer, out.c_str() + filledLength, len);\n\n    AWS_LOGDEBUG1(\"Bytes sent in chunk =\", len);\n\n    return len;\n  });\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart AsyncWebServer_SendChunked on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncWebServer is @ IP : \"));\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "#define BUFFER_SIZE     400\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_ESP32_SC_ENC!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, day, hr % 24, min % 60, sec % 60);\n\n  request->send(200, \"text/html\", temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String out;\n\n  out.reserve(3000);\n  char temp[70];\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += \"</g>\\n</svg>\\n\";\n\n  request->send(200, \"image/svg+xml\", out);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_AdvancedWebServer on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    drawGraph(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "password",
        "key",
        "wifi",
        "digitalwrite",
        "millis",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n\n\tint sec = millis() / 1000;\n\tint min = sec / 60;\n\tint hr = min / 60;\n\tint day = hr / 24;\n\n\tsnprintf(temp, BUFFER_SIZE - 1,\n\t         \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='60'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_RP2040W for %s!</h2>\\\n<h3>running WiFi on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, countryCode, BOARD_NAME, day, hr % 24, min % 60, sec % 60);\n\n\trequest->send(200, \"text/html\", temp);\n\n\tdigitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n\tString message = \"File Not Found\\n\\n\";\n\n\tmessage += \"URI: \";\n\tmessage += request->url();\n\tmessage += \"\\nMethod: \";\n\tmessage += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n\tmessage += \"\\nArguments: \";\n\tmessage += request->args();\n\tmessage += \"\\n\";\n\n\tfor (uint8_t i = 0; i < request->args(); i++)\n\t{\n\t\tmessage += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n\t}\n\n\trequest->send(404, \"text/plain\", message);\n\tdigitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String out;\n\n\tout.reserve(4000);\n\tchar temp[70];\n\n\tdigitalWrite(LED_BUILTIN, LED_ON);\n\n\tout += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n\tout += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n\tout += \"<g stroke=\\\"blue\\\">\\n\";\n\tint y = rand() % 130;\n\n\tfor (int x = 10; x < 300; x += 10)\n\t{\n\t\tint y2 = rand() % 130;\n\t\tsprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n\t\tout += temp;\n\t\ty = y2;\n\t}\n\n\tout += \"</g>\\n</svg>\\n\";\n\n\trequest->send(200, \"image/svg+xml\", out);\n\n\tdigitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);\n\n\t// print your board's country code\n\t// #define CYW43_COUNTRY(A, B, REV) ((unsigned char)(A) | ((unsigned char)(B) << 8) | ((REV) << 16))\n\tuint32_t myCountryCode = cyw43_arch_get_country_code();\n\n\tcountryCode[0] = myCountryCode & 0xFF;\n\tcountryCode[1] = (myCountryCode >> 8) & 0xFF;\n\n\tSerial.print(\"Country code: \");\n\tSerial.println(countryCode);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n\tdigitalWrite(LED_BUILTIN, LED_OFF);\n\n\tSerial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart Async_AdvancedWebServer_Country on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);\n\t}\n\n\tSerial.print(F(\"Connecting to SSID: \"));\n\tSerial.println(ssid);\n\n\tstatus = WiFi.begin(ssid, pass);\n\n\tdelay(1000);\n\n\t// attempt to connect to WiFi network\n\twhile ( status != WL_CONNECTED)\n\t{\n\t\tdelay(500);\n\n\t\t// Connect to WPA/WPA2 network\n\t\tstatus = WiFi.status();\n\t}\n\n\tprintWifiStatus();\n\n\t///////////////////////////////////\n\n\tserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\thandleRoot(request);\n\t});\n\n\tserver.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\tdrawGraph(request);\n\t});\n\n\tserver.on(\"/inline\", [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", \"This works as well\");\n\t});\n\n\tserver.onNotFound(handleNotFound);\n\n\tserver.begin();\n\n\tSerial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n\tSerial.println(WiFi.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n\tSerial.print(F(\".\"));\n\n\tif (num == 80)\n\t{\n\t\tSerial.println();\n\t\tnum = 1;\n\t}\n\telse if (num++ % 10 == 0)\n\t{\n\t\tSerial.print(F(\" \"));\n\t}"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n\t// Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n\tif ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n\t{\n\t\theartBeatPrint();\n\t\tcheckstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n\t}"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "digitalwrite",
        "millis",
        "delay",
        "led",
        "rgb",
        "flash",
        "html"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n\n#define BUFFER_SIZE     400\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_STM32_LAN8720!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, day, hr % 24, min % 60, sec % 60);\n\n  request->send(200, \"text/html\", temp);\n\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);\n  digitalWrite(led, 0);"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String out;\n\n  out.reserve(3000);\n  char temp[70];\n  \n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n  out += \"</g>\\n</svg>\\n\";\n\n  request->send(200, \"image/svg+xml\", out);"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    drawGraph(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='60'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_ESP32_SC_ENC!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", ARDUINO_BOARD, ARDUINO_BOARD, day, hr % 24, min % 60, sec % 60);\n\n  request->send(200, \"text/html\", temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);"
        },
        {
          "name": "PrintHeapData",
          "parameters": "String hIn",
          "body": "static uint32_t maxFreeHeap = 0xFFFFFFFF;\n  static uint32_t totalHeap = ESP.getHeapSize();\n\n  uint32_t freeHeap  = ESP.getFreeHeap();\n\n  // Print and update only when larger heap\n  if (maxFreeHeap > freeHeap)\n  {\n    maxFreeHeap = freeHeap;\n\n    Serial.print(\"\\nHEAP DATA - \");\n    Serial.print(hIn);\n\n    Serial.print(\"  Max heap: \");\n    Serial.print(totalHeap);\n    Serial.print(\"  Free heap: \");\n    Serial.print(ESP.getFreeHeap());\n    Serial.print(\"  Used heap: \");\n    Serial.println(totalHeap - freeHeap);\n  }"
        },
        {
          "name": "PrintStringSize",
          "parameters": "String & out",
          "body": "static uint32_t count = 0;\n\n  // Print only when cStr length too large and corrupting memory or every (20 * 5) s\n  if ( (out.length() >= STRING_SIZE) || (++count > 20) )\n  {\n    Serial.print(\"\\nOut String Length=\");\n    Serial.println(out.length());\n\n    count = 0;\n  }"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String out;\n\n  out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += \"</g>\\n</svg>\\n\";\n\n  PrintHeapData(\"Pre Send\");\n\n  PrintStringSize(out);\n\n  request->send(200, \"image/svg+xml\", out);\n\n  PrintHeapData(\"Post Send\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MemoryIssues_SendArduinoString on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    drawGraph(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  PrintHeapData(\"Pre Create Arduino String\");"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='10'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_ESP32_SC_ENC!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", ARDUINO_BOARD, ARDUINO_BOARD, day, hr % 24, min % 60, sec % 60);\n\n  request->send(200, \"text/html\", temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);"
        },
        {
          "name": "PrintHeapData",
          "parameters": "String hIn",
          "body": "static uint32_t maxFreeHeap = 0xFFFFFFFF;\n  static uint32_t totalHeap = ESP.getHeapSize();\n\n  uint32_t freeHeap  = ESP.getFreeHeap();\n\n  // Print and update only when larger heap\n  if (maxFreeHeap > freeHeap)\n  {\n    maxFreeHeap = freeHeap;\n\n    Serial.print(\"\\nHEAP DATA - \");\n    Serial.print(hIn);\n\n    Serial.print(\"  Max heap: \");\n    Serial.print(totalHeap);\n    Serial.print(\"  Free heap: \");\n    Serial.print(ESP.getFreeHeap());\n    Serial.print(\"  Used heap: \");\n    Serial.println(totalHeap - freeHeap);\n  }"
        },
        {
          "name": "PrintStringSize",
          "parameters": "const char* cStr",
          "body": "Serial.print(\"\\nOut String Length=\");\n  Serial.println(strlen(cStr));"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "char temp[80];\n\n  cStr[0] = '\\0';\n\n  strcat(cStr, \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\");\n  strcat(cStr,\n         \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\");\n  strcat(cStr, \"<g stroke=\\\"blue\\\">\\n\");\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    strcat(cStr, temp);\n    y = y2;\n  }\n\n  strcat(cStr, \"</g>\\n</svg>\\n\");\n\n  PrintHeapData(\"Pre Send\");\n\n  // Print only when cStr length too large and corrupting memory\n  if ( (strlen(cStr) >= CSTRING_SIZE))\n  {\n    PrintStringSize(cStr);\n  }\n\n  request->send(200, \"image/svg+xml\", cStr, false);\n\n  PrintHeapData(\"Post Send\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MemoryIssues_Send_CString on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  cStr = (char *) malloc(CSTRING_SIZE);           // make a little larger than required\n\n  if (cStr == NULL)\n  {\n    Serial.println(\"Unable top Allocate RAM\");\n\n    for (;;);\n  }\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    drawGraph(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  PrintHeapData(\"Pre Create Arduino String\");"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    //Serial.println();\n    PrintStringSize(cStr);\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "buffer",
        "dns",
        "spi",
        "millis",
        "delay",
        "rgb",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>Async_AdvancedWebServer_SendChunked!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", ARDUINO_BOARD, ARDUINO_BOARD, day, hr % 24, min % 60, sec % 60);\n\n  request->send(200, \"text/html\", temp);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out = String();\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += \"</g>\\n</svg>\\n\";\n\n  AWS_LOGDEBUG1(\"Total length to send in chunks =\", out.length());\n\n  AsyncWebServerResponse *response = request->beginChunkedResponse(\"image/svg+xml\", [](uint8_t *buffer, size_t maxLen,\n                                                                                       size_t filledLength) -> size_t\n  {\n    size_t len = min(maxLen, out.length() - filledLength);\n    memcpy(buffer, out.c_str() + filledLength, len);\n\n    AWS_LOGDEBUG1(\"Bytes sent in chunk =\", len);\n\n    return len;\n  });\n\n  request->send(response);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_SendChunked on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    drawGraph(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncWebServer is @ IP : \"));\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "mqtt",
        "http",
        "https",
        "publish",
        "subscribe",
        "payload",
        "buffer",
        "wifi",
        "millis",
        "delay",
        "digitalwrite",
        "rgb",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "Ticker.h",
        "AsyncMqtt_Generic.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print your board's country code\n  // #define CYW43_COUNTRY(A, B, REV) ((unsigned char)(A) | ((unsigned char)(B) << 8) | ((REV) << 16))\n  uint32_t myCountryCode = cyw43_arch_get_country_code();\n  char countryCode[3] = { 0, 0, 0 };\n\n  countryCode[0] = myCountryCode & 0xFF;\n  countryCode[1] = (myCountryCode >> 8) & 0xFF;\n\n  Serial.print(\"Country code: \");\n  Serial.println(countryCode);"
        },
        {
          "name": "connectToWifi",
          "parameters": "",
          "body": "// check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);\n  }\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(WIFI_SSID);\n\n#define MAX_NUM_WIFI_CONNECT_TRIES_PER_LOOP       20\n\n  uint8_t numWiFiConnectTries = 0;\n\n  // attempt to connect to WiFi network\n  while ( (status != WL_CONNECTED) && (numWiFiConnectTries++ < MAX_NUM_WIFI_CONNECT_TRIES_PER_LOOP) )\n  {\n    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    delay(500);\n  }\n\n  if (status != WL_CONNECTED)\n  {\n    // Restart for Portenta as something is very wrong\n    Serial.println(\"Resetting. Can't connect to any WiFi\");\n\n    NVIC_SystemReset();\n  }\n\n  printWifiStatus();\n\n  connectedWiFi = (status == WL_CONNECTED);\n\n  return (status == WL_CONNECTED);"
        },
        {
          "name": "isWiFiConnected",
          "parameters": "",
          "body": "// You can change longer or shorter depending on your network response\n  // Shorter => more responsive, but more ping traffic\n  static uint8_t theTTL = 10;\n\n  // Use ping() to test TCP connections\n  if (WiFi.ping(WiFi.gatewayIP(), theTTL) == theTTL)\n  {\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "connectToMqttLoop",
          "parameters": "",
          "body": "//if ( (WiFi.status() == WL_CONNECTED) && (WiFi.RSSI() != 0) )      // temporary workaround\n  if (isWiFiConnected())\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();\n    }\n\n    if (!connectedWiFi)\n    {\n      Serial.println(\"WiFi reconnected\");\n      connectedWiFi = true;\n    }\n  }\n  else\n  {\n    if (connectedWiFi)\n    {\n      Serial.println(\"WiFi disconnected. Reconnecting\");\n      connectedWiFi = false;\n\n      connectToWifi();\n    }\n  }"
        },
        {
          "name": "connectToMqtt",
          "parameters": "",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "parameters": "",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "parameters": "bool sessionPresent",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"RP2040W Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"RP2040W Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"RP2040W Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "parameters": "AsyncMqttClientDisconnectReason reason",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "parameters": "const uint16_t& packetId, const uint8_t& qos",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "parameters": "const uint16_t& packetId",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "parameters": "const uint16_t& packetId",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "static uint32_t pageCount   = 0;\n  static uint32_t maxfreeHeap = 0;\n  static uint32_t minFreeHeap = 0xFFFFFFFF;\n  uint32_t curFreeHeap = rp2040.getFreeHeap();\n\n  if (maxfreeHeap < curFreeHeap)\n    maxfreeHeap = curFreeHeap;\n\n  if (minFreeHeap > curFreeHeap)\n    minFreeHeap = curFreeHeap;\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_SendChunked_MQTT!</h2>\\\n<h3>running WiFi on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d, pageCount: %lu</p>\\\n<p>Heap Free: %lu, Max: %lu, Min: %lu</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, day, hr % 24, min % 60, sec % 60, ++pageCount, curFreeHeap, maxfreeHeap, minFreeHeap);\n\n  request->send(200, \"text/html\", temp);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out = String();\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n\n  out += \"</g>\\n</svg>\\n\";\n\n  AWS_LOGDEBUG1(\"Total length to send in chunks =\", out.length());\n\n  AsyncWebServerResponse *response = request->beginChunkedResponse(\"image/svg+xml\", [](uint8_t *buffer, size_t maxLen, size_t filledLength) -> size_t\n  {\n    size_t len = min(maxLen, out.length() - filledLength);\n    memcpy(buffer, out.c_str() + filledLength, len);\n\n    AWS_LOGDEBUG1(\"Bytes sent in chunk =\", len);\n    \n    return len;\n  });\n\n  request->send(response);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LED_OFF);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_SendChunked_MQTT on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  ///////////////////////////////////\n\n  connectToWifi();\n\n  ///////////////////////////////////\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToMqttTicker.start(); //start the ticker.\n\n  connectToMqtt();\n  \n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    drawGraph(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncWebServer is @ IP : \"));\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "asyncwebserver",
        "http",
        "https",
        "digitalwrite",
        "millis",
        "delay",
        "led",
        "rgb",
        "flash",
        "html"
      ],
      "libraries": [
        "favicon.h",
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>AsyncWebServer_STM32!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n<img src=\\\"/test.svg\\\" />\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, day, hr % 24, min % 60, sec % 60);\n\n  request->send(200, \"text/html\", temp);\n\n  digitalWrite(led, 0);"
        },
        {
          "name": "drawFavicon",
          "parameters": "AsyncWebServerRequest *request",
          "body": "AsyncWebServerResponse *response = request->beginResponse(200, \"image/x-icon\", favicon_ico_gz, favicon_ico_gz_len);\n  \n  response->addHeader(\"Content-Encoding\", \"gzip\");\n  request->send(response);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);\n  digitalWrite(led, 0);"
        },
        {
          "name": "drawGraph",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String out;\n\n  out.reserve(4000);\n  char temp[80];\n\n  digitalWrite(led, 1);\n  \n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;\n  }\n  \n  out += \"</g>\\n</svg>\\n\";\n\n  request->send(200, \"image/svg+xml\", out);\n\n  digitalWrite(led, 0);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_favicon on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/test.svg\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    drawGraph(request);\n  });\n\n  server.on(\"/favicon.ico\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    drawFavicon(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "millis",
        "display",
        "littlefs",
        "spiffs",
        "eeprom",
        "flash",
        "gatewayip"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(\"\\nStarting Async_AutoConnectAP using \" + String(FS_Name));\n  Serial.println(\" on \" + String(ARDUINO_BOARD));\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 ) \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AutoConnectAP\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AutoConnectAP\");\n#endif\n\n  ESPAsync_wifiManager.setDebugOutput(true);\n\n  //reset settings - for testing\n  //ESPAsync_wifiManager.resetSettings();\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  String chipID = String(ESP_getChipId(), HEX);\n  chipID.toUpperCase();\n\n  // SSID and PW for Config Portal\n  String AP_SSID = \"ESP_\" + chipID + \"_AutoConnectAP\";\n  String AP_PASS = \"MyESP_\" + chipID;\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(AP_SSID);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(AP_PASS);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n \n    // Starts an access point\n    //if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    if ( !ESPAsync_wifiManager.startConfigPortal(AP_SSID.c_str(), AP_PASS.c_str()) )\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n  else\n  {\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "json",
        "callback",
        "buffer",
        "parse",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "littlefs",
        "spiffs",
        "eeprom",
        "flash",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "saveConfigCallback",
          "parameters": "",
          "body": "Serial.println(F(\"Should save config\"));\n  shouldSaveConfig = true;"
        },
        {
          "name": "loadFileFSConfigFile",
          "parameters": "",
          "body": "//clean FS, for testing\n  //FileFS.format();\n\n  //read configuration from FS json\n  Serial.println(F(\"Mounting FS...\"));\n\n  if (FileFS.begin())\n  {\n    Serial.println(F(\"Mounted file system\"));\n\n    if (FileFS.exists(configFileName))\n    {\n      //file exists, reading and loading\n      Serial.println(F(\"Reading config file\"));\n      File configFile = FileFS.open(configFileName, \"r\");\n\n      if (configFile)\n      {\n        Serial.print(F(\"Opened config file, size = \"));\n        size_t configFileSize = configFile.size();\n        Serial.println(configFileSize);\n\n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[configFileSize + 1]);\n\n        configFile.readBytes(buf.get(), configFileSize);\n\n        Serial.print(F(\"\\nJSON parseObject() result : \"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n        DynamicJsonDocument json(1024);\n        auto deserializeError = deserializeJson(json, buf.get(), configFileSize);\n\n        if ( deserializeError )\n        {\n          Serial.println(F(\"failed\"));\n          return false;\n        }\n        else\n        {\n          Serial.println(F(\"OK\"));\n\n          if (json[\"blynk_server\"])\n            strncpy(blynk_server, json[\"blynk_server\"], sizeof(blynk_server));\n         \n          if (json[\"blynk_port\"])\n            strncpy(blynk_port, json[\"blynk_port\"], sizeof(blynk_port));\n \n          if (json[\"blynk_token\"])\n            strncpy(blynk_token,  json[\"blynk_token\"], sizeof(blynk_token));\n\n          if (json[\"mqtt_server\"])\n            strncpy(mqtt_server, json[\"mqtt_server\"], sizeof(mqtt_server));\n\n          if (json[\"mqtt_port\"])  \n            strncpy(mqtt_port,   json[\"mqtt_port\"], sizeof(mqtt_port));\n        }\n\n        //serializeJson(json, Serial);\n        serializeJsonPretty(json, Serial);\n#else\n        DynamicJsonBuffer jsonBuffer;\n        // Parse JSON string\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        // Test if parsing succeeds.\n\n        if (json.success())\n        {\n          Serial.println(\"OK\");\n\n          if (json[\"blynk_server\"])\n            strncpy(blynk_server, json[\"blynk_server\"], sizeof(blynk_server));\n         \n          if (json[\"blynk_port\"])\n            strncpy(blynk_port, json[\"blynk_port\"], sizeof(blynk_port));\n \n          if (json[\"blynk_token\"])\n            strncpy(blynk_token,  json[\"blynk_token\"], sizeof(blynk_token));\n\n          if (json[\"mqtt_server\"])\n            strncpy(mqtt_server, json[\"mqtt_server\"], sizeof(mqtt_server));\n\n          if (json[\"mqtt_port\"])  \n            strncpy(mqtt_port,   json[\"mqtt_port\"], sizeof(mqtt_port));\n        }\n        else\n        {\n          Serial.println(F(\"failed\"));\n          return false;\n        }\n        //json.printTo(Serial);\n        json.prettyPrintTo(Serial);\n#endif\n\n        configFile.close();\n      }\n    }\n  }\n  else\n  {\n    Serial.println(F(\"failed to mount FS\"));\n    return false;\n  }\n  return true;"
        },
        {
          "name": "saveFileFSConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving config\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  json[\"blynk_server\"] = blynk_server;\n  json[\"blynk_port\"]   = blynk_port;\n  json[\"blynk_token\"]  = blynk_token;\n\n  json[\"mqtt_server\"] = mqtt_server;\n  json[\"mqtt_port\"]   = mqtt_port;\n\n  File configFile = FileFS.open(configFileName, \"w\");\n\n  if (!configFile)\n  {\n    Serial.println(F(\"Failed to open config file for writing\"));\n\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  //serializeJson(json, Serial);\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, configFile);\n#else\n  //json.printTo(Serial);\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(configFile);\n#endif\n\n  configFile.close();\n  //end save\n\n  return true;"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(PIN_LED, !digitalRead(PIN_LED));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFSParams using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  loadFileFSConfigFile();\n\n  // The extra parameters to be configured (can be either global or just in the setup)\n  // After connecting, parameter.getValue() will get you the configured value\n  // id/name placeholder/prompt default length\n  ESPAsync_WMParameter custom_blynk_server(\"blynk_server\", \"blynk_server\", blynk_server, BLYNK_SERVER_LEN + 1);\n  ESPAsync_WMParameter custom_blynk_port  (\"blynk_port\",   \"blynk_port\",   blynk_port,   BLYNK_SERVER_PORT_LEN + 1);\n  ESPAsync_WMParameter custom_blynk_token (\"blynk_token\",  \"blynk_token\",  blynk_token,  BLYNK_TOKEN_LEN + 1 );\n\n  ESPAsync_WMParameter custom_mqtt_server(\"mqtt_server\", \"mqtt_server\", mqtt_server, MQTT_SERVER_MAX_LEN + 1);\n  ESPAsync_WMParameter custom_mqtt_port  (\"mqtt_port\",   \"mqtt_port\",   mqtt_port,   MQTT_SERVER_PORT_LEN + 1);\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 ) \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AutoConnect-FSParams\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AutoConnect-FSParams\");\n#endif\n\n  //set config save notify callback\n  ESPAsync_wifiManager.setSaveConfigCallback(saveConfigCallback);\n\n  //add all your parameters here\n  ESPAsync_wifiManager.addParameter(&custom_blynk_server);\n  ESPAsync_wifiManager.addParameter(&custom_blynk_port);\n  ESPAsync_wifiManager.addParameter(&custom_blynk_token);\n\n  ESPAsync_wifiManager.addParameter(&custom_mqtt_server);\n  ESPAsync_wifiManager.addParameter(&custom_mqtt_port);\n\n  //reset settings - for testing\n  //ESPAsync_wifiManager.resetSettings();\n\n  ESPAsync_wifiManager.setDebugOutput(true);\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  //set minimum quality of signal so it ignores AP's under that quality\n  //defaults to 8%\n  //ESPAsync_wifiManager.setMinimumSignalQuality();\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS/LittleFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  String chipID = String(ESP_getChipId(), HEX);\n  chipID.toUpperCase();\n\n  // SSID and PW for Config Portal\n  AP_SSID = \"ESP_\" + chipID + \"_AutoConnectAP\";\n  AP_PASS = \"MyESP_\" + chipID;\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(AP_SSID);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(AP_PASS);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    //if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    if ( !ESPAsync_wifiManager.startConfigPortal(AP_SSID.c_str(), AP_PASS.c_str()) )\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n  else\n  {\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n\n  //read updated parameters\n  strncpy(blynk_server, custom_blynk_server.getValue(), sizeof(blynk_server));\n  strncpy(blynk_port,   custom_blynk_port.getValue(),   sizeof(blynk_port));\n  strncpy(blynk_token,  custom_blynk_token.getValue(),  sizeof(blynk_token));\n\n  strncpy(mqtt_server, custom_mqtt_server.getValue(), sizeof(mqtt_server));\n  strncpy(mqtt_port, custom_mqtt_port.getValue(),     sizeof(mqtt_port));\n\n  //save the custom parameters to FS\n  if (shouldSaveConfig)\n  {\n    saveFileFSConfigFile();\n  }\n\n  Serial.print(\"Local IP = \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "asyncwebserver",
        "wificlient",
        "mqtt",
        "webserver",
        "https",
        "password",
        "token",
        "json",
        "callback",
        "buffer",
        "parse",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "saveConfigCallback",
          "parameters": "",
          "body": "Serial.println(\"Should save config\");\n  shouldSaveConfig = true;"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  \n  static ulong currentMillis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  currentMillis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((currentMillis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = currentMillis + WIFICHECK_INTERVAL;\n  }\n\n  if ((currentMillis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = currentMillis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((currentMillis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = currentMillis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LED_ON);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFSParametersAndCustomIP using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  //clean FS, for testing\n  //FileFS.format();\n\n  // Mount the filesystem\n  // Format FileFS if not yet\n#ifdef ESP32\n  bool result = FileFS.begin(true);\n  \n  if (!result)\n#else\n  bool result = FileFS.begin();\n  \n  if (!result)\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }  \n\n#if USE_LITTLEFS\n  Serial.print(F(\"\\nLittleFS opened: \"));\n#else\n  Serial.print(F(\"\\nSPIFFS opened: \"));\n#endif\n\n  Serial.println(result ? F(\"OK\") : F(\"Failed\"));\n\n  //read configuration from FS json\n  Serial.println(F(\"Mounting FS...\"));\n\n  if (result) \n  {\n    Serial.println(F(\"Mounted file system\"));\n    \n    if (FileFS.exists(CONFIG_FILE)) \n    {\n      //file exists, reading and loading\n      Serial.println(F(\"Reading config file\"));\n      \n      File configFile = FileFS.open(CONFIG_FILE, \"r\");\n      \n      if (configFile) \n      {\n        Serial.println(F(\"Opened config file\"));\n        \n        size_t size = configFile.size();\n        \n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[size]);\n\n        configFile.readBytes(buf.get(), size);\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n        DynamicJsonDocument json(1024);\n        auto deserializeError = deserializeJson(json, buf.get());\n\n        serializeJson(json, Serial);\n        \n        if ( !deserializeError )    \n#else\n        DynamicJsonBuffer jsonBuffer;\n        \n        // Parse JSON string\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        \n        json.printTo(Serial);\n\n        // Test if parsing succeeds.\n        if (json.success()) \n#endif        \n        {\n          Serial.println(F(\"\\nParsed json\"));\n\n          strcpy(mqtt_server, json[\"mqtt_server\"]);\n          strcpy(mqtt_port,   json[\"mqtt_port\"]);\n          strcpy(blynk_token, json[\"blynk_token\"]);\n        }  \n        else \n        {\n          Serial.println(F(\"Failed to load json config\"));\n        }\n      }\n    }\n  } \n  else \n  {\n    Serial.println(F(\"Failed to mount FS\"));\n  }\n  \n  //end read\n  Serial.println(String(\"MQTT Server = \") + mqtt_server);\n  Serial.println(String(\"MQTT Port   = \") + mqtt_port);\n  Serial.println(String(\"Blynk Token = \") + blynk_token);\n  \n  // The extra parameters to be configured (can be either global or just in the setup)\n  // After connecting, parameter.getValue() will get you the configured value\n  // id/name placeholder/prompt default length\n  ESPAsync_WMParameter custom_mqtt_server (\"server\",  \"mqtt server\",  mqtt_server,  40);\n  ESPAsync_WMParameter custom_mqtt_port   (\"port\",    \"mqtt port\",    mqtt_port,    5);\n  ESPAsync_WMParameter custom_blynk_token (\"blynk\",   \"blynk token\",  blynk_token,  34);\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AutoConnect-FSParams\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AutoConnect-FSParams\");\n#endif\n\n  //set config save notify callback\n  ESPAsync_wifiManager.setSaveConfigCallback(saveConfigCallback);\n\n  //add all your parameters here\n  ESPAsync_wifiManager.addParameter(&custom_mqtt_server);\n  ESPAsync_wifiManager.addParameter(&custom_mqtt_port);\n  ESPAsync_wifiManager.addParameter(&custom_blynk_token);\n\n  //reset settings - for testing\n  //ESPAsync_wifiManager.resetSettings();\n\n  ESPAsync_wifiManager.setDebugOutput(true);\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  //set minimum quality of signal so it ignores AP's under that quality\n  //defaults to 8%\n  //ESPAsync_wifiManager.setMinimumSignalQuality();\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS/LittleFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  String chipID = String(ESP_getChipId(), HEX);\n  chipID.toUpperCase();\n\n  // SSID and PW for Config Portal\n  AP_SSID = \"ESP_\" + chipID + \"_AutoConnectAP\";\n  AP_PASS = \"MyESP_\" + chipID;\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(AP_SSID);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(AP_PASS);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    //if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    if ( !ESPAsync_wifiManager.startConfigPortal(AP_SSID.c_str(), AP_PASS.c_str()) )\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n  else\n  {\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n\n  //read updated parameters\n  strcpy(mqtt_server, custom_mqtt_server.getValue());\n  strcpy(mqtt_port, custom_mqtt_port.getValue());\n  strcpy(blynk_token, custom_blynk_token.getValue());\n\n  //save the custom parameters to FS\n  if (shouldSaveConfig) \n  {\n    Serial.println(F(\"Saving config\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n    DynamicJsonDocument json(1024);\n#else\n    DynamicJsonBuffer jsonBuffer;\n    JsonObject& json = jsonBuffer.createObject();\n#endif\n    \n    json[\"mqtt_server\"] = mqtt_server;\n    json[\"mqtt_port\"]   = mqtt_port;\n    json[\"blynk_token\"] = blynk_token;\n\n    File configFile     = FileFS.open(CONFIG_FILE, \"w\");\n    \n    if (!configFile) \n    {\n      Serial.println(F(\"Failed to open config file for writing\"));\n    }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n    serializeJsonPretty(json, Serial);\n    // Write data to file and close it\n    serializeJson(json, configFile);\n#else\n    json.prettyPrintTo(Serial);\n    // Write data to file and close it\n    json.printTo(configFile);\n#endif\n    \n    configFile.close();\n    //end save\n  }\n\n  Serial.print(F(\"Local IP = \"));\n  Serial.println(WiFi.localIP());\n  Serial.print(F(\"GateWay IP = \"));\n  Serial.println(WiFi.gatewayIP());\n  Serial.print(F(\"SubnetMask = \")); \n  Serial.println(WiFi.subnetMask());\n\n  //keep LED off\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "callback",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "millis",
        "display",
        "littlefs",
        "spiffs",
        "eeprom",
        "flash",
        "gatewayip"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "configModeCallback",
          "parameters": "ESPAsync_WiFiManager *myESP_WiFiManager",
          "body": "Serial.print(F(\"Entered config mode with \"));\n  Serial.println(\"AP_SSID : \" + myESP_WiFiManager->getConfigPortalSSID() + \" and AP_PASS = \" + myESP_WiFiManager->getConfigPortalPW());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFeedBack using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AutoConnectWithFeedBack\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AutoConnectWithFeedBack\");\n#endif\n\n  //reset settings - for testing\n  //ESPAsync_wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  ESPAsync_wifiManager.setAPCallback(configModeCallback);\n\n  ESPAsync_wifiManager.setDebugOutput(true);\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  String chipID = String(ESP_getChipId(), HEX);\n  chipID.toUpperCase();\n\n  // SSID and PW for Config Portal\n  AP_SSID = \"ESP_\" + chipID + \"_AutoConnectAP\";\n  AP_PASS = \"MyESP_\" + chipID;\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(AP_SSID);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(AP_PASS);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    //if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    if ( !ESPAsync_wifiManager.startConfigPortal(AP_SSID.c_str(), AP_PASS.c_str()) )\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n  else\n  {\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "callback",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "littlefs",
        "spiffs",
        "eeprom",
        "flash",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(PIN_LED, !digitalRead(PIN_LED));"
        },
        {
          "name": "configModeCallback",
          "parameters": "ESPAsync_WiFiManager *myESP_WiFiManager",
          "body": "Serial.print(\"Entered config mode with \");\n  Serial.println(\"AP_SSID : \" + myESP_WiFiManager->getConfigPortalSSID() + \" and AP_PASS = \" + myESP_WiFiManager->getConfigPortalPW());\n  //entered config mode, make led toggle faster at 0.2s\n  ticker.attach(0.2, toggleLED);"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(PIN_LED, OUTPUT);\n  \n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFeedBackLED using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  // start ticker with 0.5s because we start in AP mode and try to connect\n  ticker.attach(0.5, toggleLED);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AutoConnectFeedBackLED\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AAutoConnectFeedBackLED\");\n#endif\n\n  //reset settings - for testing\n  //ESPAsync_wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  ESPAsync_wifiManager.setAPCallback(configModeCallback);\n\n  ESPAsync_wifiManager.setDebugOutput(true);\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  String chipID = String(ESP_getChipId(), HEX);\n  chipID.toUpperCase();\n\n  // SSID and PW for Config Portal\n  AP_SSID = \"ESP_\" + chipID + \"_AutoConnectAP\";\n  AP_PASS = \"MyESP_\" + chipID;\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(AP_SSID);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(AP_PASS);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n    \n    // Starts an access point\n    //if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    if ( !ESPAsync_wifiManager.startConfigPortal(AP_SSID.c_str(), AP_PASS.c_str()) )\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n  else\n  {\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n    \n  ticker.detach();\n  //keep LED on\n  digitalWrite(PIN_LED, LED_ON);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "mqtt",
        "wificlient",
        "webserver",
        "https",
        "password",
        "ssl",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK\n    }\n    else \n    {\n      Serial.print(F(\"F\"));        // F means publishing failure\n    }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic,  Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 ) \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnDRD-FS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnDRD-FS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(\"Got stored Credentials. Timeout 120s\");\n  }\n  else\n  {\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n\n  // AIO_SERVER\n  ESPAsync_WMParameter AIO_SERVER_FIELD(AIO_SERVER_Label, \"AIO SERVER\", custom_AIO_SERVER, custom_AIO_SERVER_LEN + 1);\n\n  // AIO_SERVERPORT\n  ESPAsync_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVERPORT_Label, \"AIO SERVER PORT\", custom_AIO_SERVERPORT, custom_AIO_PORT_LEN + 1);\n\n  // AIO_USERNAME\n  ESPAsync_WMParameter AIO_USERNAME_FIELD(AIO_USERNAME_Label, \"AIO USERNAME\", custom_AIO_USERNAME, custom_AIO_USERNAME_LEN + 1);\n\n  // AIO_KEY\n  ESPAsync_WMParameter AIO_KEY_FIELD(AIO_KEY_Label, \"AIO KEY\", custom_AIO_KEY, custom_AIO_KEY_LEN + 1);\n\n  // add all parameters here\n  // order of adding is not important\n  ESPAsync_wifiManager.addParameter(&AIO_SERVER_FIELD);\n  ESPAsync_wifiManager.addParameter(&AIO_SERVERPORT_FIELD);\n  ESPAsync_wifiManager.addParameter(&AIO_USERNAME_FIELD);\n  ESPAsync_wifiManager.addParameter(&AIO_KEY_FIELD);\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESPAsync_wifiManager.setConfigPortalTimeout(120);\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n  // New. Update Credentials, got from loadConfigData(), to display on CP\n  ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                      WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n  if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  strcpy(custom_AIO_SERVER, AIO_SERVER_FIELD.getValue());\n  strcpy(custom_AIO_SERVERPORT, AIO_SERVERPORT_FIELD.getValue());\n  strcpy(custom_AIO_USERNAME, AIO_USERNAME_FIELD.getValue());\n  strcpy(custom_AIO_KEY, AIO_KEY_FIELD.getValue());\n \n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    if (json.containsKey(AIO_SERVER_Label))\n    {\n      strcpy(custom_AIO_SERVER, json[AIO_SERVER_Label]);\n    }\n\n    if (json.containsKey(AIO_SERVERPORT_Label))\n    {\n      strcpy(custom_AIO_SERVERPORT, json[AIO_SERVERPORT_Label]);\n    }\n\n    if (json.containsKey(AIO_USERNAME_Label))\n    {\n      strcpy(custom_AIO_USERNAME, json[AIO_USERNAME_Label]);\n    }\n\n    if (json.containsKey(AIO_KEY_Label))\n    {\n      strcpy(custom_AIO_KEY, json[AIO_KEY_Label]);\n    }\n  }\n  \n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  json[AIO_SERVER_Label]      = custom_AIO_SERVER;\n  json[AIO_SERVERPORT_Label]  = custom_AIO_SERVERPORT;\n  json[AIO_USERNAME_Label]    = custom_AIO_USERNAME;\n  json[AIO_KEY_Label]         = custom_AIO_KEY;\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    \n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  // Mount the filesystem\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n  \n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n  {\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n  }\n  else if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n \n  if (initialConfig)\n  {\n    loadConfigData();\n    \n    wifi_manager();\n  }\n  else\n  {   \n    // Pretend CP is necessary as we have no AP Credentials\n    initialConfig = true;\n\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (loadConfigData())\n    {\n#if USE_ESP_WIFIMANAGER_NTP      \n      if ( strlen(WM_config.TZ_Name) > 0 )\n      {\n        LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n        configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n      }\n      else\n      {\n        Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n      }\n#endif\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n          initialConfig = false;\n        }\n      }\n    }\n\n    if (initialConfig)\n    {\n      Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n    \n      wifi_manager();\n    }\n    else if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(\"ConnectMultiWiFi in setup\");\n     \n      connectMultiWiFi();\n    }\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "mqtt",
        "wificlient",
        "webserver",
        "https",
        "password",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "map"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK\n    }\n    else \n    {\n      Serial.print(F(\"F\"));        // F means publishing failure\n    }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic, Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  AsyncWebServer webServer(HTTP_PORT);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n  \n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n\n  // AIO_SERVER\n  ESPAsync_WMParameter AIO_SERVER_FIELD(AIO_SERVER_TOTAL_DATA[\"Server\"]); \n  DATA_FIELD[\"Server\"] = &AIO_SERVER_FIELD;\n  \n  // AIO_SERVERPORT\n  ESPAsync_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVER_TOTAL_DATA[\"ServerPort\"]); \n  DATA_FIELD[\"ServerPort\"] = &AIO_SERVERPORT_FIELD;\n\n  // AIO_USERNAME\n  ESPAsync_WMParameter AIO_USERNAME_FIELD(AIO_SERVER_TOTAL_DATA[\"UserName\"]); \n  DATA_FIELD[\"UserName\"] = &AIO_USERNAME_FIELD;\n\n  // AIO_KEY\n  ESPAsync_WMParameter AIO_KEY_FIELD(AIO_SERVER_TOTAL_DATA[\"Key\"]); \n  DATA_FIELD[\"Key\"] = &AIO_KEY_FIELD;\n   \n  // add all parameters here\n  // order of adding is not important\n  for (auto &data_field : DATA_FIELD) \n  {           \n    ESPAsync_wifiManager.addParameter(data_field.second); \n  }\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESPAsync_wifiManager.setConfigPortalTimeout(120);\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n  // New. Update Credentials, got from loadConfigData(), to display on CP\n  ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                      WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n  if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  for (auto &aio_data : AIO_SERVER_TOTAL_DATA) \n  {              \n    strcpy(aio_data.second._value, DATA_FIELD[aio_data.first]->getValue());\n  }\n \n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(AIO_SERVER_TOTAL_DATA[\"UserName\"]._value) + \"/feeds/Temperature\";\n  \n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    for (auto &aio_data : AIO_SERVER_TOTAL_DATA) \n    {           \n      if (json.containsKey(aio_data.second._id))\n      {\n        strcpy(aio_data.second._value, json[aio_data.second._id]);\n      }\n    }   \n  }\n\n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  for (auto &aio_data : AIO_SERVER_TOTAL_DATA) \n  {           \n    json[aio_data.second._id] = aio_data.second._value;\n  } \n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    \n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr_Complex using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  // Mount the filesystem\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n  \n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n  {\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n  }\n  else if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    loadConfigData();\n    \n    wifi_manager();\n  }\n  else\n  {   \n    // Pretend CP is necessary as we have no AP Credentials\n    initialConfig = true;\n\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (loadConfigData())\n    {\n#if USE_ESP_WIFIMANAGER_NTP      \n      if ( strlen(WM_config.TZ_Name) > 0 )\n      {\n        LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n        configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n      }\n      else\n      {\n        Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n      } \n#endif\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n          initialConfig = false;\n        }\n      }\n    }\n\n    if (initialConfig)\n    {\n      Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n    \n      wifi_manager();\n    }\n    else if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();\n\n  delay(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "mqtt",
        "wificlient",
        "webserver",
        "https",
        "password",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK\n    }\n    else \n    {\n      Serial.print(F(\"F\"));        // F means publishing failure\n    }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic,  Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n  // AIO_SERVER\n  ESPAsync_WMParameter AIO_SERVER_FIELD(AIO_SERVER_TOTAL_DATA[0]); \n  DATA_FIELD[0] = &AIO_SERVER_FIELD;\n  \n  // AIO_SERVERPORT\n  ESPAsync_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVER_TOTAL_DATA[1]); \n  DATA_FIELD[1] = &AIO_SERVERPORT_FIELD;\n\n  // AIO_USERNAME\n  ESPAsync_WMParameter AIO_USERNAME_FIELD(AIO_SERVER_TOTAL_DATA[2]); \n  DATA_FIELD[2] = &AIO_USERNAME_FIELD;\n\n  // AIO_KEY\n  ESPAsync_WMParameter AIO_KEY_FIELD(AIO_SERVER_TOTAL_DATA[3]); \n  DATA_FIELD[3] = &AIO_KEY_FIELD;\n\n  // add all parameters here\n  // order of adding is not important\n  for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n  {\n    ESPAsync_wifiManager.addParameter(DATA_FIELD[i]); \n  }\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESPAsync_wifiManager.setConfigPortalTimeout(120);\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n  // New. Update Credentials, got from loadConfigData(), to display on CP\n  ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                      WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n  \n  if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not OK. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n  {\n    strcpy(AIO_SERVER_TOTAL_DATA[i]._value, DATA_FIELD[i]->getValue());\n  }\n \n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(AIO_SERVER_TOTAL_DATA[2]._value) + \"/feeds/Temperature\";\n  \n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n    {\n      if (json.containsKey(AIO_SERVER_TOTAL_DATA[i]._id))\n      {\n        strcpy(AIO_SERVER_TOTAL_DATA[i]._value, json[AIO_SERVER_TOTAL_DATA[i]._id]);\n      }\n    }   \n  }\n\n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n  {\n    json[AIO_SERVER_TOTAL_DATA[i]._id] = AIO_SERVER_TOTAL_DATA[i]._value;\n  }\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    \n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n  \n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr_Medium using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  // Mount the filesystem\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n  \n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n  {\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n  }\n  else if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n \n  if (initialConfig)\n  {\n    loadConfigData();\n    \n    wifi_manager();\n  }\n  else\n  {   \n    // Pretend CP is necessary as we have no AP Credentials\n    initialConfig = true;\n\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (loadConfigData())\n    {\n#if USE_ESP_WIFIMANAGER_NTP      \n      if ( strlen(WM_config.TZ_Name) > 0 )\n      {\n        LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n        configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n      }\n      else\n      {\n        Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n      } \n#endif\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n          initialConfig = false;\n        }\n      }\n    }\n\n    if (initialConfig)\n    {\n      Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n    \n      wifi_manager();\n    }\n    else if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "current",
        "voltage",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "millis",
        "digitalwrite",
        "display",
        "led",
        "eeprom",
        "littlefs",
        "spiffs",
        "flash",
        "rtc",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n  \n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AsyncConfigOnDoubleReset\");\n#else\n  AsyncDNSServer dnsServer;\n\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncConfigOnDoubleReset\");\n#endif\n\n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-11\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n  // New in v1.4.0\n  ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n  //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password   = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n\n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n\n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n    digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(600);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n\n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);\n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n\n    saveConfigData();\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED )\n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n\n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());   \n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "https",
        "password",
        "current",
        "voltage",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "digitalwrite",
        "led",
        "display",
        "eeprom",
        "spiffs",
        "littlefs",
        "flash",
        "rtc"
      ],
      "libraries": [
        "ESPAsync_WiFiManager.h",
        "Async_ConfigOnDoubleReset_Multi.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset_Multi using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n  \n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AsyncConfigOnDoubleReset\");\n#else\n  AsyncDNSServer dnsServer;\n\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncConfigOnDoubleReset\");\n#endif\n\n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-11\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n  // New in v1.4.0\n  ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n  //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password   = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n\n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n\n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n    digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(600);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n\n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);\n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n\n    saveConfigData();\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED )\n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n\n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());   \n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "current",
        "voltage",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "millis",
        "digitalwrite",
        "display",
        "led",
        "eeprom",
        "littlefs",
        "spiffs",
        "flash",
        "rtc",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset_TZ using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n  \n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AsyncConfigOnDoubleReset\");\n#else\n  AsyncDNSServer dnsServer;\n\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncConfigOnDoubleReset\");\n#endif\n\n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-11\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n  // New in v1.4.0\n  ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n  //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password   = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n\n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n\n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n    digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(600);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n\n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);\n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n\n    saveConfigData();\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED )\n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n\n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());   \n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "current",
        "voltage",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "gatewayip",
        "nodemcu"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnStartup using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AsyncConfigOnStartup\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncConfigOnStartup\");\n#endif\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.println(F(\"Opening configuration portal.\"));\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n  // New. Update Credentials, got from loadConfigData(), to display on CP\n  ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                      WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n  // Starts an access point\n  if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  else\n  {\n    Serial.println(F(\"WiFi connected...yeey :)\"));\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n\n    initialConfig = true;\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "voltage",
        "current",
        "wifi",
        "i2c",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "pwm",
        "nodemcu",
        "devices",
        "gatewayip"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwitch using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AsyncConfigOnSwitch\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncConfigOnSwitch\");\n#endif\n\n  ESPAsync_wifiManager.setDebugOutput(true);\n\n  // Use only to erase stored WiFi Credentials\n  //resetSettings();\n  //ESPAsync_wifiManager.resetSettings();\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif                   \n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif  \n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n    digitalWrite(LED_BUILTIN, LED_ON); // Turn led on as we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(600);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwitch\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwitch\");\n#endif\n\n    ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n    // From v1.0.10 only\n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n    ESPAsync_wifiManager.setConfigPortalChannel(0);\n    //////\n\n    //set custom ip for portal\n    //ESPAsync_wifiManager.setAPStaticIPConfig(IPAddress(192, 168, 100, 1), IPAddress(192, 168, 100, 1), IPAddress(255, 255, 255, 0));\n\n#if !USE_DHCP_IP    \n  #if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n  #endif \n#endif       \n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n   \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n    }\n    else if (loadConfigData())\n    {      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\")); \n    }\n    else\n    {\n      // Enter CP only if no stored SSID on flash and file \n      Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n      initialConfig = true;\n    }\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    //Starts an access point\n    //and goes into a blocking loop awaiting configuration\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n    {\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    }\n    else\n    {\n      //if you get here you have connected to the WiFi\n      Serial.println(F(\"connected...yeey :)\"));\n      Serial.print(F(\"Local IP: \"));\n      Serial.println(WiFi.localIP());\n    }\n\n    // Only clear then save data if CP entered and with new valid Credentials\n    // No CP => stored getSSID() = \"\"\n    if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n    {\n      // Stored  for later usage, from v1.1.0, but clear first\n      memset(&WM_config, 0, sizeof(WM_config));\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        String tempSSID = ESPAsync_wifiManager.getSSID(i);\n        String tempPW   = ESPAsync_wifiManager.getPW(i);\n    \n        if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n    \n        if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n    \n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n      String tempTZ = ESPAsync_wifiManager.getTimezoneName();\n  \n      if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n        strcpy(WM_config.TZ_Name, tempTZ.c_str());\n      else\n        strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n  \n      const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n      \n      if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n        strcpy(WM_config.TZ, TZ_Result);\n      else\n        strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n           \n      if ( strlen(WM_config.TZ_Name) > 0 )\n      {\n        LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n        configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n      }\n      else\n      {\n        LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n      }\n#endif\n\n      // New in v1.4.0\n      ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n      //////\n    \n      saveConfigData();\n    }\n\n    digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n  }\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "thingspeak",
        "asyncwebserver",
        "wificlient",
        "webserver",
        "api",
        "https",
        "password",
        "key",
        "json",
        "buffer",
        "parse",
        "current",
        "voltage",
        "wifi",
        "i2c",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "eeprom",
        "flash",
        "littlefs",
        "spiffs",
        "rtc",
        "pwm",
        "html",
        "nodemcu",
        "devices",
        "sensordht22",
        "sensordht22_label",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Configuration file not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    serializeJson(json, Serial);\n#else\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    json.printTo(Serial);\n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    if (json.containsKey(ThingSpeakAPI_Label))\n    {\n      strcpy(thingspeakApiKey, json[ThingSpeakAPI_Label]);\n    }\n\n    if (json.containsKey(SensorDht22_Label))\n    {\n      sensorDht22 = json[SensorDht22_Label];\n    }\n\n    if (json.containsKey(PinSDA_Label))\n    {\n      pinSda = json[PinSDA_Label];\n    }\n\n    if (json.containsKey(PinSCL_Label))\n    {\n      pinScl = json[PinSCL_Label];\n    }\n  }\n  Serial.println(F(\"\\nConfig file was successfully parsed\"));\n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving config file\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  json[ThingSpeakAPI_Label] = thingspeakApiKey;\n  json[SensorDht22_Label] = sensorDht22;\n  json[PinSDA_Label] = pinSda;\n  json[PinSCL_Label] = pinScl;\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open config file for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig file was successfully saved\"));\n  return true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwichFS using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  // Initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n  \n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Failed to read ConfigFile, using default values\"));\n  }\n\n  unsigned long startedAt = millis();\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwitchFS\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwitchFS\");\n#endif\n\n  ESPAsync_wifiManager.setDebugOutput(true);\n\n  // Use only to erase stored WiFi Credentials\n  //resetSettings();\n  //ESPAsync_wifiManager.resetSettings();\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif \n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif  \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif \n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n    digitalWrite(LED_BUILTIN, LED_ON); // Turn led on as we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(600);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    AsyncWebServer webServer(HTTP_PORT);\n    AsyncDNSServer dnsServer;\n    \n    ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwitchFS\");\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n   \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n    }\n    else if (loadConfigData())\n    {      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\")); \n    }\n    else\n    {\n      // Enter CP only if no stored SSID on flash and file \n      Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n      initialConfig = true;\n    }\n\n    // Extra parameters to be configured\n    // After connecting, parameter.getValue() will get you the configured value\n    // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n\n    // Thingspeak API Key - this is a straight forward string parameter\n    ESPAsync_WMParameter p_thingspeakApiKey(ThingSpeakAPI_Label, \"Thingspeak API Key\", thingspeakApiKey, 17);\n\n    // DHT-22 sensor present or not - bool parameter visualized using checkbox, so couple of things to note\n    // - value is always 'T' for true. When the HTML form is submitted this is the value that will be\n    //   sent as a parameter. When unchecked, nothing will be sent by the HTML standard.\n    // - customhtml must be 'type=\"checkbox\"' for obvious reasons. When the default is checked\n    //   append 'checked' too\n    // - labelplacement parameter is WFM_LABEL_AFTER for checkboxes as label has to be placed after the input field\n\n    char customhtml[24] = \"type=\\\"checkbox\\\"\";\n\n    if (sensorDht22)\n    {\n      strcat(customhtml, \" checked\");\n    }\n\n    ESPAsync_WMParameter p_sensorDht22(SensorDht22_Label, \"DHT-22 Sensor\", \"T\", 2, customhtml, WFM_LABEL_AFTER);\n\n    // I2C SCL and SDA parameters are integers so we need to convert them to char array but\n    // no other special considerations\n    char convertedValue[3];\n    sprintf(convertedValue, \"%d\", pinSda);\n    ESPAsync_WMParameter p_pinSda(PinSDA_Label, \"I2C SDA pin\", convertedValue, 3);\n    sprintf(convertedValue, \"%d\", pinScl);\n    ESPAsync_WMParameter p_pinScl(PinSCL_Label, \"I2C SCL pin\", convertedValue, 3);\n\n    // Just a quick hint\n    ESPAsync_WMParameter p_hint(\"<small>*Hint: if you want to reuse the currently active WiFi credentials, leave SSID and Password fields empty</small>\");\n\n    //add all parameters here\n\n    ESPAsync_wifiManager.addParameter(&p_hint);\n    ESPAsync_wifiManager.addParameter(&p_thingspeakApiKey);\n    ESPAsync_wifiManager.addParameter(&p_sensorDht22);\n    ESPAsync_wifiManager.addParameter(&p_pinSda);\n    ESPAsync_wifiManager.addParameter(&p_pinScl);\n\n    // Sets timeout in seconds until configuration portal gets turned off.\n    // If not specified device will remain in configuration mode until\n    // switched off via webserver or device is restarted.\n    // ESPAsync_wifiManager.setConfigPortalTimeout(120);\n\n    ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n    // From v1.0.10 only\n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n    ESPAsync_wifiManager.setConfigPortalChannel(0);\n    //////\n\n    //set custom ip for portal\n    //ESPAsync_wifiManager.setAPStaticIPConfig(IPAddress(192, 168, 100, 1), IPAddress(192, 168, 100, 1), IPAddress(255, 255, 255, 0));\n    \n#if !USE_DHCP_IP    \n  #if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n  #endif \n#endif  \n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Start an access point\n    // and goes into a blocking loop awaiting configuration.\n    // Once the user leaves the portal with the exit button\n    // processing will continue\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n    {\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    }\n    else\n    {\n      //if you get here you have connected to the WiFi\n      Serial.println(F(\"connected...yeey :)\"));\n      Serial.print(F(\"Local IP: \"));\n      Serial.println(WiFi.localIP());\n    }\n\n    // Only clear then save data if CP entered and with new valid Credentials\n    // No CP => stored getSSID() = \"\"\n    if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n    {\n      // Stored  for later usage, from v1.1.0, but clear first\n      memset(&WM_config, 0, sizeof(WM_config));\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        String tempSSID = ESPAsync_wifiManager.getSSID(i);\n        String tempPW   = ESPAsync_wifiManager.getPW(i);\n    \n        if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n    \n        if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n    \n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n    \n#if USE_ESP_WIFIMANAGER_NTP      \n      String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n  \n      if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n        strcpy(WM_config.TZ_Name, tempTZ.c_str());\n      else\n        strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n  \n      const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n      \n      if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n        strcpy(WM_config.TZ, TZ_Result);\n      else\n        strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n           \n      if ( strlen(WM_config.TZ_Name) > 0 )\n      {\n        LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n        configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n      }\n      else\n      {\n        LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n      }\n#endif\n\n      // New in v1.4.0\n      ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n      //////\n    \n      saveConfigData();\n    }\n\n    // Getting posted form values and overriding local variables parameters\n    // Config file is written regardless the connection state\n    strcpy(thingspeakApiKey, p_thingspeakApiKey.getValue());\n    sensorDht22 = (strncmp(p_sensorDht22.getValue(), \"T\", 1) == 0);\n    pinSda = atoi(p_pinSda.getValue());\n    pinScl = atoi(p_pinScl.getValue());\n    // Writing JSON config file to flash for next boot\n    writeConfigFile();\n\n    digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n  }\n\n  // Configuration portal not requested, so run normal loop\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "mqtt",
        "wificlient",
        "webserver",
        "https",
        "password",
        "ssl",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "i2c",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "pwm",
        "html",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "Arduino.h",
        "OneButton.h",
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK\n    }\n    else \n    {\n      Serial.print(F(\"F\"));        // F means publishing failure\n    }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      60000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic,  Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "handleClick",
          "parameters": "",
          "body": "Serial.println(F(\"\\nButton clicked!\"));\n  wifi_manager();"
        },
        {
          "name": "handleDoubleClick",
          "parameters": "",
          "body": "Serial.println(F(\"\\nButton double clicked!\"));"
        },
        {
          "name": "handleLongPressStop",
          "parameters": "",
          "body": "Serial.println(F(\"\\nLong Button pressed!\"));\n  newConfigData();"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n\n  // AIO_SERVER\n  ESPAsync_WMParameter AIO_SERVER_FIELD(AIO_SERVER_Label, \"AIO SERVER\", custom_AIO_SERVER, custom_AIO_SERVER_LEN + 1);\n\n  // AIO_SERVERPORT\n  ESPAsync_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVERPORT_Label, \"AIO SERVER PORT\", custom_AIO_SERVERPORT, custom_AIO_PORT_LEN + 1);\n\n  // AIO_USERNAME\n  ESPAsync_WMParameter AIO_USERNAME_FIELD(AIO_USERNAME_Label, \"AIO USERNAME\", custom_AIO_USERNAME, custom_AIO_USERNAME_LEN + 1);\n\n  // AIO_KEY\n  ESPAsync_WMParameter AIO_KEY_FIELD(AIO_KEY_Label, \"AIO KEY\", custom_AIO_KEY, custom_AIO_KEY_LEN + 1);\n\n  // add all parameters here\n  // order of adding is not important\n  ESPAsync_wifiManager.addParameter(&AIO_SERVER_FIELD);\n  ESPAsync_wifiManager.addParameter(&AIO_SERVERPORT_FIELD);\n  ESPAsync_wifiManager.addParameter(&AIO_USERNAME_FIELD);\n  ESPAsync_wifiManager.addParameter(&AIO_KEY_FIELD);\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESPAsync_wifiManager.setConfigPortalTimeout(120);\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n  \n  if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif \n  \n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  strcpy(custom_AIO_SERVER, AIO_SERVER_FIELD.getValue());\n  strcpy(custom_AIO_SERVERPORT, AIO_SERVERPORT_FIELD.getValue());\n  strcpy(custom_AIO_USERNAME, AIO_USERNAME_FIELD.getValue());\n  strcpy(custom_AIO_KEY, AIO_KEY_FIELD.getValue());\n\n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    if (json.containsKey(AIO_SERVER_Label))\n    {\n      strcpy(custom_AIO_SERVER, json[AIO_SERVER_Label]);\n    }\n\n    if (json.containsKey(AIO_SERVERPORT_Label))\n    {\n      strcpy(custom_AIO_SERVERPORT, json[AIO_SERVERPORT_Label]);\n    }\n\n    if (json.containsKey(AIO_USERNAME_Label))\n    {\n      strcpy(custom_AIO_USERNAME, json[AIO_USERNAME_Label]);\n    }\n\n    if (json.containsKey(AIO_KEY_Label))\n    {\n      strcpy(custom_AIO_KEY, json[AIO_KEY_Label]);\n    }\n  }\n  \n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  json[AIO_SERVER_Label]      = custom_AIO_SERVER;\n  json[AIO_SERVERPORT_Label]  = custom_AIO_SERVERPORT;\n  json[AIO_USERNAME_Label]    = custom_AIO_USERNAME;\n  json[AIO_KEY_Label]         = custom_AIO_KEY;\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwichFS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  btn.attachClick(handleClick);\n  btn.attachDoubleClick(handleDoubleClick);\n  btn.attachLongPressStop(handleLongPressStop);\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  // Load stored data, the addAP ready for MultiWiFi reconnection\n  bool configDataLoaded = loadConfigData();\n\n  // Pretend CP is necessary as we have no AP Credentials\n  initialConfig = true;\n\n  if (configDataLoaded)\n  {\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        initialConfig = false;\n      }\n    }\n  }\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n     \n    wifi_manager();\n  }\n  else if ( WiFi.status() != WL_CONNECTED ) \n  {\n    Serial.println(F(\"ConnectMultiWiFi in setup\"));\n   \n    connectMultiWiFi();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// checking button state all the time\n  btn.tick();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "wificlient",
        "webserver",
        "https",
        "password",
        "json",
        "buffer",
        "parse",
        "current",
        "voltage",
        "wifi",
        "i2c",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "pwm",
        "html",
        "nodemcu",
        "devices",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Configuration file not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    serializeJson(json, Serial);\n#else\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    json.printTo(Serial);\n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    if (json.containsKey(PortalSSID_Label))\n    {\n      strcpy(PortalSSID, json[PortalSSID_Label]);\n    }\n\n    if (json.containsKey(PortalPassword_Label))\n    {\n      strcpy(PortalPassword, json[PortalPassword_Label]);\n    }\n  }\n  Serial.println(F(\"\\nConfig file was successfully parsed\"));\n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving config file\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n\n  // JSONify local configuration parameters\n  json[PortalSSID_Label]      = PortalSSID;\n  json[PortalPassword_Label]  = PortalPassword;\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open config file for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig file was successfully saved\"));\n  return true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigPortalParamsOnSwitch using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Failed to read configuration file, using default values\"));\n  }\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"AsyncCP-ParamsOnSW\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncCP-ParamsOnSW\");\n#endif  \n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-11\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  bool configDataLoaded = false;\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\")); \n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    digitalWrite(LED_BUILTIN, LED_ON); // Turn led on as we are in configuration mode.\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    //it starts an access point\n    //and goes into a blocking loop awaiting configuration\n    // If Invalid PortalSSID or PortalPassword => use default\n\n    bool resultConfigPortal;\n    if ( (PortalSSID[0] == 0) || (PortalPassword[0] == 0) )\n    {\n      Serial.print(F(\", SSID = \"));\n      Serial.print(DefaultPortalSSID);\n      Serial.print(F(\", PWD = \"));\n      Serial.println(DefaultPortalPassword);\n      \n      resultConfigPortal = ESPAsync_wifiManager.startConfigPortal((const char *) DefaultPortalSSID.c_str(), DefaultPortalPassword.c_str());\n    }\n    else\n    {\n      Serial.print(F(\", SSID = \"));\n      Serial.print(PortalSSID);\n      Serial.print(F(\", PWD = \"));\n      Serial.println(PortalPassword);\n    \n      resultConfigPortal = ESPAsync_wifiManager.startConfigPortal((const char *) PortalSSID, PortalPassword);\n    }\n\n    if (resultConfigPortal)\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    else\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    AsyncWebServer webServer(HTTP_PORT);\n    AsyncDNSServer dnsServer;\n  \n    ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncCP-ParamsOnSW\");\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.print(F(\"Opening configuration portal.\"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n    \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n    }\n    else if (loadConfigData())\n    {      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\")); \n    }\n    else\n    {\n      // Enter CP only if no stored SSID on flash and file \n      Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n      initialConfig = true;\n    }\n\n    // Extra parameters to be configured\n    // After connecting, parameter.getValue() will get you the configured value\n    // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n\n    // Config Portal SSID - this is a straight forward string parameter\n    ESPAsync_WMParameter p_PortalSSID(PortalSSID_Label, \"Portal_SSID\", PortalSSID, SSID_MAX_LENGTH + 1);\n\n    // Config Portal SSID - this is a straight forward string parameter\n    ESPAsync_WMParameter p_PortalPassword(PortalPassword_Label, \"Portal_Password\", PortalPassword, PASSWORD_MAX_LENGTH + 1);\n\n    //add all parameters here\n    ESPAsync_wifiManager.addParameter(&p_PortalSSID);\n    ESPAsync_wifiManager.addParameter(&p_PortalPassword);\n\n    // Sets timeout in seconds until configuration portal gets turned off.\n    // If not specified device will remain in configuration mode until\n    // switched off via webserver or device is restarted.\n    //ESPAsync_wifiManager.setConfigPortalTimeout(120);\n\n    ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n    // From v1.0.10 only\n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n    ESPAsync_wifiManager.setConfigPortalChannel(0);\n    //////\n\n    //set custom ip for portal\n    //ESPAsync_wifiManager.setAPStaticIPConfig(IPAddress(192, 168, 100, 1), IPAddress(192, 168, 100, 1), IPAddress(255, 255, 255, 0));\n    \n#if !USE_DHCP_IP    \n  #if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n  #endif \n#endif  \n\n  // New from v1.1.0\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Start an access point and goes into a blocking loop awaiting configuration.\n    // Once the user leaves the portal with the exit button\n    // processing will continue\n\n    static bool resultConfigPortal;\n    if ( (PortalSSID[0] == 0) || (PortalPassword[0] == 0) )\n    {\n      resultConfigPortal = ESPAsync_wifiManager.startConfigPortal((const char *) DefaultPortalSSID.c_str(), DefaultPortalPassword.c_str());\n    }\n    else\n    {\n      resultConfigPortal = ESPAsync_wifiManager.startConfigPortal((const char *) PortalSSID, PortalPassword);\n    }\n\n    if (resultConfigPortal)\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n      Serial.print(F(\"Local IP: \"));\n      Serial.println(WiFi.localIP());\n    }\n    else\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n\n    // Only clear then save data if CP entered and with new valid Credentials\n    // No CP => stored getSSID() = \"\"\n    if ( String(ESPAsync_wifiManager.getSSID(0)) != \"\" && String(ESPAsync_wifiManager.getSSID(1)) != \"\" )\n    {\n      // Stored  for later usage, from v1.1.0, but clear first\n      memset(&WM_config, 0, sizeof(WM_config));\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        String tempSSID = ESPAsync_wifiManager.getSSID(i);\n        String tempPW   = ESPAsync_wifiManager.getPW(i);\n    \n        if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n    \n        if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n    \n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n    \n#if USE_ESP_WIFIMANAGER_NTP      \n      String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n  \n      if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n        strcpy(WM_config.TZ_Name, tempTZ.c_str());\n      else\n        strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n  \n      const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n      \n      if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n        strcpy(WM_config.TZ, TZ_Result);\n      else\n        strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n           \n      if ( strlen(WM_config.TZ_Name) > 0 )\n      {\n        LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n        configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n        //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n        configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n      }\n      else\n      {\n        LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n      }\n#endif\n\n      // New in v1.4.0\n      ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n      //////\n    \n      saveConfigData();\n    }\n\n    // Getting posted form values and overriding local variables parameters\n    // Config file is written regardless the connection state\n    strcpy(PortalSSID, p_PortalSSID.getValue());\n    strcpy(PortalPassword, p_PortalPassword.getValue());\n\n    // Writing JSON config file to flash for next boot\n    writeConfigFile();\n\n    digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n  }\n\n  // Put your main code here, to run repeatedly...\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "asyncwebserver",
        "http",
        "wificlient",
        "https",
        "password",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "spiffs",
        "littlefs",
        "eeprom",
        "flash",
        "sd",
        "gatewayip"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "ESPmDNS.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024) \n  {\n    return String(bytes) + \"B\";\n  } \n  else if (bytes < (1024 * 1024)) \n  {\n    return String(bytes / 1024.0) + \"KB\";\n  } \n  else if (bytes < (1024 * 1024 * 1024)) \n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  } \n  else \n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP32_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n  \n  File root = FileFS.open(\"/\");\n  File file = root.openNextFile();\n  \n  while (file) \n  {\n    String fileName = file.name();\n    size_t fileSize = file.size();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n    file = root.openNextFile();\n  }\n  \n  Serial.println();\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&server, NULL, \"AsyncESP32-FSWebServer\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&server, &dnsServer, \"AsyncESP32-FSWebServer\");\n#endif\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = loadConfigData();\n\n  if (configDataLoaded)\n  {\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID == \"\") || (Router_Pass == \"\") )\n    {\n      Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n  \n      initialConfig = true;\n\n      Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n      Serial.print(APStaticIP);\n#else\n      Serial.print(F(\"192.168.4.1\"));\n#endif\n\n      Serial.print(F(\", SSID = \"));\n      Serial.print(ssid);\n      Serial.print(F(\", PWD = \"));\n      Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n      // New. Update Credentials, got from loadConfigData(), to display on CP\n      ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                          WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n      // Starts an access point\n      if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n        Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n      else\n        Serial.println(F(\"WiFi connected...yeey :)\"));\n  \n      // Stored  for later usage, from v1.1.0, but clear first\n      memset(&WM_config, 0, sizeof(WM_config));\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        String tempSSID = ESPAsync_wifiManager.getSSID(i);\n        String tempPW   = ESPAsync_wifiManager.getPW(i);\n    \n        if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n        if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n  \n      // New in v1.4.0\n      ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n      //////\n      \n      saveConfigData();\n    }\n    else\n    {\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    }\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n\n  if ( !MDNS.begin(host.c_str()) )\n  {\n    Serial.println(F(\"Error starting MDNS responder!\"));\n  }\n  \n  // Add service to MDNS-SD\n  MDNS.addService(\"http\", \"tcp\", HTTP_PORT);\n\n  //SERVER INIT\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);\n  });\n  \n  server.addHandler(&events);\n  \n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", String(ESP.getFreeHeap()));\n  });\n\n  server.addHandler(new SPIFFSEditor(FileFS, http_username, http_password));\n  server.serveStatic(\"/\", FileFS, \"/\").setDefaultFile(\"index.htm\");\n\n  server.onNotFound([](AsyncWebServerRequest * request) \n  {\n    Serial.print(F(\"NOT_FOUND: \"));\n    \n    if (request->method() == HTTP_GET)\n      Serial.print(F(\"GET\"));\n    else if (request->method() == HTTP_POST)\n      Serial.print(F(\"POST\"));\n    else if (request->method() == HTTP_DELETE)\n      Serial.print(F(\"DELETE\"));\n    else if (request->method() == HTTP_PUT)\n      Serial.print(F(\"PUT\"));\n    else if (request->method() == HTTP_PATCH)\n      Serial.print(F(\"PATCH\"));\n    else if (request->method() == HTTP_HEAD)\n      Serial.print(F(\"HEAD\"));\n    else if (request->method() == HTTP_OPTIONS)\n      Serial.print(F(\"OPTIONS\"));\n    else\n      Serial.print(F(\"UNKNOWN\"));\n      \n    Serial.println(\" http://\" + request->host() + request->url());\n\n    if (request->contentLength()) \n    {\n      Serial.println(\"_CONTENT_TYPE: \" + request->contentType());\n      Serial.println(\"_CONTENT_LENGTH: \" + request->contentLength());\n    }\n\n    int headers = request->headers();\n    int i;\n    \n    for (i = 0; i < headers; i++) \n    {\n      AsyncWebHeader* h = request->getHeader(i);\n      Serial.println(\"_HEADER[\" + h->name() + \"]: \" + h->value());\n    }\n\n    int params = request->params();\n    \n    for (i = 0; i < params; i++) \n    {\n      AsyncWebParameter* p = request->getParam(i);\n      \n      if (p->isFile()) \n      {\n        Serial.println(\"_FILE[\" + p->name() + \"]: \" + p->value() + \", size: \" + p->size());\n      } \n      else if (p->isPost()) \n      {\n        Serial.println(\"_POST[\" + p->name() + \"]: \" + p->value());\n      } \n      else \n      {\n        Serial.println(\"_GET[\" + p->name() + \"]: \" + p->value());\n      }\n    }\n\n    request->send(404);\n  });\n  \n  server.onFileUpload([](AsyncWebServerRequest * request, const String & filename, size_t index, uint8_t *data, size_t len, bool final) \n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"UploadStart: \" + filename);\n      \n    Serial.print((const char*)data);\n    \n    if (final)\n      Serial.println(\"UploadEnd: \" + filename + \"(\" + String(index + len) + \")\" );\n  });\n  \n  server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total) \n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"BodyStart: \" + total);\n      \n    Serial.print((const char*)data);\n    \n    if (index + len == total)\n      Serial.println(\"BodyEnd: \" + total);\n  });\n  \n  server.begin();\n\n  //////\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.println(separatorLine);\n  Serial.print(\"Open http://\"); Serial.print(WiFi.localIP());\n  Serial.println(\"/edit to see the file browser\"); \n  Serial.println(\"Using username = \" + http_username + \" and password = \" + http_password);\n  Serial.println(separatorLine);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "asyncwebserver",
        "http",
        "wificlient",
        "https",
        "password",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "spiffs",
        "littlefs",
        "eeprom",
        "flash",
        "sd",
        "rtc",
        "gatewayip"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "ESPmDNS.h",
        "WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024)\n  {\n    return String(bytes) + \"B\";\n  }\n  else if (bytes < (1024 * 1024))\n  {\n    return String(bytes / 1024.0) + \"KB\";\n  }\n  else if (bytes < (1024 * 1024 * 1024))\n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  }\n  else\n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP32_FSWebServer_DRD using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM) \n    FileFS.format();\n\n  // Format FileFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n  \n  File root = FileFS.open(\"/\");\n  File file = root.openNextFile();\n  \n  while (file) \n  {\n    String fileName = file.name();\n    size_t fileSize = file.size();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n    file = root.openNextFile();\n  }\n  \n  Serial.println();\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n    \n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)0\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&server, NULL, \"AsyncESP32-FSWebServer\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&server, &dnsServer, \"AsyncESP32-FSWebServer\");\n#endif\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif  \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif \n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif \n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n\n  if ( !MDNS.begin(host.c_str()) )\n  {\n    Serial.println(F(\"Error starting MDNS responder!\"));\n  }\n  \n  // Add service to MDNS-SD\n  MDNS.addService(\"http\", \"tcp\", HTTP_PORT);\n  \n  //SERVER INIT\n  events.onConnect([](AsyncEventSourceClient * client)\n  {\n    client->send(\"hello!\", NULL, millis(), 1000);\n  });\n\n  server.addHandler(&events);\n\n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", String(ESP.getFreeHeap()));\n  });\n\n  server.addHandler(new SPIFFSEditor(FileFS, http_username, http_password));\n  server.serveStatic(\"/\", FileFS, \"/\").setDefaultFile(\"index.htm\");\n  \n\n  server.onNotFound([](AsyncWebServerRequest * request)\n  {\n    Serial.print(F(\"NOT_FOUND: \"));\n    \n    if (request->method() == HTTP_GET)\n      Serial.print(F(\"GET\"));\n    else if (request->method() == HTTP_POST)\n      Serial.print(F(\"POST\"));\n    else if (request->method() == HTTP_DELETE)\n      Serial.print(F(\"DELETE\"));\n    else if (request->method() == HTTP_PUT)\n      Serial.print(F(\"PUT\"));\n    else if (request->method() == HTTP_PATCH)\n      Serial.print(F(\"PATCH\"));\n    else if (request->method() == HTTP_HEAD)\n      Serial.print(F(\"HEAD\"));\n    else if (request->method() == HTTP_OPTIONS)\n      Serial.print(F(\"OPTIONS\"));\n    else\n      Serial.print(F(\"UNKNOWN\"));\n      \n    Serial.println(\" http://\" + request->host() + request->url());\n\n    if (request->contentLength())\n    {\n      Serial.println(\"_CONTENT_TYPE: \" + request->contentType());\n      Serial.println(\"_CONTENT_LENGTH: \" + request->contentLength());\n    }\n\n    int headers = request->headers();\n    int i;\n\n    for (i = 0; i < headers; i++)\n    {\n      AsyncWebHeader* h = request->getHeader(i);\n      Serial.println(\"_HEADER[\" + h->name() + \"]: \" + h->value());\n    }\n\n    int params = request->params();\n\n    for (i = 0; i < params; i++)\n    {\n      AsyncWebParameter* p = request->getParam(i);\n\n      if (p->isFile())\n      {\n        Serial.println(\"_FILE[\" + p->name() + \"]: \" + p->value() + \", size: \" + p->size());\n      }\n      else if (p->isPost())\n      {\n        Serial.println(\"_POST[\" + p->name() + \"]: \" + p->value());\n      }\n      else\n      {\n        Serial.println(\"_GET[\" + p->name() + \"]: \" + p->value());\n      }\n    }\n\n    request->send(404);\n  });\n\n  server.onFileUpload([](AsyncWebServerRequest * request, const String & filename, size_t index, uint8_t *data, size_t len, bool final)\n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"UploadStart: \" + filename);\n\n    Serial.print((const char*)data);\n\n    if (final)\n      Serial.println(\"UploadEnd: \" + filename + \"(\" + String(index + len) + \")\" );\n  });\n\n  server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total)\n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"BodyStart: \" + total);\n\n    Serial.print((const char*)data);\n\n    if (index + len == total)\n      Serial.println(\"BodyEnd: \" + total);\n  });\n\n  server.begin();\n\n  //////\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.println(separatorLine);\n  Serial.print(\"Open http://\"); Serial.print(WiFi.localIP());\n  Serial.println(\"/edit to see the file browser\"); \n  Serial.println(\"Using username = \" + http_username + \" and password = \" + http_password);\n  Serial.println(separatorLine);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "asyncwebserver",
        "http",
        "wificlient",
        "https",
        "password",
        "current",
        "wifi",
        "ntp",
        "delay",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "spiffs",
        "littlefs",
        "flash",
        "eeprom",
        "sd",
        "gatewayip"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "ESPAsyncDNSServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "SPIFFSEditor.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024) \n  {\n    return String(bytes) + \"B\";\n  } \n  else if (bytes < (1024 * 1024)) \n  {\n    return String(bytes / 1024.0) + \"KB\";\n  } \n  else if (bytes < (1024 * 1024 * 1024)) \n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  } \n  else \n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n  if ( String(ESP_ASYNC_WIFIMANAGER_VERSION) < ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET )\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n\n  Serial.setDebugOutput(false);\n\n  // Uncomment to force FS format. Remember to uncomment after done\n#if FORMAT_FILESYSTEM\n    FileFS.format();\n#endif\n  \n  // Format FileFS if not yet\n  if (!FileFS.begin())\n  {\n    FileFS.format();\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n    \n  Dir dir = FileFS.openDir(\"/\");\n  Serial.println(F(\"Opening / directory\"));\n  \n  while (dir.next()) \n  {\n    String fileName = dir.fileName();\n    size_t fileSize = dir.fileSize();\n    \n    Serial.println(\"FS File: \" + fileName + \", size: \" + formatBytes(fileSize));\n  }\n  \n  Serial.println();\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed) \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&server, &dnsServer, \"Async_ESP-FSWebServer\");\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = loadConfigData();\n\n  if (configDataLoaded)\n  {\n    #if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif  \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID == \"\") || (Router_Pass == \"\") )\n    {\n      Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n  \n      initialConfig = true;\n\n      Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n      Serial.print(APStaticIP);\n#else\n      Serial.print(F(\"192.168.4.1\"));\n#endif\n\n      Serial.print(F(\", SSID = \"));\n      Serial.print(ssid);\n      Serial.print(F(\", PWD = \"));\n      Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n      // Starts an access point\n      if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n        Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n      else\n        Serial.println(F(\"WiFi connected...yeey :)\"));\n  \n      // Stored  for later usage, from v1.1.0, but clear first\n      memset(&WM_config, 0, sizeof(WM_config));\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        String tempSSID = ESPAsync_wifiManager.getSSID(i);\n        String tempPW   = ESPAsync_wifiManager.getPW(i);\n    \n        if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n        if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n      // New in v1.4.0\n      ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n      //////\n      \n      saveConfigData();\n    }\n    else\n    {\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    }\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n\n  MDNS.begin(host);\n  \n  // Add service to MDNS-SD\n  MDNS.addService(\"http\", \"tcp\", HTTP_PORT);\n\n  //SERVER INIT\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);\n  });\n  \n  server.addHandler(&events);\n  \n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", String(ESP.getFreeHeap()));\n  });\n\n#if !USE_LITTLEFS\n  // SPIFFSEditor won't compile when using LittleFS\n  server.addHandler(new SPIFFSEditor(http_username, http_password, FileFS));\n#endif\n\n  server.serveStatic(\"/\", FileFS, \"/\").setDefaultFile(\"index.htm\");\n\n  server.onNotFound([](AsyncWebServerRequest * request) \n  {\n    Serial.print(F(\"NOT_FOUND: \"));\n    \n    if (request->method() == HTTP_GET)\n      Serial.print(F(\"GET\"));\n    else if (request->method() == HTTP_POST)\n      Serial.print(F(\"POST\"));\n    else if (request->method() == HTTP_DELETE)\n      Serial.print(F(\"DELETE\"));\n    else if (request->method() == HTTP_PUT)\n      Serial.print(F(\"PUT\"));\n    else if (request->method() == HTTP_PATCH)\n      Serial.print(F(\"PATCH\"));\n    else if (request->method() == HTTP_HEAD)\n      Serial.print(F(\"HEAD\"));\n    else if (request->method() == HTTP_OPTIONS)\n      Serial.print(F(\"OPTIONS\"));\n    else\n      Serial.print(F(\"UNKNOWN\"));\n    Serial.println(\" http://\" + request->host() + request->url());\n\n    if (request->contentLength()) \n    {\n      Serial.println(\"_CONTENT_TYPE: \" + request->contentType());\n      Serial.println(\"_CONTENT_LENGTH: \" + request->contentLength());\n    }\n\n    int headers = request->headers();\n    int i;\n    \n    for (i = 0; i < headers; i++) \n    {\n      AsyncWebHeader* h = request->getHeader(i);\n      Serial.println(\"_HEADER[\" + h->name() + \"]: \" + h->value());\n    }\n\n    int params = request->params();\n    \n    for (i = 0; i < params; i++) \n    {\n      AsyncWebParameter* p = request->getParam(i);\n      \n      if (p->isFile()) \n      {\n        Serial.println(\"_FILE[\" + p->name() + \"]: \" + p->value() + \", size: \" + p->size());\n      } \n      else if (p->isPost()) \n      {\n        Serial.println(\"_POST[\" + p->name() + \"]: \" + p->value());\n      } \n      else \n      {\n        Serial.println(\"_GET[\" + p->name() + \"]: \" + p->value());\n      }\n    }\n\n    request->send(404);\n  });\n  \n  server.onFileUpload([](AsyncWebServerRequest * request, const String & filename, size_t index, uint8_t *data, size_t len, bool final) \n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"UploadStart: \" + filename);\n      \n    Serial.print((const char*)data);\n    \n    if (final)\n      Serial.println(\"UploadEnd: \" + filename + \"(\" + String(index + len) + \")\" );\n  });\n  \n  server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total) \n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"BodyStart: \" + total);\n      \n    Serial.print((const char*)data);\n    \n    if (index + len == total)\n      Serial.println(\"BodyEnd: \" + total);\n  });\n  \n  server.begin();\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());\n  \n  Serial.println(separatorLine);\n  Serial.print(\"Open http://\"); Serial.print(WiFi.localIP());\n  Serial.println(\"/edit to see the file browser\"); \n  Serial.println(\"Using username = \" + http_username + \" and password = \" + http_password);\n  Serial.println(separatorLine);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "MDNS.update();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "asyncwebserver",
        "http",
        "wificlient",
        "https",
        "password",
        "current",
        "wifi",
        "ntp",
        "delay",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "spiffs",
        "littlefs",
        "flash",
        "eeprom",
        "sd",
        "rtc",
        "gatewayip"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "ESPAsyncDNSServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024) \n  {\n    return String(bytes) + \"B\";\n  } \n  else if (bytes < (1024 * 1024)) \n  {\n    return String(bytes / 1024.0) + \"KB\";\n  } \n  else if (bytes < (1024 * 1024 * 1024)) \n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  } \n  else \n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP_FSWebServer_DRD using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  // Uncomment to force FS format. Remember to uncomment after done\n#if FORMAT_FILESYSTEM\n    FileFS.format();\n#endif\n\n  // Format FileFS if not yet\n  if (!FileFS.begin())\n  {\n    FileFS.format();\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n    \n  Dir dir = FileFS.openDir(\"/\");\n  Serial.println(F(\"Opening / directory\"));\n  \n  while (dir.next()) \n  {\n    String fileName = dir.fileName();\n    size_t fileSize = dir.fileSize();\n    \n    Serial.println(\"FS File: \" + fileName + \", size: \" + formatBytes(fileSize));\n  }\n  \n  Serial.println();\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed) \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&server, &dnsServer, \"AsyncESP-FSWebServer\");\n\n#if USE_CUSTOM_AP_IP \n  //set custom ip for portal\n  // New in v1.4.0\n  ESPAsync_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESPAsync_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESPAsync_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif   \n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file \n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESPAsync_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESPAsync_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                        WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESPAsync_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESPAsync_wifiManager.getSSID(i);\n      String tempPW   = ESPAsync_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESPAsync_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESPAsync_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESPAsync_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESPAsync_wifiManager.getStatus(WiFi.status()));\n\n  MDNS.begin(host);\n  \n  // Add service to MDNS-SD\n  MDNS.addService(\"http\", \"tcp\", HTTP_PORT);\n\n  //SERVER INIT\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);\n  });\n  \n  server.addHandler(&events);\n\n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", String(ESP.getFreeHeap()));\n  });\n\n#if !USE_LITTLEFS\n  // SPIFFSEditor won't compile when using LittleFS\n  server.addHandler(new SPIFFSEditor(http_username, http_password, FileFS));\n#endif\n\n  server.serveStatic(\"/\", FileFS, \"/\").setDefaultFile(\"index.htm\");\n  \n  server.onNotFound([](AsyncWebServerRequest * request) \n  {\n    Serial.print(F(\"NOT_FOUND: \"));\n    \n    if (request->method() == HTTP_GET)\n      Serial.print(F(\"GET\"));\n    else if (request->method() == HTTP_POST)\n      Serial.print(F(\"POST\"));\n    else if (request->method() == HTTP_DELETE)\n      Serial.print(F(\"DELETE\"));\n    else if (request->method() == HTTP_PUT)\n      Serial.print(F(\"PUT\"));\n    else if (request->method() == HTTP_PATCH)\n      Serial.print(F(\"PATCH\"));\n    else if (request->method() == HTTP_HEAD)\n      Serial.print(F(\"HEAD\"));\n    else if (request->method() == HTTP_OPTIONS)\n      Serial.print(F(\"OPTIONS\"));\n    else\n      Serial.print(F(\"UNKNOWN\"));\n      \n    Serial.println(\" http://\" + request->host() + request->url());\n\n    if (request->contentLength()) \n    {\n      Serial.println(\"_CONTENT_TYPE: \" + request->contentType());\n      Serial.println(\"_CONTENT_LENGTH: \" + request->contentLength());\n    }\n\n    int headers = request->headers();\n    int i;\n    \n    for (i = 0; i < headers; i++) \n    {\n      AsyncWebHeader* h = request->getHeader(i);\n      Serial.println(\"_HEADER[\" + h->name() + \"]: \" + h->value());\n    }\n\n    int params = request->params();\n    \n    for (i = 0; i < params; i++) \n    {\n      AsyncWebParameter* p = request->getParam(i);\n      \n      if (p->isFile()) \n      {\n        Serial.println(\"_FILE[\" + p->name() + \"]: \" + p->value() + \", size: \" + p->size());\n      } \n      else if (p->isPost()) \n      {\n        Serial.println(\"_POST[\" + p->name() + \"]: \" + p->value());\n      } \n      else \n      {\n        Serial.println(\"_GET[\" + p->name() + \"]: \" + p->value());\n      }\n    }\n\n    request->send(404);\n  });\n  \n  server.onFileUpload([](AsyncWebServerRequest * request, const String & filename, size_t index, uint8_t *data, size_t len, bool final) \n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"UploadStart: \" + filename);\n      \n    Serial.print((const char*)data);\n    \n    if (final)\n      Serial.println(\"UploadEnd: \" + filename + \"(\" + String(index + len) + \")\" );\n  });\n  \n  server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total) \n  {\n    (void) request;\n    \n    if (!index)\n      Serial.println(\"BodyStart: \" + total);\n      \n    Serial.print((const char*)data);\n    \n    if (index + len == total)\n      Serial.println(\"BodyEnd: \" + total);\n  });\n  \n  server.begin();\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());\n  \n  Serial.println(separatorLine);\n  Serial.print(\"Open http://\"); Serial.print(WiFi.localIP());\n  Serial.println(\"/edit to see the file browser\"); \n  Serial.println(\"Using username = \" + http_username + \" and password = \" + http_password);\n  Serial.println(separatorLine);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n  \n  MDNS.update();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/plain\", String(\"Hello from Async_HelloServer on \") + ARDUINO_BOARD );"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_HelloServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/plain\", String(\"Hello from Async_HelloServer2 on \") + ARDUINO_BOARD );"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_HelloServer2 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.on(\"/gif\", [](AsyncWebServerRequest * request)\n  {\n    static const uint8_t gif[] =\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x10, 0x00, 0x10, 0x00, 0x80, 0x01,\n      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x2c, 0x00, 0x00, 0x00, 0x00,\n      0x10, 0x00, 0x10, 0x00, 0x00, 0x02, 0x19, 0x8c, 0x8f, 0xa9, 0xcb, 0x9d,\n      0x00, 0x5f, 0x74, 0xb4, 0x56, 0xb0, 0xb0, 0xd2, 0xf2, 0x35, 0x1e, 0x4c,\n      0x0c, 0x24, 0x5a, 0xe6, 0x89, 0xa6, 0x4d, 0x01, 0x00, 0x3b\n    };\n\n    char gif_colored[sizeof(gif)];\n\n    memcpy(gif_colored, gif, sizeof(gif));\n\n    // Set the background to a random set of colors\n    gif_colored[16] = millis() % 256;\n    gif_colored[17] = millis() % 256;\n    gif_colored[18] = millis() % 256;\n\n    request->send(200, (char *) \"image/gif\", gif_colored);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(\"HTTP EthernetWebServer started @ IP : \");\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "digitalwrite",
        "delay",
        "millis",
        "led",
        "flash"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/plain\", String(\"Hello from AsyncWebServer_STM32 on \") + BOARD_NAME );\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);\n  digitalWrite(led, 0);"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HelloServer2_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.on(\"/gif\", [](AsyncWebServerRequest * request) \n  {\n    static const uint8_t gif[] = \n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x10, 0x00, 0x10, 0x00, 0x80, 0x01,\n      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x2c, 0x00, 0x00, 0x00, 0x00,\n      0x10, 0x00, 0x10, 0x00, 0x00, 0x02, 0x19, 0x8c, 0x8f, 0xa9, 0xcb, 0x9d,\n      0x00, 0x5f, 0x74, 0xb4, 0x56, 0xb0, 0xb0, 0xd2, 0xf2, 0x35, 0x1e, 0x4c,\n      0x0c, 0x24, 0x5a, 0xe6, 0x89, 0xa6, 0x4d, 0x01, 0x00, 0x3b\n    };\n    \n    char gif_colored[sizeof(gif)];\n\n    memcpy(gif_colored, gif, sizeof(gif));\n\n    // Set the background to a random set of colors\n    gif_colored[16] = millis() % 256;\n    gif_colored[17] = millis() % 256;\n    gif_colored[18] = millis() % 256;\n\n    request->send(200, (char *) \"image/gif\", gif_colored);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(\"HTTP EthernetWebServer started @ IP : \");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "digitalwrite",
        "delay",
        "millis",
        "led",
        "flash"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/plain\", String(\"Hello from AsyncWebServer_STM32_LAN8720 on \") + BOARD_NAME );\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);\n  digitalWrite(led, 0);"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HelloServer_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  server.on(\"/inline\", [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"This works as well\");\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "password",
        "dns",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_HTTPBasicAuth on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    if (!request->authenticate(www_username, www_password))\n    {\n      return request->requestAuthentication();\n    }\n\n    request->send(200, \"text/plain\", \"Login OK\");\n  });\n\n  server.begin();\n\n  Serial.print(F(\"Async_HttpBasicAuth started @ IP : \"));\n  Serial.println(ETH.localIP());\n\n  Serial.print(F(\"Open http://\"));\n  Serial.print(ETH.localIP());\n  Serial.println(F(\"/ in your browser to see it working\"));\n\n  Serial.print(F(\"Login using username = \"));\n  Serial.print(www_username);\n  Serial.print(F(\" and password = \"));\n  Serial.println(www_password);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "password",
        "delay",
        "millis",
        "flash"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HTTPBasicAuth_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  //Ethernet.begin(mac[10]);\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    if (!request->authenticate(www_username, www_password))\n    {\n      return request->requestAuthentication();\n    }\n    \n    request->send(200, \"text/plain\", \"Login OK\");\n  });\n  \n\n  server.begin();\n\n  Serial.print(F(\"Async_HttpBasicAuth started @ IP : \"));\n  Serial.println(Ethernet.localIP());\n\n  Serial.print(F(\"Open http://\"));\n  Serial.print(Ethernet.localIP());\n  Serial.println(F(\"/ in your browser to see it working\"));\n\n  Serial.print(F(\"Login using username = \"));\n  Serial.print(www_username);\n  Serial.print(F(\" and password = \"));\n  Serial.println(www_password);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "https",
        "dns",
        "spi",
        "digitalwrite",
        "millis",
        "delay",
        "led",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/html\", postForms);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handlePlain",
          "parameters": "AsyncWebServerRequest *request",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);\n  }\n  else\n  {\n    digitalWrite(led, 1);\n    request->send(200, \"text/plain\", \"POST body was:\\n\" + request->arg(\"plain\"));\n    digitalWrite(led, 0);\n  }"
        },
        {
          "name": "handleForm",
          "parameters": "AsyncWebServerRequest *request",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);\n  }\n  else\n  {\n    digitalWrite(led, 1);\n    String message = \"POST form was:\\n\";\n\n    for (uint8_t i = 0; i < request->args(); i++)\n    {\n      message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n    }\n\n    request->send(200, \"text/plain\", message);\n    digitalWrite(led, 0);\n  }"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n\n  request->send(404, \"text/plain\", message);\n  digitalWrite(led, 0);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);;\n\n  Serial.print(F(\"\\nStart Async_PostServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //server.on(\"/postplain/\", handlePlain);\n  server.on(\"/postplain/\", HTTP_POST, [](AsyncWebServerRequest * request)\n  {\n    handlePlain(request);\n  });\n\n  //server.on(\"/postform/\", handleForm);\n  server.on(\"/postform/\", HTTP_POST, [](AsyncWebServerRequest * request)\n  {\n    handleForm(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer started @ IP : \"));\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "http",
        "https",
        "digitalwrite",
        "delay",
        "millis",
        "led",
        "flash",
        "html"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/html\", postForms);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handlePlain",
          "parameters": "AsyncWebServerRequest *request",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);\n  } \n  else\n  {\n    digitalWrite(led, 1);\n    request->send(200, \"text/plain\", \"POST body was:\\n\" + request->arg(\"plain\"));\n    digitalWrite(led, 0);\n  }"
        },
        {
          "name": "handleForm",
          "parameters": "AsyncWebServerRequest *request",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);\n  }\n  else\n  {\n    digitalWrite(led, 1);\n    String message = \"POST form was:\\n\";\n    for (uint8_t i = 0; i < request->args(); i++)\n    {\n      message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n    }\n    request->send(200, \"text/plain\", message);\n    digitalWrite(led, 0);\n  }"
        },
        {
          "name": "handleNotFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";\n  }\n  request->send(404, \"text/plain\", message);\n  digitalWrite(led, 0);"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_PostServer_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);\n  });\n\n  //server.on(\"/postplain/\", handlePlain);\n  server.on(\"/postplain/\", HTTP_POST, [](AsyncWebServerRequest * request)\n  {\n    handlePlain(request);\n  });\n\n  //server.on(\"/postform/\", handleForm);\n  server.on(\"/postform/\", HTTP_POST, [](AsyncWebServerRequest * request)\n  {\n    handleForm(request);\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"HTTP EthernetWebServer started @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "spi",
        "delay",
        "millis",
        "sensornumber"
      ],
      "libraries": [
        "defines.h",
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);\n    }\n  } \n  else \n  {\n    Serial.print(\"Connecting to network : \");\n    \n    while (!eth.connected()) \n    {\n      Serial.print(\".\");\n      delay(1000);\n    }\n  }\n \n  Serial.println();\n\n#if USING_DHCP  \n  Serial.print(\"Ethernet DHCP IP address: \");\n#else\n  Serial.print(\"Ethernet Static IP address: \");\n#endif\n  \n  Serial.println(eth.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_RegexPatterns on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns on \" + String(BOARD_NAME));\n  });\n\n  // Send a GET request to <IP>/sensor/<number>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String sensorNumber = request->pathArg(0);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber);\n  });\n\n  // Send a GET request to <IP>/sensor/<number>/action/<action>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)\\\\/action\\\\/([a-zA-Z0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String sensorNumber = request->pathArg(0);\n    String action = request->pathArg(1);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber + \", with action: \" + action);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(eth.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "sensornumber"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_ENC on \" + String(ARDUINO_BOARD));\n  });\n\n  // Send a GET request to <IP>/sensor/<number>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String sensorNumber = request->pathArg(0);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber);\n  });\n\n  // Send a GET request to <IP>/sensor/<number>/action/<action>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)\\\\/action\\\\/([a-zA-Z0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String sensorNumber = request->pathArg(0);\n    String action = request->pathArg(1);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber + \", with action: \" + action);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "sensornumber"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_W5500 on \" + String(ARDUINO_BOARD));\n  });\n\n  // Send a GET request to <IP>/sensor/<number>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String sensorNumber = request->pathArg(0);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber);\n  });\n\n  // Send a GET request to <IP>/sensor/<number>/action/<action>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)\\\\/action\\\\/([a-zA-Z0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String sensorNumber = request->pathArg(0);\n    String action = request->pathArg(1);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber + \", with action: \" + action);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "sensornumber"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_W6100 on \" + String(ARDUINO_BOARD));\n  });\n\n  // Send a GET request to <IP>/sensor/<number>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String sensorNumber = request->pathArg(0);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber);\n  });\n\n  // Send a GET request to <IP>/sensor/<number>/action/<action>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)\\\\/action\\\\/([a-zA-Z0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n  {\n    String sensorNumber = request->pathArg(0);\n    String action = request->pathArg(1);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber + \", with action: \" + action);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "https",
        "millis",
        "flash",
        "sensornumber"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart Async_RegexPatterns_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_STM32 on \" + String(BOARD_NAME));\n  });\n\n  // Send a GET request to <IP>/sensor/<number>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String sensorNumber = request->pathArg(0);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber);\n  });\n\n  // Send a GET request to <IP>/sensor/<number>/action/<action>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)\\\\/action\\\\/([a-zA-Z0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String sensorNumber = request->pathArg(0);\n    String action = request->pathArg(1);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber + \", with action: \" + action);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "https",
        "delay",
        "millis",
        "flash",
        "sensornumber"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_RegexPatterns_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_STM32_LAN8720 on \" + String(BOARD_NAME));\n  });\n\n  // Send a GET request to <IP>/sensor/<number>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String sensorNumber = request->pathArg(0);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber);\n  });\n\n  // Send a GET request to <IP>/sensor/<number>/action/<action>\n  server.on(\"^\\\\/sensor\\\\/([0-9]+)\\\\/action\\\\/([a-zA-Z0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String sensorNumber = request->pathArg(0);\n    String action = request->pathArg(1);\n    request->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber + \", with action: \" + action);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "power",
        "dns",
        "millis",
        "sensornumber"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tSerial.print(F(\"\\nStart Async_RegexPatterns_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_WT32_ETH01 on \" + String(BOARD_NAME));\n\t});\n\n\t// Send a GET request to <IP>/sensor/<number>\n\tserver.on(\"^\\\\/sensor\\\\/([0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n\t{\n\t\tString sensorNumber = request->pathArg(0);\n\t\trequest->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber);\n\t});\n\n\t// Send a GET request to <IP>/sensor/<number>/action/<action>\n\tserver.on(\"^\\\\/sensor\\\\/([0-9]+)\\\\/action\\\\/([a-zA-Z0-9]+)$\", HTTP_GET, [] (AsyncWebServerRequest * request)\n\t{\n\t\tString sensorNumber = request->pathArg(0);\n\t\tString action = request->pathArg(1);\n\t\trequest->send(200, \"text/plain\", \"Hello, sensor: \" + sensorNumber + \", with action: \" + action);\n\t});\n\n\tserver.onNotFound(notFound);\n\n\tserver.begin();\n\n\tSerial.print(\"Server started @ \");\n\tSerial.println(ETH.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "spi",
        "delay",
        "millis"
      ],
      "libraries": [
        "defines.h",
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);\n    }\n  } \n  else \n  {\n    Serial.print(\"Connecting to network : \");\n    \n    while (!eth.connected()) \n    {\n      Serial.print(\".\");\n      delay(1000);\n    }\n  }\n \n  Serial.println();\n\n#if USING_DHCP  \n  Serial.print(\"Ethernet DHCP IP address: \");\n#else\n  Serial.print(\"Ethernet Static IP address: \");\n#endif\n  \n  Serial.println(eth.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n  \n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from \" SHIELD_TYPE);\n  });\n\n  // Send a GET request to <IP>/get?message=<message>\n  server.on(\"/get\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String message;\n    \n    if (request->hasParam(PARAM_MESSAGE)) \n    {\n      message = request->getParam(PARAM_MESSAGE)->value();\n    } \n    else \n    {\n      message = \"No message sent\";\n    }\n    \n    request->send(200, \"text/plain\", \"Hello, GET: \" + message);\n  });\n\n  // Send a POST request to <IP>/post with a form field message set to <message>\n  server.on(\"/post\", HTTP_POST, [](AsyncWebServerRequest * request) \n  {\n    String message;\n    \n    if (request->hasParam(PARAM_MESSAGE, true)) \n    {\n      message = request->getParam(PARAM_MESSAGE, true)->value();\n    } \n    else \n    {\n      message = \"No message sent\";\n    }\n    \n    request->send(200, \"text/plain\", \"Hello, POST: \" + message);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(eth.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "https",
        "millis",
        "flash"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart Async_SimpleWebServer_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from LAN8742A\");\n  });\n\n  // Send a GET request to <IP>/get?message=<message>\n  server.on(\"/get\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String message;\n    \n    if (request->hasParam(PARAM_MESSAGE)) \n    {\n      message = request->getParam(PARAM_MESSAGE)->value();\n    } \n    else \n    {\n      message = \"No message sent\";\n    }\n    \n    request->send(200, \"text/plain\", \"Hello, GET: \" + message);\n  });\n\n  // Send a POST request to <IP>/post with a form field message set to <message>\n  server.on(\"/post\", HTTP_POST, [](AsyncWebServerRequest * request) \n  {\n    String message;\n    \n    if (request->hasParam(PARAM_MESSAGE, true)) \n    {\n      message = request->getParam(PARAM_MESSAGE, true)->value();\n    } \n    else \n    {\n      message = \"No message sent\";\n    }\n    \n    request->send(200, \"text/plain\", \"Hello, POST: \" + message);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "webserver",
        "https",
        "delay",
        "millis",
        "flash"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_SimpleWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from LAN8720\");\n  });\n\n  // Send a GET request to <IP>/get?message=<message>\n  server.on(\"/get\", HTTP_GET, [] (AsyncWebServerRequest * request) \n  {\n    String message;\n    \n    if (request->hasParam(PARAM_MESSAGE)) \n    {\n      message = request->getParam(PARAM_MESSAGE)->value();\n    } \n    else \n    {\n      message = \"No message sent\";\n    }\n    \n    request->send(200, \"text/plain\", \"Hello, GET: \" + message);\n  });\n\n  // Send a POST request to <IP>/post with a form field message set to <message>\n  server.on(\"/post\", HTTP_POST, [](AsyncWebServerRequest * request) \n  {\n    String message;\n    \n    if (request->hasParam(PARAM_MESSAGE, true)) \n    {\n      message = request->getParam(PARAM_MESSAGE, true)->value();\n    } \n    else \n    {\n      message = \"No message sent\";\n    }\n    \n    request->send(200, \"text/plain\", \"Hello, POST: \" + message);\n  });\n\n  server.onNotFound(notFound);\n\n  server.begin();\n\n  Serial.print(\"Server started @ \");\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "dns",
        "spi",
        "millis",
        "delay",
        "html",
        "clientid"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h",
        "webpage.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", webpageCont);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStarting Async_WebSocketsServer on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  server.on(\"/\", handleRoot);\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "https",
        "password",
        "key",
        "wifi",
        "millis",
        "delay",
        "html",
        "clientid"
      ],
      "libraries": [
        "AsyncWebServer_RP2040W.h",
        "webpage.h"
      ],
      "functions": [
        {
          "name": "onEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] WSClient connected\\n\", server->url(), client->id());\n\n\t\tglobalClient = client;\n\t\t//client->text(\"Hello from RP2040W Server\");\n\t}\n\telse if (type == WS_EVT_DISCONNECT)\n\t{\n\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] WSClient disconnected\\n\", server->url(), client->id());\n\n\t\tglobalClient = NULL;\n\t}\n\telse if (type == WS_EVT_ERROR)\n\t{\n\t\t//error was received from the other end\n\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\n\t}\n\telse if (type == WS_EVT_PONG)\n\t{\n\t\t//pong message was received (in response to a ping request maybe)\n\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len) ? (char*)data : \"\");\n\t}\n\telse if (type == WS_EVT_DATA)\n\t{\n\t\t//data packet\n\t\tAwsFrameInfo * info = (AwsFrameInfo*)arg;\n\n\t\tif (info->final && info->index == 0 && info->len == len)\n\t\t{\n\t\t\t//the whole message is in a single frame and we got all of it's data\n\t\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] %s-message[len: %llu]: \", server->url(), client->id(),\n\t\t\t              (info->opcode == WS_TEXT) ? \"text\" : \"binary\", info->len);\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tdata[len] = 0;\n\t\t\t\tSerial.printf(\"%s\\n\", (char*)data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < info->len; i++)\n\t\t\t\t{\n\t\t\t\t\tSerial.printf(\"%02x \", data[i]);\n\t\t\t\t}\n\n\t\t\t\tSerial.printf(\"\\n\");\n\t\t\t}\n\n\t\t\tif (info->opcode == WS_TEXT)\n\t\t\t\tclient->text(\"Got your text message\");\n\t\t\telse\n\t\t\t\tclient->binary(\"Got your binary message\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//message is comprised of multiple frames or the frame is split into multiple packets\n\t\t\tif (info->index == 0)\n\t\t\t{\n\t\t\t\tif (info->num == 0)\n\t\t\t\t{\n\t\t\t\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] %s-message start\\n\", server->url(), client->id(),\n\t\t\t\t\t              (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\t\t\t\t}\n\n\t\t\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\t\t\t}\n\n\t\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(),\n\t\t\t              info->num, (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\", info->index, info->index + len);\n\n\t\t\tif (info->message_opcode == WS_TEXT)\n\t\t\t{\n\t\t\t\tdata[len] = 0;\n\t\t\t\tSerial.printf(\"%s\\n\", (char*)data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tSerial.printf(\"%02x \", data[i]);\n\t\t\t\t}\n\n\t\t\t\tSerial.printf(\"\\n\");\n\t\t\t}\n\n\t\t\tif ((info->index + len) == info->len)\n\t\t\t{\n\t\t\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n\n\t\t\t\tif (info->final)\n\t\t\t\t{\n\t\t\t\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] %s-message end\\n\", server->url(), client->id(),\n\t\t\t\t\t              (info->message_opcode == WS_TEXT) ? \"text\" : \"binary\");\n\n\t\t\t\t\tif (info->message_opcode == WS_TEXT)\n\t\t\t\t\t\tclient->text(\"I got your text message\");\n\t\t\t\t\telse\n\t\t\t\t\t\tclient->binary(\"I got your binary message\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
        },
        {
          "name": "handleRoot",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(200, \"text/html\", webpageCont);"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStarting Async_WebSocketsServer_Xtreme on \");\n\tSerial.println(BOARD_NAME);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);\n\t}\n\n\tSerial.print(F(\"Connecting to SSID: \"));\n\tSerial.println(ssid);\n\n\tstatus = WiFi.begin(ssid, pass);\n\n\tdelay(1000);\n\n\t// attempt to connect to WiFi network\n\twhile ( status != WL_CONNECTED)\n\t{\n\t\tdelay(500);\n\n\t\t// Connect to WPA/WPA2 network\n\t\tstatus = WiFi.status();\n\t}\n\n\tprintWifiStatus();\n\n\t///////////////////////////////////\n\n\tws.onEvent(onEvent);\n\tserver.addHandler(&ws);\n\n\tserver.on(\"/\", handleRoot);\n\tserver.begin();"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n\tSerial.print(F(\".\"));\n\n\tif (num == 80)\n\t{\n\t\tSerial.println();\n\t\tnum = 1;\n\t}\n\telse if (num++ % 10 == 0)\n\t{\n\t\tSerial.print(F(\" \"));\n\t}"
        },
        {
          "name": "sendStatus",
          "parameters": "",
          "body": "static unsigned long sendStatus_timeout  = 1000;\n\tstatic unsigned long checkstatus_timeout = 1000;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n#define SEND_INTERVAL             30L\n\n\t// Send status report every SEND_INTERVAL (30) millis\n\tif (millis() > sendStatus_timeout)\n\t{\n\t\t//if (globalClient != NULL && globalClient->status() == WS_CONNECTED)\n\t\t// Sending only when gessage_queue not full\n\t\tif (globalClient != NULL && globalClient->status() == WS_CONNECTED && globalClient->canSend())\n\t\t{\n\t\t\tString POTvalString = String(rand() % 256);\n\n\t\t\tJSONtxt = \"{\\\"POT\\\":\\\"\" + POTvalString + \"\\\"}\";\n\n\t\t\tglobalClient->text(JSONtxt);\n\t\t}\n\n\t\tsendStatus_timeout = millis() + SEND_INTERVAL;\n\t}\n\n\t// Send status report every STATUS_REPORT_INTERVAL (10) seconds\n\tif (millis() > checkstatus_timeout)\n\t{\n\t\theartBeatPrint();\n\t\tcheckstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n\t}"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "sendStatus();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "seesaw_spectrum.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  \n  while (!Serial) delay(10);   // wait until serial port is opened\n  Serial.println(\"A\");\n  \n  if (!ss.begin()) {\n    Serial.println(\"seesaw not found!\");\n    while(1) delay(10);\n  }\n  Serial.println(\"B\");\n\n  // Configure audio sampling rate, which determines the peak\n  // frequency of the spectrum output. There are 32 possible values\n  // (0-31), where lower numbers = higher frequency.\n  // The corresponding frequency for each setting will depend on the\n  // F_CPU frequency on the Seesaw device, which has not yet been\n  // determined. 10 or 20 MHz would be ideal, but others may happen,\n  // so specific numbers are not documented here yet.\n  // If 10 or 20 MHz, value of 12 here maps to 6250 Hz:\n  ss.setRate(12);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ss.getData(); // Pull audio spectrum data from device\n  // Print contents of each of the 64 spectrum bins...\n  for (uint8_t i=0; i<64; i++) {\n    Serial.print(ss.getLevel(i));\n    Serial.write(' ');\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "password",
        "payload",
        "power",
        "dns",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting Authorization on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (WT32_ETH01_isConnected())\n  {\n    HTTPClient http;\n\n    Serial.print(\"[HTTP] begin...\\n\");\n\n    http.begin(\"http://user:password@192.168.2.112/test.html\");\n\n    /*\n      // or\n      http.begin(\"http://192.168.2.112/test.html\");\n      http.setAuthorization(\"user\", \"password\");\n      // or\n      http.begin(\"http://192.168.2.112/test.html\");\n      http.setAuthorization(\"dXNlcjpwYXN3b3Jk\");\n    */\n\n    Serial.print(\"[HTTP] GET...\\n\");\n    // start connection and send HTTP header\n    int httpCode = http.GET();\n\n    // httpCode will be negative on error\n    if (httpCode > 0) \n    {\n      // HTTP header has been send and Server response header has been handled\n      Serial.printf(\"[HTTP] GET... code: %d\\n\", httpCode);\n\n      // file found at server\n      if (httpCode == HTTP_CODE_OK) \n      {\n        String payload = http.getString();\n        Serial.println(payload);\n      }\n    } \n    else \n    {\n      Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\n    }\n\n    http.end();\n  }\n\n  delay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "https",
        "wifi",
        "eeprom"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n    Serial.begin(115200);\n\n    //WiFiManager\n    //Local intialization. Once its business is done, there is no need to keep it around\n    WiFiManager wifiManager;\n    //reset saved settings\n    //wifiManager.resetSettings();\n    \n    //set custom ip for portal\n    //wifiManager.setAPStaticIPConfig(IPAddress(10,0,1,1), IPAddress(10,0,1,1), IPAddress(255,255,255,0));\n\n    //fetches ssid and pass from eeprom and tries to connect\n    //if it does not connect it starts an access point with the specified name\n    //here  \"AutoConnectAP\"\n    //and goes into a blocking loop awaiting configuration\n    wifiManager.autoConnect(\"AutoConnectAP\");\n    //or use this for auto generated name ESP + ChipID\n    //wifiManager.autoConnect();\n\n    \n    //if you get here you have connected to the WiFi\n    Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP    \n    // put your setup code here, to run once:\n    Serial.begin(115200);\n    \n    //reset settings - wipe credentials for testing\n    //wm.resetSettings();\n\n    wm.setConfigPortalBlocking(false);\n    wm.setConfigPortalTimeout(60);\n    //automatically connect using saved credentials if they exist\n    //If connection fails it starts an access point with the specified name\n    if(wm.autoConnect(\"AutoConnectAP\")){\n        Serial.println(\"connected...yeey :)\");\n    }\n    else {\n        Serial.println(\"Configportal running\");\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "wm.process();\n    // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "https",
        "wifi"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP    \n    // put your setup code here, to run once:\n    Serial.begin(115200);\n    \n    //reset settings - wipe credentials for testing\n    //wm.resetSettings();\n    wm.addParameter(&custom_mqtt_server);\n    wm.setConfigPortalBlocking(false);\n    wm.setSaveParamsCallback(saveParamsCallback);\n\n    //automatically connect using saved credentials if they exist\n    //If connection fails it starts an access point with the specified name\n    if(wm.autoConnect(\"AutoConnectAP\")){\n        Serial.println(\"connected...yeey :)\");\n    }\n    else {\n        Serial.println(\"Configportal running\");\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "wm.process();\n    // put your main code here, to run repeatedly:"
        },
        {
          "name": "saveParamsCallback",
          "parameters": "",
          "body": "Serial.println(\"Get Params:\");\n  Serial.print(custom_mqtt_server.getID());\n  Serial.print(\" : \");\n  Serial.println(custom_mqtt_server.getValue());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "esp8266webserver",
        "mqtt",
        "https",
        "token",
        "password",
        "json",
        "callback",
        "buffer",
        "wifi",
        "delay",
        "spiffs"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "saveConfigCallback",
          "parameters": "",
          "body": "Serial.println(\"Should save config\");\n  shouldSaveConfig = true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //clean FS, for testing\n  //SPIFFS.format();\n\n  //read configuration from FS json\n  Serial.println(\"mounting FS...\");\n\n  if (SPIFFS.begin()) {\n    Serial.println(\"mounted file system\");\n    if (SPIFFS.exists(\"/config.json\")) {\n      //file exists, reading and loading\n      Serial.println(\"reading config file\");\n      File configFile = SPIFFS.open(\"/config.json\", \"r\");\n      if (configFile) {\n        Serial.println(\"opened config file\");\n        size_t size = configFile.size();\n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[size]);\n\n        configFile.readBytes(buf.get(), size);\n        DynamicJsonBuffer jsonBuffer;\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        json.printTo(Serial);\n        if (json.success()) {\n          Serial.println(\"\\nparsed json\");\n\n          strcpy(mqtt_server, json[\"mqtt_server\"]);\n          strcpy(mqtt_port, json[\"mqtt_port\"]);\n          strcpy(blynk_token, json[\"blynk_token\"]);\n\n        } else {\n          Serial.println(\"failed to load json config\");\n        }\n      }\n    }\n  } else {\n    Serial.println(\"failed to mount FS\");\n  }\n  //end read\n\n\n\n  // The extra parameters to be configured (can be either global or just in the setup)\n  // After connecting, parameter.getValue() will get you the configured value\n  // id/name placeholder/prompt default length\n  WiFiManagerParameter custom_mqtt_server(\"server\", \"mqtt server\", mqtt_server, 40);\n  WiFiManagerParameter custom_mqtt_port(\"port\", \"mqtt port\", mqtt_port, 6);\n  WiFiManagerParameter custom_blynk_token(\"blynk\", \"blynk token\", blynk_token, 32);\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //set config save notify callback\n  wifiManager.setSaveConfigCallback(saveConfigCallback);\n\n  //set static ip\n  wifiManager.setSTAStaticIPConfig(IPAddress(10,0,1,99), IPAddress(10,0,1,1), IPAddress(255,255,255,0));\n  \n  //add all your parameters here\n  wifiManager.addParameter(&custom_mqtt_server);\n  wifiManager.addParameter(&custom_mqtt_port);\n  wifiManager.addParameter(&custom_blynk_token);\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set minimu quality of signal so it ignores AP's under that quality\n  //defaults to 8%\n  //wifiManager.setMinimumSignalQuality();\n  \n  //sets timeout until configuration portal gets turned off\n  //useful to make it all retry or go to sleep\n  //in seconds\n  //wifiManager.setTimeout(120);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect and hit timeout\");\n    delay(3000);\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(5000);\n  }\n\n  //if you get here you have connected to the WiFi\n  Serial.println(\"connected...yeey :)\");\n\n  //read updated parameters\n  strcpy(mqtt_server, custom_mqtt_server.getValue());\n  strcpy(mqtt_port, custom_mqtt_port.getValue());\n  strcpy(blynk_token, custom_blynk_token.getValue());\n\n  //save the custom parameters to FS\n  if (shouldSaveConfig) {\n    Serial.println(\"saving config\");\n    DynamicJsonBuffer jsonBuffer;\n    JsonObject& json = jsonBuffer.createObject();\n    json[\"mqtt_server\"] = mqtt_server;\n    json[\"mqtt_port\"] = mqtt_port;\n    json[\"blynk_token\"] = blynk_token;\n\n    File configFile = SPIFFS.open(\"/config.json\", \"w\");\n    if (!configFile) {\n      Serial.println(\"failed to open config file for writing\");\n    }\n\n    json.printTo(Serial);\n    json.printTo(configFile);\n    configFile.close();\n    //end save\n  }\n\n  Serial.println(\"local ip\");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "esp8266webserver",
        "mqtt",
        "https",
        "token",
        "password",
        "json",
        "callback",
        "buffer",
        "wifi",
        "delay",
        "spiffs",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "saveConfigCallback",
          "parameters": "",
          "body": "Serial.println(\"Should save config\");\n  shouldSaveConfig = true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //clean FS, for testing\n  //SPIFFS.format();\n\n  //read configuration from FS json\n  Serial.println(\"mounting FS...\");\n\n  if (SPIFFS.begin()) {\n    Serial.println(\"mounted file system\");\n    if (SPIFFS.exists(\"/config.json\")) {\n      //file exists, reading and loading\n      Serial.println(\"reading config file\");\n      File configFile = SPIFFS.open(\"/config.json\", \"r\");\n      if (configFile) {\n        Serial.println(\"opened config file\");\n        size_t size = configFile.size();\n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[size]);\n\n        configFile.readBytes(buf.get(), size);\n        DynamicJsonBuffer jsonBuffer;\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        json.printTo(Serial);\n        if (json.success()) {\n          Serial.println(\"\\nparsed json\");\n\n          strcpy(mqtt_server, json[\"mqtt_server\"]);\n          strcpy(mqtt_port, json[\"mqtt_port\"]);\n          strcpy(blynk_token, json[\"blynk_token\"]);\n\n          if(json[\"ip\"]) {\n            Serial.println(\"setting custom ip from config\");\n            //static_ip = json[\"ip\"];\n            strcpy(static_ip, json[\"ip\"]);\n            strcpy(static_gw, json[\"gateway\"]);\n            strcpy(static_sn, json[\"subnet\"]);\n            //strcat(static_ip, json[\"ip\"]);\n            //static_gw = json[\"gateway\"];\n            //static_sn = json[\"subnet\"];\n            Serial.println(static_ip);\n/*            Serial.println(\"converting ip\");\n            IPAddress ip = ipFromCharArray(static_ip);\n            Serial.println(ip);*/\n          } else {\n            Serial.println(\"no custom ip in config\");\n          }\n        } else {\n          Serial.println(\"failed to load json config\");\n        }\n      }\n    }\n  } else {\n    Serial.println(\"failed to mount FS\");\n  }\n  //end read\n  Serial.println(static_ip);\n  Serial.println(blynk_token);\n  Serial.println(mqtt_server);\n\n\n  // The extra parameters to be configured (can be either global or just in the setup)\n  // After connecting, parameter.getValue() will get you the configured value\n  // id/name placeholder/prompt default length\n  WiFiManagerParameter custom_mqtt_server(\"server\", \"mqtt server\", mqtt_server, 40);\n  WiFiManagerParameter custom_mqtt_port(\"port\", \"mqtt port\", mqtt_port, 5);\n  WiFiManagerParameter custom_blynk_token(\"blynk\", \"blynk token\", blynk_token, 34);\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //set config save notify callback\n  wifiManager.setSaveConfigCallback(saveConfigCallback);\n\n  //set static ip\n  IPAddress _ip,_gw,_sn;\n  _ip.fromString(static_ip);\n  _gw.fromString(static_gw);\n  _sn.fromString(static_sn);\n\n  wifiManager.setSTAStaticIPConfig(_ip, _gw, _sn);\n  \n  //add all your parameters here\n  wifiManager.addParameter(&custom_mqtt_server);\n  wifiManager.addParameter(&custom_mqtt_port);\n  wifiManager.addParameter(&custom_blynk_token);\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set minimu quality of signal so it ignores AP's under that quality\n  //defaults to 8%\n  wifiManager.setMinimumSignalQuality();\n  \n  //sets timeout until configuration portal gets turned off\n  //useful to make it all retry or go to sleep\n  //in seconds\n  //wifiManager.setTimeout(120);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect and hit timeout\");\n    delay(3000);\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(5000);\n  }\n\n  //if you get here you have connected to the WiFi\n  Serial.println(\"connected...yeey :)\");\n\n  //read updated parameters\n  strcpy(mqtt_server, custom_mqtt_server.getValue());\n  strcpy(mqtt_port, custom_mqtt_port.getValue());\n  strcpy(blynk_token, custom_blynk_token.getValue());\n\n  //save the custom parameters to FS\n  if (shouldSaveConfig) {\n    Serial.println(\"saving config\");\n    DynamicJsonBuffer jsonBuffer;\n    JsonObject& json = jsonBuffer.createObject();\n    json[\"mqtt_server\"] = mqtt_server;\n    json[\"mqtt_port\"] = mqtt_port;\n    json[\"blynk_token\"] = blynk_token;\n\n    json[\"ip\"] = WiFi.localIP().toString();\n    json[\"gateway\"] = WiFi.gatewayIP().toString();\n    json[\"subnet\"] = WiFi.subnetMask().toString();\n\n    File configFile = SPIFFS.open(\"/config.json\", \"w\");\n    if (!configFile) {\n      Serial.println(\"failed to open config file for writing\");\n    }\n\n    json.prettyPrintTo(Serial);\n    json.printTo(configFile);\n    configFile.close();\n    //end save\n  }\n\n  Serial.println(\"local ip\");\n  Serial.println(WiFi.localIP());\n  Serial.println(WiFi.gatewayIP());\n  Serial.println(WiFi.subnetMask());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "https",
        "callback",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "configModeCallback",
          "parameters": "WiFiManager *myWiFiManager",
          "body": "Serial.println(\"Entered config mode\");\n  Serial.println(WiFi.softAPIP());\n  //if you used auto generated SSID, print it\n  Serial.println(myWiFiManager->getConfigPortalSSID());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  wifiManager.setAPCallback(configModeCallback);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if(!wifiManager.autoConnect()) {\n    Serial.println(\"failed to connect and hit timeout\");\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(1000);\n  } \n\n  //if you get here you have connected to the WiFi\n  Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "https",
        "callback",
        "current",
        "wifi",
        "digitalread",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "tick",
          "parameters": "",
          "body": "//toggle state\n  int state = digitalRead(BUILTIN_LED);  // get the current state of GPIO1 pin\n  digitalWrite(BUILTIN_LED, !state);     // set pin to the opposite state"
        },
        {
          "name": "configModeCallback",
          "parameters": "WiFiManager *myWiFiManager",
          "body": "Serial.println(\"Entered config mode\");\n  Serial.println(WiFi.softAPIP());\n  //if you used auto generated SSID, print it\n  Serial.println(myWiFiManager->getConfigPortalSSID());\n  //entered config mode, make led toggle faster\n  ticker.attach(0.2, tick);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //set led pin as output\n  pinMode(BUILTIN_LED, OUTPUT);\n  // start ticker with 0.5 because we start in AP mode and try to connect\n  ticker.attach(0.6, tick);\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  wifiManager.setAPCallback(configModeCallback);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect()) {\n    Serial.println(\"failed to connect and hit timeout\");\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(1000);\n  }\n\n  //if you get here you have connected to the WiFi\n  Serial.println(\"connected...yeey :)\");\n  ticker.detach();\n  //keep LED on\n  digitalWrite(BUILTIN_LED, LOW);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "https",
        "password",
        "wifi",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //exit after config instead of connecting\n  wifiManager.setBreakAfterConfig(true);\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n\n  //tries to connect to last known settings\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\" with password \"password\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect, we should reset as see if it connects\");\n    delay(3000);\n    ESP.reset();\n    delay(5000);\n  }\n\n  //if you get here you have connected to the WiFi\n  Serial.println(\"connected...yeey :)\");\n\n\n  Serial.println(\"local ip\");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "https",
        "password",
        "wifi",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set static ip\n  //block1 should be used for ESP8266 core 2.1.0 or newer, otherwise use block2\n\n  //start-block1\n  //IPAddress _ip,_gw,_sn;\n  //_ip.fromString(static_ip);\n  //_gw.fromString(static_gw);\n  //_sn.fromString(static_sn);\n  //end-block1\n\n  //start-block2\n  IPAddress _ip = IPAddress(10, 0, 1, 78);\n  IPAddress _gw = IPAddress(10, 0, 1, 1);\n  IPAddress _sn = IPAddress(255, 255, 255, 0);\n  //end-block2\n  \n  wifiManager.setSTAStaticIPConfig(_ip, _gw, _sn);\n\n\n  //tries to connect to last known settings\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\" with password \"password\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect, we should reset as see if it connects\");\n    delay(3000);\n    ESP.reset();\n    delay(5000);\n  }\n\n  //if you get here you have connected to the WiFi\n  Serial.println(\"connected...yeey :)\");\n\n\n  Serial.println(\"local ip\");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "https",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //sets timeout until configuration portal gets turned off\n  //useful to make it all retry or go to sleep\n  //in seconds\n  wifiManager.setTimeout(180);\n  \n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if(!wifiManager.autoConnect(\"AutoConnectAP\")) {\n    Serial.println(\"failed to connect and hit timeout\");\n    delay(3000);\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(5000);\n  } \n\n  //if you get here you have connected to the WiFi\n  Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "power",
        "current",
        "spi",
        "delay",
        "millis",
        "digitalwrite",
        "watchdog"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "SPI.begin();\n  pinMode(amisStepPin, OUTPUT);\n  delay(1);\n\n  stepper.init(amisSlaveSelect);\n  stepper.resetSettings();\n  stepper.setCurrentMilliamps(132);\n  stepper.enableDriver();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "takeSteps();\n  checkDriver();"
        },
        {
          "name": "takeSteps",
          "parameters": "",
          "body": "// Don't take any steps if there is an issue.\n  if (stepperSettingsProblem || stepperNonLatchedFlags || stepperLatchedFlags)\n  {\n    return;\n  }\n\n  uint16_t m = millis();\n\n  // We will switch directions after each pause.\n  bool desiredDirection = m >> 10 & 1;\n\n  if ((m & 1023) >= 774)\n  {\n    // Pause for 250 ms once per second.\n  }\n  else\n  {\n    // Otherwise, take a step roughly every 1500 microseconds.\n    static uint16_t lastStepTime = 0;\n    if ((uint16_t)(micros() - lastStepTime) >= 1500)\n    {\n      lastStepTime = micros();\n\n      // Send the SPI command to change the direction, but only\n      // if it is needed.\n      if (desiredDirection != stepper.getDirection())\n      {\n        stepper.setDirection(desiredDirection);\n      }\n\n      digitalWrite(amisStepPin, HIGH);\n      delayMicroseconds(3);\n      digitalWrite(amisStepPin, LOW);\n      delayMicroseconds(3);\n    }\n  }"
        },
        {
          "name": "checkDriver",
          "parameters": "",
          "body": "// Every 20 ms, perform some checks.\n  static uint16_t lastCheckTime = 0;\n  if ((uint16_t)(millis() - lastCheckTime) >= 20)\n  {\n    // Read back the configuration of the driver and make sure it\n    // is correct.\n    if (!stepperSettingsProblem && !stepper.verifySettings())\n    {\n      // We have detected the settings on the driver do not match\n      // the desired settings we chose earlier in this sketch.\n      // It is likely that stepper motor power has been lost or\n      // that communication with the driver is not working.\n      stepperSettingsProblem = true;\n      Serial.println(F(\"Could not verify settings; driver power might be off.\"));\n    }\n    if (stepperSettingsProblem)\n    {\n      // The settings are currently not correct.  Try writing the\n      // correct settings to the device to fix it.  This will not\n      // work if the device is powered off.\n      stepper.applySettings();\n\n      if (stepper.verifySettings())\n      {\n        // We successfully restored the settings.\n        stepperSettingsProblem = false;\n        Serial.println(F(\"Successfully reapplied settings.\"));\n      }\n    }\n\n    // Read the non-latched status flags.  This should allow us\n    // to detect thermal warnings, charge pump failure, watchdog\n    // events, and open coil conditions.\n    uint8_t newFlags = stepper.readNonLatchedStatusFlags();\n    if (newFlags != stepperNonLatchedFlags)\n    {\n      stepperNonLatchedFlags = newFlags;\n      Serial.print(F(\"Non-latched status flags changed: 0x\"));\n      Serial.print(newFlags, HEX);\n      Serial.println();\n    }\n\n    lastCheckTime = millis();\n  }\n\n  // Every 500 ms, perform some other checks.\n  static uint16_t lastSlowCheckTime = 0;\n  if ((uint16_t)(millis() - lastSlowCheckTime) >= 500)\n  {\n    lastSlowCheckTime = millis();\n\n    // Read the latched status flags.  Note that this has the\n    // effect of clearing the latched flags and allowing the\n    // motor driver outputs to operate again.  If there is a\n    // short circuit, reading these flags too frequently could\n    // cause damage to the driver.  That is why we only read it\n    // twice per second in this example.  If you want to get\n    // faster notifications of latched errors, you could monitor\n    // the ERR pin.\n    uint16_t newFlags = stepper.readLatchedStatusFlagsAndClear();\n    if (newFlags != stepperLatchedFlags)\n    {\n      stepperLatchedFlags = newFlags;\n      Serial.print(F(\"Latched status flags changed: 0x\"));\n      Serial.print(newFlags, HEX);\n      Serial.println();\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "millis"
      ],
      "libraries": [
        "your_edge_impulse_inferencing.h",
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/car.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___AUTONOMOUS CAR___\");\n\n    // replace with your board\n    camera.pinout.freenove_s3();\n    camera.brownout.disable();\n    camera.resolution.yolo();\n    camera.pixformat.rgb565();\n\n    // how many millis motors will run\n    // to follow given object\n    fomoCar.defaultDuration(100);\n    fomoCar.stop();\n\n    // if you mounted the camera \"backward\"\n    // (see video), you have to reverse the motors\n    // left.reverse();\n    // right.reverse();\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Put object in front of camera\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;\n    }\n\n    // run FOMO\n    if (!fomo.run().isOk()) {\n        Serial.println(fomo.exception.toString());\n        return;\n    }\n\n    // let the car follow the object\n    fomoCar.follow(fomo);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay",
        "lcd",
        "display"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// set the cursor to (0,0):\n  lcd.setCursor(0, 0);\n  // print from 0 to 9:\n  for (int thisChar = 0; thisChar < 10; thisChar++) {\n    lcd.print(thisChar);\n    delay(500);\n  }\n\n  // set the cursor to (16,1):\n  lcd.setCursor(16, 1);\n  // set the display to automatically scroll:\n  lcd.autoscroll();\n  // print from 0 to 9:\n  for (int thisChar = 0; thisChar < 10; thisChar++) {\n    lcd.print(thisChar);\n    delay(500);\n  }\n  // turn off automatic scrolling\n  lcd.noAutoscroll();\n\n  // clear screen for the next loop:\n  lcd.clear();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "rest",
        "buffer",
        "callback",
        "voltage",
        "power",
        "current",
        "light",
        "spi",
        "digitalwrite",
        "delay",
        "millis",
        "analogread",
        "yield",
        "led",
        "sd",
        "flash",
        "rtc",
        "interrupt",
        "timer"
      ],
      "libraries": [
        "SPI.h",
        "SdFat.h",
        "BufferedPrint.h",
        "FreeStack.h",
        "AvrAdcLogger.h",
        "MinimumSerial.h",
        "RTClib.h"
      ],
      "functions": [
        {
          "name": "fatalBlink",
          "parameters": "",
          "body": "while (true) {\n    if (ERROR_LED_PIN >= 0) {\n      digitalWrite(ERROR_LED_PIN, HIGH);\n      delay(200);\n      digitalWrite(ERROR_LED_PIN, LOW);\n      delay(200);\n    }\n  }"
        },
        {
          "name": "errorHalt",
          "parameters": "",
          "body": "// Print minimal error data.\n  // sd.errorPrint(&Serial);\n  // Print extended error info - uses extra bytes of flash.\n  sd.printSdError(&Serial);\n  // Try to save data.\n  binFile.close();\n  fatalBlink();"
        },
        {
          "name": "printUnusedStack",
          "parameters": "",
          "body": "Serial.print(F(\"\\nUnused stack: \"));\n  Serial.println(UnusedStack());"
        },
        {
          "name": "dateTime",
          "parameters": "uint16_t* date, uint16_t* time, uint8_t* ms10",
          "body": "DateTime now = rtc.now();\n\n  // Return date using FS_DATE macro to format fields.\n  *date = FS_DATE(now.year(), now.month(), now.day());\n\n  // Return time using FS_TIME macro to format fields.\n  *time = FS_TIME(now.hour(), now.minute(), now.second());\n\n  // Return low time bits in units of 10 ms.\n  *ms10 = now.second() & 1 ? 100 : 0;"
        },
        {
          "name": "adcActive",
          "parameters": "",
          "body": "return (1 << ADIE) & ADCSRA;}\n//------------------------------------------------------------------------------\n// initialize ADC and timer1\nvoid adcInit(metadata_t* meta) {\n  uint8_t adps;  // prescaler bits for ADCSRA\n  uint32_t ticks = F_CPU*SAMPLE_INTERVAL + 0.5;  // Sample interval cpu cycles.\n\n  if (ADC_REF & ~((1 << REFS0) | (1 << REFS1))) {\n    error(\"Invalid ADC reference\");\n  }\n#ifdef ADC_PRESCALER\n  if (ADC_PRESCALER > 7 || ADC_PRESCALER < 2) {\n    error(\"Invalid ADC prescaler\");\n  }\n  adps = ADC_PRESCALER;\n#else  // ADC_PRESCALER\n  // Allow extra cpu cycles to change ADC settings if more than one pin.\n  int32_t adcCycles = (ticks - ISR_TIMER0)/PIN_COUNT - ISR_SETUP_ADC;\n\n  for (adps = 7; adps > 0; adps--) {\n    if (adcCycles >= (MIN_ADC_CYCLES << adps)) {\n      break;\n    }\n  }\n#endif  // ADC_PRESCALER\n  meta->adcFrequency = F_CPU >> adps;\n  if (meta->adcFrequency > (RECORD_EIGHT_BITS ? 2000000 : 1000000)) {\n    error(\"Sample Rate Too High\");\n  }\n#if ROUND_SAMPLE_INTERVAL\n  // Round so interval is multiple of ADC clock.\n  ticks += 1 << (adps - 1);\n  ticks >>= adps;\n  ticks <<= adps;\n#endif  // ROUND_SAMPLE_INTERVAL\n\n  if (PIN_COUNT > BLOCK_MAX_COUNT || PIN_COUNT > PIN_NUM_DIM) {\n    error(\"Too many pins\");\n  }\n  meta->pinCount = PIN_COUNT;\n  meta->recordEightBits = RECORD_EIGHT_BITS;\n\n  for (int i = 0; i < PIN_COUNT; i++) {\n    uint8_t pin = PIN_LIST[i];\n    if (pin >= NUM_ANALOG_INPUTS) {\n      error(\"Invalid Analog pin number\");\n    }\n    meta->pinNumber[i] = pin;\n\n    // Set ADC reference and low three bits of analog pin number.\n    adcmux[i] = (pin & 7) | ADC_REF;\n    if (RECORD_EIGHT_BITS) {\n      adcmux[i] |= 1 << ADLAR;\n    }\n\n    // If this is the first pin, trigger on timer/counter 1 compare match B.\n    adcsrb[i] = i == 0 ? (1 << ADTS2) | (1 << ADTS0) : 0;\n#ifdef MUX5\n    if (pin > 7) {\n      adcsrb[i] |= (1 << MUX5);\n    }\n#endif  // MUX5\n    adcsra[i] = (1 << ADEN) | (1 << ADIE) | adps;\n    // First pin triggers on timer 1 compare match B rest are free running.\n    adcsra[i] |= i == 0 ? 1 << ADATE : 1 << ADSC;\n  }\n\n  // Setup timer1\n  TCCR1A = 0;\n  uint8_t tshift;\n  if (ticks < 0X10000) {\n    // no prescale, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS10);\n    tshift = 0;\n  } else if (ticks < 0X10000*8) {\n    // prescale 8, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);\n    tshift = 3;\n  } else if (ticks < 0X10000*64) {\n    // prescale 64, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11) | (1 << CS10);\n    tshift = 6;\n  } else if (ticks < 0X10000*256) {\n    // prescale 256, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS12);\n    tshift = 8;\n  } else if (ticks < 0X10000*1024) {\n    // prescale 1024, CTC mode\n    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS12) | (1 << CS10);\n    tshift = 10;\n  } else {\n    error(\"Sample Rate Too Slow\");\n  }\n  // divide by prescaler\n  ticks >>= tshift;\n  // set TOP for timer reset\n  ICR1 = ticks - 1;\n  // compare for ADC start\n  OCR1B = 0;\n\n  // multiply by prescaler\n  ticks <<= tshift;\n\n  // Sample interval in CPU clock ticks.\n  meta->sampleInterval = ticks;\n  meta->cpuFrequency = F_CPU;\n  float sampleRate = (float)meta->cpuFrequency/meta->sampleInterval;\n  Serial.print(F(\"Sample pins:\"));\n  for (uint8_t i = 0; i < meta->pinCount; i++) {\n    Serial.print(' ');\n    Serial.print(meta->pinNumber[i], DEC);\n  }\n  Serial.println();\n  Serial.print(F(\"ADC bits: \"));\n  Serial.println(meta->recordEightBits ? 8 : 10);\n  Serial.print(F(\"ADC clock kHz: \"));\n  Serial.println(meta->adcFrequency/1000);\n  Serial.print(F(\"Sample Rate: \"));\n  Serial.println(sampleRate);\n  Serial.print(F(\"Sample interval usec: \"));\n  Serial.println(1000000.0/sampleRate);"
        },
        {
          "name": "adcStart",
          "parameters": "",
          "body": "// initialize ISR\n  adcindex = 1;\n  isrBuf = nullptr;\n  isrOver = 0;\n  isrStop = false;\n\n  // Clear any pending interrupt.\n  ADCSRA |= 1 << ADIF;\n\n  // Setup for first pin.\n  ADMUX = adcmux[0];\n  ADCSRB = adcsrb[0];\n  ADCSRA = adcsra[0];\n\n  // Enable timer1 interrupts.\n  timerError = false;\n  timerFlag = false;\n  TCNT1 = 0;\n  TIFR1 = 1 << OCF1B;\n  TIMSK1 = 1 << OCIE1B;"
        },
        {
          "name": "adcStop",
          "parameters": "",
          "body": "TIMSK1 = 0;\n  ADCSRA = 0;"
        },
        {
          "name": "binaryToCsv",
          "parameters": "",
          "body": "uint8_t lastPct = 0;\n  block_t* pd;\n  metadata_t* pm;\n  uint32_t t0 = millis();\n  // Use fast buffered print class.\n  BufferedPrint<file_t, 64> bp(&csvFile);\n  block_t binBuffer[FIFO_DIM];\n\n  assert(sizeof(block_t) == sizeof(metadata_t));\n  binFile.rewind();\n  uint32_t tPct = millis();\n  bool doMeta = true;\n  while (!Serial.available()) {\n    pd = binBuffer;\n    int nb = binFile.read(binBuffer, sizeof(binBuffer));\n    if (nb < 0) {\n      error(\"read binFile failed\");\n    }\n    size_t nd = nb/sizeof(block_t);\n    if (nd < 1) {\n      break;\n    }\n    if (doMeta) {\n      doMeta = false;\n      pm = (metadata_t*)pd++;\n      if (PIN_COUNT != pm->pinCount) {\n        error(\"Invalid pinCount\");\n      }\n      bp.print(F(\"Interval,\"));\n      float intervalMicros = 1.0e6*pm->sampleInterval/(float)pm->cpuFrequency;\n      bp.print(intervalMicros, 4);\n      bp.println(F(\",usec\"));\n      for (uint8_t i = 0; i < PIN_COUNT; i++) {\n        if (i) {\n          bp.print(',');\n        }\n        bp.print(F(\"pin\"));\n        bp.print(pm->pinNumber[i]);\n      }\n      bp.println();\n      if (nd-- == 1) {\n        break;\n      }\n    }\n    for (size_t i = 0; i < nd; i++, pd++) {\n      if (pd->overrun) {\n        bp.print(F(\"OVERRUN,\"));\n        bp.println(pd->overrun);\n      }\n      for (size_t j = 0; j < pd->count; j += PIN_COUNT) {\n        for (size_t i = 0; i < PIN_COUNT; i++) {\n          if (!bp.printField(pd->data[i + j], i == (PIN_COUNT-1) ? '\\n' : ',')) {\n            error(\"printField failed\");\n          }\n        }\n      }\n    }\n    if ((millis() - tPct) > 1000) {\n      uint8_t pct = binFile.curPosition()/(binFile.fileSize()/100);\n      if (pct != lastPct) {\n        tPct = millis();\n        lastPct = pct;\n        Serial.print(pct, DEC);\n        Serial.println('%');\n      }\n    }\n  }\n  if (!bp.sync() || !csvFile.close()) {\n    error(\"close csvFile failed\");\n  }\n  Serial.print(F(\"Done: \"));\n  Serial.print(0.001*(millis() - t0));\n  Serial.println(F(\" Seconds\"));"
        },
        {
          "name": "clearSerialInput",
          "parameters": "",
          "body": "uint32_t m = micros();\n  do {\n    if (Serial.read() >= 0) {\n      m = micros();\n    }\n  } while (micros() - m < 10000);"
        },
        {
          "name": "createBinFile",
          "parameters": "",
          "body": "binFile.close();\n  while (sd.exists(binName)) {\n    char* p = strchr(binName, '.');\n    if (!p) {\n      error(\"no dot in filename\");\n    }\n    while (true) {\n      p--;\n      if (p < binName || *p < '0' || *p > '9') {\n        error(\"Can't create file name\");\n      }\n      if (p[0] != '9') {\n        p[0]++;\n        break;\n      }\n      p[0] = '0';\n    }\n  }\n  Serial.print(F(\"Opening: \"));\n  Serial.println(binName);\n  if (!binFile.open(binName, O_RDWR | O_CREAT)) {\n    error(\"open binName failed\");\n  }\n  Serial.print(F(\"Allocating: \"));\n  Serial.print(MAX_FILE_SIZE_MiB);\n  Serial.println(F(\" MiB\"));\n  if (!binFile.preAllocate(MAX_FILE_SIZE)) {\n    error(\"preAllocate failed\");\n  }"
        },
        {
          "name": "createCsvFile",
          "parameters": "",
          "body": "char csvName[NAME_DIM];\n\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return false;\n  }\n  binFile.getName(csvName, sizeof(csvName));\n  char* dot = strchr(csvName, '.');\n  if (!dot) {\n    error(\"no dot in binName\");\n  }\n  strcpy(dot + 1, \"csv\");\n  if (!csvFile.open(csvName, O_WRONLY|O_CREAT|O_TRUNC)) {\n    error(\"open csvFile failed\");\n  }\n  Serial.print(F(\"Writing: \"));\n  Serial.print(csvName);\n  Serial.println(F(\" - type any character to stop\"));\n  return true;"
        },
        {
          "name": "logData",
          "parameters": "",
          "body": "uint32_t t0;\n  uint32_t t1;\n  uint32_t overruns =0;\n  uint32_t count = 0;\n  uint32_t maxLatencyUsec = 0;\n  size_t maxFifoUse = 0;\n  block_t fifoBuffer[FIFO_DIM];\n\n  adcInit((metadata_t*)fifoBuffer);\n  // Write metadata.\n  if (sizeof(metadata_t) != binFile.write(fifoBuffer, sizeof(metadata_t))) {\n    error(\"Write metadata failed\");\n  }\n  fifoCount = 0;\n  fifoHead = 0;\n  fifoTail = 0;\n  fifoData = fifoBuffer;\n  // Initialize all blocks to save ISR overhead.\n  memset(fifoBuffer, 0, sizeof(fifoBuffer));\n\n  Serial.println(F(\"Logging - type any character to stop\"));\n  // Wait for Serial Idle.\n  Serial.flush();\n  delay(10);\n\n  t0 = millis();\n  t1 = t0;\n  // Start logging interrupts.\n  adcStart();\n  while (1) {\n    uint32_t m;\n    noInterrupts();\n    size_t tmpFifoCount = fifoCount;\n    interrupts();\n    if (tmpFifoCount) {\n      block_t* pBlock = fifoData + fifoTail;\n      // Write block to SD.\n      m = micros();\n      if (sizeof(block_t) != binFile.write(pBlock, sizeof(block_t))) {\n        error(\"write data failed\");\n      }\n      m = micros() - m;\n      t1 = millis();\n      if (m > maxLatencyUsec) {\n        maxLatencyUsec = m;\n      }\n      if (tmpFifoCount >maxFifoUse) {\n        maxFifoUse = tmpFifoCount;\n      }\n      count += pBlock->count;\n\n      // Add overruns and possibly light LED.\n      if (pBlock->overrun) {\n        overruns += pBlock->overrun;\n        if (ERROR_LED_PIN >= 0) {\n          digitalWrite(ERROR_LED_PIN, HIGH);\n        }\n      }\n      // Initialize empty block to save ISR overhead.\n      pBlock->count = 0;\n      pBlock->overrun = 0;\n      fifoTail = fifoTail < (FIFO_DIM - 1) ? fifoTail + 1 : 0;\n\n      noInterrupts();\n      fifoCount--;\n      interrupts();\n\n      if (binFile.curPosition() >= MAX_FILE_SIZE) {\n        // File full so stop ISR calls.\n        adcStop();\n        break;\n      }\n    }\n    if (timerError) {\n      error(\"Missed timer event - rate too high\");\n    }\n    if (Serial.available()) {\n      // Stop ISR interrupts.\n      isrStop = true;\n    }\n    if (fifoCount == 0 && !adcActive()) {\n       break;\n    }\n  }\n  Serial.println();\n  // Truncate file if recording stopped early.\n  if (binFile.curPosition() < MAX_FILE_SIZE) {\n    Serial.println(F(\"Truncating file\"));\n    Serial.flush();\n    if (!binFile.truncate()) {\n      error(\"Can't truncate file\");\n    }\n  }\n  Serial.print(F(\"Max write latency usec: \"));\n  Serial.println(maxLatencyUsec);\n  Serial.print(F(\"Record time sec: \"));\n  Serial.println(0.001*(t1 - t0), 3);\n  Serial.print(F(\"Sample count: \"));\n  Serial.println(count/PIN_COUNT);\n  Serial.print(F(\"Overruns: \"));\n  Serial.println(overruns);\n  Serial.print(F(\"FIFO_DIM: \"));\n  Serial.println(FIFO_DIM);\n  Serial.print(F(\"maxFifoUse: \"));\n  Serial.println(maxFifoUse + 1);  // include ISR use.\n  Serial.println(F(\"Done\"));"
        },
        {
          "name": "openBinFile",
          "parameters": "",
          "body": "char name[NAME_DIM];\n  clearSerialInput();\n  Serial.println(F(\"Enter file name\"));\n  if (!serialReadLine(name, sizeof(name))) {\n    return;\n  }\n  if (!sd.exists(name)) {\n    Serial.println(name);\n    Serial.println(F(\"File does not exist\"));\n    return;\n  }\n  binFile.close();\n  if (!binFile.open(name, O_RDWR)) {\n    Serial.println(name);\n    Serial.println(F(\"open failed\"));\n    return;\n  }\n  Serial.println(F(\"File opened\"));"
        },
        {
          "name": "printData",
          "parameters": "",
          "body": "block_t buf;\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;\n  }\n  binFile.rewind();\n  if (binFile.read(&buf , sizeof(buf)) != sizeof(buf)) {\n    error(\"Read metadata failed\");\n  }\n  Serial.println(F(\"Type any character to stop\"));\n  delay(1000);\n  while (!Serial.available() &&\n         binFile.read(&buf , sizeof(buf)) == sizeof(buf)) {\n    if (buf.count == 0) {\n      break;\n    }\n    if (buf.overrun) {\n      Serial.print(F(\"OVERRUN,\"));\n      Serial.println(buf.overrun);\n    }\n    for (size_t i = 0; i < buf.count; i++) {\n      Serial.print(buf.data[i], DEC);\n      if ((i+1)%PIN_COUNT) {\n        Serial.print(',');\n      } else {\n        Serial.println();\n      }\n    }\n  }\n  Serial.println(F(\"Done\"));"
        },
        {
          "name": "serialReadLine",
          "parameters": "char* str, size_t size",
          "body": "size_t n = 0;\n  while(!Serial.available()) {\n  }\n  while (true) {\n    int c = Serial.read();\n    if (c < ' ') break;\n    str[n++] = c;\n    if (n >= size) {\n      Serial.println(F(\"input too long\"));\n      return false;\n    }\n    uint32_t m = millis();\n    while (!Serial.available() && (millis() - m) < 100){}\n    if (!Serial.available()) break;\n  }\n  str[n] = 0;\n  return true;"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);\n  }\n  Serial.begin(9600);\n  while(!Serial) {}\n  Serial.println(F(\"Type any character to begin.\"));\n  while(!Serial.available()) {}\n\n  FillStack();\n\n  // Read the first sample pin to init the ADC.\n  analogRead(PIN_LIST[0]);\n\n#if !ENABLE_DEDICATED_SPI\n  Serial.println(F(\n    \"\\nFor best performance edit SdFatConfig.h\\n\"\n    \"and set ENABLE_DEDICATED_SPI nonzero\"));\n#endif  // !ENABLE_DEDICATED_SPI\n  // Initialize SD.\n  if (!sd.begin(SD_CONFIG)) {\n    error(\"sd.begin failed\");\n  }\n#if USE_RTC\n  if (!rtc.begin()) {\n    error(\"rtc.begin failed\");\n  }\n  if (!rtc.isrunning()) {\n    // Set RTC to sketch compile date & time.\n    // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));\n    error(\"RTC is NOT running!\");\n  } else {\n    Serial.println(F(\"RTC is running\"));\n  }\n  // Set callback\n  FsDateTime::setCallback(dateTime);\n#endif  // USE_RTC"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "printUnusedStack();\n  // Read any Serial data.\n  clearSerialInput();\n  Serial.println();\n  Serial.println(F(\"type:\"));\n  Serial.println(F(\"b - open existing bin file\"));\n  Serial.println(F(\"c - convert file to csv\"));\n  Serial.println(F(\"l - list files\"));\n  Serial.println(F(\"p - print data to Serial\"));\n  Serial.println(F(\"r - record ADC data\"));\n\n  while(!Serial.available()) {\n    yield();\n  }\n  char c = tolower(Serial.read());\n  Serial.println();\n  if (ERROR_LED_PIN >= 0) {\n    digitalWrite(ERROR_LED_PIN, LOW);\n  }\n  // Read any Serial data.\n  clearSerialInput();\n\n  if (c == 'b') {\n    openBinFile();\n  } else if (c == 'c') {\n    if (createCsvFile()) {\n      binaryToCsv();\n    }\n  } else if (c == 'l') {\n    Serial.println(F(\"ls:\"));\n    sd.ls(&Serial, LS_DATE | LS_SIZE);\n  } else if (c == 'p') {\n    printData();\n  } else if (c == 'r') {\n    createBinFile();\n    logData();\n  } else {\n    Serial.println(F(\"Invalid entry\"));\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "pwm"
      ],
      "libraries": [
        "ContinuousStepper.h",
        "ContinuousStepper/Tickers/AnalogWriteFrequency.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "stepper.begin(/*step=*/2, /*dir=*/3); // ⚠️ step pin must support PWM\n\n  stepper.spin(200);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "stepper.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "api",
        "key",
        "certificate",
        "ssl",
        "tls",
        "password",
        "callback",
        "publish",
        "subscribe",
        "stream",
        "current",
        "gsm",
        "gprs",
        "millis",
        "delay",
        "devices",
        "deviceid",
        "devicebound"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "MKRGSM.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  // reconstruct the self signed cert\n  ECCX08SelfSignedCert.beginReconstruction(0, 8);\n  ECCX08SelfSignedCert.setCommonName(ECCX08.serialNumber());\n  ECCX08SelfSignedCert.endReconstruction();\n\n  // Set a callback to get the current time\n  // used to validate the servers certificate\n  ArduinoBearSSL.onGetTime(getTime);\n\n  // Set the ECCX08 slot to use for the private key\n  // and the accompanying public certificate for it\n  sslClient.setEccSlot(0, ECCX08SelfSignedCert.bytes(), ECCX08SelfSignedCert.length());\n\n  // Set the client id used for MQTT as the device id\n  mqttClient.setId(deviceId);\n\n  // Set the username to \"<broker>/<device id>/api-version=2018-06-30\" and empty password\n  String username;\n\n  username += broker;\n  username += \"/\";\n  username += deviceId;\n  username += \"/api-version=2018-06-30\";\n\n  mqttClient.setUsernamePassword(username, \"\");\n\n  // Set the message callback, this function is\n  // called when the MQTTClient receives a message\n  mqttClient.onMessage(onMessageReceived);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (gsmAccess.status() != GSM_READY || gprs.status() != GPRS_READY) {\n    connectGSM();\n  }\n\n  if (!mqttClient.connected()) {\n    // MQTT client is disconnected, connect\n    connectMQTT();\n  }\n\n  // poll for new MQTT messages and send keep alives\n  mqttClient.poll();\n\n  // publish a message roughly every 5 seconds.\n  if (millis() - lastMillis > 5000) {\n    lastMillis = millis();\n\n    publishMessage();\n  }"
        },
        {
          "name": "connectGSM",
          "parameters": "",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((gsmAccess.begin(pinnumber) != GSM_READY) ||\n         (gprs.attachGPRS(gprs_apn, gprs_login, gprs_password) != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);\n  }\n\n  Serial.println(\"You're connected to the cellular network\");\n  Serial.println();"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the MQTT broker\");\n  Serial.println();\n\n  // subscribe to a topic\n  mqttClient.subscribe(\"devices/\" + deviceId + \"/messages/devicebound/#\");"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());\n  }\n  Serial.println();\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "api",
        "key",
        "certificate",
        "ssl",
        "tls",
        "https",
        "password",
        "callback",
        "publish",
        "subscribe",
        "stream",
        "current",
        "lte",
        "gprs",
        "millis",
        "delay",
        "devices",
        "deviceid",
        "devicebound"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "MKRNB.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  // reconstruct the self signed cert\n  ECCX08SelfSignedCert.beginReconstruction(0, 8);\n  ECCX08SelfSignedCert.setCommonName(ECCX08.serialNumber());\n  ECCX08SelfSignedCert.endReconstruction();\n\n  // Set a callback to get the current time\n  // used to validate the servers certificate\n  ArduinoBearSSL.onGetTime(getTime);\n\n  // Set the ECCX08 slot to use for the private key\n  // and the accompanying public certificate for it\n  sslClient.setEccSlot(0, ECCX08SelfSignedCert.bytes(), ECCX08SelfSignedCert.length());\n\n  // Set the client id used for MQTT as the device id\n  mqttClient.setId(deviceId);\n\n  // Set the username to \"<broker>/<device id>/api-version=2018-06-30\" and empty password\n  String username;\n\n  username += broker;\n  username += \"/\";\n  username += deviceId;\n  username += \"/api-version=2018-06-30\";\n\n  mqttClient.setUsernamePassword(username, \"\");\n\n  // Set the message callback, this function is\n  // called when the MQTTClient receives a message\n  mqttClient.onMessage(onMessageReceived);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (nbAccess.status() != NB_READY || gprs.status() != GPRS_READY) {\n    connectNB();\n  }\n\n  if (!mqttClient.connected()) {\n    // MQTT client is disconnected, connect\n    connectMQTT();\n  }\n\n  // poll for new MQTT messages and send keep alives\n  mqttClient.poll();\n\n  // publish a message roughly every 5 seconds.\n  if (millis() - lastMillis > 5000) {\n    lastMillis = millis();\n\n    publishMessage();\n  }"
        },
        {
          "name": "connectNB",
          "parameters": "",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((nbAccess.begin(pinnumber) != NB_READY) ||\n         (gprs.attachGPRS() != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);\n  }\n\n  Serial.println(\"You're connected to the cellular network\");\n  Serial.println();"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the MQTT broker\");\n  Serial.println();\n\n  // subscribe to a topic\n  mqttClient.subscribe(\"devices/\" + deviceId + \"/messages/devicebound/#\");"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());\n  }\n  Serial.println();\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "wificlient",
        "api",
        "key",
        "certificate",
        "ssl",
        "tls",
        "password",
        "callback",
        "publish",
        "subscribe",
        "stream",
        "current",
        "wifi",
        "millis",
        "delay",
        "devices",
        "deviceid",
        "devicebound"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  // reconstruct the self signed cert\n  ECCX08SelfSignedCert.beginReconstruction(0, 8);\n  ECCX08SelfSignedCert.setCommonName(ECCX08.serialNumber());\n  ECCX08SelfSignedCert.endReconstruction();\n\n  // Set a callback to get the current time\n  // used to validate the servers certificate\n  ArduinoBearSSL.onGetTime(getTime);\n\n  // Set the ECCX08 slot to use for the private key\n  // and the accompanying public certificate for it\n  sslClient.setEccSlot(0, ECCX08SelfSignedCert.bytes(), ECCX08SelfSignedCert.length());\n\n  // Set the client id used for MQTT as the device id\n  mqttClient.setId(deviceId);\n\n  // Set the username to \"<broker>/<device id>/api-version=2018-06-30\" and empty password\n  String username;\n\n  username += broker;\n  username += \"/\";\n  username += deviceId;\n  username += \"/api-version=2018-06-30\";\n\n  mqttClient.setUsernamePassword(username, \"\");\n\n  // Set the message callback, this function is\n  // called when the MQTTClient receives a message\n  mqttClient.onMessage(onMessageReceived);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    connectWiFi();\n  }\n\n  if (!mqttClient.connected()) {\n    // MQTT client is disconnected, connect\n    connectMQTT();\n  }\n\n  // poll for new MQTT messages and send keep alives\n  mqttClient.poll();\n\n  // publish a message roughly every 5 seconds.\n  if (millis() - lastMillis > 5000) {\n    lastMillis = millis();\n\n    publishMessage();\n  }"
        },
        {
          "name": "connectWiFi",
          "parameters": "",
          "body": "Serial.print(\"Attempting to connect to SSID: \");\n  Serial.print(ssid);\n  Serial.print(\" \");\n\n  while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the network\");\n  Serial.println();"
        },
        {
          "name": "connectMQTT",
          "parameters": "",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);\n  }\n  Serial.println();\n\n  Serial.println(\"You're connected to the MQTT broker\");\n  Serial.println();\n\n  // subscribe to a topic\n  mqttClient.subscribe(\"devices/\" + deviceId + \"/messages/devicebound/#\");"
        },
        {
          "name": "publishMessage",
          "parameters": "",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "parameters": "int messageSize",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());\n  }\n  Serial.println();\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "ble",
        "flash"
      ],
      "libraries": [
        "BlynkSimpleBLEPeripheral.h",
        "BLEPeripheral.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  SerialBLE.setLocalName(\"Blynk\");\n  SerialBLE.setDeviceName(\"Blynk\");\n  SerialBLE.setAppearance(0x0080);\n  SerialBLE.begin();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(SerialBLE, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SerialBLE.poll();\n\n  if (SerialBLE) {    // If BLE is connected...\n    Blynk.run();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "flash"
      ],
      "libraries": [
        "SPIFBlockDevice.h",
        "LittleFileSystem.h",
        "fw.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(3000);\n\n  char crc = 0;\n  for (int i = 0; i < fw_bin_len; i++) {\n    crc = crc ^ fw_bin[i];\n  }\n  \n  Serial.print(\"The computed CRC is 0x\");\n  Serial.println(crc, HEX);\n\n  Serial.println(\"Writing BHY FW binary into SPIFlash...\");\n\n  int err = fs.mount(&spif);\n  if (err) {\n    err = fs.reformat(&spif);\n    Serial.print(\"Error mounting file system: \");\n    Serial.println(err);\n  }\n\n  file = fopen(BHY_DFU_FW_PATH, \"wb\");\n  int ret = fwrite(fw_bin, fw_bin_len, 1, file);\n  fwrite(&crc, 1, 1, file);\n  delay(100);\n  fclose(file);\n\n  Serial.println(\"BHY FW Upload Done!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "millis",
        "delay",
        "digitalwrite",
        "sd"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_Blynk on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n  \n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "digitalread",
        "millis",
        "delay",
        "digitalwrite",
        "sd",
        "timer",
        "interrupt"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "parameters": "",
          "body": "//isButtonPressed = !digitalRead(BUTTON_PIN); // Invert state, since button is \"Active LOW\"\n\n  if ( !isButtonPressed && !digitalRead(BUTTON_PIN)) // You can write any condition to trigger e-mail sending\n  {\n    isButtonPressed = true;\n    count++;\n    Serial.println(\"Button pressed\");\n  }"
        },
        {
          "name": "processButton",
          "parameters": "",
          "body": "// *** WARNING: You are limited to send ONLY ONE E-MAIL PER 5 SECONDS! ***\n  // Let's send an e-mail when you press the button\n  // connected to digital pin BUTTON_PIN (2) on your Arduino\n  static String body;\n\n  if (isButtonPressed) // You can write any condition to trigger e-mail sending\n  {\n    body = String(\"You pushed the button \") + count + \" times.\";\n\n    // This can be seen in the Serial Monitor\n    Serial.println(body);\n\n    Blynk.email(\"your_email@gmail.com\", \"Subject: Button Logger\", body);\n\n    isButtonPressed = false;\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_Blynk_Email on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }\n\n  // Attach pin BUTTON_PIN (2) interrupt to our handler\n  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), emailOnButtonPress, FALLING /*CHANGE*/);\n\n  timer.setInterval(30000L, processButton);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "dht11",
        "temperature",
        "humidity",
        "wifi",
        "millis",
        "delay",
        "digitalwrite",
        "sd",
        "timer"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, F(\"NAN\"));\n      Blynk.virtualWrite(V18, F(\"NAN\"));\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_WM_Config on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  dht.begin();\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }\n\n  timer.setInterval(60000L, readAndSendData);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "bme280",
        "temperature",
        "pressure",
        "humidity",
        "current",
        "uart",
        "i2c",
        "digitalwrite",
        "delay",
        "digitalread",
        "led"
      ],
      "libraries": [
        "everytime.h",
        "Wire.h",
        "forcedBMX280.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// set LED as output and turn it off\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  // initialize serial pport\n  Serial.begin(SERIAL_BAUD);\n\n  // Wait for serial port to settle\n  while (!Serial) {\n    delay(10);\n  }\n\n  // start I2C and BME sensor\n  Wire.begin();\n  while (climateSensor.begin()) {\n    Serial.println(\"Waiting for sensor...\");\n    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n    delay(1000);\n  }\n\n  // Turn LED on if everything is fine\n  digitalWrite(LED_BUILTIN, HIGH);\n  Serial.println(dashLine);\n  Serial.println(\"BMX280 ready\");\n  Serial.print(\"\\tChipID: 0x\");\n  Serial.println(climateSensor.getChipID(), HEX);\n  Serial.println(dashLine);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// get Temperature\n  every(BMX_CYCLE) {\n    climateSensor.takeForcedMeasurement();\n    Serial.println(\" \");\n\n    // // uncomment this block to print temperature - int32_t\n    // g_temperature = climateSensor.getTemperatureCelsius();\n    // Serial.print(\"Temperature: \");\n    // Serial.print(g_temperature/100);\n    // Serial.print(\".\");\n    // Serial.print(g_temperature%100);\n    // Serial.println(\" °C\");\n\n    // uncomment this block to print temperature - float\n    g_temperatureFloat = climateSensor.getTemperatureCelsiusAsFloat(true);\n    Serial.print(\"Temperature: \");\n    Serial.print(g_temperatureFloat);\n    Serial.println(\" °C\");\n\n    // // uncomment this block to print pressure - uint32_t\n    // g_pressure = climateSensor.getPressure();\n    // Serial.print(\"Pressure: \");\n    // Serial.print(g_pressure/100);\n    // Serial.print(\".\");\n    // Serial.print(g_pressure%100);\n    // Serial.println(\" hPa\");\n\n    // uncomment this block to print pressure - float\n    g_pressureFloat = climateSensor.getPressureAsFloat();\n    Serial.print(\"Pressure: \");\n    Serial.print(g_pressureFloat);\n    Serial.println(\" hPa\");\n\n    // // uncomment this block to print humidity - uint32_t\n    // g_humidity = climateSensor.getRelativeHumidity();\n    // Serial.print(\"Humidity: \");\n    // Serial.print(g_humidity/100);\n    // Serial.print(\".\");\n    // Serial.print(g_humidity%100);\n    // Serial.println(\" %rh\");\n\n    // uncomment this block to print humidity - float\n    g_humidityFloat = climateSensor.getRelativeHumidityAsFloat();\n    Serial.print(\"Humidity: \");\n    Serial.print(g_humidityFloat);\n    Serial.println(\" %rh\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "delay",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_1000MS);     // Set the standby time to 1 second (1000ms)\n  bmp280.startNormalConversion();                 // Start NORMAL continuous conversion\n  \n  xTaskCreatePinnedToCore(                        // Kick-off \"TaskOne\" pinned to core 1\n    taskOne,\n    \"TaskOne\",\n    10000,\n    NULL,\n    1,\n    NULL,\n    1);"
        },
        {
          "name": "taskOne",
          "parameters": "void* parameter",
          "body": "while(true)\n  {\n    if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n    {\n      Serial.print(temperature);                    // Display the results    \n      Serial.print(F(\"*C   \"));\n      Serial.print(pressure);    \n      Serial.print(F(\"hPa   \"));\n      Serial.print(altitude);\n      Serial.println(F(\"m\"));  \n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "i2c",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "i2c",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "i2c",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin(BMP280_I2C_ALT_ADDR);              // Default initialisation with alternative I2C address (0x76), place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "i2c",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bmp280.startForcedConversion();                 // Start BMP280 forced conversion (if we're in SLEEP_MODE)\n  if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "i2c",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "spi",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bmp280.startForcedConversion();                 // Start BMP280 forced conversion (if we're in SLEEP_MODE)\n  if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "spi",
        "display"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "temperature",
        "pressure",
        "spi",
        "display",
        "devices"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                             // Initialise the serial port\n  bmp280_1.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280_1.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280_1.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE \n  bmp280_2.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280_2.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280_2.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (bmp280_1.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(F(\"BMP280_1 \"));                                   // Display the results   \n    Serial.print(temperature);                       \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }\n  if (bmp280_2.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(F(\"BMP280_2 \"));                                   // Display the results\n    Serial.print(temperature);                          \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));  \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "bme280",
        "bmp280",
        "temperature",
        "current",
        "uart",
        "i2c",
        "digitalwrite",
        "delay",
        "digitalread",
        "led"
      ],
      "libraries": [
        "Wire.h",
        "forcedBMX280.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// set LED as output and turn it off\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  // initialize serial pport\n  Serial.begin(SERIAL_BAUD);\n\n  // Wait for serial port to settle\n  while (!Serial) {\n    delay(10);\n  }\n\n  // start I2C and BME sensor\n  Wire.begin();\n  while (climateSensor.begin()) {\n    Serial.println(\"Waiting for sensor...\");\n    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n    delay(1000);\n  }\n\n  // Turn LED on if everything is fine\n  digitalWrite(LED_BUILTIN, HIGH);\n  Serial.println(dashLine);\n  Serial.println(\"BMX280 ready\");\n  Serial.print(\"\\tChipID: 0x\");\n  Serial.println(climateSensor.getChipID(), HEX);\n  Serial.println(dashLine);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// get Temperature\n  delay(2000);\n  climateSensor.takeForcedMeasurement();\n  g_temperature = climateSensor.getTemperatureCelsius();\n  Serial.println(\" \");\n  Serial.print(\"Temperature: \");\n  Serial.print(g_temperature/100);\n  Serial.print(\".\");\n  Serial.print(g_temperature%100);\n  Serial.println(\" °C\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "i2c",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);\n\t}\n\n\tif (bmx280.isBME280())\n\t\tSerial.println(\"sensor is a BME280\");\n\telse\n\t\tSerial.println(\"sensor is a BMP280\");\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;\n\t}\n\n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "i2c",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin(D2, D3);\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);\n\t}\n\n\tif (bmx280.isBME280())\n\t\tSerial.println(\"sensor is a BME280\");\n\telse\n\t\tSerial.println(\"sensor is a BMP280\");\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;\n\t}\n\n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Pressure (<64,8>): \"); Serial.println(bmx280.getPressureI64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "i2c",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);\n\t}\n\n\tif (bmx280.isBME280())\n\t\tSerial.println(\"sensor is a BME280\");\n\telse\n\t\tSerial.println(\"sensor is a BMP280\");\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);\n\n  //set the sensor to \"normal\" mode with 4 measurement per second:\n  bmx280.writeStandbyTime(BMx280MI::T_SB_3);\n  bmx280.writePowerMode(BMx280MI::BMx280_MODE_NORMAL);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  \n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Pressure (<64,8>): \"); Serial.println(bmx280.getPressureI64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "spi",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "BMx280SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tSPI.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and chip select pin.\");\n\t\twhile (1);\n\t}\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;\n\t}\n\n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "spi",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "BMx280SPIClass.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tSPI.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and chip select pin.\");\n\t\twhile (1);\n\t}\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;\n\t}\n\n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "i2c",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncDelay.h",
        "SoftWire.h",
        "BMx280MI.h"
      ],
      "functions": [
        {
          "name": "beginInterface",
          "parameters": "",
          "body": "return true;\n\t\t}\n\n\t\t//this function must be implemented by derived classes. this function is responsible for reading data from the sensor. \n\t\t//@param reg register to read. \n\t\t//@return read data (1 byte).\n\t\tuint8_t readRegister(uint8_t reg)\n\t\t{\n\t\t\tuint8_t data;\n\n\t\t\tsw.startWait(address_, SoftWire::writeMode);\n\t\t\tsw.llWrite(reg);\n\n\t\t\tsw.repeatedStart(address_, SoftWire::readMode);\n\t\t\tsw.readThenNack(data);  // Read 1 byte and then send ack\n\t\t\tsw.stop();\n\n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t//this function can be implemented by derived classes. implementing this function is optional, but readings may be incorrect if \n\t\t//it is not (see BMP280 / BME280 datasheet). \n\t\t//@param reg register to read. \n\t\t//@param length number of registers to read (max: 4)\n\t\t//@return read data. LSB = last register read. \n\t\tuint32_t readRegisterBurst(uint8_t reg, uint8_t length)\n\t\t{\n\t\t\tif (length > 4 || length == 0)\n\t\t\t\treturn 0L;\n\n\t\t\tuint32_t data = 0L;\n\t\t\tuint8_t curr_byte = 0;\n\n\t\t\tsw.startWait(address_, SoftWire::writeMode);\n\t\t\tsw.llWrite(reg);\n\n\t\t\tsw.repeatedStart(address_, SoftWire::readMode);\n\n\t\t\tuint8_t i = 0;\n\t\t\tfor (; i < length - 1; i++){\n\t\t\t\tsw.readThenAck(curr_byte);  // Read 1 byte and then send ack\n\t\t\t\tdata = (data << 8) | curr_byte;\n\t\t\t}\n\n\t\t\tsw.readThenNack(curr_byte);  // Read 1 byte and then send ack\n\t\t\tdata = (data << 8) | curr_byte;\n\n\t\t\tsw.stop();\n\n\t\t\treturn data;\n\t\t}\n\n\t\t//this function must be implemented by derived classes. this function is responsible for sending data to the sensor. \n\t\t//@param reg register to write to.\n\t\t//@param data data to write to register.\n\t\tvoid writeRegister(uint8_t reg, uint8_t data)\n\t\t{\n\t\t\tsw.startWait(address_, SoftWire::writeMode);\n\t\t\tsw.llWrite(reg);\n\t\t\tsw.llWrite(data);\n\t\t\tsw.stop();\n\t\t}\n\t\t\n\t\tuint8_t address_;\t\t//i2c address of sensor"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\t\n\t//SoftWire setup\n\tsw.setDelay_us(5);\n\tsw.setTimeout_ms(100);\n\tsw.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);\n\t}\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;\n\t}\n\n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "i2c",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280TwoWire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);\n\t}\n\n\tif (bmx280.isBME280())\n\t\tSerial.println(\"sensor is a BME280\");\n\telse\n\t\tSerial.println(\"sensor is a BMP280\");\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;\n\t}\n\n\t//wait for the measurement to finish. \n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "bmp280",
        "bme280",
        "pressure",
        "temperature",
        "humidity",
        "i2c",
        "spi",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280MI.h"
      ],
      "functions": [
        {
          "name": "beginInterface",
          "parameters": "",
          "body": "return true;\n\t\t}\n\n\t\t//this function must be implemented by derived classes. this function is responsible for reading data from the sensor. \n\t\t//@param reg register to read. \n\t\t//@return read data (1 byte).\n\t\tuint8_t readRegister(uint8_t reg)\n\t\t{\n\t\t#if defined(ARDUINO_SAM_DUE)\n\t\t\t//workaround for Arduino Due. The Due seems not to send a repeated start with the code above, so this \n\t\t\t//undocumented feature of Wire::requestFrom() is used. can be used on other Arduinos too (tested on Mega2560)\n\t\t\t//see this thread for more info: https://forum.arduino.cc/index.php?topic=385377.0\n\t\t\tWire1.requestFrom(address_, 1, reg, 1, true);\n\t\t#else\n\t\t\tWire1.beginTransmission(address_);\n\t\t\tWire1.write(reg);\n\t\t\tWire1.endTransmission(false);\n\t\t\tWire1.requestFrom(address_, static_cast<uint8_t>(1));\n\t\t#endif\n\t\t\t\n\t\t\treturn Wire1.read();\n\t\t}\n\t\t\n\t\t//this function can be implemented by derived classes. implementing this function is optional, but readings may be incorrect if \n\t\t//it is not (see BMP280 / BME280 datasheet). \n\t\t//@param reg register to read. \n\t\t//@param length number of registers to read (max: 4)\n\t\t//@return read data. LSB = last register read. \n\t\tuint32_t readRegisterBurst(uint8_t reg, uint8_t length)\n\t\t{\n\t\t\tif (length > 4)\n\t\t\t\treturn 0L;\n\n\t\t\tuint32_t data = 0L;\n\n#if defined(ARDUINO_SAM_DUE)\n\t\t\t//workaround for Arduino Due. The Due seems not to send a repeated start with the code below, so this \n\t\t\t//undocumented feature of Wire::requestFrom() is used. can be used on other Arduinos too (tested on Mega2560)\n\t\t\t//see this thread for more info: https://forum.arduino.cc/index.php?topic=385377.0\n\t\t\tWire1.requestFrom(address_, length, data, length, true);\n#else\n\t\t\tWire1.beginTransmission(address_);\n\t\t\tWire1.write(reg);\n\t\t\tWire1.endTransmission(false);\n\t\t\tWire1.requestFrom(address_, static_cast<uint8_t>(length));\n\n\t\t\tfor (uint8_t i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tdata <<= 8;\n\t\t\t\tdata |= Wire1.read();\n\t\t\t}\n#endif\n\n\t\t\treturn data;\n\t\t}\n\n\t\t//this function must be implemented by derived classes. this function is responsible for sending data to the sensor. \n\t\t//@param reg register to write to.\n\t\t//@param data data to write to register.\n\t\tvoid writeRegister(uint8_t reg, uint8_t data)\n\t\t{\n\t\t\tWire1.beginTransmission(address_);\n\t\t\tWire1.write(reg);\n\t\t\tWire1.write(data);\n\t\t\tWire1.endTransmission();\n\t\t}\n\t\t\n\t\tuint8_t address_;\t\t//i2c address of sensor"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire1.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);\n\t}\n\n\t//reset sensor to default parameters.\n\tbmx280.resetToDefaults();\n\n\t//by default sensing is disabled and must be enabled by setting a non-zero\n\t//oversampling setting.\n\t//set an oversampling setting for pressure and temperature measurements. \n\tbmx280.writeOversamplingPressure(BMx280MI::OSRS_P_x16);\n\tbmx280.writeOversamplingTemperature(BMx280MI::OSRS_T_x16);\n\n\t//if sensor is a BME280, set an oversampling setting for humidity measurements.\n\tif (bmx280.isBME280())\n\t\tbmx280.writeOversamplingHumidity(BMx280MI::OSRS_H_x16);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;\n\t}\n\n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);\n\t} while (!bmx280.hasValue());\n\n\t//important: measurement data is read from the sensor in function hasValue() only. \n\t//make sure to call get*() functions only after hasValue() has returned true. \n\tSerial.print(\"Pressure: \"); Serial.println(bmx280.getPressure());\n\tSerial.print(\"Pressure (64 bit): \"); Serial.println(bmx280.getPressure64());\n\tSerial.print(\"Temperature: \"); Serial.println(bmx280.getTemperature());\n\n\tif (bmx280.isBME280())\n\t{\n\t\tSerial.print(\"Humidity: \"); \n\t\tSerial.println(bmx280.getHumidity());\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "sensors",
        "sensorbsec",
        "sensor_id_bsec"
      ],
      "libraries": [
        "Arduino.h",
        "Arduino_BHY2Host.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// debug port\n  Serial.begin(115200);\n  while(!Serial);\n\n  BHY2Host.begin();\n\n  bsec.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "static auto printTime = millis();\n  BHY2Host.update();\n\n  if (millis() - printTime >= 1000) {\n    printTime = millis();\n    Serial.println(bsec.toString());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "sensorbsec2",
        "sensor_id_bsec2",
        "sensortec"
      ],
      "libraries": [
        "Arduino.h",
        "Arduino_BHY2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  BHY2.begin();\n  sensortec.bhy2_bsec2_setConfigString(BSEC2CONFIG, sizeof(BSEC2CONFIG)/sizeof(BSEC2CONFIG[0]));\n  bsec2.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Update function should be continuously polled\n  BHY2.update(100);\n\n  if (bsec2.getNewDataFlag()) {\n    bsec2.setNewDataFlag(false);\n\n    Serial.println(bsec2.toString());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "temperature",
        "pressure",
        "humidity",
        "timestamp",
        "sensortec",
        "sensorbsec2collector",
        "sensor_id_bsec2_collector"
      ],
      "libraries": [
        "Arduino.h",
        "Arduino_BHY2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  BHY2.begin();\n  sensortec.bhy2_bsec2_setHP((uint8_t*)BSEC2HP_TEMP, sizeof(BSEC2HP_TEMP), (uint8_t*)BSEC2HP_DUR, sizeof(BSEC2HP_DUR)); \n  \n  bsec2Collector.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "static auto last_index = 0;\n\n  // Update function should be continuously polled\n  BHY2.update();\n\n  if (last_index != bsec2Collector.gas_index()) {\n    last_index = bsec2Collector.gas_index();\n    Serial.println(String((uint32_t)bsec2Collector.timestamp()) + \" \" \n              + String(bsec2Collector.temperature()) + \" \" \n              + String(bsec2Collector.pressure()) + \" \" \n              + String(bsec2Collector.humidity()) + \" \" \n              + String(bsec2Collector.gas()) + \" \" \n              + String(bsec2Collector.gas_index()) \n              );\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "delay",
        "pwm"
      ],
      "libraries": [
        "BTS7960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);                       //begin the serial monitor for output\n  motor1.begin();                           //This method will set the motor driver pins as output\n  motor1.enable();                          //This method will set the L_EN and R_EN to HIGH or digitalWrite them to +5v/3v depending on your mcu"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int i=0; i<=255; i=i+10)\n  {\n    motor1.pwm = i;                         //Set the speed, by default the speed is set to 255 you can change it \n    motor1.front();                         //front functions should turn the motor in clockwise direction\n    delay(500);\n  }\n  motor1.stop();                            //stop function should halt the motor by applying 0 pwm to both R_PWM and L_PWM\n  delay(500);\n  for(int i=0; i<=255; i=i+10)\n  { \n    motor1.pwm = i;                         //Set the speed\n    motor1.back();                          //back functions should turn the motor in anti-clockwise direction\n    delay(500);\n  }\n  delay(500);\n  motor1.disable();                         //This method will set the L_EN and R_EN to LOW or digitalWrite them to 0v"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay"
      ],
      "libraries": [
        "BTS7960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": ""
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "motorController.Enable();\n\n  for(int speed = 0 ; speed < 255; speed+=10)\n  {\n\tmotorController.TurnLeft(speed);\n\tdelay(100);\n  }  \n\n  motorController.Stop();\n  \n  for(int speed = 255 ; speed > 0; speed-=10)\n  {\n\tmotorController.TurnLeft(speed);\n\tdelay(100);\n  }  \n  motorController.Stop();\n\n  motorController.Disable();\n  \n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "ina219",
        "voltage",
        "current",
        "i2c",
        "digitalwrite",
        "digitalread",
        "delay",
        "millis",
        "display",
        "led",
        "interrupt",
        "devices",
        "devicenumber",
        "devicesfound"
      ],
      "libraries": [
        "INA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(GREEN_LED_PIN, OUTPUT);        // Make the internal LED an output pin\n  digitalWrite(GREEN_LED_PIN, true);     // Turn on the LED\n  pinMode(INA_ALERT_PIN, INPUT_PULLUP);  // Declare pin with internal pull-up resistor\n  *digitalPinToPCMSK(INA_ALERT_PIN) |= bit(digitalPinToPCMSKbit(INA_ALERT_PIN));  // Enable PCMSK\n  PCIFR |= bit(digitalPinToPCICRbit(INA_ALERT_PIN));  // clear any outstanding interrupt\n  PCICR |= bit(digitalPinToPCICRbit(INA_ALERT_PIN));  // enable interrupt for the group\n  Serial.begin(SERIAL_SPEED);\n#ifdef __AVR_ATmega32U4__  // If this is a 32U4 processor, wait 2 seconds for initialization\n  delay(2000);\n#endif\n  Serial.print(F(\"\\n\\nBackground INA Read V1.0.5\\n\"));\n  uint8_t devicesFound = 0;\n  while (deviceNumber == UINT8_MAX)  // Loop until we find the first device\n  {\n    devicesFound = INA.begin(1, 100000);  // +/- 1 Amps maximum for 0.1 Ohm resistor\n    for (uint8_t i = 0; i < devicesFound; i++) {\n      /* Change the \"INA226\" in the following statement to whatever device you have attached\n         and want to measure */\n      if (strcmp(INA.getDeviceName(i), \"INA226\") == 0) {\n        deviceNumber = i;\n        INA.reset(deviceNumber);  // Reset device to default settings\n        break;\n      }  // of if-then we have found an INA226\n    }    // of for-next loop through all devices found\n    if (deviceNumber == UINT8_MAX) {\n      Serial.print(F(\"No INA found. Waiting 5s and retrying...\\n\"));\n      delay(5000);\n    }  // of if-then no INA226 found\n  }    // of if-then no device found\n  Serial.print(F(\"Found INA at device number \"));\n  Serial.println(deviceNumber);\n  Serial.println();\n  INA.setAveraging(64, deviceNumber);                   // Average each reading 64 times\n  INA.setBusConversion(8244, deviceNumber);             // Maximum conversion time 8.244ms\n  INA.setShuntConversion(8244, deviceNumber);           // Maximum conversion time 8.244ms\n  INA.setMode(INA_MODE_CONTINUOUS_BOTH, deviceNumber);  // Bus/shunt measured continuously\n  INA.alertOnConversion(true, deviceNumber);            // Make alert pin go low on finish"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*!\n   @brief    Arduino method for the main program loop\n   @details  This is the main program for the Arduino IDE, it is called in an infinite loop. The\n             INA226 measurements are triggered by the interrupt handler each time a conversion is\n             ready and stored in variables. The main program doesn't call any INA library functions,\n             that is done in the interrupt handler. Each time 10 readings have been collected the\n             program will output the averaged values and measurements resume from that point onwards\n   @return   void\n  */\n  static long lastMillis = millis();  // Store the last time we printed something\n  if (readings >= 10) {\n    Serial.print(F(\"Averaging readings taken over \"));\n    Serial.print((float)(millis() - lastMillis) / 1000, 2);\n    Serial.print(F(\" seconds.\\nBus voltage:   \"));\n    Serial.print((float)sumBusMillVolts / readings / 1000.0, 4);\n    Serial.print(F(\"V\\nBus amperage:  \"));\n    Serial.print((float)sumBusMicroAmps / readings / 1000.0, 4);\n    Serial.print(F(\"mA\\n\\n\"));\n    lastMillis = millis();\n    cli();  // Disable interrupts to reset values\n    readings        = 0;\n    sumBusMillVolts = 0;\n    sumBusMicroAmps = 0;\n    sei();  // Enable interrupts again\n  }         // of if-then we've reached the required amount of readings"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "ina219",
        "voltage",
        "current",
        "i2c",
        "delay",
        "millis",
        "display",
        "interrupt",
        "devices",
        "devicenumber",
        "devicesfound"
      ],
      "libraries": [
        "INA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/*!\n   @brief    Arduino method called once at startup to initialize the system\n   @details  This is an Arduino IDE method which is called first upon boot or restart. It is only\n             called one time and then control goes to the main \"loop()\" method, from which control\n             never returns\n   @return   void\n  */\n  pinMode(INA_ALERT_PIN, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(INA_ALERT_PIN), InterruptHandler, FALLING);\n  Serial.begin(SERIAL_SPEED);\n  Serial.print(F(\"\\n\\nBackground INA Read V1.0.1\\n\"));\n  uint8_t devicesFound = 0;\n  while (deviceNumber == UINT8_MAX)  // Loop until we find the first device\n  {\n    devicesFound = INA.begin(1, 100000);  // +/- 1 Amps maximum for 0.1 Ohm resistor\n    Serial.println(INA.getDeviceName(devicesFound - 1));\n    for (uint8_t i = 0; i < devicesFound; i++) {\n      /* Change the \"INA226\" in the following statement to whatever device you have attached and\n         want to measure */\n      if (strcmp(INA.getDeviceName(i), \"INA219\") == 0) {\n        deviceNumber = i;\n        INA.reset(deviceNumber);  // Reset device to default settings\n        break;\n      }  // of if-then we have found an INA226\n    }    // of for-next loop through all devices found\n    if (deviceNumber == UINT8_MAX) {\n      Serial.print(F(\"No INA found. Waiting 5s and retrying...\\n\"));\n      delay(5000);\n    }  // of if-then no INA226 found\n  }    // of if-then no device found\n  Serial.print(F(\"Found INA at device number \"));\n  Serial.println(deviceNumber);\n  Serial.println();\n  INA.setAveraging(64, deviceNumber);                   // Average each reading 64 times\n  INA.setBusConversion(8244, deviceNumber);             // Maximum conversion time 8.244ms\n  INA.setShuntConversion(8244, deviceNumber);           // Maximum conversion time 8.244ms\n  INA.setMode(INA_MODE_CONTINUOUS_BOTH, deviceNumber);  // Bus/shunt measured continuously\n  INA.alertOnConversion(true, deviceNumber);            // Make alert pin go low on finish"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*!\n   @brief    Arduino method for the main program loop\n   @details  This is the main program for the Arduino IDE, it is called in an infinite loop. The\n             INA226 measurements are triggered by the interrupt handler each time a conversion is\n             ready and stored in variables. The main program doesn't call any INA library functions,\n             that is done in the interrupt handler. Each time 10 readings have been collected the\n             program will output the averaged values and measurements resume from that point onwards\n   @return   void\n  */\n  static long lastMillis = millis();  // Store the last time we printed something\n  if (readings >= 10) {\n    Serial.print(F(\"Averaging readings taken over \"));\n    Serial.print((float)(millis() - lastMillis) / 1000, 2);\n    Serial.print(F(\" seconds.\\nBus voltage:   \"));\n    Serial.print((float)sumBusMillVolts / readings / 1000.0, 4);\n    Serial.print(F(\"V\\nBus amperage:  \"));\n    Serial.print((float)sumBusMicroAmps / readings / 1000.0, 4);\n    Serial.print(F(\"mA\\n\\n\"));\n    lastMillis = millis();\n    cli();  // Disable interrupts to reset values\n    readings        = 0;\n    sumBusMillVolts = 0;\n    sumBusMicroAmps = 0;\n    sei();  // Enable interrupts again\n  }         // of if-then we've reached the required amount of readings"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "yield",
        "sd",
        "flash"
      ],
      "libraries": [
        "SD.h",
        "SdFat.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial) {}\n\n#if USE_SD_H\n  Serial.println(F(\"Using SD.h. Set USE_SD_H zero to use SdFat.h.\"));\n#else  // USE_SD_H\n  Serial.println(F(\"Using SdFat.h. Set USE_SD_H nonzero to use SD.h.\"));\n#endif  // USE_SD_H\n  Serial.println(F(\"\\nType any character to begin.\"));\n  while (!Serial.available()) {\n    yield();\n  }\n  Serial.print(\"Initializing SD card...\");\n\n  if (!SD.begin(SD_CS_PIN)) {\n    Serial.println(\"initialization failed!\");\n    return;\n  }\n  Serial.println(\"initialization done.\");\n\n  // open the file.\n  myFile = SD.open(\"test.txt\", FILE_WRITE);\n\n  // if the file opened okay, write to it:\n  if (myFile) {\n    Serial.print(\"Writing to test.txt...\");\n    myFile.println(\"testing 1, 2, 3.\");\n    // close the file:\n    myFile.close();\n    Serial.println(\"done.\");\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening test.txt\");\n  }\n\n  // re-open the file for reading:\n  myFile = SD.open(\"test.txt\");\n  if (myFile) {\n    Serial.println(\"test.txt:\");\n\n    // read from the file until there's nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening test.txt\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// nothing happens after setup"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "lcd"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "create_maze",
          "parameters": "void",
          "body": "sp.clear(0);\n  sp.setColor(1);\n  sp.fillRect(0,                0, sp.width(), 16);\n  sp.fillRect(0, sp.height() - 16, sp.width(), 16);\n  sp.fillRect(            0, 0, 16, sp.height()-16);\n  sp.fillRect(sp.width()-16, 0, 16, sp.height()-16);\n  sp.setColor(3);\n  for (int y = 1; y < sp.height(); y += 2)\n  {\n    for (int x = 1; x < sp.width(); x += 2)\n    {\n      sp.writePixel(x, y);\n      int xx = x;\n      int yy = y;\n      do\n      {\n        xx = x;\n        yy = y;\n        switch (random(4)) {\n        case 0: xx = x + 1; break;\n        case 1: xx = x - 1; break;\n        case 2: yy = y + 1; break;\n        case 3: yy = y - 1; break;\n        }\n      } while (3 == sp.readPixelValue(xx, yy));\n      sp.writePixel(xx, yy);\n    }\n  }"
        },
        {
          "name": "draw",
          "parameters": "void",
          "body": "draw_count += draw_cycle;\n  std::uint_fast8_t blink = 127+abs(((int)(draw_count<<1) & 255)-128);\n  sp.setPaletteColor(1, 127, 127, blink);\n  sp.setPaletteColor(2, 127, blink, 127);\n\n  float fx = (cx - ox);\n  float fy = (cy - oy);\n  float len = sqrtf(fx * fx + fy * fy) * zoom;\n  float theta = atan2f(fx, fy) + rad;\n  sp.pushRotateZoom(px - sinf(theta) * len, py - cosf(theta) * len, angle, zoom, zoom);"
        },
        {
          "name": "game_init",
          "parameters": "void",
          "body": "px = lcd.width()>>1;\n  py = lcd.height()/3;\n\n  create_maze();\n  ox = sp.getPivotX();\n  oy = sp.getPivotY();\n\n  cx = (sp.width() >>1);\n  cy = (sp.height()>>1);\n  cr = 0.2;\n  zoom = zoom_min;"
        },
        {
          "name": "game_main",
          "parameters": "void",
          "body": "std::int32_t tx, ty, tc;\n  tc = lcd.getTouch(&tx, &ty);\n  if ((BUTTON_A_PIN >=0 && BUTTON_B_PIN >=0 && (lgfx::gpio_in(BUTTON_A_PIN) == 0 && lgfx::gpio_in(BUTTON_B_PIN) == 0)) || tc > 1)\n  {\n    zoom *= 1.0 - zoom_speed;\n    if (zoom < zoom_min) { zoom = zoom_min; }\n  }\n  else\n  {\n    zoom *= 1.0 + zoom_speed;\n    if (zoom > zoom_max) { zoom = zoom_max; }\n\n    add_angle -= add_angle / 10;\n\n    if (tc)\n    {\n      add_angle += (tx > lcd.width()>>1) ? 0.6 : -0.6;\n    }\n    else if (BUTTON_A_PIN >= 0 && BUTTON_B_PIN >= 0)\n    {\n      if (BUTTON_A_PIN >=0 && lgfx::gpio_in(BUTTON_A_PIN) == 0) add_angle += 0.6;\n      if (BUTTON_B_PIN >=0 && lgfx::gpio_in(BUTTON_B_PIN) == 0) add_angle -= 0.6;\n    }\n    else\n    {\n      static bool pressed;\n      static bool flow;\n      if (BUTTON_A_PIN >=0 && lgfx::gpio_in(BUTTON_A_PIN) == 0)\n      {\n        if (!pressed)\n        {\n          pressed = true;\n          flow = !flow;\n        }\n        add_angle += flow ? 0.6 : -0.6;\n      }\n      else\n      {\n        pressed = false;\n      }\n    }\n  }\n\n  angle += add_angle;\n  add_angle = add_angle * 9 / 10;\n  rad = angle * - deg_to_rad;\n\n  ax += sinf(rad) * gravity;\n  ay -= cosf(rad) * gravity;\n  ax = ax * 9.7 / 10;\n  ay = ay * 9.7 / 10;\n\n  float addy = (ay<0.0) ? -cr:cr;\n  auto tmpy = roundf(cy+ay+addy);\n\n  if ( 3 == sp.readPixelValue(roundf(cx), tmpy))\n  {\n    cy = tmpy - addy + (ay < 0.0 ? 0.5 : -0.5);\n    ay = -ay * 9.0 / 10;\n  }\n  else\n  {\n    cy += ay;\n  }\n\n  float addx = (ax<0.0) ? -cr:cr;\n  auto tmpx = roundf(cx+ax+addx);\n  if ( 3 == sp.readPixelValue(tmpx, roundf(cy)))\n  {\n    cx = tmpx - addx + (ax < 0.0 ? 0.5 : -0.5);\n    ax = -ax * 9.0 / 10;\n  }\n  else\n  {\n    cx += ax;\n  }\n\n  std::uint32_t pv = sp.readPixelValue(roundf(cx), roundf(cy));\n  if ( 0 == pv)\n  {\n    sp.drawPixel(roundf(cx), roundf(cy), 2);\n  }\n  else if (1 == pv) return true;\n\n  if (++skip_count == draw_cycle)\n  {\n    skip_count = 0;\n    draw();\n  }\n  return false;"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "lgfx::lgfxPinMode(BUTTON_A_PIN, lgfx::pin_mode_t::input);\n  lgfx::lgfxPinMode(BUTTON_B_PIN, lgfx::pin_mode_t::input);\n\n  lcd.init();\n  lcd.startWrite();\n  lcd.setColorDepth(16);\n  sp.setColorDepth(2);\n  sp.createSprite(257, 257);\n  game_init();"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "if (!game_main())\n  {\n    lcd.fillCircle(px, py, roundf(cr*zoom), 0xFFFF00U);\n  }\n  else\n  {\n    std::int32_t py0 = lcd.height() >> 1;\n    float cx0 = (cx + (sp.width() >>1)) / 2;\n    float cy0 = (cy + (sp.height()>>1)) / 2;\n    for (;;)\n    {\n      draw();\n      if (py < py0) ++py;\n      if (cx != cx0) cx += (cx0 - cx) / 256;\n      if (cy != cy0) cy += (cy0 - cy) / 256;\n\n      angle += .5;\n      rad = angle * - deg_to_rad;\n      zoom *= 1 - zoom_speed;\n      if (zoom < zoom_min)\n      {\n        std::int32_t tx, ty;\n        zoom = zoom_min;\n        if ((BUTTON_A_PIN >=0 && lgfx::gpio_in(BUTTON_A_PIN) == 0)\n         || (BUTTON_B_PIN >=0 && lgfx::gpio_in(BUTTON_B_PIN) == 0)\n         || lcd.getTouch(&tx, &ty)\n         ) break;\n      }\n    }\n    game_init();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "buffer",
        "current",
        "gsm",
        "html"
      ],
      "libraries": [
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for Leonardo only\n  }\n\n  // Beginning the band manager restarts the modem\n  Serial.println(\"Restarting modem...\");\n  band.begin();\n  Serial.println(\"Modem restarted.\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Get current band\n  String bandName = band.getBand(); // Get and print band name\n  Serial.print(\"Current band:\");\n  Serial.println(bandName);\n  Serial.println(\"Want to change the band you’re on?\");\n  String newBandName;\n  newBandName = askUser();\n  // Tell the user what we are about to do…\n  Serial.print(\"\\nConfiguring band \");\n  Serial.println(newBandName);\n  // Change the band\n  bool operationSuccess;\n  operationSuccess = band.setBand(newBandName);\n  // Tell the user if the operation was OK\n  if (operationSuccess) {\n    Serial.println(\"Success\");\n  } else {\n    Serial.println(\"Error while changing band\");\n  }\n\n  if (operationSuccess) {\n    while (true);\n  }"
        },
        {
          "name": "askUser",
          "parameters": "",
          "body": "String newBand;\n  Serial.println(\"Select band:\");\n  // Print the different options\n  Serial.println(\"1 : E-GSM(900)\");\n  Serial.println(\"2 : DCS(1800)\");\n  Serial.println(\"3 : PCS(1900)\");\n  Serial.println(\"4 : E-GSM(900)+DCS(1800) ex: Europe\");\n  Serial.println(\"5 : GSM(850)+PCS(1900) Ex: USA, South Am.\");\n  Serial.println(\"6 : GSM800(800)+GSM(850)+E-GSM(900)+PCS(1900)\");\n  Serial.println(\"7 : UMTS(2100)\");\n  Serial.println(\"8 : GSM(850)+E-GSM(900)+PCS(1900)+UMTS(2100)\");\n\n  // Empty the incoming buffer\n  while (Serial.available()) {\n    Serial.read();\n  }\n\n  // Wait for an answer, just look at the first character\n  while (!Serial.available());\n  char c = Serial.read();\n  if (c == '1') {\n    newBand = GSM_MODE_EGSM;\n  } else if (c == '2') {\n    newBand = GSM_MODE_DCS;\n  } else if (c == '3') {\n    newBand = GSM_MODE_PCS;\n  } else if (c == '4') {\n    newBand = GSM_MODE_EGSM_DCS;\n  } else if (c == '5') {\n    newBand = GSM_MODE_GSM850_PCS;\n  } else if (c == '6') {\n    newBand = GSM_MODE_GSM850_EGSM_DCS_PCS;\n  } else if (c == '7') {\n    newBand = GSM_MODE_UMTS;\n  } else if (c == '8') {\n    newBand = GSM_MODE_GSM850_EGSM_PCS_UMTS;\n  } else {\n    newBand = \"GSM_MODE_UNDEFINED\";\n  }\n\n  return newBand;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogread",
        "digitalread",
        "millis",
        "digitalwrite",
        "delay",
        "lcd",
        "debounce"
      ],
      "libraries": [
        "Wire.h",
        "LiquidCrystal_I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  lcd.begin(16, 2);\n  pinMode(btnIncrease, INPUT_PULLUP);\n  pinMode(btnDecrease, INPUT_PULLUP);\n  pinMode(kipas, OUTPUT);\n  pinMode(heater, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int s = analogRead(A1);\n  float v = (s * 5.0) / 1023.0;\n  float suhu = v * 100.0;\n\n  // Debounce for btnIncrease\n  if (digitalRead(btnIncrease) == LOW && (millis() - lastDebounceTime1) > debounceDelay) {\n    while (digitalRead(btnIncrease) == LOW);\n    sp++;\n    lastDebounceTime1 = millis();\n  }\n\n  // Debounce for btnDecrease\n  if (digitalRead(btnDecrease) == LOW && (millis() - lastDebounceTime2) > debounceDelay) {\n    while (digitalRead(btnDecrease) == LOW);\n    sp--;\n    lastDebounceTime2 = millis();\n  }\n\n  if (suhu >= sp + 2 && state == 0) {\n    digitalWrite(kipas, HIGH);\n    digitalWrite(heater, LOW);\n    state = 1;\n  } else if (suhu < sp - 2 && state == 1) {\n    digitalWrite(kipas, LOW);\n    digitalWrite(heater, HIGH);\n    state = 0;\n  }\n\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"Set Point : \");\n  lcd.print(sp);\n  lcd.setCursor(0, 1);\n  lcd.print(\"Act Suhu : \");\n  lcd.print(suhu);\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "pressure",
        "temperature",
        "ble",
        "delay"
      ],
      "libraries": [
        "Arduino_LPS22HB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!BARO.begin()) {\n    Serial.println(\"Failed to initialize pressure sensor!\");\n    while (1);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the sensor value\n  float pressure = BARO.readPressure();\n\n  // print the sensor value\n  Serial.print(\"Pressure = \");\n  Serial.print(pressure);\n  Serial.println(\" kPa\");\n\n  float temperature = BARO.readTemperature();\n\n  // print the sensor value\n  Serial.print(\"Temperature = \");\n  Serial.print(temperature);\n  Serial.println(\" C\");\n\n  // print an empty line\n  Serial.println();\n\n  // wait 1 second to print again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "publish",
        "temperature",
        "pressure",
        "current",
        "delay",
        "display"
      ],
      "libraries": [
        "BMP085.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    while (!Serial);\n    myBarometer.init();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "temperature = myBarometer.bmp085GetTemperature(\n                      myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n    pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n\n    /*\n        To specify a more accurate altitude, enter the correct mean sea level\n        pressure level.  For example, if the current pressure level is 1019.00 hPa\n        enter 101900 since we include two decimal places in the integer value。\n    */\n    altitude = myBarometer.calcAltitude(101900);\n\n    atm = pressure / 101325;\n\n    Serial.print(\"Temperature: \");\n    Serial.print(temperature, 2); //display 2 decimal places\n    Serial.println(\" Celsius\");\n\n    Serial.print(\"Pressure: \");\n    Serial.print(pressure, 0); //whole number only.\n    Serial.println(\" Pa\");\n\n    Serial.print(\"Ralated Atmosphere: \");\n    Serial.println(atm, 4); //display 4 decimal places\n\n    Serial.print(\"Altitude: \");\n    Serial.print(altitude, 2); //display 2 decimal places\n    Serial.println(\" m\");\n\n    Serial.println();\n\n    delay(1000); //wait a second and get values again."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "pressure",
        "temperature",
        "current",
        "spi",
        "delay",
        "millis",
        "digitalread",
        "digitalwrite",
        "display",
        "timestamp",
        "html",
        "sensors",
        "clients"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// start the SPI library:\n  SPI.begin();\n\n  // start the Ethernet connection and the server:\n  Ethernet.begin(ip);\n  server.begin();\n\n  // initialize the  data ready and chip select pins:\n  pinMode(dataReadyPin, INPUT);\n  pinMode(chipSelectPin, OUTPUT);\n\n  Serial.begin(9600);\n\n  //Configure SCP1000 for low noise configuration:\n  writeRegister(0x02, 0x2D);\n  writeRegister(0x01, 0x03);\n  writeRegister(0x03, 0x02);\n\n  // give the sensor and Ethernet shield time to set up:\n  delay(1000);\n\n  //Set the sensor to high resolution mode tp start readings:\n  writeRegister(0x03, 0x0A);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check for a reading no more than once a second.\n  if (millis() - lastReadingTime > 1000) {\n    // if there's a reading ready, read it:\n    // don't do anything until the data ready pin is high:\n    if (digitalRead(dataReadyPin) == HIGH) {\n      getData();\n      // timestamp the last time you got a reading:\n      lastReadingTime = millis();\n    }\n  }\n\n  // listen for incoming Ethernet connections:\n  listenForEthernetClients();"
        },
        {
          "name": "getData",
          "parameters": "",
          "body": "Serial.println(\"Getting reading\");\n  //Read the temperature data\n  int tempData = readRegister(0x21, 2);\n\n  // convert the temperature to celsius and display it:\n  temperature = (float)tempData / 20.0;\n\n  //Read the pressure data highest 3 bits:\n  byte  pressureDataHigh = readRegister(0x1F, 1);\n  pressureDataHigh &= 0b00000111; //you only needs bits 2 to 0\n\n  //Read the pressure data lower 16 bits:\n  unsigned int pressureDataLow = readRegister(0x20, 2);\n  //combine the two parts into one 19-bit number:\n  pressure = ((pressureDataHigh << 16) | pressureDataLow) / 4;\n\n  Serial.print(\"Temperature: \");\n  Serial.print(temperature);\n  Serial.println(\" degrees C\");\n  Serial.print(\"Pressure: \" + String(pressure));\n  Serial.println(\" Pa\");"
        },
        {
          "name": "listenForEthernetClients",
          "parameters": "",
          "body": "// listen for incoming clients\n  EthernetClient client = server.available();\n  if (client) {\n    Serial.println(\"Got a client\");\n    // an http request ends with a blank line\n    bool currentLineIsBlank = true;\n    while (client.connected()) {\n      if (client.available()) {\n        char c = client.read();\n        // if you've gotten to the end of the line (received a newline\n        // character) and the line is blank, the http request has ended,\n        // so you can send a reply\n        if (c == '\\n' && currentLineIsBlank) {\n          // send a standard http response header\n          client.println(\"HTTP/1.1 200 OK\");\n          client.println(\"Content-Type: text/html\");\n          client.println();\n          // print the current readings, in HTML format:\n          client.print(\"Temperature: \");\n          client.print(temperature);\n          client.print(\" degrees C\");\n          client.println(\"<br />\");\n          client.print(\"Pressure: \" + String(pressure));\n          client.print(\" Pa\");\n          client.println(\"<br />\");\n          break;\n        }\n        if (c == '\\n') {\n          // you're starting a new line\n          currentLineIsBlank = true;\n        } else if (c != '\\r') {\n          // you've gotten a character on the current line\n          currentLineIsBlank = false;\n        }\n      }\n    }\n    // give the web browser time to receive the data\n    delay(1);\n    // close the connection:\n    client.stop();\n  }"
        },
        {
          "name": "writeRegister",
          "parameters": "byte registerName, byte registerValue",
          "body": "// SCP1000 expects the register name in the upper 6 bits\n  // of the byte:\n  registerName <<= 2;\n  // command (read or write) goes in the lower two bits:\n  registerName |= 0b00000010; //Write command\n\n  // take the chip select low to select the device:\n  digitalWrite(chipSelectPin, LOW);\n\n  SPI.transfer(registerName); //Send register location\n  SPI.transfer(registerValue); //Send value to record into register\n\n  // take the chip select high to de-select:\n  digitalWrite(chipSelectPin, HIGH);"
        },
        {
          "name": "readRegister",
          "parameters": "byte registerName, int numBytes",
          "body": "byte inByte = 0;           // incoming from  the SPI read\n  unsigned int result = 0;   // result to return\n\n  // SCP1000 expects the register name in the upper 6 bits\n  // of the byte:\n  registerName <<=  2;\n  // command (read or write) goes in the lower two bits:\n  registerName &= 0b11111100; //Read command\n\n  // take the chip select low to select the device:\n  digitalWrite(chipSelectPin, LOW);\n  // send the device the register you want to read:\n  int command = SPI.transfer(registerName);\n  // send a value of 0 to read the first byte returned:\n  inByte = SPI.transfer(0x00);\n\n  result = inByte;\n  // if there's more than one byte returned,\n  // shift the first byte then get the second byte:\n  if (numBytes > 1) {\n    result = inByte << 8;\n    inByte = SPI.transfer(0x00);\n    result = result | inByte;\n  }\n  // take the chip select high to de-select:\n  digitalWrite(chipSelectPin, HIGH);\n  // return the result:\n  return (result);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "yield",
        "sd"
      ],
      "libraries": [
        "SPI.h",
        "SdFat.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();\n  }\n  Serial.println(\"type any character to start\");\n  while (!Serial.available()) {\n    yield();\n  }\n  if (!sd.begin(chipSelect, SD_SCK_MHZ(50))) {\n    Serial.println(\"begin failed\");\n    return;\n  }\n  for (uint8_t i = 0; i < 9; i++) {\n    sd.remove(name[i]);\n    if (!file.open(name[i], O_RDWR | O_CREAT | O_EXCL)) {\n      sd.errorHalt(name[i]);\n    }\n    file.println(name[i]);\n\n    file.close();\n  }\n  sd.ls(LS_DATE|LS_SIZE);\n  Serial.println(\"Done\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "https",
        "database",
        "json",
        "wifi",
        "delay",
        "timestamp"
      ],
      "libraries": [
        "Firebase_Arduino_WiFiNINA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(100);\n  Serial.println();\n\n  Serial.print(\"Connecting to Wi-Fi\");\n  int status = WL_IDLE_STATUS;\n  while (status != WL_CONNECTED)\n  {\n    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\".\");\n    delay(100);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  //Provide the autntication data\n  Firebase.begin(DATABASE_URL, DATABASE_SECRET, WIFI_SSID, WIFI_PASSWORD);\n  Firebase.reconnectWiFi(true);\n\n  String path = \"/test\";\n  String jsonStr;\n\n  Serial.print(\"Set int... \");\n\n  unsigned long long val = 1634631042000;\n\n  if (Firebase.setInt(fbdo, path + \"/int/data\", val)) //support large number\n  {\n    Serial.println(\"ok\");\n    Serial.println(\"path: \" + fbdo.dataPath());\n    Serial.println(\"type: \" + fbdo.dataType());\n    Serial.print(\"value: \");\n    if (fbdo.dataType() == \"int\")\n      Serial.println(fbdo.intData());\n    if (fbdo.dataType() == \"int64\")\n      Serial.println(fbdo.int64Data());\n    if (fbdo.dataType() == \"uint64\")\n      Serial.println(fbdo.uint64Data());\n    else if (fbdo.dataType() == \"double\")\n      Serial.println(fbdo.doubleData());\n    else if (fbdo.dataType() == \"float\")\n      Serial.println(fbdo.floatData());\n    else if (fbdo.dataType() == \"boolean\")\n      Serial.println(fbdo.boolData() == 1 ? \"true\" : \"false\");\n    else if (fbdo.dataType() == \"string\")\n      Serial.println(fbdo.stringData());\n    else if (fbdo.dataType() == \"json\")\n      Serial.println(fbdo.jsonData());\n    else if (fbdo.dataType() == \"array\")\n      Serial.println(fbdo.arrayData());\n  }\n  else\n  {\n    Serial.println(\"error, \" + fbdo.errorReason());\n  }\n\n  Serial.println();\n\n  Serial.print(\"Get int... \");\n\n  if (Firebase.getInt(fbdo, path + \"/int/data\")) // also can use Firebase.get(fbdo, path)\n  {\n    Serial.println(\"ok\");\n    Serial.println(\"path: \" + fbdo.dataPath());\n    Serial.println(\"type: \" + fbdo.dataType());\n    Serial.print(\"value: \");\n    if (fbdo.dataType() == \"int\")\n      Serial.println(fbdo.intData());\n    if (fbdo.dataType() == \"int64\")\n      Serial.println(fbdo.int64Data());\n    if (fbdo.dataType() == \"uint64\")\n      Serial.println(fbdo.uint64Data());\n    else if (fbdo.dataType() == \"double\")\n      Serial.println(fbdo.doubleData());\n    else if (fbdo.dataType() == \"float\")\n      Serial.println(fbdo.floatData());\n    else if (fbdo.dataType() == \"boolean\")\n      Serial.println(fbdo.boolData() == 1 ? \"true\" : \"false\");\n    else if (fbdo.dataType() == \"string\")\n      Serial.println(fbdo.stringData());\n    else if (fbdo.dataType() == \"json\")\n      Serial.println(fbdo.jsonData());\n    else if (fbdo.dataType() == \"array\")\n      Serial.println(fbdo.arrayData());\n  }\n  else\n  {\n    Serial.println(\"error, \" + fbdo.errorReason());\n  }\n\n  Serial.println();\n\n  Serial.print(\"Push double... \");\n\n  if (Firebase.pushDouble(fbdo, path + \"/push/double\", 1234.56789))\n  {\n    Serial.println(\"ok\");\n    Serial.println(\"path: \" + fbdo.dataPath());\n    Serial.print(\"push name: \");\n    Serial.println(fbdo.pushName());\n  }\n  else\n  {\n    Serial.println(\"error, \" + fbdo.errorReason());\n  }\n\n  Serial.println();\n\n  Serial.print(\"Push json... \");\n\n  jsonStr = \"{\\\"title\\\":{\\\"index\\\":0,\\\"text\\\":{\\\"us\\\":\\\"abc\\\"},\\\"ts\\\":{\\\".sv\\\":\\\"timestamp\\\"}}}\";\n\n  if (Firebase.pushJSON(fbdo, path + \"/push/json\", jsonStr))\n  {\n    Serial.println(\"ok\");\n    Serial.println(\"path: \" + fbdo.dataPath());\n    Serial.print(\"push name: \");\n    Serial.println(fbdo.pushName());\n  }\n  else\n  {\n    Serial.println(\"error, \" + fbdo.errorReason());\n  }\n\n  Serial.println();\n\n  Serial.print(\"Update node... \");\n\n  jsonStr = \"{\\\"jp\\\":\\\"def\\\",\\\"sg\\\":\\\"ghi\\\"}\";\n\n  if (Firebase.updateNode(fbdo, path + \"/push/json/\" + fbdo.pushName() + \"/title/text\", jsonStr))\n  {\n    Serial.println(\"ok\");\n    Serial.println(\"path: \" + fbdo.dataPath());\n    Serial.println(\"type: \" + fbdo.dataType());\n    Serial.print(\"value: \");\n    if (fbdo.dataType() == \"int\")\n      Serial.println(fbdo.intData());\n    if (fbdo.dataType() == \"int64\")\n      Serial.println(fbdo.int64Data());\n    if (fbdo.dataType() == \"uint64\")\n      Serial.println(fbdo.uint64Data());\n    else if (fbdo.dataType() == \"double\")\n      Serial.println(fbdo.doubleData());\n    else if (fbdo.dataType() == \"float\")\n      Serial.println(fbdo.floatData());\n    else if (fbdo.dataType() == \"boolean\")\n      Serial.println(fbdo.boolData() == 1 ? \"true\" : \"false\");\n    else if (fbdo.dataType() == \"string\")\n      Serial.println(fbdo.stringData());\n    else if (fbdo.dataType() == \"json\")\n      Serial.println(fbdo.jsonData());\n    else if (fbdo.dataType() == \"array\")\n      Serial.println(fbdo.arrayData());\n    \n  }\n  else\n  {\n    Serial.println(\"error, \" + fbdo.errorReason());\n  }\n  Serial.println();\n\n  // clear internal memory used\n  fbdo.clear();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "pubsubclient",
        "asyncwebserver",
        "wificlient",
        "password",
        "md5",
        "auth",
        "json",
        "publish",
        "callback",
        "power",
        "wifi",
        "dns",
        "delay",
        "esp.restart",
        "digitalread",
        "digitalwrite",
        "millis",
        "analogwrite",
        "led",
        "eeprom",
        "spiffs",
        "html",
        "nodemcu",
        "devices",
        "sensors",
        "sensorstatus",
        "sensorname",
        "clientid"
      ],
      "libraries": [
        "EEPROM.h",
        "AsyncTCP.h",
        "ESPAsyncWebServer.h",
        "WiFi.h",
        "PubSubClient.h",
        "ArduinoOTA.h",
        "dynaHTML.h"
      ],
      "functions": [
        {
          "name": "dynaCallback",
          "parameters": "",
          "body": "Serial.println(\"YOUR CALLBACK WORKED!!!!!!!!!!\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyconfigData.wifi_pw);\n    Serial.println(MyconfigData.mqtt_server);\n    Serial.println(MyconfigData.sensorname);\n    Serial.println(MyconfigData.sensorstatus);\n    Serial.println(MyconfigData.mqtt_id);\n    Serial.println(MyconfigData.mqtt_key);\n    Serial.println(MyconfigData.usb_power);\n    saveconfigtoEE(MyconfigData);\n    // if we are updating data, force a refresh of the SSID\n    MyAPdata.crc32 = 8675309; // If your CRC based on your bssid and channel happen to be Jennys number, CALL HER!\n    saveAPEE(MyAPdata);\n    delay(1000);\n    ESP.restart();"
        },
        {
          "name": "OTAinit",
          "parameters": "",
          "body": "// Port defaults to 3232\n    // ArduinoOTA.setPort(3232);\n\n    // Hostname defaults to esp3232-[MAC]\n    ArduinoOTA.setHostname(MyconfigData.sensorname);\n\n    // No authentication by default\n    ArduinoOTA.setPassword(OTA_PASSDW);\n\n    // Password can be set with it's md5 value as well\n    // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3\n    // ArduinoOTA.setPasswordHash(\"21232f297a57a5a743894a0e4a801fc3\");\n\n    ArduinoOTA\n        .onStart([]()\n                 {\n      String type;\n      if (ArduinoOTA.getCommand() == U_FLASH)\n        type = \"sketch\";\n      else // U_SPIFFS\n        type = \"filesystem\";\n\n      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()\n      Serial.println(\"Start updating \" + type); })\n        .onEnd([]()\n               { Serial.println(\"\\nEnd\"); })\n        .onProgress([](unsigned int progress, unsigned int total)\n                    { Serial.printf(\"Progress: %u%%\\r\", (progress / (total / 100))); })\n        .onError([](ota_error_t error)\n                 {\n      Serial.printf(\"Error[%u]: \", error);\n      if (error == OTA_AUTH_ERROR) Serial.println(\"Auth Failed\");\n      else if (error == OTA_BEGIN_ERROR) Serial.println(\"Begin Failed\");\n      else if (error == OTA_CONNECT_ERROR) Serial.println(\"Connect Failed\");\n      else if (error == OTA_RECEIVE_ERROR) Serial.println(\"Receive Failed\");\n      else if (error == OTA_END_ERROR) Serial.println(\"End Failed\"); });\n\n    ArduinoOTA.begin();\n\n    Serial.println(\"Ready\");\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());"
        },
        {
          "name": "saveconfigtoEE",
          "parameters": "configData MyconfigData",
          "body": "EEPROM.put(eepromstart, MyconfigData);\n    JumpStart();\n    boolean ok2 = EEPROM.commit();\n    Serial.println(ok2);"
        },
        {
          "name": "saveAPEE",
          "parameters": "apData MyAPData",
          "body": "EEPROM.put(eepromapstart, MyAPData);\n    boolean ok2 = EEPROM.commit();"
        },
        {
          "name": "chkColdStart",
          "parameters": "",
          "body": "EEPROM.get(eepromcoldstart, ColdStart);\n    if (ColdStart.One == 0x45 && ColdStart.Two == 0x72)\n    {\n        hasConfig = true;\n    }"
        },
        {
          "name": "JumpStart",
          "parameters": "",
          "body": "ColdStart.One = 0x45;\n    ColdStart.Two = 0x72;\n    EEPROM.put(eepromcoldstart, ColdStart);"
        },
        {
          "name": "setup_wifi",
          "parameters": "",
          "body": "// We start by connecting to a WiFi network\n    WiFi.persistent(true);\n    WiFi.mode(WIFI_STA);\n\n    // delay(200);\n    // WiFi.config(staticIP, subnet, gateway, dns);\n    // WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    if (apValid)\n    {\n        Serial.println(\"Using BSSID data\");\n        // The BSSID data was good, make a quick connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw, MyAPdata.channel, MyAPdata.bssid, true);\n    }\n    else\n    {\n        Serial.println(\"Not using BSSID data\");\n        // The BSSID data was not valid, so make a regular connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    }\n    int retries = 0;\n    int wifiStatus = WiFi.status();\n\n    while (wifiStatus != WL_CONNECTED)\n    {\n        retries++;\n        if (retries == 100)\n        {\n            // Quick connect is not working, reset WiFi and try regular connection\n            WiFi.disconnect();\n            delay(10);\n            WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n        }\n        // Give it 20 Seconds of retrying, otherwise reset the BSSID and try again.\n        if (retries == 400)\n        {\n            WiFi.disconnect(true);\n            delay(1);\n            WiFi.mode(WIFI_OFF);\n            // invalidate the CRC, force a refresh of the WIFI AP without a BSSID/CHANNEL\n            MyAPdata.crc32 = 8675309;\n            saveAPEE(MyAPdata);\n            delay(10);\n            ESP.restart();\n            return;\n        }\n        delay(50);\n        if (retries % 10 == 1)\n            Serial.print(\".-.\");\n        wifiStatus = WiFi.status();\n    }\n\n    MyAPdata.channel = WiFi.channel();\n    memcpy(MyAPdata.bssid, WiFi.BSSID(), 6); // Copy 6 bytes of BSSID (AP's MAC address)\n\n    MyAPdata.crc32 = calculateCRC32(((uint8_t *)&MyAPdata) + 4, sizeof(MyAPdata) - 4);\n    saveAPEE(MyAPdata);\n\n    randomSeed(micros());\n\n    Serial.println(\"\");\n    Serial.println(\"WiFi connected\");\n    Serial.println(\"IP address: \");\n    Serial.println(WiFi.localIP().toString());"
        },
        {
          "name": "reconnect",
          "parameters": "",
          "body": "if (WiFi.status() != WL_CONNECTED)\n    {\n        return;\n    }\n    // Loop until we're reconnected\n    while (!client.connected())\n    {\n        Serial.println(\"Attempting MQTT connection...\");\n        // Create a random client ID\n        String clientId = \"DB-\";\n        clientId += String(random(0xffff), HEX);\n        // Attempt to connect\n        if (client.connect(clientId.c_str(), MyconfigData.mqtt_id, MyconfigData.mqtt_key))\n        {\n            Serial.println(\"connected\");\n            Serial.println(MyconfigData.sensorstatus);\n        }\n        else\n        {\n            Serial.println(\"failed, rc=\");\n            Serial.println(client.state());\n            Serial.println(\" try again in 1 seconds\");\n            // Wait 1 seconds before retrying\n            delay(1000); // oh man, we should not be blocking.\n        }\n    }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_CONFIG, OUTPUT);  // Initialize the BUILTIN_LED pin as an output\n    pinMode(GPIO4, INPUT_PULLUP); // If this pin is LOW, then REPROGRAM by setting up the Access Point.\n    Serial.begin(115200);\n    EEPROM.begin(EEPROM_SIZE);\n    delay(10);\n    MyconfigData = getConfigData();\n    delay(10);\n    MyAPdata = getAPData();\n    delay(10);\n    chkColdStart();\n    Serial.println(\"Config/ap data\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyAPdata.crc32);\n\n    if (hasConfig == false or digitalRead(GPIO4) == LOW)\n    {\n        configmode = CONFIG;\n\n        WiFi.mode(WIFI_AP_STA);\n        WiFi.softAP(ssidAP, passwordAP);\n        IPAddress IP = WiFi.softAPIP();\n\n        dHTML.setCallback(dynaCallback);\n        uint16_t tot = dHTML.setMenuItems(mallItem, NUM_MENU_ITEMS);\n\n        server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request)\n                  { dHTML.handleRequest(request); });\n\n        server.begin();\n    }\n    if (hasConfig == true and digitalRead(GPIO4) == HIGH)\n    {\n        configmode = RUN;\n        setup_wifi();\n        client.setServer(MyconfigData.mqtt_server, 1883);\n        // client.setCallback(callback);\n\n        digitalWrite(LED_CONFIG, HIGH);\n        delay(100);\n        digitalWrite(LED_CONFIG, LOW);\n        delay(100);\n        digitalWrite(LED_CONFIG, HIGH);\n        delay(100);\n        digitalWrite(LED_CONFIG, LOW);\n        OTAinit();\n        USBpower = (strcmp(MyconfigData.usb_power, \"1\") == 0);\n        Serial.println(WiFi.localIP().toString());\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (configmode == RUN)\n    {\n        if (!client.connected())\n        {\n            reconnect();\n        }\n        client.loop();\n\n        ArduinoOTA.handle();\n    }\n    unsigned long now = millis();\n\n    if (configmode == CONFIG)\n    {\n\n        if (now - mslightdim > 30)\n        {\n            mslightdim = now;\n            analogWrite(LED_CONFIG, brightness);\n\n            // change the brightness for next time through the loop:\n            brightness = brightness + fadeAmount;\n\n            // reverse the direction of the fading at the ends of the fade:\n            if (brightness <= 0 || brightness >= 255)\n            {\n                fadeAmount = -fadeAmount;\n            }\n        }\n    }\n    if (configmode == RUN)\n    {\n        if (now - lastMsg > 10000)\n        {\n            lastMsg = now;\n            ++value;\n            snprintf(msg, MSG_BUFFER_SIZE, \"msg #%ld\", value);\n\n            client.publish(MyconfigData.sensorstatus, msg);\n            digitalWrite(LED_CONFIG, !digitalRead(LED_CONFIG));\n\n            if (USBpower == true)\n            {\n                Serial.println(\"USB POWER ENABLED\");\n            }\n        }\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "wificlient",
        "https",
        "password",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting BasicAuthGet on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);\n  }\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n\n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n\n#endif\n\n#endif\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  // you're connected now, so print out the data\n  printWifiStatus();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"making GET request with HTTP basic authentication\");\n  httpClient.beginRequest();\n  httpClient.get(\"/secure\");\n  httpClient.sendBasicAuth(\"username\", \"password\"); // send the username and password for authentication\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "password",
        "delay",
        "millis"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStarting BasicAuthGet_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"making GET request with HTTP basic authentication\");\n  httpClient.beginRequest();\n  httpClient.get(\"/secure\");\n  httpClient.sendBasicAuth(\"username\", \"password\"); // send the username and password for authentication\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n  \n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "http",
        "https",
        "token",
        "key",
        "password",
        "certificate",
        "auth",
        "ssl",
        "payload",
        "callback",
        "buffer",
        "database",
        "stream",
        "json",
        "wifi",
        "delay",
        "millis",
        "flash",
        "sd",
        "timestamp"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the api key (required) */\n  config.api_key = API_KEY;\n\n  /* Assign the user sign in credentials */\n  auth.user.email = USER_EMAIL;\n  auth.user.password = USER_PASSWORD;\n\n  /* Assign the RTDB URL (required) */\n  config.database_url = DATABASE_URL;\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  /* In case the certificate data was used  */\n  config.cert.data = rootCACert;\n\n  // Or custom set the root certificate for each FirebaseData object\n  fbdo.setCert(rootCACert);\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  /* Or assign the certificate file */\n\n  /** From the test as of July 2021, GlobalSign Root CA was missing from Google server\n   * as described above, GTS Root R1 (gsr1.pem or gsr1.der) can be used instead.\n   * ESP32 Arduino SDK supports PEM format only even mBedTLS supports DER format too.\n   * ESP8266 SDK supports both PEM and DER format certificates.\n   */\n  // config.cert.file = \"/gsr1.pem\";\n  // config.cert.file_storage = StorageType::FLASH;   //or StorageType::SD\n\n  // Or use legacy authenticate method\n  // config.database_url = DATABASE_URL;\n  // config.signer.tokens.legacy_token = \"<database secret>\";\n\n  // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n  Firebase.begin(&config, &auth);\n\n  Firebase.setDoubleDigits(5);\n\n  // You can use TCP KeepAlive in FirebaseData object and tracking the server connection status, please read this for detail.\n  // https://github.com/mobizt/Firebase-ESP32#about-firebasedata-object\n  // fbdo.keepAlive(5, 5, 1);\n\n  /** Timeout options.\n\n  //Network reconnect timeout (interval) in ms (10 sec - 5 min) when network or WiFi disconnected.\n  config.timeout.networkReconnect = 10 * 1000;\n\n  //Socket connection and SSL handshake timeout in ms (1 sec - 1 min).\n  config.timeout.socketConnection = 10 * 1000;\n\n  //Server response read timeout in ms (1 sec - 1 min).\n  config.timeout.serverResponse = 10 * 1000;\n\n  //RTDB Stream keep-alive timeout in ms (20 sec - 2 min) when no server's keep-alive event data received.\n  config.timeout.rtdbKeepAlive = 45 * 1000;\n\n  //RTDB Stream reconnect timeout (interval) in ms (1 sec - 1 min) when RTDB Stream closed and want to resume.\n  config.timeout.rtdbStreamReconnect = 1 * 1000;\n\n  //RTDB Stream error notification timeout (interval) in ms (3 sec - 30 sec). It determines how often the readStream\n  //will return false (error) when it called repeatedly in loop.\n  config.timeout.rtdbStreamError = 3 * 1000;\n\n  Note:\n  The function that starting the new TCP session i.e. first time server connection or previous session was closed, the function won't exit until the\n  time of config.timeout.socketConnection.\n\n  You can also set the TCP data sending retry with\n  config.tcp_data_sending_retry = 1;\n\n  */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && (millis() - sendDataPrevMillis > 15000 || sendDataPrevMillis == 0))\n  {\n    sendDataPrevMillis = millis();\n\n    Serial.printf(\"Set bool... %s\\n\", Firebase.setBool(fbdo, \"/test/bool\", count % 2 == 0) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get bool... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\") ? fbdo.to<bool>() ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    bool bVal;\n    Serial.printf(\"Get bool ref... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\", &bVal) ? bVal ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get int... %s\\n\", Firebase.getInt(fbdo, \"/test/int\") ? String(fbdo.to<int>()).c_str() : fbdo.errorReason().c_str());\n\n    int iVal = 0;\n    Serial.printf(\"Get int ref... %s\\n\", Firebase.getInt(fbdo, \"/test/int\", &iVal) ? String(iVal).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set float... %s\\n\", Firebase.setFloat(fbdo, \"/test/float\", count + 10.2) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get float... %s\\n\", Firebase.getFloat(fbdo, \"/test/float\") ? String(fbdo.to<float>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set double... %s\\n\", Firebase.setDouble(fbdo, \"/test/double\", count + 35.517549723765) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get double... %s\\n\", Firebase.getDouble(fbdo, \"/test/double\") ? String(fbdo.to<double>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set string... %s\\n\", Firebase.setString(fbdo, \"/test/string\", \"Hello World!\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get string... %s\\n\", Firebase.getString(fbdo, \"/test/string\") ? fbdo.to<const char *>() : fbdo.errorReason().c_str());\n\n    // For the usage of FirebaseJson, see examples/FirebaseJson/BasicUsage/Create_Edit_Parse.ino\n    FirebaseJson json;\n\n    if (count == 0)\n    {\n      json.set(\"value/round/\" + String(count), \"cool!\");\n      json.set(\"vaue/ts/.sv\", \"timestamp\");\n      Serial.printf(\"Set json... %s\\n\", Firebase.set(fbdo, \"/test/json\", json) ? \"ok\" : fbdo.errorReason().c_str());\n    }\n    else\n    {\n      json.add(String(count), \"smart!\");\n      Serial.printf(\"Update node... %s\\n\", Firebase.updateNode(fbdo, \"/test/json/value/round\", json) ? \"ok\" : fbdo.errorReason().c_str());\n    }\n\n    Serial.println();\n\n    // For generic set/get functions.\n\n    // For generic set, use Firebase.set(fbdo, <path>, <any variable or value>)\n\n    // For generic get, use Firebase.get(fbdo, <path>).\n    // And check its type with fbdo.dataType() or fbdo.dataTypeEnum() and\n    // cast the value from it e.g. fbdo.to<int>(), fbdo.to<std::string>().\n\n    // The function, fbdo.dataType() returns types String e.g. string, boolean,\n    // int, float, double, json, array, blob, file and null.\n\n    // The function, fbdo.dataTypeEnum() returns type enum (number) e.g. firebase_rtdb_data_type_null (1),\n    // firebase_rtdb_data_type_integer, firebase_rtdb_data_type_float, firebase_rtdb_data_type_double,\n    // firebase_rtdb_data_type_boolean, firebase_rtdb_data_type_string, firebase_rtdb_data_type_json,\n    // firebase_rtdb_data_type_array, firebase_rtdb_data_type_blob, and firebase_rtdb_data_type_file (10)\n\n    count++;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "database",
        "payload",
        "callback",
        "buffer",
        "json",
        "wifi",
        "millis",
        "interrupt",
        "timestamp"
      ],
      "libraries": [
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "WiFiEvent",
          "parameters": "WiFiEvent_t event",
          "body": "// Do not run any function here to prevent stack overflow or nested interrupt\n#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)\n\n    switch (event)\n    {\n    case ARDUINO_EVENT_ETH_START:\n        Serial.println(\"ETH Started\");\n        // set eth hostname here\n        ETH.setHostname(\"esp32-ethernet\");\n        break;\n    case ARDUINO_EVENT_ETH_CONNECTED:\n        Serial.println(\"ETH Connected\");\n        break;\n    case ARDUINO_EVENT_ETH_GOT_IP:\n        Serial.print(\"ETH MAC: \");\n        Serial.print(ETH.macAddress());\n        Serial.print(\", IPv4: \");\n        Serial.print(ETH.localIP());\n        if (ETH.fullDuplex())\n        {\n            Serial.print(\", FULL_DUPLEX\");\n        }\n        Serial.print(\", \");\n        Serial.print(ETH.linkSpeed());\n        Serial.println(\"Mbps\");\n        eth_connected = true;\n        break;\n    case ARDUINO_EVENT_ETH_DISCONNECTED:\n        Serial.println(\"ETH Disconnected\");\n        eth_connected = false;\n        break;\n    case ARDUINO_EVENT_ETH_STOP:\n        Serial.println(\"ETH Stopped\");\n        eth_connected = false;\n        break;\n    default:\n        break;\n    }\n\n#else\n    switch (event)\n    {\n    case SYSTEM_EVENT_ETH_START:\n        Serial.println(\"ETH Started\");\n        // set eth hostname here\n        ETH.setHostname(\"esp32-ethernet\");\n        break;\n    case SYSTEM_EVENT_ETH_CONNECTED:\n        Serial.println(\"ETH Connected\");\n        break;\n    case SYSTEM_EVENT_ETH_GOT_IP:\n        Serial.print(\"ETH MAC: \");\n        Serial.print(ETH.macAddress());\n        Serial.print(\", IPv4: \");\n        Serial.print(ETH.localIP());\n        if (ETH.fullDuplex())\n        {\n            Serial.print(\", FULL_DUPLEX\");\n        }\n        Serial.print(\", \");\n        Serial.print(ETH.linkSpeed());\n        Serial.println(\"Mbps\");\n        eth_connected = true;\n        break;\n    case SYSTEM_EVENT_ETH_DISCONNECTED:\n        Serial.println(\"ETH Disconnected\");\n        eth_connected = false;\n        break;\n    case SYSTEM_EVENT_ETH_STOP:\n        Serial.println(\"ETH Stopped\");\n        eth_connected = false;\n        break;\n    default:\n        break;\n    }\n#endif"
        },
        {
          "name": "setupFirebase",
          "parameters": "",
          "body": "if (firebaseConfigReady)\n        return;\n\n    firebaseConfigReady = true;\n\n    // For the following credentials, see examples/Authentications/SignInAsUser/EmailPassword/EmailPassword.ino\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the user sign in credentials */\n    auth.user.email = USER_EMAIL;\n    auth.user.password = USER_PASSWORD;\n\n    /* Assign the RTDB URL (required) */\n    config.database_url = DATABASE_URL;\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    // Or use legacy authenticate method\n    // config.database_url = DATABASE_URL;\n    // config.signer.tokens.legacy_token = \"<database secret>\";\n\n    // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n    Firebase.begin(&config, &auth);"
        },
        {
          "name": "testFirebase",
          "parameters": "",
          "body": "Serial.printf(\"Set bool... %s\\n\", Firebase.setBool(fbdo, \"/test/bool\", count % 2 == 0) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get bool... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\") ? fbdo.to<bool>() ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    bool bVal;\n    Serial.printf(\"Get bool ref... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\", &bVal) ? bVal ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get int... %s\\n\", Firebase.getInt(fbdo, \"/test/int\") ? String(fbdo.to<int>()).c_str() : fbdo.errorReason().c_str());\n\n    int iVal = 0;\n    Serial.printf(\"Get int ref... %s\\n\", Firebase.getInt(fbdo, \"/test/int\", &iVal) ? String(iVal).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set float... %s\\n\", Firebase.setFloat(fbdo, \"/test/float\", count + 10.2) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get float... %s\\n\", Firebase.getFloat(fbdo, \"/test/float\") ? String(fbdo.to<float>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set double... %s\\n\", Firebase.setDouble(fbdo, \"/test/double\", count + 35.517549723765) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get double... %s\\n\", Firebase.getDouble(fbdo, \"/test/double\") ? String(fbdo.to<double>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set string... %s\\n\", Firebase.setString(fbdo, \"/test/string\", \"Hello World!\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get string... %s\\n\", Firebase.getString(fbdo, \"/test/string\") ? fbdo.to<const char *>() : fbdo.errorReason().c_str());\n\n    // For the usage of FirebaseJson, see examples/FirebaseJson/BasicUsage/Create_Edit_Parse.ino\n    FirebaseJson json;\n\n    if (count == 0)\n    {\n        json.set(\"value/round/\" + String(count), \"cool!\");\n        json.set(\"vaue/ts/.sv\", \"timestamp\");\n        Serial.printf(\"Set json... %s\\n\", Firebase.set(fbdo, \"/test/json\", json) ? \"ok\" : fbdo.errorReason().c_str());\n    }\n    else\n    {\n        json.add(String(count), \"smart!\");\n        Serial.printf(\"Update node... %s\\n\", Firebase.updateNode(fbdo, \"/test/json/value/round\", json) ? \"ok\" : fbdo.errorReason().c_str());\n    }\n\n    Serial.println();\n\n    // For generic set/get functions.\n\n    // For generic set, use Firebase.set(fbdo, <path>, <any variable or value>)\n\n    // For generic get, use Firebase.get(fbdo, <path>).\n    // And check its type with fbdo.dataType() or fbdo.dataTypeEnum() and\n    // cast the value from it e.g. fbdo.to<int>(), fbdo.to<std::string>().\n\n    // The function, fbdo.dataType() returns types String e.g. string, boolean,\n    // int, float, double, json, array, blob, file and null.\n\n    // The function, fbdo.dataTypeEnum() returns type enum (number) e.g. firebase_rtdb_data_type_null (1),\n    // firebase_rtdb_data_type_integer, firebase_rtdb_data_type_float, firebase_rtdb_data_type_double,\n    // firebase_rtdb_data_type_boolean, firebase_rtdb_data_type_string, firebase_rtdb_data_type_json,\n    // firebase_rtdb_data_type_array, firebase_rtdb_data_type_blob, and firebase_rtdb_data_type_file (10)\n\n    count++;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n    WiFi.onEvent(WiFiEvent);\n    ETH.begin(ETH_ADDR, ETH_POWER_PIN, ETH_MDC_PIN, ETH_MDIO_PIN, ETH_TYPE, ETH_CLK_MODE);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (eth_connected && (millis() - sendDataPrevMillis > 30000 || sendDataPrevMillis == 0))\n    {\n        sendDataPrevMillis = millis();\n        setupFirebase();\n        if (Firebase.ready())\n            testFirebase();\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "ContinuousStepper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// If using a stepper driver, with STEP and DIR pins\n  stepper.begin(/*step=*/2, /*dir=*/3);\n\n  // If using a four-wire stepper:\n  // stepper.begin(8, 10, 9, 11);\n\n  stepper.spin(200);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "stepper.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "payload",
        "power",
        "dns",
        "millis",
        "delay",
        "html"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting BasicHttpClient on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (WT32_ETH01_isConnected()) \n  {\n    HTTPClient http;\n\n    Serial.print(\"[HTTP] begin...\\n\");\n    // configure traged server and url\n    //http.begin(\"https://www.howsmyssl.com/a/check\", ca); //HTTPS\n    http.begin(\"http://example.com/index.html\"); //HTTP\n\n    Serial.print(\"[HTTP] GET...\\n\");\n    // start connection and send HTTP header\n    int httpCode = http.GET();\n\n    // httpCode will be negative on error\n    if (httpCode > 0) \n    {\n      // HTTP header has been send and Server response header has been handled\n      Serial.printf(\"[HTTP] GET... code: %d\\n\", httpCode);\n\n      // file found at server\n      if (httpCode == HTTP_CODE_OK) \n      {\n        String payload = http.getString();\n        Serial.println(payload);\n      }\n    } \n    else \n    {\n      Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\n    }\n\n    http.end();\n  }\n\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "certificate",
        "payload",
        "current",
        "power",
        "dns",
        "ntp",
        "delay",
        "yield",
        "millis",
        "html"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h",
        "WiFiClientSecure.h"
      ],
      "functions": [
        {
          "name": "setClock",
          "parameters": "",
          "body": "configTime(0, 0, \"pool.ntp.org\");\n\n  Serial.print(F(\"Waiting for NTP time sync: \"));\n  time_t nowSecs = time(nullptr);\n\n  while (nowSecs < 8 * 3600 * 2)\n  {\n    delay(500);\n    Serial.print(F(\".\"));\n    yield();\n    nowSecs = time(nullptr);\n  }\n\n  Serial.println();\n  struct tm timeinfo;\n  gmtime_r(&nowSecs, &timeinfo);\n  Serial.print(F(\"Current time: \"));\n  Serial.print(asctime(&timeinfo));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting BasicHttpsClient on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  setClock();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (WT32_ETH01_isConnected())\n  {\n    WiFiClientSecure *client = new WiFiClientSecure;\n\n    if (client) \n    {\n      client -> setCACert(rootCACertificate);\n\n      {\n        // Add a scoping block for HTTPClient https to make sure it is destroyed before WiFiClientSecure *client is\n        HTTPClient https;\n\n        Serial.print(\"[HTTPS] begin...\\n\");\n        if (https.begin(*client, \"https://jigsaw.w3.org/HTTP/connection.html\")) \n        {  \n          // HTTPS\n          Serial.print(\"[HTTPS] GET...\\n\");\n          // start connection and send HTTP header\n          int httpCode = https.GET();\n\n          // httpCode will be negative on error\n          if (httpCode > 0) \n          {\n            // HTTP header has been send and Server response header has been handled\n            Serial.printf(\"[HTTPS] GET... code: %d\\n\", httpCode);\n\n            // file found at server\n            if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) \n            {\n              String payload = https.getString();\n              Serial.println(payload);\n            }\n          } \n          else \n          {\n            Serial.printf(\"[HTTPS] GET... failed, error: %s\\n\", https.errorToString(httpCode).c_str());\n          }\n\n          https.end();\n        } \n        else \n        {\n          Serial.printf(\"[HTTPS] Unable to connect\\n\");\n        }\n\n        // End extra scoping block\n      }\n\n      delete client;\n    } \n    else \n    {\n      Serial.println(\"Unable to create client\");\n    }\n\n    Serial.println();\n    Serial.println(\"Waiting 10s before the next round...\");\n    delay(10000);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "pubsubclient",
        "asyncwebserver",
        "wificlient",
        "password",
        "md5",
        "auth",
        "json",
        "publish",
        "callback",
        "power",
        "wifi",
        "dns",
        "delay",
        "esp.restart",
        "digitalread",
        "digitalwrite",
        "millis",
        "analogwrite",
        "led",
        "eeprom",
        "spiffs",
        "html",
        "nodemcu",
        "devices",
        "sensors",
        "sensorstatus",
        "sensorname",
        "clientid"
      ],
      "libraries": [
        "ESP_EEPROM.h",
        "ESPAsyncTCP.h",
        "ESPAsyncWebServer.h",
        "ESP8266WiFi.h",
        "PubSubClient.h",
        "ArduinoOTA.h",
        "dynaHTML.h"
      ],
      "functions": [
        {
          "name": "dynaCallback",
          "parameters": "",
          "body": "Serial.println(\"YOUR CALLBACK WORKED!!!!!!!!!!\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyconfigData.wifi_pw);\n    Serial.println(MyconfigData.mqtt_server);\n    Serial.println(MyconfigData.sensorname);\n    Serial.println(MyconfigData.sensorstatus);\n    Serial.println(MyconfigData.mqtt_id);\n    Serial.println(MyconfigData.mqtt_key);\n    Serial.println(MyconfigData.usb_power);\n    saveconfigtoEE(MyconfigData);\n    // if we are updating data, force a refresh of the SSID\n    MyAPdata.crc32 = 8675309; // If your CRC based on your bssid and channel happen to be Jennys number, CALL HER!\n    saveAPEE(MyAPdata);\n    delay(1000);\n    ESP.restart();"
        },
        {
          "name": "OTAinit",
          "parameters": "",
          "body": "// Port defaults to 8266\n    ArduinoOTA.setPort(8266);\n\n    // Hostname defaults to esp8266-[ChipID]\n    // ArduinoOTA.setHostname(\"DOOR-FRONT-ESP\");\n    ArduinoOTA.setHostname(MyconfigData.sensorname);\n    // if (DEBUG == false) {\n    //  Comment to: No authentication by default\n    ArduinoOTA.setPassword(OTA_PASSDW);\n    // Password can be set with it's md5 value as well\n    // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3\n    // ArduinoOTA.setPasswordHash(\"21232f297a57a5a743894a0e4a801fc3\");\n    // }\n\n    ArduinoOTA.onStart([]()\n                       {\n    String type;\n    if (ArduinoOTA.getCommand() == U_FLASH)\n      type = \"sketch\";\n    else // U_SPIFFS\n      type = \"filesystem\";\n\n    // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()\n    Serial.println(\"Start updating \" + type); });\n    ArduinoOTA.onEnd([]()\n                     { Serial.println(\"\\nEnd\"); });\n    ArduinoOTA.onProgress([](unsigned int progress, unsigned int total)\n                          { Serial.printf(\"Progress: %u%%\\r\\n\", (progress / (total / 100))); });\n    ArduinoOTA.onError([](ota_error_t error)\n                       {\n    Serial.printf(\"Error[%u]: \", error);\n    if (error == OTA_AUTH_ERROR) Serial.println(\"Auth Failed\");\n    else if (error == OTA_BEGIN_ERROR) Serial.println(\"Begin Failed\");\n    else if (error == OTA_CONNECT_ERROR) Serial.println(\"Connect Failed\");\n    else if (error == OTA_RECEIVE_ERROR) Serial.println(\"Receive Failed\");\n    else if (error == OTA_END_ERROR) Serial.println(\"End Failed\"); });\n    ArduinoOTA.begin();\n    Serial.println(\"Ready\");\n    Serial.println(\"IP address: \");\n    Serial.println(WiFi.localIP());"
        },
        {
          "name": "saveconfigtoEE",
          "parameters": "configData MyconfigData",
          "body": "EEPROM.put(eepromstart, MyconfigData);\n    JumpStart();\n    boolean ok2 = EEPROM.commit();\n    Serial.println(ok2);"
        },
        {
          "name": "saveAPEE",
          "parameters": "apData MyAPData",
          "body": "EEPROM.put(eepromapstart, MyAPData);\n    boolean ok2 = EEPROM.commit();"
        },
        {
          "name": "chkColdStart",
          "parameters": "",
          "body": "EEPROM.get(eepromcoldstart, ColdStart);\n    if (ColdStart.One == 0x45 && ColdStart.Two == 0x72)\n    {\n        hasConfig = true;\n    }"
        },
        {
          "name": "JumpStart",
          "parameters": "",
          "body": "ColdStart.One = 0x45;\n    ColdStart.Two = 0x72;\n    EEPROM.put(eepromcoldstart, ColdStart);"
        },
        {
          "name": "setup_wifi",
          "parameters": "",
          "body": "// We start by connecting to a WiFi network\n    WiFi.persistent(true);\n    WiFi.mode(WIFI_STA);\n    WiFi.forceSleepWake();\n    // delay(200);\n    // WiFi.config(staticIP, subnet, gateway, dns);\n    // WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    if (apValid)\n    {\n        Serial.println(\"Using BSSID data\");\n        // The BSSID data was good, make a quick connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw, MyAPdata.channel, MyAPdata.bssid, true);\n    }\n    else\n    {\n        Serial.println(\"Not using BSSID data\");\n        // The BSSID data was not valid, so make a regular connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    }\n    int retries = 0;\n    int wifiStatus = WiFi.status();\n\n    while (wifiStatus != WL_CONNECTED)\n    {\n        retries++;\n        if (retries == 100)\n        {\n            // Quick connect is not working, reset WiFi and try regular connection\n            WiFi.disconnect();\n            delay(10);\n            WiFi.forceSleepBegin();\n            delay(10);\n            WiFi.forceSleepWake();\n            delay(10);\n            WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n        }\n        // Give it 20 Seconds of retrying, otherwise reset the BSSID and try again.\n        if (retries == 400)\n        {\n            WiFi.disconnect(true);\n            delay(1);\n            WiFi.mode(WIFI_OFF);\n            // invalidate the CRC, force a refresh of the WIFI AP without a BSSID/CHANNEL\n            MyAPdata.crc32 = 8675309;\n            saveAPEE(MyAPdata);\n            delay(10);\n            ESP.restart();\n            return;\n        }\n        delay(50);\n        if (retries % 10 == 1)\n            Serial.print(\".-.\");\n        wifiStatus = WiFi.status();\n    }\n\n    MyAPdata.channel = WiFi.channel();\n    memcpy(MyAPdata.bssid, WiFi.BSSID(), 6); // Copy 6 bytes of BSSID (AP's MAC address)\n\n    MyAPdata.crc32 = calculateCRC32(((uint8_t *)&MyAPdata) + 4, sizeof(MyAPdata) - 4);\n    saveAPEE(MyAPdata);\n\n    randomSeed(micros());\n\n    Serial.println(\"\");\n    Serial.println(\"WiFi connected\");\n    Serial.println(\"IP address: \");\n    Serial.println(WiFi.localIP().toString());"
        },
        {
          "name": "reconnect",
          "parameters": "",
          "body": "if (WiFi.status() != WL_CONNECTED)\n    {\n        return;\n    }\n    // Loop until we're reconnected\n    while (!client.connected())\n    {\n        Serial.println(\"Attempting MQTT connection...\");\n        // Create a random client ID\n        String clientId = \"DB-\";\n        clientId += String(random(0xffff), HEX);\n        // Attempt to connect\n        if (client.connect(clientId.c_str(), MyconfigData.mqtt_id, MyconfigData.mqtt_key))\n        {\n            Serial.println(\"connected\");\n            Serial.println(MyconfigData.sensorstatus);\n        }\n        else\n        {\n            Serial.println(\"failed, rc=\");\n            Serial.println(client.state());\n            Serial.println(\" try again in 1 seconds\");\n            // Wait 1 seconds before retrying\n            delay(1000); // oh man, we should not be blocking.\n        }\n    }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT); // Initialize the BUILTIN_LED pin as an output\n    pinMode(GPIO4, INPUT_PULLUP); // If this pin is LOW, then REPROGRAM by setting up the Access Point.\n    Serial.begin(115200);\n    EEPROM.begin(EEPROM_SIZE);\n    delay(10);\n    MyconfigData = getConfigData();\n    delay(10);\n    MyAPdata = getAPData();\n    delay(10);\n    chkColdStart();\n    Serial.println(\"Config/ap data\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyAPdata.crc32);\n\n    if (hasConfig == false or digitalRead(GPIO4) == LOW)\n    {\n        configmode = CONFIG;\n\n        WiFi.mode(WIFI_AP_STA);\n        WiFi.softAP(ssidAP, passwordAP);\n        IPAddress IP = WiFi.softAPIP();\n\n        dHTML.setCallback(dynaCallback);\n        uint16_t tot = dHTML.setMenuItems(mallItem, NUM_MENU_ITEMS);\n\n        server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request)\n                  { dHTML.handleRequest(request); });\n\n        server.begin();\n    }\n    if (hasConfig == true and digitalRead(GPIO4) == HIGH)\n    {\n        configmode = RUN;\n        setup_wifi();\n        client.setServer(MyconfigData.mqtt_server, 1883);\n        // client.setCallback(callback);\n\n        digitalWrite(LED_BUILTIN, HIGH);\n        delay(100);\n        digitalWrite(LED_BUILTIN, LOW);\n        delay(100);\n        digitalWrite(LED_BUILTIN, HIGH);\n        delay(100);\n        digitalWrite(LED_BUILTIN, LOW);\n        OTAinit();\n        USBpower = (strcmp(MyconfigData.usb_power, \"1\") == 0);\n        Serial.println(WiFi.localIP().toString());\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (configmode == RUN)\n    {\n        if (!client.connected())\n        {\n            reconnect();\n        }\n        client.loop();\n\n        ArduinoOTA.handle();\n    }\n    unsigned long now = millis();\n\n    if (configmode == CONFIG)\n    {\n\n        if (now - mslightdim > 30)\n        {\n            mslightdim = now;\n            analogWrite(LED_BUILTIN, brightness);\n\n            // change the brightness for next time through the loop:\n            brightness = brightness + fadeAmount;\n\n            // reverse the direction of the fading at the ends of the fade:\n            if (brightness <= 0 || brightness >= 255)\n            {\n                fadeAmount = -fadeAmount;\n            }\n        }\n    }\n    if (configmode == RUN)\n    {\n        if (now - lastMsg > 10000)\n        {\n            lastMsg = now;\n            ++value;\n            snprintf(msg, MSG_BUFFER_SIZE, \"msg #%ld\", value);\n\n            client.publish(MyconfigData.sensorstatus, msg);\n            digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n\n            if (USBpower == true)\n            {\n                Serial.println(\"USB POWER ENABLED\");\n            }\n        }\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "current",
        "power",
        "spi",
        "digitalwrite",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "SPI.begin();\n  stepper.init(amisSlaveSelect);\n\n  // Drive the NXT/STEP and DIR pins low initially.\n  digitalWrite(amisStepPin, LOW);\n  pinMode(amisStepPin, OUTPUT);\n  digitalWrite(amisDirPin, LOW);\n  pinMode(amisDirPin, OUTPUT);\n\n  // Give the driver some time to power up.\n  delay(1);\n\n  // Reset the driver to its default settings.\n  stepper.resetSettings();\n\n  // Set the current limit.  You should change the number here to\n  // an appropriate value for your particular system.\n  stepper.setCurrentMilliamps(132);\n\n  // Set the number of microsteps that correspond to one full step.\n  stepper.setStepMode(32);\n\n  // Enable the motor outputs.\n  stepper.enableDriver();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Step in the default direction 1000 times.\n  setDirection(0);\n  for (unsigned int x = 0; x < 1000; x++)\n  {\n    step();\n  }\n\n  // Wait for 300 ms.\n  delay(300);\n\n  // Step in the other direction 1000 times.\n  setDirection(1);\n  for (unsigned int x = 0; x < 1000; x++)\n  {\n    step();\n  }\n\n  // Wait for 300 ms.\n  delay(300);"
        },
        {
          "name": "step",
          "parameters": "",
          "body": "// The NXT/STEP minimum high pulse width is 2 microseconds.\n  digitalWrite(amisStepPin, HIGH);\n  delayMicroseconds(3);\n  digitalWrite(amisStepPin, LOW);\n  delayMicroseconds(3);\n\n  // The delay here controls the stepper motor's speed.  You can\n  // increase the delay to make the stepper motor go slower.  If\n  // you decrease the delay, the stepper motor will go fast, but\n  // there is a limit to how fast it can go before it starts\n  // missing steps.\n  delayMicroseconds(2000);"
        },
        {
          "name": "setDirection",
          "parameters": "bool dir",
          "body": "// The NXT/STEP pin must not change for at least 0.5\n  // microseconds before and after changing the DIR pin.\n  delayMicroseconds(1);\n  digitalWrite(amisDirPin, dir);\n  delayMicroseconds(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "yield",
        "watchdog",
        "timer"
      ],
      "libraries": [
        "Adafruit_SleepyDog.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial)\n    delay(10);\n  // wait for Arduino Serial Monitor (native USB boards)\n\n  Serial.println(\"Adafruit Watchdog Library Demo!\");\n  Serial.println();\n\n  // First a normal example of using the watchdog timer.\n  // Enable the watchdog by calling Watchdog.enable() as below.\n  // This will turn on the watchdog timer with a ~4 second timeout\n  // before reseting the Arduino. The estimated actual milliseconds\n  // before reset (in milliseconds) is returned.\n  // Make sure to reset the watchdog before the countdown expires or\n  // the Arduino will reset!\n  int countdownMS = Watchdog.enable(4000);\n  Serial.print(\"Enabled the watchdog with max countdown of \");\n  Serial.print(countdownMS, DEC);\n  Serial.println(\" milliseconds!\");\n  Serial.println();\n\n  // Now loop a few times and periodically reset the watchdog.\n  Serial.println(\"Looping ten times while resetting the watchdog...\");\n  for (int i = 1; i <= 10; ++i) {\n    Serial.print(\"Loop #\");\n    Serial.println(i, DEC);\n    delay(1000);\n    // Reset watchdog with every loop to make sure the sketch keeps running.\n    // If you comment out this call watch what happens in about 4 iterations!\n    Watchdog.reset();\n  }\n  Serial.println();\n\n// can not disable NRF or RP2040 wdt once enabled\n#if !defined(NRF52_SERIES) || !defined(ARDUINO_ARCH_RP2040)\n  // Disable the watchdog entirely by calling Watchdog.disable();\n  Watchdog.disable();\n#endif\n\n  // Finally demonstrate the watchdog resetting by enabling it for a shorter\n  // period of time and waiting a long time without a reset.  Notice you can\n  // pass a _maximum_ countdown time (in milliseconds) to the enable call.\n  // The library will try to use that value as the countdown, but it might\n  // pick a smaller value if the hardware doesn't support it.  The actual\n  // countdown value will be returned so you can see what it is.\n  countdownMS = Watchdog.enable(4000);\n  Serial.print(\"Get ready, the watchdog will reset in \");\n  Serial.print(countdownMS, DEC);\n  Serial.println(\" milliseconds!\");\n  Serial.println();\n#ifndef ARDUINO_ARCH_ESP8266\n  delay(countdownMS + 1000);\n#else\n  // Calls to delay() and yield() feed the ESP8266's\n  // hardware and software watchdog timers, delayMicroseconds does not.\n  delayMicroseconds(countdownMS * 1000);\n#endif\n\n  // Execution will never get here because the watchdog resets the Arduino!"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// We'll never actually get to the loop because the watchdog will reset in\n  // the setup function.\n  Serial.println(\"You shouldn't see this message.\");\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "password",
        "wifi",
        "delay",
        "display",
        "devicename"
      ],
      "libraries": [
        "DurianBlynkESP8266.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();\n  \n  //Set counter index to virtual pin V0 \n  DBlynk.virtualWrite(V0, gsCounter_Index);\n\n  gsCounter_Index++;\n  if(gsCounter_Index > 100) //if counter index more than 100, reset to 0\n  {\n    gsCounter_Index = 0;  \n  }\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [
        "MIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n    MIDI.begin(4);                      // Launch MIDI and listen to channel 4"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (MIDI.read())                    // If we have received a message\n    {\n        digitalWrite(LED_BUILTIN, HIGH);\n        MIDI.sendNoteOn(42, 127, 1);    // Send a Note (pitch 42, velo 127 on channel 1)\n        delay(1000);\t\t            // Wait for a second\n        MIDI.sendNoteOff(42, 0, 1);     // Stop the note\n        digitalWrite(LED_BUILTIN, LOW);\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "token",
        "database",
        "payload",
        "json",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(sa_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Docs.resetApp();\n    app.getApp<Firestore::Documents>(Docs);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        Serial.println(\"Get multiple documents...\");\n\n        BatchGetDocumentOptions options;\n        options.documents(\"info/countries\");\n        options.documents(\"a0/b0\");\n        options.documents(\"test_collection/test_document\");\n        options.mask(DocumentMask(\"Singapore.population,key1\"));\n\n        // You can set the content of options object directly with options.setContent(\"your content\")\n\n        String payload = Docs.batchGet(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), options);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);\n        }\n    }\n    ts = time(nullptr);\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\n    ts = WiFi.getTime();\n#endif"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "token",
        "database",
        "payload",
        "json",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(sa_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Docs.resetApp();\n    app.getApp<Firestore::Documents>(Docs);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Batch write documents... \");\n\n        String documentPath = \"test_collection/test_document_map_value\";\n\n        Values::MapValue mapV(\"name\", Values::StringValue(\"value\" + String(counter)));\n        mapV.add(\"count\", Values::StringValue(String(counter)));\n\n        Values::MapValue mapV2(\"key\" + String(counter), mapV);\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV2));\n\n        Values::MapValue labels;\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */), Values::MapValue() /* Labels */);\n\n        String documentPath2 = \"test_collection/test_document_timestamp\";\n        String fieldPath = \"myTime\";\n        FieldTransform::SetToServerValue setValue(FieldTransform::REQUEST_TIME);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, setValue);\n        DocumentTransform transform(documentPath2, fieldTransforms);\n\n        writes.add(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // Serial.println(writes);\n\n        // All Writes, DocumentTransform and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.batchWrite(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);\n        }\n    }\n    ts = time(nullptr);\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\n    ts = WiFi.getTime();\n#endif"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "voltage",
        "delay"
      ],
      "libraries": [
        "Arduino_PMIC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  if (!PMIC.begin()) {\n    Serial.println(\"Failed to initialize PMIC!\");\n    while (1);\n  }\n\n  // Set the input current limit to 2 A and the overload input voltage to 3.88 V\n  if (!PMIC.setInputCurrentLimit(2.0)) {\n    Serial.println(\"Error in set input current limit\");\n  }\n\n  if (!PMIC.setInputVoltageLimit(3.88)) {\n    Serial.println(\"Error in set input voltage limit\");\n  }\n\n  // set the minimum voltage used to feeding the module embed on Board\n  if (!PMIC.setMinimumSystemVoltage(3.5)) {\n    Serial.println(\"Error in set minimum system volage\");\n  }\n\n  // Set the desired charge voltage to 4.11 V\n  if (!PMIC.setChargeVoltage(4.2)) {\n    Serial.println(\"Error in set charge volage\");\n  }\n\n  // Set the charge current to 375 mA\n  // the charge current should be defined as maximum at (C for hour)/2h\n  // to avoid battery explosion (for example for a 750 mAh battery set to 0.375 A)\n  if (!PMIC.setChargeCurrent(0.375)) {\n    Serial.println(\"Error in set charge current\");\n  }\n  Serial.println(\"Initialization done!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Enable the Charger\n  if (!PMIC.enableCharge()) {\n    Serial.println(\"Error enabling Charge mode\");\n  }\n  // canRunOnBattery() returns true if the battery voltage is < the minimum\n  // systems voltage\n  if (PMIC.canRunOnBattery()) {\n    // loop until charge is done\n    while (PMIC.chargeStatus() != CHARGE_TERMINATION_DONE) {\n      delay(1000);\n    }\n    // Disable the charger and loop forever\n    Serial.println(\"Disable Charge mode\");\n    if (!PMIC.disableCharge()) {\n      Serial.println(\"Error disabling Charge mode\");\n    }\n    while (1);\n    // if you really want to detach the battery call\n    // PMIC.disableBATFET();\n    //isbatteryconnected = false;\n  }\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "voltage",
        "millis",
        "delay",
        "interrupt"
      ],
      "libraries": [
        "Arduino_PMIC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n// Available only for MKRGSM1400 and MKRNB1500\n#if defined(ARDUINO_SAMD_MKRGSM1400) || defined(ARDUINO_SAMD_MKRNB1500)\n  // Attach the PMIC IRQ pin\n  attachInterrupt(digitalPinToInterrupt(PMIC_IRQ_PIN), batteryConnected, FALLING);\n#endif\n\n  if (!PMIC.begin()) {\n    Serial.println(\"Failed to initialize PMIC!\");\n    while (1);\n  }\n\n  // Set the input current limit to 2 A and the overload input voltage to 3.88 V\n  if (!PMIC.setInputCurrentLimit(2.0)) {\n    Serial.println(\"Error in set input current limit\");\n  }\n\n  if (!PMIC.setInputVoltageLimit(3.88)) {\n    Serial.println(\"Error in set input voltage limit\");\n  }\n\n  // set the minimum voltage used to feeding the module embed on Board\n  if (!PMIC.setMinimumSystemVoltage(3.5)) {\n    Serial.println(\"Error in set minimum system volage\");\n  }\n\n  // Set the desired charge voltage to 4.11 V\n  if (!PMIC.setChargeVoltage(4.2)) {\n    Serial.println(\"Error in set charge volage\");\n  }\n\n  // Set the charge current to 375 mA\n  // the charge current should be defined as maximum at (C for hour)/2h\n  // to avoid battery explosion (for example for a 750mAh battery set to 0.375 A)\n  if (!PMIC.setChargeCurrent(0.375)) {\n    Serial.println(\"Error in set charge current\");\n  }\n  Serial.println(\"Initialization done!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - time_last_interrupt > 100) {\n    // Enable the Charger\n    if (!PMIC.enableCharge()) {\n      Serial.println(\"Error enabling Charge mode\");\n    }\n\n    // canRunOnBattery() returns true if the battery voltage is < the minimum\n    // systems voltage\n    if (PMIC.canRunOnBattery()) {\n\n      // loop until charge is done\n      if (PMIC.chargeStatus() != CHARGE_TERMINATION_DONE) {\n        delay(1000);\n      } else {\n        // Disable the charger\n        Serial.println(\"Disable Charge mode\");\n        if (!PMIC.disableCharge()) {\n          Serial.println(\"Error disabling Charge mode\");\n        }\n        // if you really want to detach the battery call\n        // PMIC.disableBATFET();\n        //isbatteryconnected = false;\n      }\n    }\n  }\n  delay(100);"
        },
        {
          "name": "batteryConnected",
          "parameters": "",
          "body": "time_last_interrupt = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "energy",
        "current",
        "voltage",
        "bluetooth",
        "wifi",
        "ble",
        "digitalwrite",
        "millis",
        "analogread",
        "led",
        "clients",
        "devices"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);    // initialize serial communication\n  while (!Serial);\n\n  pinMode(LED_BUILTIN, OUTPUT); // initialize the built-in LED pin to indicate when a central is connected\n\n  // begin initialization\n  if (!BLE.begin()) {\n    Serial.println(\"starting BLE failed!\");\n\n    while (1);\n  }\n\n  /* Set a local name for the Bluetooth® Low Energy device\n     This name will appear in advertising packets\n     and can be used by remote devices to identify this Bluetooth® Low Energy device\n     The name can be changed but maybe be truncated based on space left in advertisement packet\n  */\n  BLE.setLocalName(\"BatteryMonitor\");\n  BLE.setAdvertisedService(batteryService); // add the service UUID\n  batteryService.addCharacteristic(batteryLevelChar); // add the battery level characteristic\n  BLE.addService(batteryService); // Add the battery service\n  batteryLevelChar.writeValue(oldBatteryLevel); // set initial value for this characteristic\n\n  /* Start advertising Bluetooth® Low Energy.  It will start continuously transmitting Bluetooth® Low Energy\n     advertising packets and will be visible to remote Bluetooth® Low Energy central devices\n     until it receives a new connection */\n\n  // start advertising\n  BLE.advertise();\n\n  Serial.println(\"Bluetooth® device active, waiting for connections...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// wait for a Bluetooth® Low Energy central\n  BLEDevice central = BLE.central();\n\n  // if a central is connected to the peripheral:\n  if (central) {\n    Serial.print(\"Connected to central: \");\n    // print the central's BT address:\n    Serial.println(central.address());\n    // turn on the LED to indicate the connection:\n    digitalWrite(LED_BUILTIN, HIGH);\n\n    // check the battery level every 200ms\n    // while the central is connected:\n    while (central.connected()) {\n      long currentMillis = millis();\n      // if 200ms have passed, check the battery level:\n      if (currentMillis - previousMillis >= 200) {\n        previousMillis = currentMillis;\n        updateBatteryLevel();\n      }\n    }\n    // when the central disconnects, turn off the LED:\n    digitalWrite(LED_BUILTIN, LOW);\n    Serial.print(\"Disconnected from central: \");\n    Serial.println(central.address());\n  }"
        },
        {
          "name": "updateBatteryLevel",
          "parameters": "",
          "body": "/* Read the current voltage level on the A0 analog input pin.\n     This is used here to simulate the charge level of a battery.\n  */\n  int battery = analogRead(A0);\n  int batteryLevel = map(battery, 0, 1023, 0, 100);\n\n  if (batteryLevel != oldBatteryLevel) {      // if the battery level has changed\n    Serial.print(\"Battery Level % is now: \"); // print it\n    Serial.println(batteryLevel);\n    batteryLevelChar.writeValue(batteryLevel);  // and update the battery level characteristic\n    oldBatteryLevel = batteryLevel;           // save the level for next comparison\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "voltage",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    const uint32_t startNow { millis() + 2500 };\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Checking Power Supply and Solar Charger status\");\n\n    EdgeControl.begin();\n    Power.on(PWR_VBAT);\n    Power.on(PWR_3V3);\n\n    Wire.begin();\n    delay(500);\n\n    Serial.print(\"I/O Expander initializazion \");\n    while (!Expander.begin()) {\n        Serial.println(\"failed.\");\n        Serial.println(\"Please, be sure to enable gated 3V3 and 5V power rails\");\n        Serial.println(\"via Power.on(PWR_3V3) and Power.on(PWR_VBAT).\");\n        delay(500);\n    }\n    Serial.println(\"succeeded.\");\n\n    Expander.pinMode(EXP_FAULT_SOLAR_PANEL, INPUT);\n    Expander.pinMode(EXP_FAULT_5V, INPUT);\n\n    printNow = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() > printNow) {\n        auto vbat = Power.getVBat();\n        Serial.print(\"Battery Voltage: \");\n        Serial.println(vbat);\n\n        auto solarStatus = Power.getSolarChargerStatus();\n        Serial.print(\"Solar Panel Charger Status: \");\n        Serial.println(solarStatus ? \"OK\" : \"Error\");\n\n        auto fiveVoltsStatus = Power.get5VoltStatus();\n        Serial.print(\"5V Power Rail Status: \");\n        Serial.println(fiveVoltsStatus ? \"OK\" : \"Error\");\n\n        printNow = millis() + printInterval;\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "voltage",
        "power",
        "delay",
        "led"
      ],
      "libraries": [
        "ArduinoMotorCarrier.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  //while (!Serial);\n\n  if (controller.begin())\n  {\n    Serial.print(\"Nano Motor Shield connected, firmware version \");\n    Serial.println(controller.getFWVersion());\n  }\n  else\n  {\n    Serial.println(\"Couldn't connect! Is the red led blinking? You may need to update the firmware with FWUpdater sketch\");\n    while (1);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "batteryVoltage = battery.getRaw()/236.0;\n  Serial.print(\"Battery voltage: \");\n  Serial.print(batteryVoltage,3);\n  //Serial.println(\"V\");\n  Serial.print(\"V, Raw \");\n  Serial.println(battery.getRaw());\n  delay(5000); //wait for a few seconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // initialize the sound speaker\n  Robot.beginSpeaker();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Robot.beep(BEEP_SIMPLE);\n  delay(1000);\n  Robot.beep(BEEP_DOUBLE);\n  delay(1000);\n  Robot.beep(BEEP_LONG);\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "flash"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize Bell 202 modem\n  Serial.print(F(\"[Bell 202] Initializing ... \"));\n  state = bell.begin(Bell202);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[Bell 202] Sending data ... \"));\n\n  // send out idle condition for 500 ms\n  bell.idle();\n  delay(500);\n\n  // BellClient supports all methods of the Serial class\n\n  // Arduino String class\n  String aStr = \"Arduino String\";\n  bell.println(aStr);\n\n  // character array (C-String)\n  bell.println(\"C-String\");\n\n  // string saved in flash\n  bell.println(F(\"Flash String\"));\n\n  // character\n  bell.println('c');\n\n  // byte\n  // formatting DEC/HEX/OCT/BIN is supported for\n  // any integer type (byte/int/long)\n  bell.println(255, HEX);\n\n  // integer number\n  int i = 1000;\n  bell.println(i);\n\n  // floating point number\n  float f = -3.1415;\n  bell.println(f, 3);\n\n  // ITA2-encoded string\n  ITA2String str(\"HELLO WORLD!\");\n  bell.print(str);\n\n  // turn the transmitter off\n  bell.standby();\n\n  Serial.println(F(\"done!\"));\n\n  // wait for a second before transmitting again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "parse"
      ],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "handleNoteOn",
          "parameters": "byte inChannel, byte inNote, byte inVelocity",
          "body": "gTime_stop = micros();\n\n    const unsigned long diff = gTime_stop - gTime_start;\n    gTime_sum += diff;\n\n    if (diff > gTime_max) gTime_max = diff;\n    if (diff < gTime_min) gTime_min = diff;\n\n    if (gCounter++ >= 1000)\n    {\n        const unsigned long average = gTime_sum / (float)gCounter;\n\n        Serial.println(\"Time to receive NoteOn: \");\n\n        Serial.print(\"Average: \");\n        Serial.print(average);\n        Serial.println(\" microsecs\");\n\n        Serial.print(\"Min:     \");\n        Serial.print(gTime_min);\n        Serial.println(\" microsecs\");\n\n        Serial.print(\"Max:     \");\n        Serial.print(gTime_max);\n        Serial.println(\" microsecs\");\n\n        gCounter = 0;\n        gTime_sum = 0;\n        gTime_max = 0;\n        gTime_min = -1;\n\n        midiBench.turnThruOff();\n    }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "midiBench.setHandleNoteOn(handleNoteOn);\n    midiBench.begin();\n\n    Serial.begin(115200);\n    while(!Serial);\n    Serial.println(\"Arduino Ready\");\n\n    midiBench.sendNoteOn(69,127,1);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "gTime_start = micros();\n    midiBench.read();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "subscribe",
        "publish",
        "digitalwrite",
        "delay",
        "millis",
        "analogread"
      ],
      "libraries": [
        "ObloqAdafruit.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "mensajeRecibido",
          "parameters": "const String& topic,const String& mensaje",
          "body": "if(topic==\"lampara\"){\n      if(mensaje==\"ON\"){\n        digitalWrite(13,1);\n      }else{\n        digitalWrite(13,0);\n      }\n    }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "softSerial.begin(9600);\n    olq.setMsgHandle(mensajeRecibido);\n    olq.subscribe(\"lampara\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "olq.update();\n\n    // no usar delay!, chequear el tiempo transcurrido con millis()\n    if(millis() - millisAnterior > 5000)\n    {\n        olq.publish(\"temperatura\", analogRead(A0));\n        millisAnterior =  millis();\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "pressure",
        "light",
        "current",
        "tone",
        "delay",
        "millis",
        "led",
        "rgb",
        "html",
        "bootstrap"
      ],
      "libraries": [
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "playNote",
          "parameters": "int frequency, int duration, bool hold=false, bool measure=true",
          "body": "// Check if the slide switch is off or the candles have been blown out\n  // and stop immediately without playing anything.\n  if (!CircuitPlayground.slideSwitch() || lit < 0) {\n    return;\n  }\n  if (hold) {\n    // For a note that's held play it a little longer than the specified duration\n    // so it blends into the next tone (but there's still a small delay to \n    // hear the next note).\n    CircuitPlayground.playTone(frequency, duration + duration/32, false);\n  }\n  else {\n    // For a note that isn't held just play it for the specified duration.\n    CircuitPlayground.playTone(frequency, duration, false);\n  }\n  // Use waitBreath instead of Arduino's delay because breath detection and\n  // pixel animation needs to occur while music plays.  However skip this logic\n  // if not asked for (measure = false, only needed when playing celebration\n  // song so as to not continue waiting for breaths).\n  if (measure) {\n    waitBreath(duration + duration/16);\n  }\n  else {\n    delay(duration + duration/16);\n  }"
        },
        {
          "name": "waitBreath",
          "parameters": "uint32_t milliseconds",
          "body": "float peakToPeak = measurePeak(milliseconds);\n  // Serial.println(peakToPeak);\n  while (peakToPeak >= BREATH_THRESHOLD) {\n    // Decrement the number of lit candles and keep it from going below\n    // the value -1 (a sentinel that indicates all the candles are blown out\n    // and no music playback, etc. should occur anymore).\n    lit = max(lit-1, -1);\n    // For the simple solid color animation (i.e. no flickering) only update\n    // the pixels when the lit pixel count changes.  This allows the tone\n    // playback to sound better because the pixels don't need to be updated\n    // during delays and music note playback (the pixel writing messes with\n    // interrupts that drive tone playback and cause scratchier sounding tones).\n    if (animation == SOLID) {\n      showLitSolid();\n    }\n    // Check if we just hit 0 candles lit up, i.e. they're all blown out.\n    // Turn off the pixels and play a little celebration tune when it \n    // happens, then indicate the candles are blown out with the -1 sentinel value.\n    if (lit == 0) {\n      CircuitPlayground.clearPixels();\n      celebrateSong();\n      lit = -1;\n    }\n    // Keep measuring the peak to peak sound value for a period of time\n    // that it takes to blow out another candle.\n    peakToPeak = measurePeak(FLAME_LIFE_MS);\n  }"
        },
        {
          "name": "celebrateSong",
          "parameters": "",
          "body": "// Play a little charge melody, from:\n  //  https://en.wikipedia.org/wiki/Charge_(fanfare)\n  // Note the explicit boolean parameters in particular the measure=false\n  // at the end.  This means the notes will play without any breath measurement\n  // logic.  Without this false value playNote will try to keep waiting for candles\n  // to blow out during the celebration song!\n  playNote(NOTE_G4, EIGHTH_TRIPLE, true, false);\n  playNote(NOTE_C5, EIGHTH_TRIPLE, true, false);\n  playNote(NOTE_E5, EIGHTH_TRIPLE, false, false);\n  playNote(NOTE_G5, EIGHTH, true, false);\n  playNote(NOTE_E5, SIXTEENTH, false);\n  playNote(NOTE_G5, HALF, false);"
        },
        {
          "name": "measurePeak",
          "parameters": "uint32_t milliseconds",
          "body": "float soundMax = 0;\n  // Loop until the specified number of milliseconds have ellapsed.\n  uint32_t start = millis();\n  uint32_t current = start;\n  while ((current - start) < milliseconds) {\n    // Inside the loop check the sound pressure level 10ms at a time\n    float sample = CircuitPlayground.mic.soundPressureLevel(10);\n    Serial.println(sample);\n    soundMax = max(sample, soundMax);\n    // Be sure to drive the NeoPixel animation too.\n    animatePixels(current);\n    current = millis();\n  }\n  return soundMax;"
        },
        {
          "name": "animatePixels",
          "parameters": "uint32_t current",
          "body": "switch (animation) {\n    case FLICKER:\n      showLitFlicker(current);\n      break;\n    case RAINBOW:\n      showLitRainbow(current);\n      break;\n    // Ignore the SOLID case as it has no animation.\n    // This makes the audio smoother since it doesn't get interrupted by\n    // NeoPixel writing like the other animations.  The pixels are instead\n    // changed only once when the number of lit candles changes (see the\n    // waitBreath function's loop).\n    default: break;\n  }"
        },
        {
          "name": "setPixelHSV",
          "parameters": "int i, float h, float s, float v",
          "body": "// Convert HSV to RGB\n  float r, g, b = 0.0;\n  HSVtoRGB(&r, &g, &b, h, s, v);\n  // Lookup gamma correct RGB colors (also convert from 0...1.0 RGB range to 0...255 byte range).\n  uint8_t r1 = pgm_read_byte(&gamma8[int(r*255.0)]);\n  uint8_t g1 = pgm_read_byte(&gamma8[int(g*255.0)]);\n  uint8_t b1 = pgm_read_byte(&gamma8[int(b*255.0)]);\n  // Set the color of the pixel.\n  CircuitPlayground.strip.setPixelColor(i, r1, g1, b1);"
        },
        {
          "name": "showLitRainbow",
          "parameters": "uint32_t current",
          "body": "// Convert time from milliseconds to seconds.\n  float t = current/1000.0;\n  // Loop through each pixel and compute its color.\n  for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit, so compute its hue from the sine wave\n      // equation and set the color accordingly.  Notice the frequency\n      // is scaled down by 10 to 'slow down' the rainbow flicker animation.\n      // This lets the same random frequencies be shared between fast candle\n      // flame effects and this slower rainbow flicker effect.\n      float x  = sin(2.0*PI*frequencies[i]/10.0*t + phases[i]);\n      // Interpolate the sine wave between all 360 degree hue values.\n      float h = lerp(x, -1.0, 1.0, 0.0, 360.0);\n      setPixelHSV(i, h, 1.0, 1.0);\n    }\n    else {\n      // This pixel has been blown out, just turn it off.\n      setPixelHSV(i, 0, 0, 0);\n    }\n  }\n  CircuitPlayground.strip.show();"
        },
        {
          "name": "showLitFlicker",
          "parameters": "uint32_t current",
          "body": "// First determine the low and high bounds of the flicker hues.\n  // These are +/- 10 degrees of the specified target hue and will\n  // wrap around to the start/end as appropriate.\n  float lowHue = fmod(FLAME_HUE - 10.0, 360.0);\n  float highHue = fmod(FLAME_HUE + 10.0, 360.0);\n  // Convert time from milliseconds to seconds.\n  float t = current/1000.0;\n  // Loop through each pixel and compute its color.\n  for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit, so compute its hue by composing\n      // a low frequency / slowly changing sine wave with a high\n      // frequency / fast changing cosine wave.  This means the candle will\n      // pulse and jump around in an organice but random looking way.\n      // The frequencies and phases of the waves are randomly generated at\n      // startup in the setup function.\n      // Low frequency wave is a sine wave with random freuqency between 1 and 4,\n      // and offset by a random phase to keep pixels from all starting at the same\n      // color:\n      float lowFreq  = sin(2.0*PI*frequencies[i]*t + phases[i]);\n      // High frequency is a faster changing cosine wave that uses a different\n      // pixel's random frequency.\n      float highFreq = cos(3.0*PI*frequencies[(i+5)%10]*t);\n      // Add the low and high frequency waves together, then interpolate their value\n      // to a hue that's +/-20% of the configured target hue.\n      float h = lerp(lowFreq+highFreq, -2.0, 2.0, lowHue, highHue);\n      setPixelHSV(i, h, 1.0, 1.0);\n    }\n    else {\n      // This pixel has been blown out, just turn it off.\n      setPixelHSV(i, 0, 0, 0);\n    }\n  }\n  CircuitPlayground.strip.show();"
        },
        {
          "name": "showLitSolid",
          "parameters": "",
          "body": "for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit.\n      setPixelHSV(i, FLAME_HUE, 1.0, 1.0);\n    }\n    else {\n      // This pixel has been blown out, just turn it off.\n      setPixelHSV(i, 0, 0, 0);\n    }\n  }\n  CircuitPlayground.strip.show();"
        },
        {
          "name": "HSVtoRGB",
          "parameters": "float *r, float *g, float *b, float h, float s, float v",
          "body": "int i;\n  float f, p, q, t;\n  if( s == 0 ) {\n    // achromatic (grey)\n    *r = *g = *b = v;\n    return;\n  }\n  h /= 60;      // sector 0 to 5\n  i = floor( h );\n  f = h - i;      // factorial part of h\n  p = v * ( 1 - s );\n  q = v * ( 1 - s * f );\n  t = v * ( 1 - s * ( 1 - f ) );\n  switch( i ) {\n    case 0:\n      *r = v;\n      *g = t;\n      *b = p;\n      break;\n    case 1:\n      *r = q;\n      *g = v;\n      *b = p;\n      break;\n    case 2:\n      *r = p;\n      *g = v;\n      *b = t;\n      break;\n    case 3:\n      *r = p;\n      *g = q;\n      *b = v;\n      break;\n    case 4:\n      *r = t;\n      *g = p;\n      *b = v;\n      break;\n    default:    // case 5:\n      *r = v;\n      *g = p;\n      *b = q;\n      break;\n  }"
        },
        {
          "name": "lerp",
          "parameters": "float x, float x0, float x1, float y0, float y1",
          "body": "return y0 + (x-x0)*((y1-y0)/(x1-x0));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize serial output and Circuit Playground library.\n  Serial.begin(115200);\n  CircuitPlayground.begin();\n  // Check if a button is being pressed at startup and change the\n  // animation mode accordingly.\n  if (CircuitPlayground.leftButton()) {\n    // Rainbow animation on left button press at startup.\n    animation = RAINBOW;\n  }\n  else if (CircuitPlayground.rightButton()) {\n    // Solid color animation on right button press at startup.\n    animation = SOLID;\n    // Since the solid animation doesn't update every frame, bootstrap it by\n    // turning all the pixels on at the start.  As candles are blown out the\n    // pixels will be updated (see the waitBreath function's loop).\n    showLitSolid();\n  }\n  else {\n    // Otherwise default to flicker animation.\n    animation = FLICKER;\n  }\n  // Read the sound sensor and use it to initialize the random number generator.\n  randomSeed(CircuitPlayground.soundSensor());\n  // Precompute random frequency and phase values for each pixel.\n  // This gives the flicker an organic but random looking appearance.\n  for (int i=0; i<10; ++i) {\n    // Generate random floating point frequency values between 1.0 and 4.0.\n    frequencies[i] = random(1000, 4000)/1000.0;\n    // Generate random floating point phase values between 0 and 2*PI.\n    phases[i] = random(1000)/1000.0 * 2.0 * PI;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Play happy birthday tune, from:\n  //  http://www.irish-folk-songs.com/happy-birthday-tin-whistle-sheet-music.html#.WXFJMtPytBw\n  // Inside each playNote call it will play a note and drive the NeoPixel animation\n  // and check for a breath against the sound sensor.  Once all the candles are blown out\n  // the playNote calls will stop playing music.\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_E4, QUARTER);       // Bar 1\n  playNote(NOTE_D4, QUARTER);\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_FS4, HALF);         // Bar 2\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_E4, QUARTER);       // Bar 3\n  playNote(NOTE_D4, QUARTER);\n  playNote(NOTE_A4, QUARTER);\n  playNote(NOTE_G4, HALF);          // Bar 4\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_D5, QUARTER);       // Bar 5\n  playNote(NOTE_B4, QUARTER);\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_FS4, QUARTER);      // Bar 6\n  playNote(NOTE_E4, QUARTER);\n  playNote(NOTE_C5, EIGHTH, true);\n  playNote(NOTE_C5, EIGHTH);\n  playNote(NOTE_B4, QUARTER);       // Bar 7\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_A4, QUARTER);\n  playNote(NOTE_G4, HALF);          // Bar 8\n  // One second pause before repeating the loop and playing\n  // the tune again.  Use waitBreath instead of delay so the\n  // pixel animation and breath check continues to happen.\n  waitBreath(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "buffer",
        "delay",
        "flash"
      ],
      "libraries": [
        "Audio.h",
        "Adafruit_Keypad.h",
        "Adafruit_SPIFlash_FatFs.h",
        "Adafruit_QSPI_GD25Q.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // open the serial\n\n  customKeypad.begin();\n\n  // Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(40); //this is WAY more tha nwe need\n  // Initialize flash library and check its chip ID.\n  if (!flash.begin()) {\n    while(1){\n      Serial.println(\"Error, failed to initialize flash chip!\");\n      delay(1000);\n    }\n  }\n  flash.setFlashType(FLASH_TYPE);\n\n  // First call begin to mount the filesystem.  Check that it returns true\n  // to make sure the filesystem was mounted.\n  if (!pythonfs.begin()) {\n    while(1){\n      Serial.println(\"Failed to mount filesystem!\");\n      Serial.println(\"Was CircuitPython loaded on the board first to create the filesystem?\");\n    }\n  }\n  Serial.println(\"Mounted filesystem!\");\n\n  playWav1.useFilesystem(&pythonfs);\n  \n  // Bitcrusher\n  left_BitCrusher.bits(current_CrushBits); //set the crusher to defaults. This will passthrough clean at 16,44100\n  left_BitCrusher.sampleRate(current_SampleRate); //set the crusher to defaults. This will passthrough clean at 16,44100\n  right_BitCrusher.bits(current_CrushBits); //set the crusher to defaults. This will passthrough clean at 16,44100\n  right_BitCrusher.sampleRate(current_SampleRate); //set the crusher to defaults. This will passthrough clean at 16,44100\n  //Bitcrusher\n\n\n  /* Valid values for dap_avc parameters\n\n\tmaxGain; Maximum gain that can be applied\n\t0 - 0 dB\n\t1 - 6.0 dB\n\t2 - 12 dB\n\t\n\tlbiResponse; Integrator Response\n\t0 - 0 mS\n\t1 - 25 mS\n\t2 - 50 mS\n\t3 - 100 mS\n\t\n\thardLimit\n\t0 - Hard limit disabled. AVC Compressor/Expander enabled.\n\t1 - Hard limit enabled. The signal is limited to the programmed threshold (signal saturates at the threshold)\n\t\n\tthreshold\n\tfloating point in range 0 to -96 dB\n\t\n\tattack\n\tfloating point figure is dB/s rate at which gain is increased\n\t\n\tdecay\n\tfloating point figure is dB/s rate at which gain is reduced\n*/"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "customKeypad.tick();\n  \n  while(customKeypad.available())\n  {\n    keypadEvent e = customKeypad.read();\n    if(e.bit.EVENT == KEY_JUST_PRESSED){\n        if(e.bit.KEY == 1){\n          //Bitcrusher BitDepth\n          if (current_CrushBits >= 2) { //eachtime you press it, deduct 1 bit from the settings.\n              current_CrushBits--;\n          } else {\n            current_CrushBits = 16; // if you get down to 1 go back to the top.\n          }\n      \n          left_BitCrusher.bits(current_CrushBits);\n          left_BitCrusher.sampleRate(current_SampleRate);\n          right_BitCrusher.bits(current_CrushBits);\n          right_BitCrusher.sampleRate(current_SampleRate);\n          Serial.print(\"Bitcrusher set to \");\n          Serial.print(current_CrushBits);\n          Serial.print(\" Bit, Samplerate at \");\n          Serial.print(current_SampleRate);\n          Serial.println(\"Hz\");\n        }\n        else if(e.bit.KEY == 2){\n          //Bitcrusher SampleRate // the lowest sensible setting is 345. There is a 128 sample buffer, and this will copy sample 1, to each of the other 127 samples.\n          if (current_SampleRate >= 690) { // 345 * 2, so we can do one more divide\n            current_SampleRate = current_SampleRate / 2; // half the sample rate each time\n          } else {\n            current_SampleRate=44100; // if you get down to the minimum then go back to the top and start over.\n          }\n      \n          left_BitCrusher.bits(current_CrushBits);\n          left_BitCrusher.sampleRate(current_SampleRate);\n          right_BitCrusher.bits(current_CrushBits);\n          right_BitCrusher.sampleRate(current_SampleRate);\n          Serial.print(\"Bitcrusher set to \");\n          Serial.print(current_CrushBits);\n          Serial.print(\" Bit, Samplerate at \");\n          Serial.print(current_SampleRate);\n          Serial.println(\"Hz\");\n        }\n      }\n  }\n\n  // Start test sound if it is not playing. This will loop infinitely.\n  if (! (playWav1.isPlaying())){\n    playWav1.play(\"A4-49-96.wav\");\n  }\n\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "key",
        "power",
        "dns",
        "nodebug_websockets",
        "deviceid"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "SinricPro_Generic.h",
        "SinricProBlinds.h"
      ],
      "functions": [
        {
          "name": "onPowerState",
          "parameters": "const String &deviceId, bool &state",
          "body": "Serial.printf(\"Device %s power turned %s \\r\\n\", deviceId.c_str(), state ? \"on\" : \"off\");\n  powerState = state;\n  return true; // request handled properly"
        },
        {
          "name": "onSetPosition",
          "parameters": "const String &deviceId, int &position",
          "body": "Serial.printf(\"Device %s set position to %d\\r\\n\", deviceId.c_str(), position);\n  return true; // request handled properly"
        },
        {
          "name": "onAdjustPosition",
          "parameters": "const String &deviceId, int &positionDelta",
          "body": "blindsPosition += positionDelta;\n  Serial.printf(\"Device %s position changed about %i to %d\\r\\n\", deviceId.c_str(), positionDelta, blindsPosition);\n  positionDelta = blindsPosition; // calculate and return absolute position\n  \n  return true; // request handled properly"
        },
        {
          "name": "setupETH",
          "parameters": "",
          "body": "Serial.print(\"[ETH]: Connecting\");\n  \n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n  \n  Serial.print(\"[ETH]: IP-Address is \");\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "setupSinricPro",
          "parameters": "",
          "body": "// get a new Blinds device from SinricPro\n  SinricProBlinds &myBlinds = SinricPro[BLINDS_ID];\n  myBlinds.onPowerState(onPowerState);\n  myBlinds.onSetPosition(onSetPosition);\n  myBlinds.onAdjustPosition(onAdjustPosition);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");\n  });\n  \n  SinricPro.onDisconnected([]() \n  {\n    Serial.println(\"Disconnected from SinricPro\");\n  });\n  \n  SinricPro.begin(APP_KEY, APP_SECRET);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.print(F(\"\\nStart Blinds on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(SINRICPRO_VERSION_STR);\n  \n  setupETH();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SinricPro.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "led"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//nothing here"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "led.on();       // set the LED on\n  delay(1000);    // wait for a second\n  led.off();      // set the LED off\n  delay(1000);    // wait for a second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogread",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  randomSeed(analogRead(0));\n\n#ifdef CORE_CM7\n  bootM4();\n  myLED = LEDB; // built-in blue LED\n#endif\n#ifdef CORE_CM4\n  myLED = LEDG; // built-in greeen LED\n#endif\n  pinMode(myLED, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  digitalWrite(myLED, LOW); // turn the LED on\n  delay(200);\n  digitalWrite(myLED, HIGH); // turn the LED off\n  delay( rand() % 2000 + 1000); // wait for a random amount of time between 1 and 3 seconds."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "power",
        "voltage",
        "delay",
        "digitalwrite",
        "led",
        "html"
      ],
      "libraries": [
        "loopTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  for (int i = 10; i > 0; i--) {\n    Serial.println(i);\n    delay(500);\n  }\n  // initialize digital pin led as an output.\n  pinMode(led, OUTPUT);"
        },
        {
          "name": "blinkLed13",
          "parameters": "",
          "body": "digitalWrite(led, HIGH);   // turn the led on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(led, LOW);    // turn the led off by making the voltage LOW\n  delay(1000);                       // wait for a second"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "loopTimer.check(Serial);\n  blinkLed13(); // call the method to blink the led"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "voltage",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n    pinMode(LEDG, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalWrite(LEDG, LOW); // turn the LED on (LOW is the voltage level)\n    delay(500); // wait for half a second\n    digitalWrite(LEDG, HIGH); // turn the LED off by making the voltage HIGH\n    delay(500); // wait for half a second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial1.begin(9600);\n      pinMode(LED_BUILTIN, OUTPUT);\n      digitalWrite(LED_BUILTIN, LOW);\n\n      delay(1000);\n    }\n\n    void loop() {\n      if (Serial1.available()) {\n        auto c = Serial1.read();\n        digitalWrite(LED_BUILTIN, c);\n      }\n    }\n*\n*\n*/\n\n#include <Arduino_EdgeControl.h>\n\nbool led { false };\n\nvoid setup()\n{\n    EdgeControl.begin();\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_MKR2);\n\n    // Wait for MKR to power on\n    delay(5000);\n\n    SerialMKR2.begin(115200);\n    while (!SerialMKR2) {\n        delay(500);\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SerialMKR2.write(led);\n    led = !led;\n    delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "voltage",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n  bootM4();\n  pinMode(LEDR, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalWrite(LEDR, LOW); // turn the red LED on (LOW is the voltage level)\n  delay(200); // wait for 200 milliseconds\n  digitalWrite(LEDR, HIGH); // turn the LED off by setting the voltage HIGH\n  delay(200); // wait for 200 milliseconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "voltage",
        "digitalwrite",
        "delay",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n  pinMode(LEDR, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "digitalWrite(LEDR, HIGH); // turn the LED off (HIGH is the voltage level)\n  delay(200); // wait for 200 milliseconds\n  digitalWrite(LEDR, LOW); // turn the LED on by making the voltage LOW\n  delay(200); // wait for 200 milliseconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "digitalread",
        "led"
      ],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n\n  t.setInterval([]() { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); },\n                1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay",
        "digitalwrite",
        "led"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LEDpin, OUTPUT);\n  LEDtime.start();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if(LEDtime.update())//Checks to see if set time has past\n  {\n    // if the LED is off turn it on and vice-versa:\n    if (ledState == LOW)\n      ledState = HIGH;\n    else\n      ledState = LOW;\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(LEDpin, ledState);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay",
        "digitalwrite",
        "led",
        "nodelay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LEDpin, OUTPUT);\n  LEDtime.start();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "LEDtime.update();//will check if set time has past and if so will run set function"
        },
        {
          "name": "ledBlink",
          "parameters": "",
          "body": "// if the LED is off turn it on and vice-versa:\n    if (ledState == LOW)\n      ledState = HIGH;\n    else\n      ledState = LOW;\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(LEDpin, ledState);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay",
        "digitalwrite",
        "led",
        "nodelay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LEDpin, OUTPUT);\n  LEDtime.start();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "LEDtime.update();//will check if set time has past and if so will run set function"
        },
        {
          "name": "ledBlink",
          "parameters": "",
          "body": "// if the LED is off turn it on and vice-versa:\n    if (ledState == LOW)\n      ledState = HIGH;\n    else\n      ledState = LOW;\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(LEDpin, ledState);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "elk.h"
      ],
      "functions": [
        {
          "name": "myDelay",
          "parameters": "int milli",
          "body": "delay(milli);}\nvoid myWrite(int pin, int val) { digitalWrite(pin, val); }\nvoid myMode(int pin, int mode) { pinMode(pin, mode); }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "struct js *js = js_create(buf, sizeof(buf));\n  jsval_t global = js_glob(js), gpio = js_mkobj(js);    // Equivalent to:\n  js_set(js, global, \"gpio\", gpio);                     // let gpio = {};\n  js_set(js, global, \"delay\", js_import(js, (uintptr_t) myDelay, \"vi\"));\n  js_set(js, gpio, \"mode\", js_import(js, (uintptr_t) myMode, \"vii\"));\n  js_set(js, gpio, \"write\", js_import(js, (uintptr_t) myWrite, \"vii\"));\n\n  js_eval(js, \"let pin = 13;\"     // LED pin. Usually 13, but double-check\n          \"gpio.mode(pin, 1);\"    // Set OUTPUT mode on a LED pin\n          \"while (true) {\"\n          \"  delay(300);\"\n          \"  gpio.write(pin, 1);\"\n          \"  delay(300);\"\n          \"  gpio.write(pin, 0);\"\n          \"}\",\n          ~0);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "database",
        "payload",
        "callback",
        "buffer",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the api key (required) */\n  config.api_key = API_KEY;\n\n  /* Assign the user sign in credentials */\n  auth.user.email = USER_EMAIL;\n  auth.user.password = USER_PASSWORD;\n\n  /* Assign the RTDB URL (required) */\n  config.database_url = DATABASE_URL;\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  // Or use legacy authenticate method\n  // config.database_url = DATABASE_URL;\n  // config.signer.tokens.legacy_token = \"<database secret>\";\n\n  // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n  Firebase.begin(&config, &auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && (millis() - sendDataPrevMillis > 15000 || sendDataPrevMillis == 0))\n  {\n    sendDataPrevMillis = millis();\n\n    // Create demo data\n    uint8_t data[256];\n    for (int i = 0; i < 256; i++)\n      data[i] = count;\n\n    Serial.printf(\"Set BLOB... %s\\n\", Firebase.setBlob(fbdo, \"/test/blob\", data, sizeof(data)) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get BLOB... %s\\n\", Firebase.getBlob(fbdo, \"/test/blob\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK) // 200\n      printResult(fbdo);                                // see addons/RTDBHelper.h\n\n    Serial.println();\n\n    (count < 255) ? count++ : count = 0;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "rest",
        "https",
        "delay",
        "digitalwrite",
        "led",
        "html"
      ],
      "libraries": [
        "millisDelay.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the digital pin as an output.\n  Serial.begin(9600);\n  // wait a few sec to let user open the monitor\n  for (int i = 5; i > 0; i--) {\n    delay(1000);\n    Serial.print(i); Serial.print(' ');\n  }\n  Serial.println();\n\n  Serial.println(\"Enter R to turn LED on for 1sec\");\n  Serial.println(\" After LED goes off it is blocked from turning on again for 10sec\");\n\n  pinMode(led, OUTPUT);\n  digitalWrite(led, LOW);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ledBlockOnDelay.justFinished(); // check for timeout and set isRunning() false when timed out\n\n  if (ledOnDelay.justFinished()) { // don't combine this test with any other condition\n    // on delay timed out\n    digitalWrite(led, LOW); // turn led off\n    Serial.println(\"ledOnDelay finished, LED turned off.\");\n    ledBlockOnDelay.start(BLOCKING_DELAY_TIME);\n  }\n\n  char c = 0;\n  if (Serial.available()) {\n    c = Serial.read();\n    while (Serial.available()) {\n      Serial.read(); // clear rest on input\n    }\n  }\n\n  if ((c == 'R') || (c == 'r')) {\n    if (ledBlockOnDelay.isRunning()) {\n      Serial.print(\"LED blocked from turning on for next \"); Serial.print(ledBlockOnDelay.remaining()); Serial.println(\"ms\");\n    } else {\n      // can turn led on again\n      ledOnDelay.start(LED_ON_DELAY_TIME);\n      digitalWrite(led, HIGH); // turn let on\n      Serial.println(\"ledDelay.start(....) called and Led turned ON\");\n    }\n  } else if ((c == '\\n') || (c == '\\r')) {\n    // skip end of line chars\n  } else if (c != 0) {\n    Serial.print(\"Invalid cmd:\"); Serial.println(c);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token"
      ],
      "libraries": [
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial1.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "http",
        "https",
        "json",
        "temperature",
        "voltage",
        "analogread",
        "analogwrite",
        "delay"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Ciao.begin();  //Start the serial connection with the computer\n                       //to view the result open the serial monitor\n  pinMode(9,OUTPUT);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "blynk",
        "api",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "payload",
        "stream",
        "callback",
        "buffer",
        "database",
        "wifi",
        "delay",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  pinMode(BuiltIn_LED, OUTPUT);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the api key (required) */\n  config.api_key = API_KEY;\n\n  /* Assign the user sign in credentials */\n  auth.user.email = USER_EMAIL;\n  auth.user.password = USER_PASSWORD;\n\n  /* Assign the RTDB URL (required) */\n  config.database_url = DATABASE_URL;\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  // Or use legacy authenticate method\n  // config.database_url = DATABASE_URL;\n  // config.signer.tokens.legacy_token = \"<database secret>\";\n\n  // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n  Firebase.begin(&config, &auth);\n\n  if (!Firebase.beginStream(stream, \"/test/blynk/int\"))\n    Serial.printf(\"sream begin error, %s\\n\\n\", stream.errorReason().c_str());\n\n  Blynk.begin(BLYNK_AUTH, WIFI_SSID, WIFI_PASSWORD);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n\n  // Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready())\n  {\n    if (!Firebase.readStream(stream))\n      Serial.printf(\"sream read error, %s\\n\\n\", stream.errorReason().c_str());\n\n    if (stream.streamTimeout())\n      Serial.println(\"stream timeout, resuming...\\n\");\n\n    if (stream.streamAvailable())\n    {\n\n      Serial.printf(\"sream path, %s\\nevent path, %s\\ndata type, %s\\nevent type, %s\\nvalue, %d\\n\\n\",\n                    stream.streamPath().c_str(),\n                    stream.dataPath().c_str(),\n                    stream.dataType().c_str(),\n                    stream.eventType().c_str(),\n                    stream.intData());\n\n      if (stream.dataType() == \"int\")\n      {\n        if (stream.intData() == 1)\n        {\n          digitalWrite(BuiltIn_LED, HIGH);\n          led.on();\n        }\n        else\n        {\n          digitalWrite(BuiltIn_LED, LOW);\n          led.off();\n        }\n      }\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "bluetooth",
        "spi",
        "delay",
        "led"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// See the connection status in Serial Monitor\n  Serial.begin(9600);\n\n  // Here your Arduino connects to the Blynk Cloud.\n  Blynk.begin(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// All the Blynk Magic happens here...\n  Blynk.run();\n\n  // You can inject your own code or combine it with other sketches.\n  // Check other examples on how to communicate with Blynk. Remember\n  // to avoid delay() function!"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "buffer",
        "millis",
        "flash"
      ],
      "libraries": [
        "BlynkSimpleUserDefined.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Blynk.begin(auth);\n  Blynk.connect();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bool hasIncomingData = (test > 0);\n\n  if (!Blynk.run(hasIncomingData)) {\n\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "wifi",
        "gsm",
        "bluetooth",
        "ble",
        "gprs",
        "delay"
      ],
      "libraries": [
        "TinyGsmClient.h",
        "BlynkSimpleTinyGSM.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n  delay(6000);\n\n  // Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  SerialMon.println(\"Initializing modem...\");\n  modem.restart();\n\n  String modemInfo = modem.getModemInfo();\n  SerialMon.print(\"Modem Info: \");\n  SerialMon.println(modemInfo);\n\n  // Unlock your SIM card with a PIN\n  // modem.simUnlock(\"1234\");\n\n  Blynk.begin(auth, modem, apn, user, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "auth",
        "stream",
        "wifi",
        "millis",
        "flash"
      ],
      "libraries": [
        "BlynkSimpleUserDefined.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Blynk.begin(auth);\n  Blynk.connect();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bool hasIncomingData = (test > 0);\n\n  if (!Blynk.run(hasIncomingData)) {\n\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "buffer",
        "gsm",
        "gprs",
        "delay",
        "digitalwrite",
        "millis",
        "sd"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "TinyGsmClient.h",
        "BlynkSimpleSIM800.h",
        "BlynkSimpleTinyGSM.h",
        "StreamDebugger.h",
        "ArduinoHttpClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(200);\n\n#if ( BLYNK_HTTP_CLIENT_USING_ETHERNET )  \n  Serial.print(F(\"\\nStart BlynkHTTPClient on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  #if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n    // Deselect the SD card\n    pinMode(SDCARD_CS, OUTPUT);\n    digitalWrite(SDCARD_CS, HIGH);\n  #endif\n\n#else\n  Serial.print(F(\"\\nStart BlynkHTTPClient on \")); Serial.print(BOARD_NAME);\n  Serial.println(F(\" using GSM/GPRS Modem\");\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n  delay(3000);\n\n  // Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  SerialMon.println(F(\"Initializing modem...\"));\n  modem.restart();\n\n  String modemInfo = modem.getModemInfo();\n  SerialMon.print(F(\"Modem: \"));\n  SerialMon.println(modemInfo);\n\n  // Unlock your SIM card with a PIN\n  //modem.simUnlock(\"1234\");\n#endif\n\n#if ( BLYNK_HTTP_CLIENT_USING_ETHERNET )\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(blynk_auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(blynk_auth);\n#endif\n#endif\n#else\n  Blynk.begin(blynk_gsm_auth, modem, apn, user, pass);\n#endif\n\n  if (Blynk.connected())\n    SerialMon.println(F(\"Blynk connected\"));"
        },
        {
          "name": "HTTPClientHandle",
          "parameters": "",
          "body": "#if !( BLYNK_HTTP_CLIENT_USING_ETHERNET )\n\n  SerialMon.print(F(\"Waiting for network...\"));\n  if (!modem.waitForNetwork())\n  {\n    SerialMon.println(F(\" fail\"));\n    return;\n  }\n\n  SerialMon.println(F(\" OK\"));\n\n  SerialMon.print(F(\"Connecting to \"));\n  SerialMon.print(apn);\n  if (!modem.gprsConnect(apn, user, pass))\n  {\n    SerialMon.println(F(\" fail\"));\n    return;\n  }\n  SerialMon.println(F(\" OK\"));\n#endif\n\n#define USE_DIRECT_CLIENT     true\n\n#if USE_DIRECT_CLIENT\n\n  // Test client directly, see Arduino_TinyGSM.ino\n  // https://github.com/Xinyuan-LilyGO/TTGO-T-Call/blob/master/examples/Arduino_TinyGSM/Arduino_TinyGSM.ino\n  // Just added\n  SerialMon.print(F(\"Connecting to \"));\n  SerialMon.print(http_server);\n  if (!client.connect(http_server, http_port))\n  {\n    SerialMon.println(F(\" fail\"));\n    //delay(10000);\n    return;\n  }\n  SerialMon.println(F(\" OK\"));\n\n  // Make a HTTP GET request:\n  SerialMon.println(F(\"Performing HTTP GET request...\"));\n  client.print(String(F(\"GET \")) + resource + F(\" HTTP/1.1\\r\\n\"));\n  client.print(String(F(\"Host: \")) + http_server + F(\"\\r\\n\"));\n  client.print(F(\"Connection: close\\r\\n\\r\\n\"));\n  client.println();\n\n  unsigned long timeout = millis();\n  while (client.connected() && millis() - timeout < 10000L)\n  {\n    // Print available data\n    while (client.available())\n    {\n      char c = client.read();\n      SerialMon.print(c);\n      timeout = millis();\n    }\n  }\n  SerialMon.println();\n\n  // Shutdown\n\n  client.stop();\n\n#else\n\n  SerialMon.print(F(\"Performing HTTP GET request... \"));\n  int err = http.get(resource);\n  \n  if (err != 0)\n  {\n    SerialMon.print(F(\"failed to connect, error = \"));\n    SerialMon.println(err);\n    return;\n  }\n\n  int status = http.responseStatusCode();\n  SerialMon.println(status);\n  \n  if (!status)\n  {\n    SerialMon.print(F(\"Status Code is: \"));\n    SerialMon.println(status);\n    return;\n  }\n\n  while (http.headerAvailable())\n  {\n    String headerName = http.readHeaderName();\n    String headerValue = http.readHeaderValue();\n    //SerialMon.println(headerName + \" : \" + headerValue);\n  }\n\n  int length = http.contentLength();\n  \n  if (length >= 0)\n  {\n    SerialMon.print(F(\"Content length is: \"));\n    SerialMon.println(length);\n  }\n\n  if (http.isResponseChunked())\n  {\n    SerialMon.println(F(\"The response is chunked\"));\n  }\n\n  String body = http.responseBody();\n  SerialMon.println(F(\"Response:\"));\n  SerialMon.println(body);\n\n  SerialMon.print(F(\"Body length is: \"));\n  SerialMon.println(body.length());\n\n  // Shutdown\n\n  http.stop();\n#endif\n\n  SerialMon.println(F(\"Server disconnected\"));\n\n#if !( BLYNK_HTTP_CLIENT_USING_ETHERNET )\n  modem.gprsDisconnect();\n  SerialMon.println(F(\"GPRS disconnected\"));\n#endif"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    HTTPClientHandle();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "password",
        "power",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "WiFi.h",
        "BlynkSimpleEsp32.h",
        "IRremoteESP8266.h",
        "IRsend.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "#if defined(BLYNK_PRINT)\n  // Debug console\n  Serial.begin(115200);\n#endif  // BLYNK_PRINT\n\n  Blynk.begin(auth, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "buffer",
        "callback",
        "power",
        "digitalwrite",
        "millis",
        "led"
      ],
      "libraries": [
        "ArduinoUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "SerialDbg.begin(115200);\n  waitSerialConsole(SerialDbg);\n\n  // Power-up NCP (if needed)\n#if defined(ARDUINO_NANO_RP2040_CONNECT)\n  pinMode(NINA_RESETN, OUTPUT);\n  digitalWrite(NINA_RESETN, HIGH);\n#endif\n\n  if (!ncpSetupSerial()) {\n    return;\n  }\n\n  const char* ncpFwVer = \"unknown\";\n  if (rpc_blynk_getNcpVersion(&ncpFwVer)) {\n    SerialDbg.print(F(\"NCP firmware: \"));\n    SerialDbg.println(ncpFwVer);\n  }\n\n  // Setup the indicator LED, user button (if needed)\n#if defined(ARDUINO_NANO_RP2040_CONNECT)\n  rpc_hw_initRGB(27, 25, 26, true);\n  rpc_hw_setLedBrightness(128);\n#elif defined(BLYNK_NCP_TYPE_WITTY_CLOUD)\n  rpc_hw_initUserButton(4, true);\n  rpc_hw_initRGB(15, 12, 13, false);\n#else\n  //rpc_hw_initUserButton(0, true);\n  //rpc_hw_initLED(19, false);\n  //rpc_hw_setLedBrightness(160);\n#endif\n\n  // Set config mode timeout to 30 minutes, for testing purposes\n  rpc_blynk_setConfigTimeout(30*60);\n\n  // Provide MCU firmware info to the NCP\n  // This info is mainly used for the Primary MCU OTA updates\n  rpc_blynk_setFirmwareInfo(BLYNK_FIRMWARE_TYPE,\n                            BLYNK_FIRMWARE_VERSION,\n                            BLYNK_FIRMWARE_BUILD_TIME,\n                            BLYNK_RPC_LIB_VERSION);\n\n  // White labeling (use this ONLY if you have a branded Blynk App)\n  //rpc_blynk_setVendorPrefix(\"MyCompany\");\n  //rpc_blynk_setVendorServer(\"dashboard.mycompany.com\");\n\n  // Product setup\n  if (!rpc_blynk_initialize(BLYNK_TEMPLATE_ID, BLYNK_TEMPLATE_NAME)) {\n    SerialDbg.println(F(\"rpc_blynk_initialize failed\"));\n  }"
        },
        {
          "name": "sendPeriodicMessage",
          "parameters": "",
          "body": "static uint32_t last_change = millis();\n  if (millis() - last_change > 10000) {\n    last_change += 10000;\n\n    // Send a value to Blynk Virtual Pin 1\n    virtualWrite(1, millis());\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "rpc_run();\n\n  sendPeriodicMessage();"
        },
        {
          "name": "rpc_client_blynkVPinChange_impl",
          "parameters": "uint16_t vpin, buffer_t param",
          "body": "// NOTE: we could copy the buffer, but we use 0-copy instead\n    // But we need to 0-terminate it, overwriting the CRC8\n    param.data[param.length] = '\\0';\n\n    SerialDbg.print(F(\"Got data on Virtual Pin \"));\n    SerialDbg.println(vpin);\n\n    // Param format. Most values will be plain strings: \"Hello world\", \"1234\", \"123.456\", etc.\n    // However, sometimes the value contains multiple items (an array). In this case, the values are separated using a 0x00 byte, i.e:\n    // \"First\\0Second\\0Third\""
        },
        {
          "name": "rpc_client_blynkStateChange_impl",
          "parameters": "uint8_t state",
          "body": "SerialDbg.print(F(\"NCP state: \"));\n  SerialDbg.println(ncpGetStateString(state));\n  if ((RpcBlynkState)state == BLYNK_STATE_CONNECTED) {\n    // Send a value to Virtual Pin 1\n    virtualWrite(1, \"hello world!\");\n  }"
        },
        {
          "name": "rpc_client_processEvent_impl",
          "parameters": "uint8_t event",
          "body": "switch ((RpcEvent)event) {\n    /*\n     * System events\n     */\n    case RPC_EVENT_NCP_REBOOTING:\n      SerialDbg.println(F(\"NCP is rebooting. TODO: reinitialize NCP\"));\n      break;\n    case RPC_EVENT_BLYNK_PROVISIONED:\n      SerialDbg.println(F(\"NCP finished provisioning\"));\n      break;\n    case RPC_EVENT_BLYNK_TIME_SYNC:\n      SerialDbg.println(F(\"NCP requests time sync from external time source\"));\n      break;\n    case RPC_EVENT_BLYNK_TIME_CHANGED: break;\n      SerialDbg.println(F(\"NCP local time changed\"));\n      break;\n    /*\n     * User button events (see rpc_hw_initUserButton)\n     */\n    case RPC_EVENT_HW_USER_CLICK:\n      SerialDbg.println(F(\"NCP: user button click\"));\n      break;\n    case RPC_EVENT_HW_USER_DBLCLICK:\n      SerialDbg.println(F(\"NCP: user button double click\"));\n      break;\n    case RPC_EVENT_HW_USER_LONGPRESS:\n      SerialDbg.println(F(\"NCP: user button long press start\"));\n      break;\n    case RPC_EVENT_HW_USER_LONGRELEASE:\n      SerialDbg.println(F(\"NCP: user button long press stop\"));\n      break;\n    case RPC_EVENT_HW_USER_RESET_START:\n      SerialDbg.println(F(\"NCP: Button is pressed for 10 seconds => release to clear configuration\"));\n      break;\n    case RPC_EVENT_HW_USER_RESET_CANCEL:\n      SerialDbg.println(F(\"NCP: Button is pressed for 15 seconds => cancel config reset operation\"));\n      break;\n    case RPC_EVENT_HW_USER_RESET_DONE:\n      SerialDbg.println(F(\"NCP: Button was released => configuration is reset\"));\n      break;\n    default: break;\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "password",
        "wifi",
        "delay",
        "digitalwrite",
        "led",
        "devicename"
      ],
      "libraries": [
        "DurianBlynkESP8266.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);\n\n  //set Output pin to output\n  for(short i=0; i<4; i++)\n  {\n    pinMode(gsOut_PinArray[i], OUTPUT);\n    digitalWrite(gsOut_PinArray[i], LOW);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();\n\n  //checking virtual pin V0 to V4, if high turn on the output pin. Otherwise, turn off\n  for(short i=V0; i<V4; i++)\n  {\n    if(DBlynk.read_asInt(i) == 1)\n    {\n      digitalWrite(gsOut_PinArray[i], HIGH);\n    }\n    else\n    {\n      digitalWrite(gsOut_PinArray[i], LOW);\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "password",
        "wifi",
        "delay",
        "devicename"
      ],
      "libraries": [
        "DurianBlynkESP8266.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "ssl",
        "auth",
        "token",
        "power",
        "wifi",
        "delay",
        "digitalwrite",
        "esp.restart",
        "millis",
        "led",
        "display",
        "eeprom",
        "littlefs",
        "spiffs",
        "timer",
        "device_host_name"
      ],
      "libraries": [
        "MY_WIFI_CREDENTIALS.h",
        "MY_BLYNK_CREDENTIALS.h",
        "BlynkSimpleEsp8266_WM.h",
        "BlynkSimpleEsp32_WFM.h",
        "BlynkSimpleEsp8266_SSL_WM.h",
        "BlynkSimpleEsp32_SSL_WM.h",
        "BlynkSimpleEsp32_WM.h",
        "BlynkSimpleEsp8266_SSL.h",
        "BlynkSimpleEsp32_SSL.h",
        "BlynkSimpleEsp8266.h",
        "BlynkSimpleEsp32.h",
        "ESP_LED_BUILTINS.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// HELP DEBUG THIS SKETCH WITH GOOD PRINTOUTS\n  Serial.begin ( SERIAL_SPEED );\n  delay ( 500 );  \n  Serial.println ( F(\"\\n\\n=======================================\") );\n  Serial.print ( SKETCH_NAME );\n\n#if (USE_LITTLEFS)\n  Serial.print( F(\" ** Using LITTLEFS **\") );\n#elif (USE_SPIFFS)\n  Serial.print( F(\" ** Using SPIFFS **\") );  \n#else\n  Serial.print( F(\" ** Using EEPROM **\") );\n#endif\n  \n#if USE_SSL\n  Serial.print ( F(\" ** Using SSL **\") );  \n#endif\nSerial.println();\n\n#if USE_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  connectToWLANandBlynk();  // Connect to WiFi, then to Blynk server\n\n  setupBlynkTimers();  // Establish Blynk timers after Blynk is connected\n\n  // Initialize Onboard LED \n  pinMode ( LED_BUILTIN, OUTPUT );  \n  digitalWrite ( LED_BUILTIN, LED_BUILTIN_LOW ); \n    \n  // Set Blynk Virtual Heartbeat LED OFF\n  Blynk.virtualWrite ( heartbeatVpin, 000 );  \n  heartbeatLEDblink(); // start first heartbeat \n  \n  Serial.println ( F(\"\\nSetup complete \\n\") );"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  myTimer.run();"
        },
        {
          "name": "connectToWLANandBlynk",
          "parameters": "",
          "body": "// Setup WLAN and Blynk\n  Serial.print ( F(\"\\nSetting up WLAN and Blynk \") );  \n  #if USE_WM\n    Serial.println ( F(\"WITH WiFiManager\") ); \n  #else\n    Serial.println ( F(\"WITHOUT WiFiManager\") );  \n  #endif\n  \n  #if USE_WM\n    Serial.println ( F(\"Starting Blynk.begin (with WM)\") );  \n\n    // SET UP THE CONFIG PORTAL CREDENTIALS AND CONNECTION INFO\n    Blynk.setConfigPortalChannel ( 0 );  // 0 -> Use a random WiFi 2.4GHz channel for the Config Portal\n    Blynk.setConfigPortal ( CONFIG_PORTAL_SSID, CONFIG_PORTAL_PASSWORD ); // Set up Config Portal SSID & Password\n    Blynk.setConfigPortalIP ( IPAddress ( CONFIG_PORTAL_IPADDRESS ) ); // Set up IP address for COnfig Portal once connected to WiFi\n\n    Serial.print ( F(\"Blynk.setConfigPortal(\") ); \n    Serial.print ( CONFIG_PORTAL_SSID ); Serial.print ( F(\",\") );  \n    Serial.print ( CONFIG_PORTAL_PASSWORD ); Serial.println ( F(\")\") );   \n    Serial.print ( F(\"  Config Portal will be found at IP: \") ); Serial.print ( IPAddress ( CONFIG_PORTAL_IPADDRESS ) );  \n    Serial.println ( F(\"\\n\") );  \n    \n    //Blynk.config ( blynkAuth );  // not needed with WM \n    Blynk.begin ( DEVICE_HOST_NAME ); // DHCP (router) device name\n  \n  #else//NOT using WM\n    Serial.println ( F(\"Starting WiFi.begin (no WM)\") );  \n    WiFi.begin ( WiFiSSID, WiFiPass );\n    Serial.println ( F(\"... waiting a few seconds for WiFi ...\") );    \n    #if ESP8266\n      delay ( 7500 );  // For esp8266, it needs a delay to realize it has connected\n    #endif\n      \n    // REBOOT if we do not have a good WiFi connection\n    if ( WiFi.status() != WL_CONNECTED )\n    {\n      Serial.println ( F(\"Resetting in a few seconds...\\n\\n\\n\\n\\n\") );\n      delay ( 3000 );  \n      ESP.restart();\n    } \n    \n    // Configure and launch Blynk\n    Blynk.config ( blynkAuth );\n    Blynk.connect ( 2500 ); // Don't get stuck hanging for more than 2500 millis.\n  #endif // using WM\n\n  if ( Blynk.connected() ) \n  {\n    #if USE_WM\n      #if ( USE_LITTLEFS || USE_SPIFFS )\n        Serial.print ( F(\"\\nBlynk using \") ); Serial.print ( CurrentFileFS );\n        Serial.print ( F(\" connected. Board Name : \") ); Serial.println ( Blynk.getBoardName() );\n      #else\n         Serial.print ( F(\"\\nBlynk using EEPROM connected. Board Name : \") );\n         Serial.println ( Blynk.getBoardName() );\n         Serial.printf( \"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START );\n      #endif  \n    #endif      \n    Serial.println ( F(\"Blynk connected just fine\") ); \n    Serial.print   ( F(\"  IP address  \") ); Serial.println ( WiFi.localIP() ) ;\n    Serial.print   ( F(\"  MAC address \") ); Serial.println ( WiFi.macAddress() );  \n    Serial.println();  \n  }\n  else Serial.println ( F(\"Blynk NOT CONNECTED \\n\\n\") );"
        },
        {
          "name": "setupBlynkTimers",
          "parameters": "",
          "body": "Serial.println ( F(\"Setting up Blynk timers\") );  \n  // Interval timer for heartbeatLED (Blynk LED and onboard LED\n  heartbeatLEDtimerID = myTimer.setInterval ( heartbeatLEDinterval, heartbeatLEDblink );  \n\n  Serial.println ( F(\"... Blynk timers set up.\") );"
        },
        {
          "name": "updateDynamicParameters",
          "parameters": "",
          "body": "Serial.print ( F(\"\\nupdateDynamicParameters has: \") ); \n  Serial.print ( F(\"\\n   controlVpinC/label = \"\"\") );   Serial.print ( controlVpinC );   Serial.print ( F(\"\"\"/\") ); Serial.print ( controlLabel ); \n  Serial.print ( F(\"\\n   heartbeatVpinC/label = \"\"\") ); Serial.print ( heartbeatVpinC ); Serial.print ( F(\"\"\"/\") ); Serial.print ( heartbeatLabel ); \n  Serial.print ( F(\"\\n   displayVpinC/label = \"\"\") );   Serial.print ( displayVpinC );   Serial.print ( F(\"\"\"/\") ); Serial.print ( displayLabel ); \n  Serial.println ( F(\"\\n\") );  \n    \n  // Convert char Virtual Pin numbers to int in preperation for Blynk connect\n  controlVpin = atoi ( controlVpinC );\n  if ( controlVpin < 0 || controlVpin > 255 )\n  {\n    controlVpin = atoi ( CONTROL_DEFAULT_VPIN );\n    Serial.print ( F(\"**** Bad controlVpin input value of \") );\n    Serial.println ( controlVpinC );\n  };\n  Serial.print ( F(\"   Set controlVpin/controlLabel to \") ) ; Serial.print ( controlVpin );\n  Serial.print ( F(\"/\") ); Serial.println ( controlLabel );   \n  Blynk.setProperty ( controlVpin, \"label\", controlLabel ); \n\n  heartbeatVpin = atoi ( heartbeatVpinC );\n  if ( heartbeatVpin < 0 || heartbeatVpin > 255 )\n  {\n    heartbeatVpin = atoi ( HEARTBEAT_LED_DEFAULT_VPIN );\n    Serial.print ( F(\"**** Bad heartbeatVpin input value of \") );\n    Serial.println ( heartbeatVpinC );\n  }\n  Serial.print ( F(\"   Set heartbeatVpin/heartbeatLabel to \") ) ; Serial.print ( heartbeatVpin );\n  Serial.print ( F(\"/\") ); Serial.println ( heartbeatLabel );   \n  Blynk.setProperty ( heartbeatVpin, \"label\", heartbeatLabel );  \n    \n  displayVpin = atoi ( displayVpinC );\n  if ( displayVpin < 0 || displayVpin > 255 )\n  {\n    displayVpin = atoi ( DISPLAY_DEFAULT_VPIN );\n    Serial.print ( F(\"**** Bad displayVpin input value of \") );\n    Serial.println ( displayVpinC );\n  }\n  Serial.print ( F(\"   Set displayVpin/displayLabel to \") ) ; Serial.print ( displayVpin );\n  Serial.print ( F(\"/\") ); Serial.println ( displayLabel );   \n  Blynk.setProperty ( displayVpin, \"label\", displayLabel );  \n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//init Ciao\n\tCiao.begin();\n\tSerial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if(ArduinoBoard == \"\"){\n\t\t//Run commands in Linino OS to get the board model\n\t\tCiaoData data = Ciao.write(\"shell\",\"awk\",\"'/machine/ {print $4}' /proc/cpuinfo\");\n\t\tif(!data.isEmpty()){\n\t\t\t//extract data back\n\t\t\tArduinoBoard = data.get(2);\n\t\t\tSerial.println(ArduinoBoard);\n\t\t}\n\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "motion",
        "millis",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "event_handler",
          "parameters": "lv_event_t * e",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_CLICKED)\n  {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was pressed\\n\", txt);\n    if (Serial) Serial.println(txt);\n\n    if (strcmp(txt, \"Move\") == 0)\n      move_joint = !move_joint;\n  }\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "customMenu",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_add_event_cb(btnm1, event_handler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  for (auto const start = millis(); !Serial && ((millis() - start) < 5000); delay(10)) { }\n\n  if (!Braccio.begin(customMenu)) {\n    if (Serial) Serial.println(\"Braccio.begin() failed.\");\n    for(;;) { }\n  }\n\n  Braccio.moveTo(home_position[0], home_position[1], home_position[2], home_position[3], home_position[4], home_position[5]);\n  delay(1000);\n  Braccio.setAngularVelocity(45.0f); /* 45 deg/sec */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (move_joint)\n  {\n    Braccio.move(4).to((SmartServoClass::MAX_ANGLE / 2.0f) - 45.0f);\n    delay(2000);\n    Braccio.move(4).to((SmartServoClass::MAX_ANGLE / 2.0f) + 45.0f);\n    delay(2000);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "eventsource"
      ],
      "libraries": [
        "Braccio++.h",
        "AppState.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (Braccio.begin(custom_main_menu))\n  {\n    app.enableButtons();\n    /* Allow greater angular velocity than the default one. */\n    Braccio.setAngularVelocity(45.0f);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "distance",
        "delay",
        "fetch"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (Braccio.begin())\n  {\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(TIME_DELAY);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n  {\n    // Pinch movement\n    gripper.move().to(230.0f);         delay(TIME_DELAY);\n    gripper.move().to(HOME_POS[0]);    delay(TIME_DELAY);\n\n    // // Wrist Roll movement\n    wristRoll.move().to(0.0f);          delay(TIME_DELAY);\n    wristRoll.move().to(HOME_POS[1]);   delay(TIME_DELAY);\n    wristRoll.move().to(315.0f);        delay(TIME_DELAY);\n    wristRoll.move().to(HOME_POS[1]);   delay(TIME_DELAY);\n\n    // // Wrist Pitch movement\n    wristPitch.move().to(70.0f);       delay(TIME_DELAY);\n    wristPitch.move().to(HOME_POS[2]); delay(TIME_DELAY);\n    wristPitch.move().to(260.0f);      delay(TIME_DELAY);\n    wristPitch.move().to(HOME_POS[2]); delay(TIME_DELAY);\n\n    // Elbow movement\n    for(float i=HOME_POS[3]; i >= 70.0; i-=5)\n        { elbow.move().to(i);          delay(TIME_DELAY/2000); }\n    elbow.move().to(HOME_POS[3]);      delay(TIME_DELAY);\n    for(float i=HOME_POS[3]; i <= 260.0; i+=5)\n        { elbow.move().to(i);          delay(TIME_DELAY/2000); }\n    elbow.move().to(HOME_POS[3]);      delay(TIME_DELAY);\n\n    // Shoulder movement\n    shoulder.move().to(120.0f);       delay(TIME_DELAY/2);\n    shoulder.move().to(90.0f);        delay(TIME_DELAY/2);\n    shoulder.move().to(120.0f);       delay(TIME_DELAY/2);\n    shoulder.move().to(HOME_POS[4]);  delay(TIME_DELAY);\n    shoulder.move().to(200.0f);       delay(TIME_DELAY/2);\n    shoulder.move().to(230.0f);       delay(TIME_DELAY/2);\n    shoulder.move().to(200.0f);       delay(TIME_DELAY/2);\n    shoulder.move().to(HOME_POS[4]);  delay(TIME_DELAY);\n\n    // Base movement\n    base.move().to(0.0f);              delay(TIME_DELAY);\n    base.move().to(HOME_POS[5]);       delay(TIME_DELAY);\n    base.move().to(315.0f);            delay(TIME_DELAY);\n    base.move().to(HOME_POS[5]);       delay(TIME_DELAY);\n\n    while(pressedKey == BUTTON_ENTER) { pressedKey = Braccio.getKey(); }\n  }\n\n  if (pressedKey == BUTTON_SELECT)\n  {\n    // Fetch the joints positions\n    Braccio.positions(angles);\n\n    // Print the joint angles\n    Serial.println(\"************* Joints Angles *************\");\n    Serial.println(\"|\\tMotor ID\\t|\\tAngle\\t|\");\n    Serial.println(\"----------------------------------------\");\n    Serial.print(\"| 1 - Gripper\\t\\t|\\t\" + String(angles[0]) + \"\\t|\\n\" + \n                 \"| 2 - Wrist Rotation\\t|\\t\" + String(angles[1]) + \"\\t|\\n\" +\n                 \"| 3 - Wrist Vertical\\t|\\t\" + String(angles[2]) + \"\\t|\\n\" + \n                 \"| 4 - Elbow\\t\\t|\\t\" + String(angles[3]) + \"\\t|\\n\" + \n                 \"| 5 - Shoulder\\t\\t|\\t\" + String(angles[4]) + \"\\t|\\n\" + \n                 \"| 6 - Base\\t\\t|\\t\" + String(angles[5]) + \"\\t|\\n\" +\n                 \"*****************************************\\n\\n\\n\\n\\n\");\n\n    while(pressedKey == BUTTON_SELECT) { pressedKey = Braccio.getKey(); }\n    \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_SSD1331.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.begin(); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(BLUE);\n\n  // Load full-screen BMP file 'daffodil.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading daffodil.bmp to screen...\"));\n  stat = reader.drawBMP(\"/daffodil.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "tft",
        "oled",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_SSD1351.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.begin(); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(BLUE);\n\n  // Load full-screen BMP file 'rgbwheel.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading rgbwheel.bmp to screen...\"));\n  stat = reader.drawBMP(\"/rgbwheel.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7735.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.initR(INITR_144GREENTAB); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST7735_BLUE);\n\n  // Load full-screen BMP file 'rgbwheel.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading rgbwheel.bmp to screen...\"));\n  stat = reader.drawBMP(\"/rgbwheel.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7735.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.initR(INITR_BLACKTAB); // Initialize screen\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST7735_BLUE);\n\n  // Load full-screen BMP file 'parrot.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading parrot.bmp to screen...\"));\n  stat = reader.drawBMP(\"/parrot.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7735.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.initR(INITR_MINI160x80); // Initialize screen\n  Serial.println(F(\"TFT initialized.\"));\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST77XX_BLUE);\n\n  // Load full-screen BMP file 'minibot.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading minibot.bmp to screen...\"));\n  stat = reader.drawBMP(\"/minibot.bmp\", tft, 0, 0);\n  // (Absolute path isn't necessary on most devices, but something\n  // with the ESP32 SD library seems to require it.)\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'rgbwheel.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying rgbwheel.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/rgbwheel.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should\n  // fail gracefully on AVR and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it\n  // just continues on without it.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'rgbwheel.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/rgbwheel.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "st7789",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(170, 320);           // Init ST7789 170x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST77XX_BLUE);\n  tft.setRotation(3);\n\n  // Load full-screen BMP file 'adabot.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading adabot.bmp to screen...\"));\n  stat = reader.drawBMP(\"/adabot.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "st7789",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(172, 320);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST77XX_BLUE);\n  tft.setRotation(3);\n\n  // Load full-screen BMP file 'adabot.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading adabot.bmp to screen...\"));\n  stat = reader.drawBMP(\"/adabot.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "st7789",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(135, 240);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST77XX_BLUE);\n  tft.setRotation(3);\n\n  // Load full-screen BMP file 'adabot.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading adabot.bmp to screen...\"));\n  stat = reader.drawBMP(\"/adabot.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "st7789",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(240, 240);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST77XX_BLUE);\n\n  // Load full-screen BMP file 'adabot.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading adabot.bmp to screen...\"));\n  stat = reader.drawBMP(\"/adabot.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "st7789",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  while(!Serial);       // Wait for Serial Monitor before continuing\n\n  tft.init(240, 280);           // Init ST7789 172x320\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatFileSystem object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST77XX_BLUE);\n\n  // Load full-screen BMP file 'adabot.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading adabot.bmp to screen...\"));\n  stat = reader.drawBMP(\"/adabot.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "st7789",
        "tft",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ST7789.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n#if !defined(ESP32)\n  while(!Serial);       // Wait for Serial Monitor before continuing\n#endif\n\n  tft.init(240, 320);           // Init ST7789 320x240\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Fill screen blue. Not a required step, this just shows that we're\n  // successfully communicating with the screen.\n  tft.fillScreen(ST77XX_BLUE);\n\n  // Load full-screen BMP file 'purple.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'tft' as an argument.\n  Serial.print(F(\"Loading purple.bmp to screen...\"));\n  stat = reader.drawBMP(\"/purple.bmp\", tft, 0, 0);\n  reader.printStatus(stat);   // How'd we do?\n\n  // Query the dimensions of image 'miniwoof.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying miniwoof.bmp image size...\"));\n  stat = reader.bmpDimensions(\"/miniwoof.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  // Load small BMP 'wales.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on Arduino Mega, Zero, etc.\n  Serial.print(F(\"Loading wales.bmp to canvas...\"));\n  stat = reader.loadBMP(\"/wales.bmp\", img);\n  reader.printStatus(stat); // How'd we do?\n\n  delay(2000); // Pause 2 seconds before moving on to loop()"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    tft.setRotation(r);    // Set rotation\n    tft.fillScreen(0);     // and clear screen\n\n    // Load 4 copies of the 'miniwoof.bmp' image to the screen, some\n    // partially off screen edges to demonstrate clipping. Globals\n    // 'width' and 'height' were set by bmpDimensions() call in setup().\n    for(int i=0; i<4; i++) {\n      reader.drawBMP(\"/miniwoof.bmp\", tft,\n        (tft.width()  * i / 3) - (width  / 2),\n        (tft.height() * i / 3) - (height / 2));\n    }\n\n    delay(1000); // Pause 1 sec.\n\n    // Draw 50 Welsh dragon flags in random positions. This has no effect\n    // on memory-constrained boards like the Arduino Uno, where the image\n    // failed to load due to insufficient RAM, but it's NOT fatal.\n    for(int i=0; i<50; i++) {\n      // Rather than reader.drawBMP() (which works from SD card),\n      // a different function is used for RAM-resident images:\n      img.draw(tft,                                    // Pass in tft object\n        (int16_t)random(-img.width() , tft.width()) ,  // Horiz pos.\n        (int16_t)random(-img.height(), tft.height())); // Vert pos\n      // Reiterating a prior point: img.draw() does nothing and returns\n      // if the image failed to load. It's unfortunate but not disastrous.\n    }\n\n    delay(2000); // Pause 2 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "rest",
        "api",
        "http",
        "webserver",
        "key",
        "current",
        "digitalread",
        "digitalwrite",
        "analogwrite",
        "analogread",
        "delay",
        "clients"
      ],
      "libraries": [
        "Bridge.h",
        "BridgeServer.h",
        "BridgeClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Bridge startup\n  pinMode(13, OUTPUT);\n  digitalWrite(13, LOW);\n  Bridge.begin();\n  digitalWrite(13, HIGH);\n\n  // Listen for incoming connection only from localhost\n  // (no one from the external network could connect)\n  server.listenOnLocalhost();\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Get clients coming from server\n  BridgeClient client = server.accept();\n\n  // There is a new client?\n  if (client) {\n    // Process request\n    process(client);\n\n    // Close connection and free resources.\n    client.stop();\n  }\n\n  delay(50); // Poll every 50ms"
        },
        {
          "name": "process",
          "parameters": "BridgeClient client",
          "body": "// read the command\n  String command = client.readStringUntil('/');\n\n  // is \"digital\" command?\n  if (command == \"digital\") {\n    digitalCommand(client);\n  }\n\n  // is \"analog\" command?\n  if (command == \"analog\") {\n    analogCommand(client);\n  }\n\n  // is \"mode\" command?\n  if (command == \"mode\") {\n    modeCommand(client);\n  }"
        },
        {
          "name": "digitalCommand",
          "parameters": "BridgeClient client",
          "body": "int pin, value;\n\n  // Read pin number\n  pin = client.parseInt();\n\n  // If the next character is a '/' it means we have an URL\n  // with a value like: \"/digital/13/1\"\n  if (client.read() == '/') {\n    value = client.parseInt();\n    digitalWrite(pin, value);\n  } else {\n    value = digitalRead(pin);\n  }\n\n  // Send feedback to client\n  client.print(F(\"Pin D\"));\n  client.print(pin);\n  client.print(F(\" set to \"));\n  client.println(value);\n\n  // Update datastore key with the current pin value\n  String key = \"D\";\n  key += pin;\n  Bridge.put(key, String(value));"
        },
        {
          "name": "analogCommand",
          "parameters": "BridgeClient client",
          "body": "int pin, value;\n\n  // Read pin number\n  pin = client.parseInt();\n\n  // If the next character is a '/' it means we have an URL\n  // with a value like: \"/analog/5/120\"\n  if (client.read() == '/') {\n    // Read value and execute command\n    value = client.parseInt();\n    analogWrite(pin, value);\n\n    // Send feedback to client\n    client.print(F(\"Pin D\"));\n    client.print(pin);\n    client.print(F(\" set to analog \"));\n    client.println(value);\n\n    // Update datastore key with the current pin value\n    String key = \"D\";\n    key += pin;\n    Bridge.put(key, String(value));\n  } else {\n    // Read analog pin\n    value = analogRead(pin);\n\n    // Send feedback to client\n    client.print(F(\"Pin A\"));\n    client.print(pin);\n    client.print(F(\" reads analog \"));\n    client.println(value);\n\n    // Update datastore key with the current pin value\n    String key = \"A\";\n    key += pin;\n    Bridge.put(key, String(value));\n  }"
        },
        {
          "name": "modeCommand",
          "parameters": "BridgeClient client",
          "body": "int pin;\n\n  // Read pin number\n  pin = client.parseInt();\n\n  // If the next character is not a '/' we have a malformed URL\n  if (client.read() != '/') {\n    client.println(F(\"error\"));\n    return;\n  }\n\n  String mode = client.readStringUntil('\\r');\n\n  if (mode == \"input\") {\n    pinMode(pin, INPUT);\n    // Send feedback to client\n    client.print(F(\"Pin D\"));\n    client.print(pin);\n    client.print(F(\" configured as INPUT!\"));\n    return;\n  }\n\n  if (mode == \"output\") {\n    pinMode(pin, OUTPUT);\n    // Send feedback to client\n    client.print(F(\"Pin D\"));\n    client.print(pin);\n    client.print(F(\" configured as OUTPUT!\"));\n    return;\n  }\n\n  client.print(F(\"error: invalid mode \"));\n  client.print(mode);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "dns",
        "millis",
        "gatewayip"
      ],
      "libraries": [
        "QNEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial\n  }\n  printf(\"Starting...\\r\\n\");\n\n  uint8_t mac[6];\n  Ethernet.macAddress(mac);  // This is informative; it retrieves, not sets\n  printf(\"MAC = %02x:%02x:%02x:%02x:%02x:%02x\\r\\n\",\n         mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n\n  Ethernet.onLinkState([](bool state) {\n    printf(\"[Ethernet] Link %s\\r\\n\", state ? \"ON\" : \"OFF\");\n  });\n\n  printf(\"Starting Ethernet with DHCP...\\r\\n\");\n  if (!Ethernet.begin()) {\n    printf(\"Failed to start Ethernet\\r\\n\");\n    return;\n  }\n  if (!Ethernet.waitForLocalIP(kDHCPTimeout)) {\n    printf(\"Failed to get IP address from DHCP\\r\\n\");\n    return;\n  }\n\n  IPAddress ip = Ethernet.localIP();\n  printf(\"    Local IP     = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n  ip = Ethernet.subnetMask();\n  printf(\"    Subnet mask  = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n  ip = Ethernet.broadcastIP();\n  printf(\"    Broadcast IP = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n  ip = Ethernet.gatewayIP();\n  printf(\"    Gateway      = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n  ip = Ethernet.dnsServerIP();\n  printf(\"    DNS          = %u.%u.%u.%u\\r\\n\", ip[0], ip[1], ip[2], ip[3]);\n\n  // Start UDP listening on the port\n  udp.begin(kPort);\n\n  printPrompt();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "receivePacket();\n  sendLine();"
        },
        {
          "name": "receivePacket",
          "parameters": "",
          "body": "int size = udp.parsePacket();\n  if (size < 0) {\n    return;\n  }\n\n  // Get the packet data and remote address\n  const uint8_t *data = udp.data();\n  IPAddress ip = udp.remoteIP();\n\n  printf(\"[%u.%u.%u.%u][%d] \", ip[0], ip[1], ip[2], ip[3], size);\n\n  // Print each character\n  for (int i = 0; i < size; i++) {\n    uint8_t b = data[i];\n    if (b < 0x20) {\n      printf(\"<%s>\", kCtrlNames[b]);\n    } else if (b < 0x7f) {\n      putchar(data[i]);\n    } else {\n      printf(\"<%02xh>\", data[i]);\n    }\n  }\n  printf(\"\\r\\n\");"
        },
        {
          "name": "readLine",
          "parameters": "String &line",
          "body": "static bool inCR = false;  // Keeps track of CR state\n\n  while (Serial.available() > 0) {\n    int c;\n    switch (c = Serial.read()) {\n      case '\\r':\n        inCR = true;\n        return true;\n\n      case '\\n':\n        if (inCR) {\n          // Ignore the LF\n          inCR = false;\n          break;\n        }\n        return true;\n\n      default:\n        if (c < 0) {\n          return false;\n        }\n        inCR = false;\n        line.concat(static_cast<char>(c));\n    }\n  }\n\n  return false;"
        },
        {
          "name": "printPrompt",
          "parameters": "",
          "body": "printf(\"chat> \");\n  fflush(stdout);  // printf may be line-buffered, so ensure there's output"
        },
        {
          "name": "sendLine",
          "parameters": "",
          "body": "static String line;\n\n  // Read from the console and send lines\n  if (readLine(line)) {\n    if (!udp.send(Ethernet.broadcastIP(), kPort,\n                  reinterpret_cast<const uint8_t *>(line.c_str()),\n                  line.length())) {\n      printf(\"[Error sending]\\r\\n\");\n    }\n    line = \"\";\n    printPrompt();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "http",
        "https",
        "key",
        "ssl",
        "json",
        "payload",
        "buffer",
        "wifi",
        "millis",
        "delay",
        "timestamp",
        "clients",
        "devices",
        "device_registration_id_token_1",
        "device_token_1",
        "device_registration_id_token_2",
        "device_token_2",
        "device_registration_id_token_3",
        "device_token_3"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    // required for legacy HTTP API\n    Firebase.FCM.setServerKey(FIREBASE_FCM_SERVER_KEY);\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    sendMessage();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - lastTime > 60 * 1000)\n    {\n        lastTime = millis();\n\n        sendMessage();\n    }"
        },
        {
          "name": "sendMessage",
          "parameters": "",
          "body": "Serial.print(\"Send Firebase Cloud Messaging... \");\n\n    // Read more details about legacy HTTP API here https://firebase.google.com/docs/cloud-messaging/http-server-ref\n    FCM_Legacy_HTTP_Message msg;\n\n    FirebaseJsonArray arr;\n    arr.add(DEVICE_REGISTRATION_ID_TOKEN_1);\n    arr.add(DEVICE_REGISTRATION_ID_TOKEN_2);\n    arr.add(DEVICE_REGISTRATION_ID_TOKEN_3);\n\n    msg.targets.registration_ids = arr.raw();\n\n    msg.options.time_to_live = \"1000\";\n    msg.options.priority = \"high\";\n\n    msg.payloads.notification.title = \"Notification title\";\n    msg.payloads.notification.body = \"Notification body\";\n    msg.payloads.notification.icon = \"myicon\";\n    msg.payloads.notification.click_action = \"OPEN_ACTIVITY_1\";\n\n    FirebaseJson payload;\n\n    // all data key-values should be string\n    payload.add(\"temp\", \"28\");\n    payload.add(\"unit\", \"celsius\");\n    payload.add(\"timestamp\", \"1609815454\");\n    msg.payloads.data = payload.raw();\n\n    if (Firebase.FCM.send(&fbdo, &msg)) // send message to recipient\n        Serial.printf(\"ok\\n%s\\n\\n\", Firebase.FCM.payload(&fbdo).c_str());\n    else\n        Serial.println(fbdo.errorReason());\n\n    count++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "millis",
        "sd",
        "flash"
      ],
      "libraries": [
        "SdFat.h",
        "BufferedPrint.h"
      ],
      "functions": [
        {
          "name": "benchmark",
          "parameters": "",
          "body": "file_t file;\n  BufferedPrint<file_t, 64> bp;\n  // do write test\n  Serial.println();\n  for (int test = 0; test < 6; test++) {\n    char fileName[13] = \"bench0.txt\";\n    fileName[5] = '0' + test;\n    // open or create file - truncate existing file.\n    if (!file.open(fileName, O_RDWR | O_CREAT | O_TRUNC)) {\n      sd.errorHalt(&Serial, F(\"open failed\"));\n    }\n    if (test & 1) {\n      bp.begin(&file);\n    }\n    uint32_t t = millis();\n    switch(test) {\n    case 0:\n      Serial.println(F(\"Test of println(uint16_t)\"));\n      for (uint16_t i = 0; i < N_PRINT; i++) {\n        file.println(i);\n      }\n      break;\n\n    case 1:\n      Serial.println(F(\"Test of printField(uint16_t, char)\"));\n      for (uint16_t i = 0; i < N_PRINT; i++) {\n        bp.printField(i, '\\n');\n      }\n      break;\n\n    case 2:\n      Serial.println(F(\"Test of println(uint32_t)\"));\n      for (uint16_t i = 0; i < N_PRINT; i++) {\n        file.println(12345678UL + i);\n      }\n      break;\n\n    case 3:\n      Serial.println(F(\"Test of printField(uint32_t, char)\"));\n      for (uint16_t i = 0; i < N_PRINT; i++) {\n        bp.printField(12345678UL + i, '\\n');\n      }\n      break;\n\n    case 4:\n      Serial.println(F(\"Test of println(double)\"));\n      for (uint16_t i = 0; i < N_PRINT; i++) {\n        file.println((double)0.01*i);\n      }\n      break;\n\n    case 5:\n      Serial.println(F(\"Test of printField(double, char)\"));\n      for (uint16_t i = 0; i < N_PRINT; i++) {\n        bp.printField((double)0.01*i, '\\n');\n      }\n      break;\n\n    }\n    if (test & 1) {\n      bp.sync();\n    }\n    if (file.getWriteError()) {\n      sd.errorHalt(&Serial, F(\"write failed\"));\n    }\n    double s = file.fileSize();\n    file.close();\n    t = millis() - t;\n    Serial.print(F(\"Time \"));\n    Serial.print(0.001*t, 3);\n    Serial.println(F(\" sec\"));\n    Serial.print(F(\"File size \"));\n    Serial.print(0.001*s);\n    Serial.println(F(\" KB\"));\n    Serial.print(F(\"Write \"));\n    Serial.print(s/t);\n    Serial.println(F(\" KB/sec\"));\n    Serial.println();\n  }"
        },
        {
          "name": "testMemberFunctions",
          "parameters": "",
          "body": "BufferedPrint<Print, 32> bp(&Serial);\n  char c = 'c';    // char\n//#define BASIC_TYPES\n#ifdef BASIC_TYPES\n  signed char sc = -1;   // signed 8-bit\n  unsigned char uc = 1;  // unsiged 8-bit\n  signed short ss = -2;  // signed 16-bit\n  unsigned short us = 2; // unsigned 16-bit\n  signed long sl = -4;   // signed 32-bit\n  unsigned long ul = 4;  // unsigned 32-bit\n#else  // BASIC_TYPES\n  int8_t sc = -1;  // signed 8-bit\n  uint8_t uc = 1;  // unsiged 8-bit\n  int16_t ss = -2; // signed 16-bit\n  uint16_t us = 2; // unsigned 16-bit\n  int32_t sl = -4; // signed 32-bit\n  uint32_t ul = 4; // unsigned 32-bit\n#endif  // BASIC_TYPES\n  float f = -1.234;\n  double d = -5.678;\n  bp.println();\n  bp.println(\"Test print()\");\n  bp.print(c);\n  bp.println();\n  bp.print(\"string\");\n  bp.println();\n  bp.print(F(\"flash\"));\n  bp.println();\n  bp.print(sc);\n  bp.println();\n  bp.print(uc);\n  bp.println();\n  bp.print(ss);\n  bp.println();\n  bp.print(us);\n  bp.println();\n  bp.print(sl);\n  bp.println();\n  bp.print(ul);\n  bp.println();\n  bp.print(f);\n  bp.println();\n  bp.print(d);\n  bp.println();\n  bp.println();\n\n  bp.println(\"Test println()\");\n  bp.println(c);\n  bp.println(\"string\");\n  bp.println(F(\"flash\"));\n  bp.println(sc);\n  bp.println(uc);\n  bp.println(ss);\n  bp.println(us);\n  bp.println(sl);\n  bp.println(ul);\n  bp.println(f);\n  bp.println(d);\n  bp.println();\n\n  bp.println(\"Test printField()\");\n  bp.printField(c, ',');\n  bp.printField(\"string\", ',');\n  bp.printField(F(\"flash\"), ',');\n  bp.printField(sc, ',');\n  bp.printField(uc, ',');\n  bp.printField(ss, ',');\n  bp.printField(us, ',');\n  bp.printField(sl, ',');\n  bp.printField(ul, ',');\n  bp.printField(f, ',');\n  bp.printField(d, '\\n');\n\n  bp.sync();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial) {}\n  Serial.println(\"Type any character to begin.\");\n  while(!Serial.available()) {}\n  if (!sd.begin(SD_CONFIG)) {\n    sd.initErrorHalt(&Serial);\n  }\n  Serial.println();\n  Serial.println(F(\"Test member funcions:\"));\n  testMemberFunctions();\n  Serial.println();\n  Serial.println(F(\"Benchmark performance for uint16_t, uint32_t, and double:\"));\n  benchmark();\n  Serial.println(\"Done\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "stream",
        "power",
        "current",
        "delay",
        "digitalwrite",
        "millis",
        "led",
        "timer",
        "html"
      ],
      "libraries": [
        "loopTimer.h",
        "BufferedOutput.h",
        "millisDelay.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  for (int i = 10; i > 0; i--) {\n    Serial.println(i);\n    delay(500);\n  }\n  bufferedOut.connect(Serial);  // connect buffered stream to Serial\n\n  // initialize digital pin led as an output.\n  pinMode(led, OUTPUT);\n  ledDelay.start(1000); // start the ledDelay, toggle every 1000ms\n  printDelay.start(5000); // start the printDelay, print every 5000ms"
        },
        {
          "name": "blinkLed13",
          "parameters": "",
          "body": "if (ledDelay.justFinished()) {   // check if delay has timed out\n    ledDelay.repeat(); // start delay again without drift\n    ledOn = !ledOn;     // toggle the led\n    bufferedOut.print(\"The built-in board led, pin 13, is being turned \"); bufferedOut.println(ledOn?\"ON\":\"OFF\");\n    digitalWrite(led, ledOn?HIGH:LOW); // turn led on/off\n  } // else nothing to do this call just return, quickly"
        },
        {
          "name": "print_ms",
          "parameters": "",
          "body": "if (printDelay.justFinished()) {\n    printDelay.repeat(); // start delay again without drift\n    bufferedOut.println(millis());   // print the current ms\n  } // else nothing to do this call just return, quickly"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bufferedOut.nextByteOut(); // call at least once per loop to release chars\n  loopTimer.check(bufferedOut); // send loop timer output to the bufferedOut\n  blinkLed13(); // call the method to blink the led\n  print_ms(); // print the time"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "telegram",
        "api",
        "token",
        "key",
        "certificate",
        "json",
        "parse",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "littlefs"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "ArduinoJson.h",
        "LittleFS.h"
      ],
      "functions": [
        {
          "name": "addSubscribedUser",
          "parameters": "String chat_id, String from_name",
          "body": "JsonObject users = getSubscribedUsers();\n  users[chat_id] = from_name;\n\n  File subscribedUsersFile = LittleFS.open(SUBSCRIBED_USERS_FILENAME, \"w+\");\n  // file not available\n  if (!subscribedUsersFile)\n  {\n    subscribedUsersFile.close();\n    Serial.println(\"Failed to open subscribed users file for writing\");\n    return false;\n  }\n\n  //users.getOrCreateMember(chat_id, from_name);\n  serializeJson(users, subscribedUsersFile);\n  subscribedUsersFile.close();\n  return true;"
        },
        {
          "name": "removeSubscribedUser",
          "parameters": "String chat_id",
          "body": "JsonObject users = getSubscribedUsers();\n  users.remove(chat_id);\n\n  File subscribedUsersFile = LittleFS.open(SUBSCRIBED_USERS_FILENAME, \"w\");\n  // file not available\n  if (!subscribedUsersFile)\n  {\n    subscribedUsersFile.close();\n    Serial.println(\"Failed to open subscribed users file for writing\");\n    return false;\n  }\n\n  serializeJson(users, subscribedUsersFile);\n  subscribedUsersFile.close();\n  return true;"
        },
        {
          "name": "sendMessageToAllSubscribedUsers",
          "parameters": "String message",
          "body": "JsonObject users = getSubscribedUsers();\n  unsigned int users_processed = 0;\n\n  for (JsonObject::iterator it = users.begin(); it != users.end(); ++it)\n  {\n    users_processed++;\n    if (users_processed < MESSAGES_LIMIT_PER_SECOND)\n    {\n      const char *chat_id = it->key().c_str();\n      bot.sendMessage(chat_id, message, \"\");\n    }\n    else\n    {\n      delay(BULK_MESSAGES_MTBS);\n      users_processed = 0;\n    }\n  }"
        },
        {
          "name": "handleNewMessages",
          "parameters": "int numNewMessages",
          "body": "Serial.print(\"handleNewMessages: \");\n  Serial.println(numNewMessages);\n\n  for (int i = 0; i < numNewMessages; i++)\n  {\n    String chat_id = bot.messages[i].chat_id;\n    String text = bot.messages[i].text;\n    String from_name = bot.messages[i].from_name;\n    if (from_name == \"\")\n      from_name = \"Guest\";\n\n    if (text == \"/start\")\n    {\n      if (addSubscribedUser(chat_id, from_name))\n      {\n        String welcome = \"Welcome to Universal Arduino Telegram Bot library.\\n\";\n        welcome += \"This is Bulk Messages example.\\n\\n\";\n        welcome += \"You, \" + from_name + \", have been subscribed.\\n\";\n        welcome += \"/showallusers : show all subscribed users\\n\";\n        welcome += \"/testbulkmessage : send test message to subscribed users\\n\";\n        welcome += \"/removeallusers : remove all subscribed users\\n\";\n        welcome += \"/stop : unsubscribe from bot\\n\";\n        bot.sendMessage(chat_id, welcome, \"Markdown\");\n      }\n      else\n      {\n        bot.sendMessage(chat_id, \"Something wrong, please try again (later?)\", \"\");\n      }\n    }\n\n    if (text == \"/stop\")\n    {\n      if (removeSubscribedUser(chat_id))\n      {\n        bot.sendMessage(chat_id, \"Thank you, \" + from_name + \", we always waiting you back\", \"\");\n      }\n      else\n      {\n        bot.sendMessage(chat_id, \"Something wrong, please try again (later?)\", \"\");\n      }\n    }\n\n    if (text == \"/testbulkmessage\")\n    {\n      sendMessageToAllSubscribedUsers(\"ATTENTION, this is bulk message for all subscribed users!\");\n    }\n\n    if (text == \"/showallusers\")\n    {\n      File subscribedUsersFile = LittleFS.open(SUBSCRIBED_USERS_FILENAME, \"r\");\n      // no file\n      if (!subscribedUsersFile)\n      {\n        bot.sendMessage(chat_id, \"No subscription file\", \"\");\n        return;\n      }\n      size_t size = subscribedUsersFile.size();\n      if (size > 1024)\n      {\n        bot.sendMessage(chat_id, \"Subscribed users file is too large\", \"\");\n      }\n      else\n      {\n        String file_content = subscribedUsersFile.readString();\n        bot.sendMessage(chat_id, file_content, \"\");\n      }\n    }\n\n    if (text == \"/removeallusers\")\n    {\n      if (LittleFS.remove(SUBSCRIBED_USERS_FILENAME))\n      {\n        bot.sendMessage(chat_id, \"All users removed\", \"\");\n      }\n      else\n      {\n        bot.sendMessage(chat_id, \"Something wrong, please try again (later?)\", \"\");\n      }\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  if (!LittleFS.begin())\n  {\n    Serial.println(\"Failed to mount file system\");\n    return;\n  }\n\n  // attempt to connect to Wifi network:\n  configTime(0, 0, \"pool.ntp.org\");      // get UTC time via NTP\n  secured_client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org\n  Serial.print(\"Connecting to Wifi SSID \");\n  Serial.print(WIFI_SSID);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);\n  }\n  Serial.print(\"\\nWiFi connected. IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // Check NTP/Time, usually it is instantaneous and you can delete the code below.\n  Serial.print(\"Retrieving time: \");\n  time_t now = time(nullptr);\n  while (now < 24 * 3600)\n  {\n    Serial.print(\".\");\n    delay(100);\n    now = time(nullptr);\n  }\n  Serial.println(now);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n    }\n\n    bot_lasttime = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "light",
        "led"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//nothing here"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check the switchState of the button\n  // each time it is pressed, it toggles the LED\n  // when LOW, light should go on\n  if (button.readSwitch() == LOW) {\n    led.on();\n  }\n  else {\n    led.off();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "spi",
        "wifi",
        "digitalread",
        "led",
        "interrupt"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "checkPin",
          "parameters": "",
          "body": "// Invert state, since button is \"Active LOW\"\n  pinValue = !digitalRead(2);\n\n  // Mark pin value changed\n  pinChanged = true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n\n  // Make pin 2 HIGH by default\n  pinMode(2, INPUT_PULLUP);\n  // Attach INT to our handler\n  attachInterrupt(digitalPinToInterrupt(2), checkPin, CHANGE);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n\n  if (pinChanged) {\n\n    // Process the value\n    if (pinValue) {\n      led1.on();\n    } else {\n      led1.off();\n    }\n\n    // Clear the mark, as we have processed the value\n    pinChanged = false;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "energy",
        "current",
        "bluetooth",
        "wifi",
        "ble",
        "digitalread",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  pinMode(ledPin, OUTPUT); // use the LED as an output\n  pinMode(buttonPin, INPUT); // use button pin as an input\n\n  // begin initialization\n  if (!BLE.begin()) {\n    Serial.println(\"starting Bluetooth® Low Energy module failed!\");\n\n    while (1);\n  }\n\n  // set the local name peripheral advertises\n  BLE.setLocalName(\"ButtonLED\");\n  // set the UUID for the service this peripheral advertises:\n  BLE.setAdvertisedService(ledService);\n\n  // add the characteristics to the service\n  ledService.addCharacteristic(ledCharacteristic);\n  ledService.addCharacteristic(buttonCharacteristic);\n\n  // add the service\n  BLE.addService(ledService);\n\n  ledCharacteristic.writeValue(0);\n  buttonCharacteristic.writeValue(0);\n\n  // start advertising\n  BLE.advertise();\n\n  Serial.println(\"Bluetooth® device active, waiting for connections...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// poll for Bluetooth® Low Energy events\n  BLE.poll();\n\n  // read the current button pin state\n  char buttonValue = digitalRead(buttonPin);\n\n  // has the value changed since the last read\n  bool buttonChanged = (buttonCharacteristic.value() != buttonValue);\n\n  if (buttonChanged) {\n    // button state changed, update characteristics\n    ledCharacteristic.writeValue(buttonValue);\n    buttonCharacteristic.writeValue(buttonValue);\n  }\n\n  if (ledCharacteristic.written() || buttonChanged) {\n    // update LED, either central has written to characteristic or button state has changed\n    if (ledCharacteristic.value()) {\n      Serial.println(\"LED on\");\n      digitalWrite(ledPin, HIGH);\n    } else {\n      Serial.println(\"LED off\");\n      digitalWrite(ledPin, LOW);\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "spi",
        "digitalread",
        "millis",
        "led",
        "debounce"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "checkPin",
          "parameters": "",
          "body": "// Invert state, since button is \"Active LOW\"\n  int state = !digitalRead(2);\n\n  // Debounce mechanism\n  long t = millis();\n  if (state != prevState) {\n    lastChangeTime = t;\n  }\n  if (t - lastChangeTime > 50) {\n    if (state != currState) {\n      currState = state;\n      Blynk.virtualWrite(V1, state);\n    }\n  }\n  prevState = state;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n\n  // Make pin 2 default HIGH, and attach INT to our handler\n  pinMode(2, INPUT_PULLUP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  checkPin();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// we are going to use the serial communication as a\n  // way to see on the PC what is happening on the Arduino\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if(btn.pressed())\n    Serial.println(\"pressed\");\n  if(btn.held())\n    Serial.println(\"held\");\n  if(btn.released()) {\n    Serial.println(\"released\");\n    Serial.print(\"switch: \");\n    Serial.println(btn.readSwitch());\n  }\n\n  delay(50);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key"
      ],
      "libraries": [
        "EduIntro.h",
        "Keyboard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// we are going to use the serial communication as a\n  // way to see on the PC what is happening on the Arduino\n  Serial.begin(9600);\n\n  // initialize the keyboard controller\n  Keyboard.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for (int i; i < 4; i ++) {\n    if (btn[i].pressed()) {\n      Serial.print(\"pressed pin: \"); Serial.println(btnPins[i]);\n      Keyboard.press(key[i]);\n    }\n    if (btn[i].held())\n      Serial.print(\"held pin: \"); Serial.println(btnPins[i]);\n    if (btn[i].released()) {\n      Serial.print(\"released pin: \"); Serial.println(btnPins[i]);\n      Serial.print(\"switch pin \"); Serial.print(btnPins[i]); Serial.print(\": \");\n      Serial.println(btn[i].readSwitch());\n      Keyboard.release(key[i]);\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "analogwrite",
        "digitalwrite",
        "delay",
        "led",
        "oled",
        "pwm",
        "nodes",
        "devices"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "SSD1306Ascii.h",
        "SSD1306AsciiWire.h",
        "menu.h",
        "menuIO/SSD1306AsciiOut.h",
        "menuIO/keyIn.h",
        "menuIO/chainStream.h",
        "config.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "joystickBtns.begin();\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(LED_BUILTIN, OUTPUT);\n  Wire.begin();\n  oled.begin(&Adafruit128x64, OLED_I2C_ADDRESS); //check config\n  oled.setFont(menuFont);\n  oled.clear();\n  nav.idleTask = idle; //point a function to be used when menu is suspended"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "nav.poll();\n  delay(1);//simulate a delay when other tasks are done"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "display"
      ],
      "libraries": [
        "MicroGamer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//initiate mg instance\n  mg.begin();\n\n  // here we set the framerate to 30, we do not need to run at default 60 and\n  // it saves us battery life.\n  mg.setFrameRate(30);\n\n  // set x and y to the middle of the screen\n  x = (WIDTH / 2) - (NUM_CHARS * CHAR_WIDTH / 2);\n  y = (HEIGHT / 2) - (CHAR_HEIGHT / 2);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// pause render until it's time for the next frame\n  if (!(mg.nextFrame()))\n    return;\n\n  // the next couple of lines will deal with checking if the D-pad buttons\n  // are pressed and move our text accordingly.\n  // We check to make sure that x and y stay within a range that keeps the\n  // text on the screen.\n\n  // if the right button is pressed move 1 pixel to the right every frame\n  if(mg.pressed(RIGHT_BUTTON) && (x < X_MAX)) {\n    x++;\n  }\n\n  // if the left button is pressed move 1 pixel to the left every frame\n  if(mg.pressed(LEFT_BUTTON) && (x > 0)) {\n    x--;\n  }\n\n  // if the up button or B button or X button is pressed move 1 pixel up every frame\n  if((mg.pressed(UP_BUTTON) || mg.pressed(B_BUTTON) || mg.pressed(X_BUTTON)) && (y > 0)) {\n    y--;\n  }\n\n  // if the down button or A button or Y button is pressed move 1 pixel down every frame\n  if((mg.pressed(DOWN_BUTTON) || mg.pressed(A_BUTTON) || mg.pressed(Y_BUTTON)) && (y < Y_MAX)) {\n    y++;\n  }\n\n\n  // we clear our screen to black\n  mg.clear();\n\n  // we set our cursor x pixels to the right and y down from the top\n  mg.setCursor(x, y);\n\n  // then we print to screen what is stored in our title variable we declared earlier\n  mg.print(title);\n\n  // then we finaly we tell the MicroGamer to display what we just wrote to the display.\n  mg.display();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "callback",
        "power",
        "current",
        "digitalwrite",
        "digitalread",
        "delay",
        "rgb",
        "led",
        "rtc"
      ],
      "libraries": [
        "Arduino_PF1550.h",
        "Wire.h",
        "RTC.h",
        "r_lpm.h"
      ],
      "functions": [
        {
          "name": "periodic_cbk",
          "parameters": "",
          "body": "digitalWrite(LEDR, !digitalRead(LEDR));"
        },
        {
          "name": "alarm_cbk",
          "parameters": "",
          "body": "digitalWrite(LED_BUILTIN, LOW);\n  delay(500);\n  digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial) { }\n\n  //PMIC.debug(Serial);\n  PMIC.begin();\n  PMIC.configLDO1(Ldo1Voltage::V_3_30, false, false, false);\n  PMIC.configLDO2(Ldo2Voltage::V_3_30, false, false, false);\n  PMIC.configLDO3(Ldo3Voltage::V_1_20, false, false, false);\n  PMIC.configSw2(Sw2Voltage::V_3_30, Sw2Voltage::V_3_30, Sw2Voltage::V_3_30, Sw2CurrentLimit::I_1_5_A, false, false, false);\n\n  Serial.print(\"Device ID = \");\n  Serial.println(PMIC.getDeviceId(), HEX);\n\n  p_cfg.low_power_mode = LPM_MODE_DEEP; //  LPM_MODE_SLEEP  LPM_MODE_STANDBY    LPM_MODE_STANDBY_SNOOZE    LPM_MODE_DEEP\n  p_cfg.standby_wake_sources = LPM_STANDBY_WAKE_SOURCE_IRQ0 | LPM_STANDBY_WAKE_SOURCE_RTCALM;\n  p_cfg.dtc_state_in_snooze = LPM_SNOOZE_DTC_DISABLE; // LPM_SNOOZE_DTC_ENABLE LPM_SNOOZE_DTC_DISABLE\n  p_cfg.power_supply_state = LPM_POWER_SUPPLY_DEEPCUT0; // LPM_POWER_SUPPLY_DEEPCUT0, LPM_POWER_SUPPLY_DEEPCUT1, LPM_POWER_SUPPLY_DEEPCUT3\n  p_cfg.output_port_enable = LPM_OUTPUT_PORT_ENABLE_RETAIN; // LPM_OUTPUT_PORT_ENABLE_RETAIN LPM_OUTPUT_PORT_ENABLE_HIGH_IMPEDANCE\n  p_cfg.io_port_state = LPM_IO_PORT_NO_CHANGE;  // LPM_IO_PORT_NO_CHANGE LPM_IO_PORT_RESET\n  p_cfg.deep_standby_cancel_source = LPM_DEEP_STANDBY_CANCEL_SOURCE_RTC_ALARM;\n\n  R_LPM_Open(&p_api_ctrl, &p_cfg);\n\n  /* Configure LED_BUILTIN. */\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n\n  /* Configure the red RGB LED. */\n  pinMode(LEDR, OUTPUT);\n  digitalWrite(LEDR, LOW);\n  delay(200);\n  digitalWrite(LEDR, HIGH);\n\n  /* Initialize the RTC. */\n  RTC.begin();\n  RTCTime initial_time(1, Month::JANUARY, 2000, 12, 10, 00, DayOfWeek::TUESDAY, SaveLight::SAVING_TIME_ACTIVE);\n\n  if (!RTC.isRunning())\n    RTC.setTime(initial_time);\n\n  RTCTime alarm_time;\n  alarm_time.setSecond(35);\n\n  AlarmMatch alarm_match;\n  alarm_match.addMatchSecond();\n\n  if (!RTC.setPeriodicCallback(periodic_cbk, Period::ONCE_EVERY_2_SEC))\n    Serial.println(\"ERROR: periodic callback not set\");\n\n  if (!RTC.setAlarmCallback(alarm_cbk, alarm_time, alarm_match))\n    Serial.println(\"ERROR: alarm callback not set\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Enter low power mode. Note: The JLink looses connection here. */\n  R_LPM_LowPowerModeEnter(&p_api_ctrl);\n\n  if (RTC.isRunning())\n  {\n    /* GET CURRENT TIME FROM RTC */\n    RTCTime current_time;\n    RTC.getTime(current_time);\n\n    /* PRINT CURRENT TIME on Serial */\n    Serial.print(\"Current time: \");\n    /* DATE */\n    Serial.print(current_time.getDayOfMonth());\n    Serial.print(\"/\");\n    Serial.print(Month2int(current_time.getMonth()));\n    Serial.print(\"/\");\n    Serial.print(current_time.getYear());\n    Serial.print(\" - \");\n    Serial.print(current_time.getUnixTime());\n    Serial.print(\" - \");\n\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    Serial.print(tv.tv_sec);\n    Serial.print(\" - \");\n\n    /* HOUR:MINUTES:SECONDS */\n    Serial.print(current_time.getHour());\n    Serial.print(\":\");\n    Serial.print(current_time.getMinutes());\n    Serial.print(\":\");\n    Serial.println(current_time.getSeconds());\n\n    delay(1000);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "servo"
      ],
      "libraries": [
        "Commanders.h",
        "Accessories.h"
      ],
      "functions": [
        {
          "name": "ReceiveEvent",
          "parameters": "unsigned long inId, COMMANDERS_EVENT_TYPE inEventType, int inEventData",
          "body": "Accessories::ReceiveEvent(inId, (ACCESSORIES_EVENT_TYPE) inEventType, inEventData);\n\t\n\t#ifdef ACCESSORIES_DEBUG_MODE\n    COMMANDERS_PRINT_EVENT(inId, inEventType, inEventData);\n    #endif"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\t//while (!Serial);\t\t// For Leonardo only. No effect on other Arduino.\n\n\tCommanders::begin(ReceiveEvent, LED_BUILTIN);\n\tAccessories::begin();\n\n\t// Commanders setup\n\n\tDccCommander.begin(0x00, 0x00, digitalPinToInterrupt(2));\n\tSerialCommander.begin();\n\n\tCANCommander.begin(10, CAN_125KBPS, digitalPinToInterrupt(3), 100);\n\n\t// Ports setups\n\n\tPort0.begin(6);\n\tPort1.begin(7);\n\tPort2.begin(8);\n\tPort3.begin(9);\n\tPort4.begin(A0);\n\tPort5.begin(A1);\n\tPort6.begin(A2);\n\tPort7.begin(A3);\n\n\t// Accessories setups\n\n\tspeed = 19;\t// starting speed state : fast.\n\n\tservo0.begin(&Port0, speed, 0, 10, 2);\n\tservo1.begin(&Port1, speed, 0, 10, 2);\n\tservo2.begin(&Port2, speed, 0, 10, 2);\n\tservo3.begin(&Port3, speed, 0, 10, 2);\n\tservo4.begin(&Port4, speed, 0, 10, 2);\n\tservo5.begin(&Port5, speed, 0, 10, 2);\n\tservo6.begin(&Port6, speed, 0, 10, 2);\n\tservo7.begin(&Port7, speed, 0, 10, 2);\n\n\tservo0.AddMinMaxMovingPositions(SERVO0_MIN, SERVO0_MAX);\n\tservo1.AddMinMaxMovingPositions(SERVO1_MIN, SERVO1_MAX);\n\tservo2.AddMinMaxMovingPositions(SERVO2_MIN, SERVO2_MAX);\n\tservo3.AddMinMaxMovingPositions(SERVO3_MIN, SERVO3_MAX);\n\tservo4.AddMinMaxMovingPositions(SERVO4_MIN, SERVO4_MAX);\n\tservo5.AddMinMaxMovingPositions(SERVO5_MIN, SERVO5_MAX);\n\tservo6.AddMinMaxMovingPositions(SERVO6_MIN, SERVO6_MAX);\n\tservo7.AddMinMaxMovingPositions(SERVO7_MIN, SERVO7_MAX);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Commanders::loop();\n\tAccessories::loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "millis"
      ],
      "libraries": [
        "SPI.h",
        "mcp2515.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n \n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_125KBPS);\n  mcp2515.setNormalMode();\n \n  Serial.println(\"------- CAN Speedtest ----------\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (mcp2515.readMessage(&canMsg) == MCP2515::ERROR_OK) {\n    cntr++;\n  }\n \n  if ((millis()-oldTime)>1000) {\n    oldTime = millis();\n    Serial.print(cntr);\n    Serial.println(\" msg/sec\");\n    cntr = 0;      \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi"
      ],
      "libraries": [
        "SPI.h",
        "mcp2515.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  \n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_125KBPS);\n  mcp2515.setNormalMode();\n  \n  Serial.println(\"------- CAN Read ----------\");\n  Serial.println(\"ID  DLC   DATA\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (mcp2515.readMessage(&canMsg) == MCP2515::ERROR_OK) {\n    Serial.print(canMsg.can_id, HEX); // print ID\n    Serial.print(\" \"); \n    Serial.print(canMsg.can_dlc, HEX); // print DLC\n    Serial.print(\" \");\n    \n    for (int i = 0; i<canMsg.can_dlc; i++)  {  // print the data\n      Serial.print(canMsg.data[i],HEX);\n      Serial.print(\" \");\n    }\n\n    Serial.println();      \n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "mcp2515.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "canMsg1.can_id  = 0x0F6;\n  canMsg1.can_dlc = 8;\n  canMsg1.data[0] = 0x8E;\n  canMsg1.data[1] = 0x87;\n  canMsg1.data[2] = 0x32;\n  canMsg1.data[3] = 0xFA;\n  canMsg1.data[4] = 0x26;\n  canMsg1.data[5] = 0x8E;\n  canMsg1.data[6] = 0xBE;\n  canMsg1.data[7] = 0x86;\n\n  canMsg2.can_id  = 0x036;\n  canMsg2.can_dlc = 8;\n  canMsg2.data[0] = 0x0E;\n  canMsg2.data[1] = 0x00;\n  canMsg2.data[2] = 0x00;\n  canMsg2.data[3] = 0x08;\n  canMsg2.data[4] = 0x01;\n  canMsg2.data[5] = 0x00;\n  canMsg2.data[6] = 0x00;\n  canMsg2.data[7] = 0xA0;\n  \n  while (!Serial);\n  Serial.begin(115200);\n  \n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_125KBPS);\n  mcp2515.setNormalMode();\n  \n  Serial.println(\"Example: Write to CAN\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "mcp2515.sendMessage(&canMsg1);\n  mcp2515.sendMessage(&canMsg2);\n\n  Serial.println(\"Messages sent\");\n  \n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // set node address\n  // NOTE: Calling this method will automatically enable\n  //       address filtering. CC1101 also allows to set\n  //       number of broadcast address (0/1/2).\n  //       The following sets one broadcast address 0x00.\n  //       When setting two broadcast addresses, 0x00 and\n  //       0xFF will be used.\n  Serial.print(F(\"[CC1101] Setting node address ... \"));\n  state = radio.setNodeAddress(0x01, 1);\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // address filtering can also be disabled\n  // NOTE: Calling this method will also erase previously\n  //       set node address\n  /*\n    Serial.print(F(\"[CC1101] Disabling address filtering ... \"));\n    state == radio.disableAddressFiltering();\n    if(state == RADIOLIB_ERR_NONE) {\n      Serial.println(F(\"success!\"));\n    } else {\n      Serial.print(F(\"failed, code \"));\n      Serial.println(state);\n      while (true) { delay(10); }\n    }\n  */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[CC1101] Waiting for incoming transmission ... \"));\n\n  // you can receive data as an Arduino String\n  String str;\n  int state = radio.receive(str);\n\n  // you can also receive data as byte array\n  /*\n    byte byteArr[8];\n    int state = radio.receive(byteArr, 8);\n  */\n\n  if (state == RADIOLIB_ERR_NONE) {\n    // packet was successfully received\n    Serial.println(F(\"success!\"));\n\n    // print the data of the packet\n    Serial.print(F(\"[CC1101] Data:\\t\\t\"));\n    Serial.println(str);\n\n    // print RSSI (Received Signal Strength Indicator)\n    // of the last received packet\n    Serial.print(F(\"[CC1101] RSSI:\\t\\t\"));\n    Serial.print(radio.getRSSI());\n    Serial.println(F(\" dBm\"));\n\n    // print LQI (Link Quality Indicator)\n    // of the last received packet, lower is better\n    Serial.print(F(\"[CC1101] LQI:\\t\\t\"));\n    Serial.println(radio.getLQI());\n\n  } else if (state == RADIOLIB_ERR_CRC_MISMATCH) {\n    // packet was received, but is malformed\n    Serial.println(F(\"CRC error!\"));\n\n  } else {\n    // some other error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay",
        "interrupt"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[CC1101] Waiting for incoming transmission ... \"));\n\n  // you can receive data as an Arduino String\n  String str;\n  int state = radio.receive(str);\n\n  // you can also receive data as byte array\n  /*\n    byte byteArr[8];\n    int state = radio.receive(byteArr, 8);\n  */\n\n  if (state == RADIOLIB_ERR_NONE) {\n    // packet was successfully received\n    Serial.println(F(\"success!\"));\n\n    // print the data of the packet\n    Serial.print(F(\"[CC1101] Data:\\t\\t\"));\n    Serial.println(str);\n\n    // print RSSI (Received Signal Strength Indicator)\n    // of the last received packet\n    Serial.print(F(\"[CC1101] RSSI:\\t\\t\"));\n    Serial.print(radio.getRSSI());\n    Serial.println(F(\" dBm\"));\n\n    // print LQI (Link Quality Indicator)\n    // of the last received packet, lower is better\n    Serial.print(F(\"[CC1101] LQI:\\t\\t\"));\n    Serial.println(radio.getLQI());\n\n  } else if (state == RADIOLIB_ERR_RX_TIMEOUT) {\n    // timeout occurred while waiting for a packet\n    Serial.println(F(\"timeout!\"));\n\n  } else if (state == RADIOLIB_ERR_CRC_MISMATCH) {\n    // packet was received, but is malformed\n    Serial.println(F(\"CRC error!\"));\n\n  } else {\n    // some other error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay",
        "interrupt"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // set the function that will be called\n  // when new packet is received\n  radio.setPacketReceivedAction(setFlag);\n\n  // start listening for packets\n  Serial.print(F(\"[CC1101] Starting to listen ... \"));\n  state = radio.startReceive();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // if needed, 'listen' mode can be disabled by calling\n  // any of the following methods:\n  //\n  // radio.standby()\n  // radio.sleep()\n  // radio.transmit();\n  // radio.receive();\n  // radio.readData();"
        },
        {
          "name": "setFlag",
          "parameters": "void",
          "body": "// we got a packet, set the flag\n  receivedFlag = true;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check if the flag is set\n  if(receivedFlag) {\n    // reset flag\n    receivedFlag = false;\n\n    // you can read received data as an Arduino String\n    String str;\n    int state = radio.readData(str);\n\n    // you can also read received data as byte array\n    /*\n      byte byteArr[8];\n      int numBytes = radio.getPacketLength();\n      int state = radio.readData(byteArr, numBytes);\n    */\n\n    if (state == RADIOLIB_ERR_NONE) {\n      // packet was successfully received\n      Serial.println(F(\"[CC1101] Received packet!\"));\n\n      // print data of the packet\n      Serial.print(F(\"[CC1101] Data:\\t\\t\"));\n      Serial.println(str);\n\n      // print RSSI (Received Signal Strength Indicator)\n      // of the last received packet\n      Serial.print(F(\"[CC1101] RSSI:\\t\\t\"));\n      Serial.print(radio.getRSSI());\n      Serial.println(F(\" dBm\"));\n\n      // print LQI (Link Quality Indicator)\n      // of the last received packet, lower is better\n      Serial.print(F(\"[CC1101] LQI:\\t\\t\"));\n      Serial.println(radio.getLQI());\n\n    } else if (state == RADIOLIB_ERR_CRC_MISMATCH) {\n      // packet was received, but is malformed\n      Serial.println(F(\"CRC error!\"));\n\n    } else {\n      // some other error occurred\n      Serial.print(F(\"failed, code \"));\n      Serial.println(state);\n\n    }\n\n    // put module back to listen mode\n    radio.startReceive();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "power",
        "spi",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio1.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize CC1101 with non-default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  // carrier frequency:                   434.0 MHz\n  // bit rate:                            32.0 kbps\n  // frequency deviation:                 60.0 kHz\n  // Rx bandwidth:                        250.0 kHz\n  // output power:                        7 dBm\n  // preamble length:                     32 bits\n  state = radio2.begin(434.0, 32.0, 60.0, 250.0, 7, 32);\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // you can also change the settings at runtime\n  // and check if the configuration was changed successfully\n\n  // set carrier frequency to 433.5 MHz\n  if (radio1.setFrequency(433.5) == RADIOLIB_ERR_INVALID_FREQUENCY) {\n    Serial.println(F(\"[CC1101] Selected frequency is invalid for this module!\"));\n    while (true) { delay(10); }\n  }\n\n  // set bit rate to 100.0 kbps\n  state = radio1.setBitRate(100.0);\n  if (state == RADIOLIB_ERR_INVALID_BIT_RATE) {\n    Serial.println(F(\"[CC1101] Selected bit rate is invalid for this module!\"));\n    while (true) { delay(10); }\n  } else if (state == RADIOLIB_ERR_INVALID_BIT_RATE_BW_RATIO) {\n    Serial.println(F(\"[CC1101] Selected bit rate to bandwidth ratio is invalid!\"));\n    Serial.println(F(\"[CC1101] Increase receiver bandwidth to set this bit rate.\"));\n    while (true) { delay(10); }\n  }\n\n  // set receiver bandwidth to 250.0 kHz\n  if (radio1.setRxBandwidth(250.0) == RADIOLIB_ERR_INVALID_RX_BANDWIDTH) {\n    Serial.println(F(\"[CC1101] Selected receiver bandwidth is invalid for this module!\"));\n    while (true) { delay(10); }\n  }\n\n  // set allowed frequency deviation to 10.0 kHz\n  if (radio1.setFrequencyDeviation(10.0) == RADIOLIB_ERR_INVALID_FREQUENCY_DEVIATION) {\n    Serial.println(F(\"[CC1101] Selected frequency deviation is invalid for this module!\"));\n    while (true) { delay(10); }\n  }\n\n  // set output power to 5 dBm\n  if (radio1.setOutputPower(5) == RADIOLIB_ERR_INVALID_OUTPUT_POWER) {\n    Serial.println(F(\"[CC1101] Selected output power is invalid for this module!\"));\n    while (true) { delay(10); }\n  }\n\n  // 2 bytes can be set as sync word\n  if (radio1.setSyncWord(0x01, 0x23) == RADIOLIB_ERR_INVALID_SYNC_WORD) {\n    Serial.println(F(\"[CC1101] Selected sync word is invalid for this module!\"));\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// nothing here"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // set node address\n  // NOTE: Calling this method will automatically enable\n  //       address filtering. CC1101 also allows to set\n  //       number of broadcast address (0/1/2).\n  //       The following sets one broadcast address 0x00.\n  //       When setting two broadcast addresses, 0x00 and\n  //       0xFF will be used.\n  Serial.print(F(\"[CC1101] Setting node address ... \"));\n  state = radio.setNodeAddress(0x01, 1);\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // address filtering can also be disabled\n  // NOTE: Calling this method will also erase previously\n  //       set node address\n  /*\n    Serial.print(F(\"[CC1101] Disabling address filtering ... \"));\n    state == radio.disableAddressFiltering();\n    if(state == RADIOLIB_ERR_NONE) {\n      Serial.println(F(\"success!\"));\n    } else {\n      Serial.print(F(\"failed, code \"));\n      Serial.println(state);\n      while (true) { delay(10); }\n    }\n  */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[CC1101] Transmitting packet ... \"));\n\n  // you can transmit C-string or Arduino string up to 63 characters long\n  int state = radio.transmit(\"Hello World!\");\n\n  // you can also transmit byte array up to 63 bytes long\n  /*\n    byte byteArr[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};\n    int state = radio.transmit(byteArr, 8);\n  */\n\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));\n\n  } else if (state == RADIOLIB_ERR_PACKET_TOO_LONG) {\n    // the supplied packet was longer than 255 bytes\n    Serial.println(F(\"too long!\"));\n\n  } else {\n    // some other error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }\n\n  // wait for a second before transmitting again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay",
        "interrupt"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[CC1101] Transmitting packet ... \"));\n\n  // you can transmit C-string or Arduino string up to 63 characters long\n  String str = \"Hello World! #\" + String(count++);\n  int state = radio.transmit(str);\n\n  // you can also transmit byte array up to 63 bytes long\n  /*\n    byte byteArr[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};\n    int state = radio.transmit(byteArr, 8);\n  */\n\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));\n\n  } else if (state == RADIOLIB_ERR_PACKET_TOO_LONG) {\n    // the supplied packet was longer than 64 bytes\n    Serial.println(F(\"too long!\"));\n\n  } else {\n    // some other error occurred\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n\n  }\n\n  // wait for a second before transmitting again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay",
        "interrupt"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize CC1101 with default settings\n  Serial.print(F(\"[CC1101] Initializing ... \"));\n  int state = radio.begin();\n  if (state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // set the function that will be called\n  // when packet transmission is finished\n  radio.setPacketSentAction(setFlag);\n\n  // start transmitting the first packet\n  Serial.print(F(\"[CC1101] Sending first packet ... \"));\n\n  // you can transmit C-string or Arduino string up to\n  // 64 characters long\n  transmissionState = radio.startTransmit(\"Hello World!\");\n\n  // you can also transmit byte array up to 64 bytes long\n  /*\n    byte byteArr[] = {0x01, 0x23, 0x45, 0x56,\n                      0x78, 0xAB, 0xCD, 0xEF};\n    state = radio.startTransmit(byteArr, 8);\n  */"
        },
        {
          "name": "setFlag",
          "parameters": "void",
          "body": "// we sent a packet, set the flag\n  transmittedFlag = true;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check if the previous transmission finished\n  if(transmittedFlag) {\n    // reset flag\n    transmittedFlag = false;\n\n    if (transmissionState == RADIOLIB_ERR_NONE) {\n      // packet was successfully sent\n      Serial.println(F(\"transmission finished!\"));\n\n      // NOTE: when using interrupt-driven transmit method,\n      //       it is not possible to automatically measure\n      //       transmission data rate using getDataRate()\n\n    } else {\n      Serial.print(F(\"failed, code \"));\n      Serial.println(transmissionState);\n\n    }\n\n    // clean up after transmission is finished\n    // this will ensure transmitter is disabled,\n    // RF switch is powered down etc.\n    radio.finishTransmit();\n\n    // wait a second before transmitting again\n    delay(1000);\n\n    // send another one\n    Serial.print(F(\"[CC1101] Sending another packet ... \"));\n\n    // you can transmit C-string or Arduino string up to\n    // 256 characters long\n    String str = \"Hello World! #\" + String(count++);\n    transmissionState = radio.startTransmit(str);\n\n    // you can also transmit byte array up to 256 bytes long\n    /*\n      byte byteArr[] = {0x01, 0x23, 0x45, 0x67,\n                        0x89, 0xAB, 0xCD, 0xEF};\n      int state = radio.startTransmit(byteArr, 8);\n    */\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "wifi",
        "spi",
        "interrupt"
      ],
      "libraries": [
        "SPI.h",
        "Adafruit_CC3000.h",
        "BlynkSimpleCC3000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass, wifi_sec);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wifi",
        "delay"
      ],
      "libraries": [
        "Wire.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "MQ7.h"
      ],
      "functions": [
        {
          "name": "sigmoid",
          "parameters": "float x",
          "body": "return 1 / (1 + exp(-x));"
        },
        {
          "name": "defuzzify",
          "parameters": "float fuzzyOutput",
          "body": "if (fuzzyOutput < 0.5) {\n    return 0; // Safe\n  } else {\n    return 100; // Danger\n  }"
        },
        {
          "name": "predictFNN",
          "parameters": "float input",
          "body": "float fuzzyInput1 = exp(-pow((input - 10) / 15, 2)); // Gaussian for low\n  float fuzzyInput2 = exp(-pow((input - 40) / 15, 2)); // Gaussian for medium\n  float fuzzyInput3 = exp(-pow((input - 70) / 15, 2)); // Gaussian for high\n  \n  float hiddenSum = fuzzyInput1 * weights[0] + fuzzyInput2 * weights[1] + fuzzyInput3 * weights[2] + bias;\n  float output = sigmoid(hiddenSum);\n  return defuzzify(output);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.println(\"Connecting to WiFi...\");\n  }\n  Serial.println(\"Connected to WiFi\");\n  Serial.print(\"Alamat IP: \");\n  Serial.println(WiFi.localIP());\n  net_ssl.setCACert(TELEGRAM_CERTIFICATE_ROOT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int coLevel = mq7.getPPM();\n  Serial.print(\"Nilai Sensor CO: \");\n  Serial.println(coLevel);\n\n  float prediction = predictFNN(coLevel);\n\n  String message;\n  if (prediction == 0) {\n    message = \"Tingkat polutan CO: \" + String(coLevel) + \" ppm, Status: Aman.\";\n  } else {\n    message = \"Tingkat polutan CO: \" + String(coLevel) + \" ppm, Status: Bahaya!\";\n  }\n  bot.sendMessage(CHAT_ID, message, \"\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "telegram",
        "api",
        "certificate",
        "wifi",
        "delay"
      ],
      "libraries": [
        "MQ7.h",
        "MQ3.h",
        "Wire.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "Fuzzy.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // Koneksi ke WiFi\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n  }\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);                              // Menunnggu atau delay waktu untuk koneksi ke jaringan WiFi\n    Serial.println(\"Connecting to WiFi...\");  // Pesan koneksi WiFi\n  }\n  Serial.println(\"Connected to WiFi\");  // Status koneksi yang ditampilkan jika dikoneksi\n  // Tampilkan alamat IP pada serial monitor\n  Serial.print(\"Alamat IP: \");                   // Alamat IP yang digunakan untuk komunikasi via Telegram\n  Serial.println(WiFi.localIP());                // Melihat Alamat IP\n  net_ssl.setCACert(TELEGRAM_CERTIFICATE_ROOT);  // Add root certificate for api.telegram.org\n\n\n  FuzzyInput *co = new FuzzyInput(1);\n  FuzzySet *low = new FuzzySet(0, 10, 10, 30);\n  co->addFuzzySet(low);\n  FuzzySet *medium = new FuzzySet(20, 40, 40, 60);\n  co->addFuzzySet(medium);\n  FuzzySet *high = new FuzzySet(50, 70, 70, 1023);\n  co->addFuzzySet(high);\n  fuzzy->addFuzzyInput(co);\n\n  FuzzyOutput *alert = new FuzzyOutput(1);\n  FuzzySet *safe = new FuzzySet(0, 0, 0, 45);\n  alert->addFuzzySet(safe);\n  FuzzySet *danger = new FuzzySet(30, 60, 60, 90);\n  alert->addFuzzySet(danger);\n  fuzzy->addFuzzyOutput(alert);\n\n  // Aturan fuzzy\n  FuzzyRuleAntecedent *ifLowOrMedium = new FuzzyRuleAntecedent();\n  ifLowOrMedium->joinWithOR(low, medium);\n  FuzzyRuleConsequent *thenSafe = new FuzzyRuleConsequent();\n  thenSafe->addOutput(safe);\n  FuzzyRule *fRule1 = new FuzzyRule(1, ifLowOrMedium, thenSafe);\n  fuzzy->addFuzzyRule(fRule1);\n\n  FuzzyRuleAntecedent *ifHigh = new FuzzyRuleAntecedent();\n  ifHigh->joinSingle(high);\n  FuzzyRuleConsequent *thenDanger = new FuzzyRuleConsequent();\n  thenDanger->addOutput(danger);\n  FuzzyRule *fRule2 = new FuzzyRule(2, ifHigh, thenDanger);\n  fuzzy->addFuzzyRule(fRule2);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int coLevel = mq7.getPPM();\n  Serial.print(\"Nilai Sensor CO: \");\n  Serial.println(coLevel);\n  delay(5000);\n\n  fuzzy->setInput(1, coLevel);\n\n  fuzzy->fuzzify();\n\n  float alertLevel = fuzzy->defuzzify(1);\n  if (alertLevel == 0.0) {\n    // Replace the output message with an error message\n    String message = \"Error: Sensor not sensing\";\n    bot.sendMessage(CHAT_ID, message, \"\");\n    delay(1000);\n  } else {\n    //String message = \"Tingkat polutan CO: \" + String(coLevel) + \", Tingkat bahaya: \" + String(alertLevel) + \" di Wilayah FMIPA\";  //FMIPA\n    String message = \"Tingkat polutan CO: \" + String(coLevel) + \" ppm, Tingkat bahaya: \" + String(alertLevel) + \"% di Sekitaran Wilayah Fakultas Matematika dan Ilmu Pengetahuan dan Fakultas Bahasa dan Seni\"; //FH\n    //String message = \"Tingkat polutan CO: \" + String(coLevel) + \", Tingkat bahaya: \" + String(alertLevel) + \" di Wilayah FK\"; //FK\n    //String message = \"Tingkat polutan CO: \" + String(coLevel) + \", Tingkat bahaya: \" + String(alertLevel) + \" di Wilayah FISIP dan FEB\"; //FISIP dan FEB\n    //String message = \"Tingkat polutan CO: \" + String(coLevel) + \", Tingkat bahaya: \" + String(alertLevel) + \"di Wilayah FIK\"; //FIK\n    //String message = \"Tingkat polutan CO: \" + String(coLevel) + \", Tingkat bahaya: \" + String(alertLevel) + \"di Wilayah FBS\"; //FBS\n    //String message = \"Tingkat polutan CO: \" + String(coLevel) + \", Tingkat bahaya: \" + String(alertLevel) + \"di Wilayah FIPP\"; //FIPP\n    bot.sendMessage(CHAT_ID, message, \"\");\n    delay(1000);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "current",
        "voltage",
        "power",
        "uart",
        "delay",
        "millis",
        "eeprom"
      ],
      "libraries": [
        "CS5490.h",
        "EEPROM.h"
      ],
      "functions": [
        {
          "name": "CS5490_testReset",
          "parameters": "void",
          "body": "// Activate HPF on I current (to remove the DC component: it's an AC application)\n  uint32_t reg = line.readReg(16,0);\n  reg |= 0x0000000A;\n  line.write(16,0,reg);\n  \n  // Set to single conversion in order to force CRC computing\n  line.singConv();\n\n\tuint32_t regChk = line.getRegChk();\n  if (!line.areLastReadingOperationsSucceeded()) return false;\n\n  if(regChk != 0x00DD8BD6) return false;\n\n  return true; // Reset OK"
        },
        {
          "name": "CS5490_SendConfiguration",
          "parameters": "void",
          "body": "uint32_t IgainCalibrated;\n  uint8_t calibrationData[7];\n\n  // Look for calibration data stored in EEPROM\n  uint8_t CRC = 0;\n  for(uint8_t i=0; i<7;i++)\n  {\n    calibrationData[i] = EEPROM.read(i);\n    //Serial.println(calibrationData[i], HEX);\n    CRC ^=calibrationData[i];\n  }\n\n  if(!CRC) // EEPROM CRC OK\n  {\n    IgainCalibrated = ((uint32_t)calibrationData[0]) * 65536 + ((uint32_t)calibrationData[1]) * 256 + calibrationData[2];\n    CriticalRegisterChecksum = ((uint32_t)calibrationData[3]) * 65536 + ((uint32_t)calibrationData[4]) * 256 + calibrationData[5];\n    \n    Serial.println(\"___CALIBRATION DATA READ FROM EEPROM___ \");\n    Serial.print(\"   IgainCalibrated: \");\n    Serial.println(IgainCalibrated, HEX);\n\n    Serial.print(\"   CriticalRegisterChecksum: \");\n    Serial.println(CriticalRegisterChecksum, HEX);\n\n    // Send calibration data\n    line.write(16,33,IgainCalibrated);\n    uint32_t IgainCalibratedReadBack = line.readReg(16, 33);\n    if (line.areLastReadingOperationsSucceeded() && IgainCalibratedReadBack == IgainCalibrated)\n    {\n      Serial.println(\"Igain written and verified\");\n    }\n    else\n    {\n      Serial.println(\"Igain error!\");\n    }\n  }\n  else // No valid calibration parameters found in EEPROM --> APPLY DEFAULTS 0xDD8BD6\n  {\n    Serial.println(\"CALIBRATION DATA NOT FOUND: apply default CriticalRegisterChecksum: 0xDD8BD6\");\n    CriticalRegisterChecksum = 0xDD8BD6;\n  }\n  \n  // Activate HPF on I current (Don't alterate critical registers checksum)\n  uint32_t reg = line.readReg(16,0);\n  reg |= 0x0000000A;\n  line.write(16,0,reg);\n  \n  //line.setDOpinFunction(DO_V_ZERO_CROSSING, false); // Test the zero crossing feature\n\n  // Set to continous conversion\n  line.contConv();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initializing communication with CS5490\n  //600 is the default baud rate velocity.\n   line.begin(baudRate_default);\n\n  line.hardwareReset();\n  resetRequired = false;\n  \n  //Initializing communication arduino/PC to show results in Monitor Serial\n  Serial.begin(115200);\n  // wait for serial port to connect. Needed for Leonardo only\n  while (!Serial);\n\n#ifndef TUNING_MODE_ACTIVE\n  CS5490_SendConfiguration();\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#ifdef TUNING_MODE_ACTIVE\n\n  // The application is AC (mains voltage) with shunt resistor used to measure the current.\n  // Perform the Igain calibration with a reference instruments (a calibrated digital power meter) in the condition of more less HALF LOAD \n  // Implementation based on \"CIRRUS LOGIC AN366REV2\" pag. 15 \"Main Calibration Flow\" https://statics.cirrus.com/pubs/appNote/AN366REV2.pdf\n  // Calibration should be performed with PF=1 --> pure resistive load\n  \n  #define I_CAL_RMS_A  1.3126 // Moreless 1/2 max load\n  #define SCALE_REGISTER_FRACTION  (0.6 * SYS_GAIN * (I_CAL_RMS_A / I_MAX_RMS_A)) // For not full load calibration\n  #define SCALE_REGISTER_VALUE ((uint32_t)(SCALE_REGISTER_FRACTION * 0x800000)) \n\n  // Verify that reset is ok: HW RESET --> START SINGLE CONVERSION --> CHECK RESET CHECKSUM\n  while(!CS5490_testReset())\n  {\n    Serial.println( \"RESET issue... retry\" );\n    line.resolve();\n  }\n\n  Serial.println( \"RESET OK! Default parameters applied.\" );\n\n  line.write(18, 63, SCALE_REGISTER_VALUE); // Set scale register for not full load AC current gain calibration --> THIS MODIFY THE critical registers checksum!!!\n\n  Serial.println( \"Scale register set --> Start continuos conversion...\" );\n\n  line.contConv();\n\n  delay(2000); // Wait 2 seconds\n\n  line.haltConv();\n\n  double rmsV = line.getRmsV();\n  double freq = line.getFreq();\n  double rmsI = line.getRmsI();\n  double PF = line.getPF();\n  double P = line.getAvgP();\n  double Q = line.getAvgQ();\n  double S = line.getAvgS();\n   \n  if(line.areLastReadingOperationsSucceeded())\n  {\n        Serial.print(\"Vac RMS: \");\n        rmsV = (((rmsV/SYS_GAIN)/V_FS)*V_FS_RMS_V)/V_ALFA;\n        Serial.print( rmsV, 2 );\n        Serial.print(\" [V] @ \");\n        Serial.print(freq*SAMPLE_COUNT_DEFAULT, 2);\n        Serial.println(\" Hz\");\n        Serial.print(\"Iac RMS: \");\n        rmsI  = (((rmsI/SYS_GAIN)/I_FS)*I_FS_RMS_V)/R_SHUNT_OHM;\n        Serial.print( rmsI, 4 );\n        Serial.println(\" [A]\");\n        Serial.print(\"PF: \");\n        Serial.println( PF, 4 );\n        Serial.print(\"Active power: \");\n        Serial.print( P * P_COEFF , 4 ); \n        Serial.println(\" W\");\n        Serial.print(\"Reactive power: \");\n        Serial.print( Q * P_COEFF, 4 );\n        Serial.println(\" VAR\");\n        Serial.print(\"Apparent power: \");\n        Serial.print( S * P_COEFF, 4 );\n        Serial.println(\" VA\");\n        \n        Serial.println();\n        Serial.println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\n        Serial.println(\"Please check if measures are in the expected range, otherwise the calibration is invalid.\");\n        Serial.println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\n        Serial.println();\n\n        bool tuningSubSequenceIsOK = true;\n\n        line.write(16, 57, 0x1F40); // Set Tsettle to 2000ms\n        uint32_t reg = line.readReg(16, 57);\n        if (!line.areLastReadingOperationsSucceeded() || reg != 0x1F40) tuningSubSequenceIsOK = false;\n\n        line.write(16, 51, 0x3E80); // Set sample count register to 16000\n        reg = line.readReg(16, 51);\n        if (!line.areLastReadingOperationsSucceeded() || reg != 0x3E80) tuningSubSequenceIsOK = false;\n\n        reg = line.readReg(0, 23); // Status0 register (in order to manage the DRDY bit)\n        if (!line.areLastReadingOperationsSucceeded()) tuningSubSequenceIsOK = false;\n        line.write(0, 23, 0x00800000); // Clear DRDY by setting it\n        uint32_t status0_reg_verify = line.readReg(0, 23);\n        if (!line.areLastReadingOperationsSucceeded() || reg & 0x7FFFFF != status0_reg_verify) tuningSubSequenceIsOK = false;\n\n        if(tuningSubSequenceIsOK)\n        {\n          line.sendCalibrationCommand(Gain, Current);  // Start current gain calibration\n          \n          // Wait for DRDY set, with 3000ms time-out\n          unsigned long startMillis = millis();\n          bool DRDY;\n          do\n          {\n            reg = line.readReg(0, 23); // Status0 register (in order to manage the DRDY bit)\n            if(line.areLastReadingOperationsSucceeded() && reg & 0x800000)\n              DRDY = true; \n            else \n              DRDY = false;\n          }\n          while( !DRDY && ( (millis()-startMillis) < 3000));\n\n          if(DRDY)\n          {\n            line.contConv();\n\n            delay(2000);\n\n            double rmsV = line.getRmsV();\n            double freq = line.getFreq();\n            double rmsI = line.getRmsI();\n            double PF = line.getPF();\n            uint32_t Igain = line.readReg(16, 33);\n  \n            // Power read always 0 in this calibration phase (experimental result)\n            // double P = line.getAvgP();\n            // double Q = line.getAvgQ();\n            // double S = line.getAvgS();\n              \n            if(line.areLastReadingOperationsSucceeded())\n            {\n                  Serial.print(\"Vac RMS: \");\n                  rmsV = (((rmsV/SYS_GAIN)/V_FS)*V_FS_RMS_V)/V_ALFA;\n                  Serial.print( rmsV, 2 );\n                  Serial.print(\" [V] @ \");\n                  Serial.print(freq*SAMPLE_COUNT_DEFAULT, 2);\n                  Serial.println(\" Hz\");\n                  Serial.print(\"Iac RMS: \");\n                  rmsI  = (((rmsI/SYS_GAIN)/I_FS)*I_FS_RMS_V)/R_SHUNT_OHM;\n                  Serial.print( rmsI, 4 );\n                  Serial.println(\" [A]\");\n                  Serial.print(\"PF: \");\n                  Serial.println( PF, 4 );\n  \n                  // Power read always 0 in this calibration phase (experimental result)\n                  // Serial.print(\"Active power: \");\n                  // Serial.print( P * P_COEFF , 4 ); \n                  // Serial.println(\" W\");\n                  // Serial.print(\"Reactive power: \");\n                  // Serial.print( Q * P_COEFF, 4 );\n                  // Serial.println(\" VAR\");\n                  // Serial.print(\"Apparent power: \");\n                  // Serial.print( S * P_COEFF, 4 );\n                  // Serial.println(\" VA\");\n                  \n                  // Verify that reset is ok: HW RESET --> START SINGLE CONVERSION --> CHECK RESET CHECKSUM\n                  while(!CS5490_testReset())\n                  {\n                    Serial.println( \"RESETTING CS5490...\" );\n                    line.hardwareReset();\n                  }\n\n                  line.write(16, 33, Igain);\n                  uint32_t IgainReadBack = line.readReg(16, 33);\n                  if ( line.areLastReadingOperationsSucceeded() && IgainReadBack == Igain)\n                  {\n                    line.singConv(); // In order to compute the critical register checksum\n                    delay(1000);\n\n                    uint32_t regChk = line.getRegChk();\n                    if(line.areLastReadingOperationsSucceeded())\n                    {\n                        Serial.print(\"I gain: \"); \n                        Serial.println(Igain, HEX);\n                        Serial.print(\"Critical registers checksum: \"); // Must be compared with the one expected for the current configuration (stored in the eeprom). In case of mismatch --> reset CS5490\n                        Serial.println(regChk, HEX);\n                        Serial.println( \"RESET OK! Tuned parameters applied.\" );\n\n                        uint8_t calibrationData[6];\n                        calibrationData[0] = (uint8_t)(Igain>>16); // MSB \n                        calibrationData[1] = (uint8_t)(Igain>>8); \n                        calibrationData[2] = (uint8_t)Igain;       // LSB\n                        calibrationData[3] = (uint8_t)(regChk>>16); // MSB \n                        calibrationData[4] = (uint8_t)(regChk>>8); \n                        calibrationData[5] = (uint8_t)regChk;       // LSB\n\n                        uint8_t CRC = 0;\n                        for(uint8_t i=0; i<6;i++)\n                        {\n                          CRC ^= calibrationData[i];\n                          EEPROM.update(i, calibrationData[i]);\n                          delay(100);\n                        }\n                        EEPROM.update(6, CRC);\n                        delay(100);\n\n                        // EEPROM saved data verification\n                        CRC = 0;\n                        for(uint8_t i=0; i<7;i++)\n                          CRC ^= EEPROM.read(i);\n                        \n                        if(!CRC)\n                        {\n                          Serial.println();\n                          Serial.println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\n                          Serial.println(\"Calibration data Igain has been saved in the EEPROM and will be restored at the normal startup\");\n                          Serial.println(\"Please check if measures are in the expected range, otherwise the calibration is invalid.\");\n                          Serial.println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\n                          Serial.println();\n                        }\n                        else\n                        {\n                          Serial.println(\"Calibration data storage issue!\\n Please try restart the calibration or replace the logic board\\n\");\n                        }\n                    }\n                    else\n                    {\n                      Serial.print(\"Calibration aborted due to serial communication errors.\\n Please try restart the calibration\\n\");\n                    }  \n                  }\n                  else\n                  {\n                    Serial.print(\"Calibration aborted due to serial communication errors.\\n Please try restart the calibration\\n\");\n                  }\n            }\n            else\n            {\n              Serial.print(\"Calibration aborted due to serial communication errors.\\n Please try restart the calibration\\n\");\n            }\n            \n\n          }\n          else\n          {\n            Serial.println(\"Calibration measuring time-out error\\n Please try restart the calibration\\n\");\n          }\n        \n        }\n        else\n        {\n          Serial.print(\"Calibration aborted due to serial communication errors.\\n Please try restart the calibration\\n\"); \n        }\n  }\n  else\n  {\n     Serial.print(\"Calibration aborted due to serial communication errors.\\n Please try restart the calibration\\n\");  \n  }\n  \n\n\n  for(;;);\n\n#else \n\n   //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n   // Demo application: \n   // the evaluation board CDB5490 measures electrical parameters directly from the mains (max 300Vrms). \n   // The current is sensed using a shunt resistor between IN+ and IN- (J32) - J7 on IN- , J8 on IN+, J44 and J46 closed, J53 and J54 open\n   // The voltage is connected between LINE and GND (J4) using the builtin attenuation network - J6 in line and J11 on GND, J45 open\n   // UART connection with Arduino on J19 (TX, RX, RESET and GND1) - J20 in TX-DIGITAL position - R37, R38 and R43 must be removed to avoid collision with onboard uC\n   // J23 on the RESET line must be closed.\n   //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \n  static uint8_t communicationMaxRetries = 5;\n  static uint8_t measureErrorDetectionCounter = 10;\n  \n  // Acquire data and control that read operations are all OK\n  double rmsV = line.getRmsV();\n  double freq = line.getFreq();\n  double rmsI = line.getRmsI();\n  double PF = line.getPF();\n  double P = line.getAvgP();\n  double Q = line.getAvgQ();\n  double S = line.getAvgS();\n\tuint32_t regChk = line.getRegChk();\n  bool internalVoltageReferenceOK = line.checkInternalVoltageReference();\n\n  // If all data are valid and the meter configuration is not corrupted, print results\n  if(line.areLastReadingOperationsSucceeded())\n  {\n    if(regChk == CriticalRegisterChecksum)\n    {\n      Serial.print(\"Vac RMS: \");\n      rmsV = (((rmsV/SYS_GAIN)/V_FS)*V_FS_RMS_V)/V_ALFA;\n      Serial.print( rmsV, 2 );\n      Serial.print(\" [V] @ \");\n      Serial.print(freq*SAMPLE_COUNT_DEFAULT, 2);\n      Serial.println(\" Hz\");\n      Serial.print(\"Iac RMS: \");\n      \n      rmsI  = (((rmsI/SYS_GAIN)/I_FS)*I_FS_RMS_V)/R_SHUNT_OHM;\n      \n      Serial.print( rmsI, 4 );\n      Serial.println(\" [A]\");\n      Serial.print(\"PF: \");\n      Serial.println( PF, 4 );\n      Serial.print(\"Active power: \");\n      Serial.print( P * P_COEFF , 4 ); \n      Serial.println(\" W\");\n      Serial.print(\"Reactive power: \");\n      Serial.print( Q * P_COEFF, 4 );\n      Serial.println(\" VAR\");\n      Serial.print(\"Apparent power: \");\n      Serial.print( S * P_COEFF, 4 );\n      Serial.println(\" VA\");\n      Serial.print(\"Critical registers checksum: \"); // Must be compared with the one expected for the current configuration (stored in the eeprom). In case of mismatch --> reset CS5490\n      Serial.println(regChk, HEX);\n\n      if(internalVoltageReferenceOK)\n        Serial.println(\"Voltage reference OK\");\n      else\n      {\n        Serial.println(\"Voltage reference drift ERROR - CS5490 hardware reset required!\");\n        resetRequired = true;\n      }\n\n      if(rmsV==0 && rmsI==0) // Sometimes the meter could enter some meta-state, reporting all 0s\n      {\n        Serial.println(\"Potential measuring error - CS5490 hardware reset required!\");\n        measureErrorDetectionCounter--;\n        if(!measureErrorDetectionCounter)\n          resetRequired = true;  \n      }\n    }\n    else\n    {\n      // Critical registes checksum error\n      Serial.println(\"Critical registes checksum error - CS5490 hardware reset required!\");\n      Serial.print(\"regChk: \");\n      Serial.println(regChk, HEX);\n      Serial.print(\"CriticalRegisterChecksum: \");\n      Serial.println(CriticalRegisterChecksum, HEX);\n      resetRequired = true;  \n    }\n    \n  }\n  else\n  {\n   Serial.println(\"Communication error - no reply!\"); \n   communicationMaxRetries--;\n   if(!communicationMaxRetries)\n          resetRequired = true; \n  }\n\n  if(resetRequired)\n  {\n      resetRequired = false;\n      measureErrorDetectionCounter = 10;\n      communicationMaxRetries = 5;\n\n      line.resolve();   \n      CS5490_SendConfiguration();\n      \n      Serial.println(\"RESET PERFORMED\");\n  }\n\n  Serial.println(\"\");\n  delay(1000);\n  #endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initializing communication with CS5490\n  //600 is the default baud rate velocity.\n  line.begin(baudRate_default);\n  //Initializing communication arduino/PC to show results in Monitor Serial\n  Serial.begin(115200);\n  // wait for serial port to connect. Needed for Leonardo only\n  while (!Serial);\n  //Set to continous conversion\n  line.contConv();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "double foo = line.getFreq();\n  double bar = line.getTime();\n\n  Serial.print(\"The Line to Sample Frequency Ratio is: \");\n  Serial.println( foo , 5 ); //5 is the number of decimal places\n\n  Serial.print(\"The System Time is: \");\n  Serial.println( bar );\n\n  Serial.println(\"\");\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "analogread",
        "sd"
      ],
      "libraries": [
        "Audio.h",
        "Wire.h",
        "SPI.h",
        "SD.h",
        "SerialFlash.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(4);\n  // Enable the audio shield, select the input and set the output volume.\n  audioShield.enable();\n  audioShield.inputSelect(myInput);\n  audioShield.volume(0.5);\n  audioShield.audioPostProcessorEnable(); // enable the DAP block in SGTL5000\n  // audioShield.eqSelect(1); // using PEQ Biquad filters\n  // audioShield.eqFilterCount(2); // enable filter 0 & filter 1\n  calcBiquad(FILTER_PARAEQ,110,0,0.2,524288,44100,updateFilter); // automation negates the need\n  audioShield.eqFilter(0,updateFilter); // for the three lines commented out above.\n  calcBiquad(FILTER_PARAEQ,4400,0,0.167,524288,44100,updateFilter);\n  audioShield.eqFilter(1,updateFilter);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// every 10 ms, check for adjustment\n  if (chgMsec > 10) {\n    \n    float tone2=analogRead(15);\n    tone2=floor(((tone2-512)/512)*70)/10;\n    if(tone2!=tone1)\n    {\n      // calcBiquad(FilterType,FrequencyC,dBgain,Q,QuantizationUnit,SampleRate,int*);\n      calcBiquad(FILTER_PARAEQ,110,-tone2,0.2,524288,44100,updateFilter);\n      audioShield.eqFilter(0,updateFilter);\n      calcBiquad(FILTER_PARAEQ,4400,tone2,0.167,524288,44100,updateFilter);\n      audioShield.eqFilter(1,updateFilter);\n      tone1=tone2;\n    }\n    chgMsec = 0;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "CalibratedSpeed.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n\n  // include your motors initialization here\n\n  Serial.begin(9600); // only because this example outputs values\n  // on serial interface instead of the actual motors\n\n// Accelerate form 0 to maximum speed\n  for (int spd = 0; spd < 256; spd++)\n  {\n    // call getSpeed method of your calibration objects\n    // getSpeed accepts the desired speed and retuns the calibrated speed value\n    // Here the \"calibrated\" speed is sent to the serial interface  instead of the actual motors\n    Serial.print(csl.getSpeed(spd));\n    Serial.print(\" \");\n    Serial.println(csr.getSpeed(spd));\n    delay(10);\n  }\n  // Deccelerate form maximum speed to 0\n  for (int spd = 255; spd >= 0; spd--)\n  {\n    Serial.print(csl.getSpeed(spd));\n    Serial.print(\" \");\n    Serial.println(csr.getSpeed(spd));\n    delay(10);\n  }\n  // Accelerate form 0 to maximum speed in reverse  direction\n  for (int spd = 0; spd < 256; spd++)\n  {\n    // getSpeed method accepts and returs negative values to acomodate all kind of dc motor drivers\n    // and it uses the positive calibration values mirrored in the negative domain\n    Serial.print(csl.getSpeed(-spd));\n    Serial.print(\" \");\n    Serial.println(csr.getSpeed(-spd));\n    delay(10);\n  }\n  // Deccelerate form maximum speed to 0 in reverse direction\n  for (int spd = 255; spd >= 0; spd--)\n  {\n    Serial.print(csl.getSpeed(-spd));\n    Serial.print(\" \");\n    Serial.println(csr.getSpeed(-spd));\n    delay(10);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "token",
        "payload",
        "json",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(sa_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use cfunctions.resetApp();\n    app.getApp<CloudFunctions>(cfunctions);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    cfunctions.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        Serial.println(\"Call a function...\");\n\n        String payload = cfunctions.call(aClient, GoogleCloudFunctions::Parent(FIREBASE_PROJECT_ID, PROJECT_LOCATION), \"helloWorld\" /* function name */, \"test\" /* data to pass to function */);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);\n        }\n    }\n    ts = time(nullptr);\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\n    ts = WiFi.getTime();\n#endif"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "http",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "payload",
        "stream",
        "buffer",
        "callback",
        "database",
        "json",
        "current",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "streamCallback",
          "parameters": "StreamData data",
          "body": "Serial.printf(\"sream path, %s\\nevent path, %s\\ndata type, %s\\nevent type, %s\\n\\n\",\n                data.streamPath().c_str(),\n                data.dataPath().c_str(),\n                data.dataType().c_str(),\n                data.eventType().c_str());\n  printResult(data); // see addons/RTDBHelper.h\n  Serial.println();\n\n  // This is the size of stream payload received (current and max value)\n  // Max payload size is the payload size under the stream path since the stream connected\n  // and read once and will not update until stream reconnection takes place.\n  // This max value will be zero as no payload received in case of ESP8266 which\n  // BearSSL reserved Rx buffer size is less than the actual stream payload.\n  Serial.printf(\"Received stream payload size: %d (Max. %d)\\n\\n\", data.payloadLength(), data.maxPayloadLength());"
        },
        {
          "name": "streamTimeoutCallback",
          "parameters": "bool timeout",
          "body": "if (timeout)\n    Serial.println(\"stream timed out, resuming...\\n\");\n\n  if (!stream.httpConnected())\n    Serial.printf(\"error code: %d, reason: %s\\n\\n\", stream.httpCode(), stream.errorReason().c_str());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the api key (required) */\n  config.api_key = API_KEY;\n\n  /* Assign the user sign in credentials */\n  auth.user.email = USER_EMAIL;\n  auth.user.password = USER_PASSWORD;\n\n  /* Assign the RTDB URL (required) */\n  config.database_url = DATABASE_URL;\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(2048 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n  stream.setBSSLBufferSize(2048 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  // Or use legacy authenticate method\n  // config.database_url = DATABASE_URL;\n  // config.signer.tokens.legacy_token = \"<database secret>\";\n\n  // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n  Firebase.begin(&config, &auth);\n\n  // You can use TCP KeepAlive For more reliable stream operation and tracking the server connection status, please read this for detail.\n  // https://github.com/mobizt/Firebase-ESP32#enable-tcp-keepalive-for-reliable-http-streaming\n  stream.keepAlive(5, 5, 1);\n\n  if (!Firebase.beginStream(stream, \"/test/stream/data\"))\n    Serial.printf(\"sream begin error, %s\\n\\n\", stream.errorReason().c_str());\n\n  Firebase.setStreamCallback(stream, streamCallback, streamTimeoutCallback);\n\n  /** Timeout options, below is default config.\n\n  //Network reconnect timeout (interval) in ms (10 sec - 5 min) when network or WiFi disconnected.\n  config.timeout.networkReconnect = 10 * 1000;\n\n  //Socket begin connection timeout (ESP32) or data transfer timeout (ESP8266) in ms (1 sec - 1 min).\n  config.timeout.socketConnection = 30 * 1000;\n\n  //ESP32 SSL handshake in ms (1 sec - 2 min). This option doesn't allow in ESP8266 core library.\n  config.timeout.sslHandshake = 2 * 60 * 1000;\n\n  //Server response read timeout in ms (1 sec - 1 min).\n  config.timeout.serverResponse = 10 * 1000;\n\n  //RTDB Stream keep-alive timeout in ms (20 sec - 2 min) when no server's keep-alive event data received.\n  config.timeout.rtdbKeepAlive = 45 * 1000;\n\n  //RTDB Stream reconnect timeout (interval) in ms (1 sec - 1 min) when RTDB Stream closed and want to resume.\n  config.timeout.rtdbStreamReconnect = 1 * 1000;\n\n  //RTDB Stream error notification timeout (interval) in ms (3 sec - 30 sec). It determines how often the readStream\n  //will return false (error) when it called repeatedly in loop.\n  config.timeout.rtdbStreamError = 3 * 1000;\n\n  */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && (millis() - sendDataPrevMillis > 15000 || sendDataPrevMillis == 0))\n  {\n    sendDataPrevMillis = millis();\n    count++;\n    FirebaseJson json;\n    json.add(\"data\", \"hello\");\n    json.add(\"num\", count);\n    Serial.printf(\"Set json... %s\\n\\n\", Firebase.setJSON(fbdo, \"/test/stream/data/json\", json) ? \"ok\" : fbdo.errorReason().c_str());\n  }\n\n  // After calling stream.keepAlive, now we can track the server connecting status\n  if (!stream.httpConnected())\n  {\n    // Server was disconnected!\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "callback",
        "energy",
        "bluetooth",
        "wifi",
        "ble",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n  \n  pinMode(ledPin, OUTPUT); // use the LED pin as an output\n\n  // begin initialization\n  if (!BLE.begin()) {\n    Serial.println(\"starting Bluetooth® Low Energy module failed!\");\n\n    while (1);\n  }\n\n  // set the local name peripheral advertises\n  BLE.setLocalName(\"LEDCallback\");\n  // set the UUID for the service this peripheral advertises\n  BLE.setAdvertisedService(ledService);\n\n  // add the characteristic to the service\n  ledService.addCharacteristic(switchCharacteristic);\n\n  // add service\n  BLE.addService(ledService);\n\n  // assign event handlers for connected, disconnected to peripheral\n  BLE.setEventHandler(BLEConnected, blePeripheralConnectHandler);\n  BLE.setEventHandler(BLEDisconnected, blePeripheralDisconnectHandler);\n\n  // assign event handlers for characteristic\n  switchCharacteristic.setEventHandler(BLEWritten, switchCharacteristicWritten);\n  // set an initial value for the characteristic\n  switchCharacteristic.setValue(0);\n\n  // start advertising\n  BLE.advertise();\n\n  Serial.println((\"Bluetooth® device active, waiting for connections...\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// poll for Bluetooth® Low Energy events\n  BLE.poll();"
        },
        {
          "name": "blePeripheralConnectHandler",
          "parameters": "BLEDevice central",
          "body": "// central connected event handler\n  Serial.print(\"Connected event, central: \");\n  Serial.println(central.address());"
        },
        {
          "name": "blePeripheralDisconnectHandler",
          "parameters": "BLEDevice central",
          "body": "// central disconnected event handler\n  Serial.print(\"Disconnected event, central: \");\n  Serial.println(central.address());"
        },
        {
          "name": "switchCharacteristicWritten",
          "parameters": "BLEDevice central, BLECharacteristic characteristic",
          "body": "// central wrote new value to characteristic, update LED\n  Serial.print(\"Characteristic event, written: \");\n\n  if (switchCharacteristic.value()) {\n    Serial.println(\"LED on\");\n    digitalWrite(ledPin, HIGH);\n  } else {\n    Serial.println(\"LED off\");\n    digitalWrite(ledPin, LOW);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "callback"
      ],
      "libraries": [
        "MIDI.h"
      ],
      "functions": [
        {
          "name": "handleNoteOn",
          "parameters": "byte channel, byte pitch, byte velocity",
          "body": "// Do whatever you want when a note is pressed.\n\n    // Try to keep your callbacks short (no delays ect)\n    // otherwise it would slow down the loop() and have a bad impact\n    // on real-time performance."
        },
        {
          "name": "handleNoteOff",
          "parameters": "byte channel, byte pitch, byte velocity",
          "body": "// Do something when the note is released.\n    // Note that NoteOn messages with 0 velocity are interpreted as NoteOffs."
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Connect the handleNoteOn function to the library,\n    // so it is called upon reception of a NoteOn.\n    MIDI.setHandleNoteOn(handleNoteOn);  // Put only the name of the function\n\n    // Do the same for NoteOffs\n    MIDI.setHandleNoteOff(handleNoteOff);\n\n    // Initiate MIDI communications, listen to all channels\n    MIDI.begin(MIDI_CHANNEL_OMNI);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call MIDI.read the fastest you can for real-time performance.\n    MIDI.read();\n\n    // There is no need to check if there are messages incoming\n    // if they are bound to a Callback function.\n    // The attached method will be called automatically\n    // when the corresponding message has been received."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "wificlient",
        "wifiserver",
        "https",
        "password",
        "key",
        "callback",
        "power",
        "wifi",
        "delay",
        "millis",
        "led",
        "nodebug_websockets",
        "devices",
        "deviceid"
      ],
      "libraries": [
        "WiFi.h",
        "WebServer.h",
        "WiFiClient.h",
        "SinricPro_Generic.h",
        "SinricProCamera.h",
        "SimStreamer.h",
        "OV2640Streamer.h",
        "CRtspSession.h",
        "select_pins.h"
      ],
      "functions": [
        {
          "name": "onPowerState",
          "parameters": "const String &deviceId, bool &state",
          "body": "Serial.printf(\"Device %s turned %s (via SinricPro) \\r\\n\", deviceId.c_str(), state ? \"on\" : \"off\");\n  \n  return true; // request handled properly"
        },
        {
          "name": "setupSinricPro",
          "parameters": "",
          "body": "// add device to SinricPro\n  SinricProCamera& mySwitch = SinricPro[CAMERA_ID];\n\n  // set callback function to device\n  mySwitch.onPowerState(onPowerState);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");\n  });\n  \n  SinricPro.onDisconnected([]() \n  {\n    Serial.println(\"Disconnected from SinricPro\");\n  });\n\n  SinricPro.begin(APP_KEY, APP_SECRET);"
        },
        {
          "name": "setupWiFi",
          "parameters": "",
          "body": "IPAddress ip;\n\n  // Configures static IP address\n  if (!WiFi.config(local_IP, gateway, subnet, primaryDNS, secondaryDNS))\n  {\n    Serial.println(\"Failed to configure IP\");\n  }\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWD);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\\nWiFi connected\");\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "setupCamera",
          "parameters": "",
          "body": "camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer   = LEDC_TIMER_0;\n  \n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  \n  config.pin_xclk     = XCLK_GPIO_NUM;\n  config.pin_pclk     = PCLK_GPIO_NUM;\n  config.pin_vsync    = VSYNC_GPIO_NUM;\n  config.pin_href     = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn     = PWDN_GPIO_NUM;\n  config.pin_reset    = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.pixel_format = PIXFORMAT_JPEG; //PIXFORMAT_YUV422 PIXFORMAT_GRAYSCALE PIXFORMAT_RGB565 PIXFORMAT_JPEG\n\n  /*\n    FRAMESIZE_UXGA (1600 x 1200)\n    FRAMESIZE_QVGA (320 x 240)\n    FRAMESIZE_CIF (352 x 288)\n    FRAMESIZE_VGA (640 x 480)\n    FRAMESIZE_SVGA (800 x 600)\n    FRAMESIZE_XGA (1024 x 768)\n    FRAMESIZE_SXGA (1280 x 1024)\n  */\n\n  if (psramFound())\n  {\n    Serial.println(\"psram found\");\n    \n    config.frame_size = FRAMESIZE_UXGA;\n    config.jpeg_quality = 40; //10-63 lower number means higher quality\n    config.fb_count = 2;\n  }\n  else\n  {\n    Serial.println(\"psram not found\");\n    config.frame_size = FRAMESIZE_VGA;\n    config.jpeg_quality = 12;\n    config.fb_count = 1;\n  }\n\n  cam.init(config);"
        },
        {
          "name": "setupStreaming",
          "parameters": "",
          "body": "rtspServer.begin();\n  //streamer = new SimStreamer(true);             // our streamer for UDP/TCP based RTP transport\n  streamer = new OV2640Streamer(cam);             // our streamer for UDP/TCP based RTP transport"
        },
        {
          "name": "handleStreaming",
          "parameters": "",
          "body": "uint32_t msecPerFrame = 100;\n  static uint32_t lastimage = millis();\n\n  // If we have an active client connection, just service that until gone\n  streamer->handleRequests(0); // we don't use a timeout here,\n\n  // instead we send only if we have new enough frames\n  uint32_t now = millis();\n\n  if (streamer->anySessions())\n  {\n    if (now > lastimage + msecPerFrame || now < lastimage)\n    {\n      // handle clock rollover\n      streamer->streamImage(now);\n      lastimage = now;\n\n      // check if we are overrunning our max frame rate\n      now = millis();\n\n      if (now > lastimage + msecPerFrame)\n      {\n        printf(\"Warning exceeding max frame rate of %d ms\\n\", now - lastimage);\n        Serial.printf(\"Warning exceeding max frame rate of %d ms\\n\", now - lastimage);\n      }\n    }\n  }\n\n  WiFiClient rtspClient = rtspServer.accept();\n\n  if (rtspClient)\n  {\n    Serial.print(\"client: \");\n    Serial.println(rtspClient.remoteIP());\n\n    streamer->addSession(rtspClient);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(BAUD_RATE);\n  while (!Serial);            //wait for serial connection.\n\n  Serial.println(\"\\nStarting Camera on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n\n  setupCamera();\n  setupWiFi();\n  setupSinricPro();\n  setupStreaming();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SinricPro.handle();\n  handleStreaming();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "ble"
      ],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  Serial.println(\"OV767X Camera Capture\");\n  Serial.println();\n\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);\n  }\n\n  Serial.println(\"Camera settings:\");\n  Serial.print(\"\\twidth = \");\n  Serial.println(Camera.width());\n  Serial.print(\"\\theight = \");\n  Serial.println(Camera.height());\n  Serial.print(\"\\tbits per pixel = \");\n  Serial.println(Camera.bitsPerPixel());\n  Serial.println();\n\n  Serial.println(\"Send the 'c' character to read a frame ...\");\n  Serial.println();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (Serial.read() == 'c') {\n    Serial.println(\"Reading frame\");\n    Serial.println();\n    Camera.readFrame(pixels);\n\n    int numPixels = Camera.width() * Camera.height();\n\n    for (int i = 0; i < numPixels; i++) {\n      unsigned short p = pixels[i];\n\n      if (p < 0x1000) {\n        Serial.print('0');\n      }\n\n      if (p < 0x0100) {\n        Serial.print('0');\n      }\n\n      if (p < 0x0010) {\n        Serial.print('0');\n      }\n\n      Serial.print(p, HEX);\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);\n  }\n\n  bytesPerFrame = Camera.width() * Camera.height() * Camera.bytesPerPixel();\n\n  // Optionally, enable the test pattern for testing\n  // Camera.testPattern();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Camera.readFrame(data);\n\n  Serial.write(data, bytesPerFrame);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "ble"
      ],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  Serial.println(\"OV767X Test Pattern\");\n  Serial.println();\n\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);\n  }\n\n  Serial.println(\"Camera settings:\");\n  Serial.print(\"\\twidth = \");\n  Serial.println(Camera.width());\n  Serial.print(\"\\theight = \");\n  Serial.println(Camera.height());\n  Serial.print(\"\\tbits per pixel = \");\n  Serial.println(Camera.bitsPerPixel());\n  Serial.println();\n\n  Serial.println(\"Enabling test pattern mode\");\n  Serial.println();\n  Camera.testPattern();\n\n  Serial.println(\"Reading frame\");\n  Serial.println();\n  Camera.readFrame(pixels);\n\n  int numPixels = Camera.width() * Camera.height();\n\n  for (int i = 0; i < numPixels; i++) {\n    unsigned short p = pixels[i];\n\n    if (p < 0x1000) {\n      Serial.print('0');\n    }\n\n    if (p < 0x0100) {\n      Serial.print('0');\n    }\n\n    if (p < 0x0010) {\n      Serial.print('0');\n    }\n\n    Serial.print(p, HEX);\n  }\n\n  Serial.println();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "delay"
      ],
      "libraries": [
        "TinyMLShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the Serial \n  Serial.begin(9600);\n  while (!Serial);\n\n  // initialize the Shield\n  initializeShield();\n\n  // Initialize the OV7675 camera\n  if (!Camera.begin(QCIF, RGB565, 1, OV7675))\n  {\n    Serial.println(\"Failed to initialize camera\");\n    while (1);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int i = 0;\n\n  bool clicked = readShieldButton();\n  if (clicked)\n  {\n    Serial.println(\"\\nImage data will be printed out!\");\n    delay(1000);\n    Camera.readFrame(image);\n    for (int i = 0; i < bytesPerFrame; i += 2)\n    {\n      Serial.print(\"0x\");\n      Serial.print(image[i + 1], HEX);\n      Serial.print(image[i], HEX);\n      if (i != bytesPerFrame - 2) Serial.print(\", \");\n    }\n    Serial.println();\n    Serial.println(\"Done!\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "digitalread"
      ],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH);\n\n  unsigned short intervalId = t.setInterval(\n      []() { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); }, 1000);\n\n  t.setTimeout([=]() { t.cancel(intervalId); }, 10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  unsigned short timeoutId = t.setTimeout(\n      []() { Serial.println(\"Message after 10 seconds from booting\"); }, 10000);\n\n  // Cancel instantly:\n  // t.cancel(timeoutId);\n\n  // Or cancel using another timeout after 3 seconds:\n  t.setTimeout([=]() { t.cancel(timeoutId); }, 3000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "CAP.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Open serial port, set the baud rate to 9600 bits per second\n\tcap.begin(); // Call begin method of cap library for secondary initialization"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int rawData = cap.getRawData(); // Retrieve raw analog cap sensor reading and store in initialized variable\n\tSerial.println(rawData); // Print raw data\n\tdelay(100); // Wait 100ms between samples (no offset adjustment)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "CAP.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Begin serial communication at 9600 baud rate\n  cap.begin(); // Call the begin method for the Capacitive Sensor (initialization method)\n  \n  // CHANGE THESE POINTS TO YOUR CALIBRATION POINTS (ADC READING, KNOWN DIELECTRIC CONST)\n  cap.addCalibrationPoint(17,94); // Add Calibration Point 1\n  cap.addCalibrationPoint(13,73); // Add Calibration Point 2\n  cap.addCalibrationPoint(12,59); // Add Calibration Point 3\n  \n  coefs = cap.getLinearRegression(); // Preform Linear Regression on entered Calibration Points \n\n  // Print Calibration Coefficents\n  Serial.print(\"First Coefficent: \"); Serial.println(*coefs);\n  Serial.print(\"Second Coefficent: \"); Serial.println(*(coefs + 1));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "CAP.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600); // Begin serial communication with 9600 baud rate\n\n  cap.begin(); // Begin Capacitive Sensor (initialization method)\n  \n  cap.setCal(c1,c2); // Set calibration using user defined calibration coefficients"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "dielectricConst = cap.getDielectric(); // Sample dielectric constant (using set calibration coefficents)\n\n  Serial.print(\"Dielectric Const: \"); Serial.println(dielectricConst);\n\n  delay(1000); // Wait 1s between samples"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "wifi",
        "html"
      ],
      "libraries": [
        "DNSServer.h",
        "WiFi.h",
        "AsyncTCP.h",
        "ESP8266WiFi.h",
        "ESPAsyncTCP.h",
        "ESPAsyncWebSrv.h"
      ],
      "functions": [
        {
          "name": "canHandle",
          "parameters": "AsyncWebServerRequest *request",
          "body": "//request->addInterestingHeader(\"ANY\");\n    return true;\n  }\n\n  void handleRequest(AsyncWebServerRequest *request) {\n    AsyncResponseStream *response = request->beginResponseStream(\"text/html\");\n    response->print(\"<!DOCTYPE html><html><head><title>Captive Portal</title></head><body>\");\n    response->print(\"<p>This is out captive portal front page.</p>\");\n    response->printf(\"<p>You were trying to reach: http://%s%s</p>\", request->host().c_str(), request->url().c_str());\n    response->printf(\"<p>Try opening <a href='http://%s'>this link</a> instead</p>\", WiFi.softAPIP().toString().c_str());\n    response->print(\"</body></html>\");\n    request->send(response);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//your other setup stuff...\n  WiFi.softAP(\"esp-captive\");\n  dnsServer.start(53, \"*\", WiFi.softAPIP());\n  server.addHandler(new CaptiveRequestHandler()).setFilter(ON_AP_FILTER);//only when requested from AP\n  //more handlers...\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "dnsServer.processNextRequest();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "your_edge_impulse_inferencing.h",
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/car.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(3000);\n  Serial.begin(115200);\n  Serial.println(\"___AUTONOMOUS CAR___\");\n\n  camera.pinout.freenove_s3();\n  camera.brownout.disable();\n  camera.resolution.yolo();\n  camera.pixformat.rgb565();\n\n  fomoCar.defaultDuration(100);\n  fomoCar.stop();\n\n  while (!camera.begin().isOk())\n      Serial.println(camera.exception.toString());\n\n  Serial.println(\"Camera OK\");\n  Serial.println(\"Put object in front of camera\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// capture picture\n  if (!camera.capture().isOk()) {\n      Serial.println(camera.exception.toString());\n      return;\n  }\n\n  // run FOMO\n  if (!fomo.run().isOk()) {\n      Serial.println(fomo.exception.toString());\n      return;\n  }\n\n  // let the car follow the object\n  fomoCar.follow(fomo);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "millis"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/car/two_wheels_car.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___CAR TEST___\");\n\n    // how many millis motors will run\n    testCar.defaultDuration(200);\n    testCar.stop();\n\n    Serial.println(\"Enter one of f (forward), b (backward), l (left), r (right)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (!Serial.available())\n        return;\n\n    String cmd = Serial.readStringUntil('\\n');\n\n    if (cmd.startsWith(\"f\")) testCar.forward();\n    else if (cmd.startsWith(\"b\")) testCar.backward();\n    else if (cmd.startsWith(\"l\")) testCar.left();\n    else if (cmd.startsWith(\"r\")) testCar.right();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "spi",
        "sd"
      ],
      "libraries": [
        "Arduino_EdgeControl.h",
        "SD.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Open serial communications and wait for port to open:\n    Serial.begin(115200);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for native USB port only\n    }\n\n    EdgeControl.begin();\n    // Power on the 3V3 rail for SD Card\n    Power.on(PWR_3V3);\n\n    Serial.print(\"\\nInitializing SD card...\");\n\n    // we'll use the initialization code from the utility libraries\n    // since we're just testing if the card is working!\n    if (!card.init(SPI_HALF_SPEED, chipSelect)) {\n        Serial.println(\"initialization failed. Things to check:\");\n        Serial.println(\"* is a card inserted?\");\n        Serial.println(\"* is your wiring correct?\");\n        Serial.println(\"* did you change the chipSelect pin to match your shield or module?\");\n        while (1)\n            ;\n    } else {\n        Serial.println(\"Wiring is correct and a card is present.\");\n    }\n\n    // print the type of card\n    Serial.println();\n    Serial.print(\"Card type:         \");\n    switch (card.type()) {\n    case SD_CARD_TYPE_SD1:\n        Serial.println(\"SD1\");\n        break;\n    case SD_CARD_TYPE_SD2:\n        Serial.println(\"SD2\");\n        break;\n    case SD_CARD_TYPE_SDHC:\n        Serial.println(\"SDHC\");\n        break;\n    default:\n        Serial.println(\"Unknown\");\n    }\n\n    // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32\n    if (!volume.init(card)) {\n        Serial.println(\"Could not find FAT16/FAT32 partition.\\nMake sure you've formatted the card\");\n        while (1)\n            ;\n    }\n\n    Serial.print(\"Clusters:          \");\n    Serial.println(volume.clusterCount());\n    Serial.print(\"Blocks x Cluster:  \");\n    Serial.println(volume.blocksPerCluster());\n\n    Serial.print(\"Total Blocks:      \");\n    Serial.println(volume.blocksPerCluster() * volume.clusterCount());\n    Serial.println();\n\n    // print the type and size of the first FAT-type volume\n    uint32_t volumesize;\n    Serial.print(\"Volume type is:    FAT\");\n    Serial.println(volume.fatType(), DEC);\n\n    volumesize = volume.blocksPerCluster(); // clusters are collections of blocks\n    volumesize *= volume.clusterCount(); // we'll have a lot of clusters\n    volumesize /= 2; // SD card blocks are always 512 bytes (2 blocks are 1KB)\n    Serial.print(\"Volume size (Kb):  \");\n    Serial.println(volumesize);\n    Serial.print(\"Volume size (Mb):  \");\n    volumesize /= 1024;\n    Serial.println(volumesize);\n    Serial.print(\"Volume size (Gb):  \");\n    Serial.println((float)volumesize / 1024.0);\n\n    Serial.println(\"\\nFiles found on the card (name, date and size in bytes): \");\n    root.openRoot(volume);\n\n    // list all files in the card with date and size\n    root.ls(LS_R | LS_DATE | LS_SIZE);"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "delay"
      ],
      "libraries": [
        "WiFiEspAT.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(OLD_BAUD_RATE);\n\n  Serial.println(\"Sending baud rate change...\");\n  Serial1.print(\"AT+UART_DEF=\");\n  Serial1.print(NEW_BAUD_RATE);\n  Serial1.println(\",8,1,0,0\");\n  delay(100);\n  // we can't expect a readable answer over SoftwareSerial at 115200\n\n  Serial1.begin(NEW_BAUD_RATE);\n  WiFi.init(Serial1);\n  const char* ver = WiFi.firmwareVersion();\n  if (ver[0] != 0) {\n    Serial.print(\"Baud rate \");\n    Serial.print(NEW_BAUD_RATE);\n    Serial.println(\" baud is working.\");\n    Serial.print(\"Firmware version is \");\n    Serial.println(ver);\n  } else {\n    Serial.print(\"Error communicating at \");\n    Serial.print(NEW_BAUD_RATE);\n    Serial.println(\" baud.\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "i2c",
        "delay"
      ],
      "libraries": [
        "KM1_I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "motor.i2cSlaveAddress(0x30); // Change I2C Address from 0x20 to 0x30\n  motor.saveAllRegisters();\n  delay(2000);\n  motor.reboot();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis"
      ],
      "libraries": [
        "Tasker.h"
      ],
      "functions": [
        {
          "name": "task1",
          "parameters": "",
          "body": "static unsigned long last = 0;\n    Serial.print(millis());\n    Serial.print(F(\": task1 called after \"));\n    Serial.println(millis() - last);\n    last = millis();"
        },
        {
          "name": "task2",
          "parameters": "",
          "body": "Serial.print(millis());\n    Serial.print(F(\": reset and change the interval of task1 to \"));\n    unsigned r = random(1000, 3000);\n    Serial.println(r);\n    tasker.setInterval(task1, r);"
        },
        {
          "name": "task3",
          "parameters": "",
          "body": "Serial.print(millis());\n    Serial.println(\": STOP\");\n    tasker.cancel(task1);\n    tasker.cancel(task2);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println(\"Tasker: Demo of changing scheduled task setup at runtime\");\n\n    // set task1 to be called every 2 seconds\n    tasker.setInterval(task1, 2000);\n    \n    // every 8 seconds call task2 that changes the settings of task1\n    tasker.setInterval(task2, 8000);\n    \n    // after 60 seconds stop both tasks\n    tasker.setTimeout(task3, 60000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "tasker.loop();\n    // your code can be here"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initializing communication with CS5490\n  //600 is the default baud rate velocity.\n  line.begin(600);\n  //Initializing communication arduino/PC to show results in Monitor Serial\n  Serial.begin(115200);\n  //Changing BaudRate of CS5490 to 115200\n  /*\n    WARNING: Everytime that you reset the software from board you also need to reset\n    the CS5490!!! If you don't, it will not work properly\n  */\n  line.setBaudRate(115200);\n  //Set to continous conversion\n  line.contConv();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "double foo = line.getFreq();\n  double bar = line.getTime();\n\n  Serial.print(\"The Line to Sample Frequency Ratio is: \");\n  Serial.println( foo , 5 ); //5 is the number of decimal places\n\n  Serial.print(\"The System Time is: \");\n  Serial.println( bar );\n\n  Serial.println(\"\");\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "password",
        "wifi",
        "delay",
        "led",
        "devicename"
      ],
      "libraries": [
        "DurianBlynkESP8266.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();\n\n  //set LED widget to Green\n  DBlynk.setProperty(V0, \"color\", BLYNK_GREEN);\n  \n  //turn on LED widget with maximum brightness \n  DBlynk.virtualWrite(V0, 255);\n\n  delay(1000);\n\n  //set LED widget to Blue\n  DBlynk.setProperty(V0, \"color\", BLYNK_BLUE);\n  \n  //turn on LED widget with maximum brightness \n  DBlynk.virtualWrite(V0, 255);\n\n  delay(1000);\n\n  //set LED widget to Yellow\n  DBlynk.setProperty(V0, \"color\", BLYNK_YELLOW);\n  \n  //turn on LED widget with maximum brightness \n  DBlynk.virtualWrite(V0, 255);\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "telegram",
        "http",
        "api",
        "https",
        "token",
        "certificate",
        "wifi",
        "ntp",
        "delay",
        "millis"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "parameters": "int numNewMessages",
          "body": "for (int i = 0; i < numNewMessages; i++)\n  {\n    if (bot.messages[i].type == \"channel_post\")\n    {\n      bot.sendMessage(bot.messages[i].chat_id, bot.messages[i].chat_title + \" \" + bot.messages[i].text, \"\");\n    }\n    else\n    {\n      bot.sendMessage(bot.messages[i].chat_id, bot.messages[i].text, \"\");\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  // attempt to connect to Wifi network:\n  configTime(0, 0, \"pool.ntp.org\");      // get UTC time via NTP\n  secured_client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org\n  Serial.print(\"Connecting to Wifi SSID \");\n  Serial.print(WIFI_SSID);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);\n  }\n  Serial.print(\"\\nWiFi connected. IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // Check NTP/Time, usually it is instantaneous and you can delete the code below.\n  Serial.print(\"Retrieving time: \");\n  time_t now = time(nullptr);\n  while (now < 24 * 3600)\n  {\n    Serial.print(\".\");\n    delay(100);\n    now = time(nullptr);\n  }\n  Serial.println(now);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n    }\n\n    bot_lasttime = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "telegram",
        "api",
        "token",
        "https",
        "certificate",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "parameters": "int numNewMessages",
          "body": "Serial.println(\"handleNewMessages\");\n  Serial.println(String(numNewMessages));\n\n  for (int i = 0; i < numNewMessages; i++)\n  {\n    String chat_id = bot.messages[i].chat_id;\n    String text = bot.messages[i].text;\n\n    String from_name = bot.messages[i].from_name;\n    if (from_name == \"\")\n      from_name = \"Guest\";\n\n    if (text == \"/send_test_action\")\n    {\n      bot.sendChatAction(chat_id, \"typing\");\n      delay(4000);\n      bot.sendMessage(chat_id, \"Did you see the action message?\");\n\n      // You can't use own message, just choose from one of bellow\n\n      //typing for text messages\n      //upload_photo for photos\n      //record_video or upload_video for videos\n      //record_audio or upload_audio for audio files\n      //upload_document for general files\n      //find_location for location data\n\n      //more info here - https://core.telegram.org/bots/api#sendchataction\n    }\n\n    if (text == \"/start\")\n    {\n      String welcome = \"Welcome to Universal Arduino Telegram Bot library, \" + from_name + \".\\n\";\n      welcome += \"This is Chat Action Bot example.\\n\\n\";\n      welcome += \"/send_test_action : to send test chat action message\\n\";\n      bot.sendMessage(chat_id, welcome);\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  // Set WiFi to station mode and disconnect from an AP if it was Previously\n  // connected\n  WiFi.mode(WIFI_STA);\n  WiFi.disconnect();\n  delay(100);\n\n  // attempt to connect to Wifi network:\n  Serial.print(\"Connecting to Wifi SSID \");\n  Serial.print(WIFI_SSID);\n  Serial.print(\" \");\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  secured_client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);\n  }\n  Serial.println();\n\n  Serial.print(\"WiFi connected. IP address: \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n    }\n\n    bot_lasttime = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "wifi",
        "spi",
        "dns",
        "delay",
        "display",
        "flash",
        "interrupt",
        "clients"
      ],
      "libraries": [
        "Adafruit_CC3000.h",
        "SPI.h",
        "utility/debug.h",
        "utility/socket.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "Serial.begin(115200);\n  Serial.println(F(\"Hello, CC3000!\\n\")); \n\n  Serial.print(\"Free RAM: \"); Serial.println(getFreeRam(), DEC);\n  \n  /* Initialise the module */\n  Serial.println(F(\"\\nInitializing...\"));\n  if (!cc3000.begin())\n  {\n    Serial.println(F(\"Couldn't begin()! Check your wiring?\"));\n    while(1);\n  }\n  \n  Serial.print(F(\"\\nAttempting to connect to \")); Serial.println(WLAN_SSID);\n  if (!cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY)) {\n    Serial.println(F(\"Failed!\"));\n    while(1);\n  }\n   \n  Serial.println(F(\"Connected!\"));\n  \n  Serial.println(F(\"Request DHCP\"));\n  while (!cc3000.checkDHCP())\n  {\n    delay(100); // ToDo: Insert a DHCP timeout!\n  }  \n\n  /* Display the IP address DNS, Gateway, etc. */  \n  while (! displayConnectionDetails()) {\n    delay(1000);\n  }\n  \n  /*********************************************************/\n  /* You can safely remove this to save some flash memory! */\n  /*********************************************************/\n  Serial.println(F(\"\\r\\nNOTE: This sketch may cause problems with other sketches\"));\n  Serial.println(F(\"since the .disconnect() function is never called, so the\"));\n  Serial.println(F(\"AP may refuse connection requests from the CC3000 until a\"));\n  Serial.println(F(\"timeout period passes.  This is normal behaviour since\"));\n  Serial.println(F(\"there isn't an obvious moment to disconnect with a server.\\r\\n\"));\n\n  // Start listening for connections\n  chatServer.begin();\n  \n  Serial.println(F(\"Listening for connections...\"));"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "// Try to get a client which is connected.\n  Adafruit_CC3000_ClientRef client = chatServer.available();\n  if (client) {\n     // Check if there is data available to read.\n     if (client.available() > 0) {\n       // Read a byte and write it to all clients.\n       uint8_t ch = client.read();\n       chatServer.write(ch);\n     }\n  }"
        },
        {
          "name": "displayConnectionDetails",
          "parameters": "void",
          "body": "uint32_t ipAddress, netmask, gateway, dhcpserv, dnsserv;\n  \n  if(!cc3000.getIPAddress(&ipAddress, &netmask, &gateway, &dhcpserv, &dnsserv))\n  {\n    Serial.println(F(\"Unable to retrieve the IP Address!\\r\\n\"));\n    return false;\n  }\n  else\n  {\n    Serial.print(F(\"\\nIP Addr: \")); cc3000.printIPdotsRev(ipAddress);\n    Serial.print(F(\"\\nNetmask: \")); cc3000.printIPdotsRev(netmask);\n    Serial.print(F(\"\\nGateway: \")); cc3000.printIPdotsRev(gateway);\n    Serial.print(F(\"\\nDHCPsrv: \")); cc3000.printIPdotsRev(dhcpserv);\n    Serial.print(F(\"\\nDNSserv: \")); cc3000.printIPdotsRev(dnsserv);\n    Serial.println();\n    return true;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi"
      ],
      "libraries": [
        "WiFiEspAT.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(AT_BAUD_RATE);\n  WiFi.init(Serial1);\n\n  if (WiFi.status() == WL_NO_MODULE) {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }\n\n  char ver[10];\n  int major = 0;\n  int minor = 0;\n  if (WiFi.firmwareVersion(ver)) {\n    Serial.print(\"AT firmware version \");\n    Serial.println(ver);\n    char* tok = strtok(ver, \".\");\n    major = atoi(tok);\n    tok = strtok(NULL, \".\");\n    minor = atoi(tok);\n    if (major == 2 && minor == 0) {\n      Serial.println(\"AT firmware version 2.0 doesn't support passive receive mode and can't be used with the WiFiEspAt library\");\n    } else if (major < 1 || (major == 1 && minor < 7)) {\n      Serial.println(\"WiWiEspAT library requires at least version 1.7.0 of AT firmware (but not 2.0)\");\n    } else {\n      Serial.println(\"AT firmware is OK for the WiFiEspAT library.\");\n#ifdef WIFIESPAT1\n      if (major > 1) {\n        Serial.println(\"For AT firmware version 2 comment out #define WIFIESPAT1 in EspAtDrvTypes.h\");\n      }\n#else\n      if (major == 1) {\n        Serial.println(\"For AT firmware version 1 add #define WIFIESPAT1 in EspAtDrvTypes.h\");\n      }\n#endif\n    }\n  } else {\n    Serial.println(\"Error getting AT firmware version\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "spi",
        "millis"
      ],
      "libraries": [
        "defines.h",
        "SPI.h",
        "WiFiNINA_Generic.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  // Print a welcome message\n  Serial.print(F(\"\\nStart WiFiNINA CheckFirmwareVersion on \"));\n  Serial.println(BOARD_NAME);\n  Serial.println(WIFININA_GENERIC_VERSION);\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"Communication with WiFi module failed!\"));\n\n    // don't continue\n    while (true);\n  }\n\n  // Print firmware version on the module\n  String fv = WiFi.firmwareVersion();\n  String latestFv;\n\n  Serial.print(\"Firmware version installed: \");\n  Serial.println(fv);\n\n  latestFv = WIFI_FIRMWARE_LATEST_VERSION;\n\n  // Print required firmware version\n  Serial.print(F(\"Latest firmware version available : \"));\n  Serial.println(latestFv);\n\n  // Check if the latest version is installed\n  Serial.println();\n\n  if (fv >= latestFv)\n  {\n    Serial.println(F(\"Check result: PASSED\"));\n  }\n  else\n  {\n    Serial.println(F(\"Check result: NOT PASSED\"));\n    Serial.println(F(\" - The firmware version on the module do not match the\"));\n    Serial.println(F(\"   version required by the library, you may experience\"));\n    Serial.println(F(\"   issues or failures.\"));\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wifi"
      ],
      "libraries": [
        "WiFiLink.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize serial\n  Serial.begin(115200);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // Print a welcome message\n  Serial.println(\"WiFi Link firmware check.\");\n  Serial.println();\n\n  //Check if communication with the wifi module has been established\n  if (WiFi.status() == WL_NO_WIFI_MODULE_COMM) {\n    Serial.println(\"Communication with WiFi module not established.\");\n    while (true); // don't continue:\n  }\n\n  // Print firmware version on the shield\n  String fv = WiFi.firmwareVersion();\n  Serial.print(\"Firmware version installed: \");\n  Serial.println(fv);\n\n  // Print required firmware version\n  Serial.print(\"Firmware version required : \");\n  Serial.println(WIFI_FIRMWARE_REQUIRED);\n\n  // Check if the required version is installed\n  Serial.println();\n  if (WiFi.checkFirmwareVersion(WIFI_FIRMWARE_REQUIRED)) {\n    Serial.println(\"Check result: PASSED\");\n  } else {\n    Serial.println(\"Check result: NOT PASSED\");\n    Serial.println(\" - The firmware version installed do not match the\");\n    Serial.println(\"   version required by the library, you may experience\");\n    Serial.println(\"   issues or failures.\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "wifi"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "driver/source/nmasic.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize serial\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // Print a welcome message\n  Serial.println(\"WiFi101 firmware check.\");\n  Serial.println();\n\n  // Check for the presence of the shield\n  Serial.print(\"WiFi101 shield: \");\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"NOT PRESENT\");\n    return; // don't continue\n  }\n  Serial.println(\"DETECTED\");\n\n  // Print firmware version on the shield\n  String fv = WiFi.firmwareVersion();\n  String latestFv;\n  Serial.print(\"Firmware version installed: \");\n  Serial.println(fv);\n\n  if (REV(GET_CHIPID()) >= REV_3A0) {\n    // model B\n    latestFv = WIFI_FIRMWARE_LATEST_MODEL_B;\n  } else {\n    // model A\n    latestFv = WIFI_FIRMWARE_LATEST_MODEL_A;\n  }\n\n  // Print required firmware version\n  Serial.print(\"Latest firmware version available : \");\n  Serial.println(latestFv);\n\n  // Check if the latest version is installed\n  Serial.println();\n  if (fv >= latestFv) {\n    Serial.println(\"Check result: PASSED\");\n  } else {\n    Serial.println(\"Check result: NOT PASSED\");\n    Serial.println(\" - The firmware version on the shield do not match the\");\n    Serial.println(\"   version required by the library, you may experience\");\n    Serial.println(\"   issues or failures.\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "gsm",
        "delay"
      ],
      "libraries": [
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  MODEM.begin();\n  while (!MODEM.noop());\n\n  for (int i = 0; i < 80; i++) Serial.print(\"*\");\n  Serial.println();\n  Serial.println(\"This sketch allows you to select your preferred\");\n  Serial.println(\"GSM Radio Access Technology (RAT).\");\n  Serial.println();\n  Serial.println(\"You can choose among 2G, 3G/UMTS or a combination of both.\");\n  Serial.println();\n  Serial.println(\"The chosen configuration will be saved to modem's internal memory\");\n  Serial.println(\"and will be preserved through MKR GSM 1400 sketch uploads.\");\n  Serial.println();\n  Serial.println(\"In order to change the RAT, you will need to run this sketch again.\");\n  for (int i = 0; i < 80; i++) Serial.print(\"*\");\n\n  Serial.println();\n  Serial.println();\n  Serial.println(\"Please choose your Radio Access Technology:\");\n  Serial.println();\n  Serial.println(\"    0 - 2G only\");\n  Serial.println(\"    1 - 3G/UMTS only\");\n  Serial.println(\"    2 - 2G preferred, 3G/UMTS as failover\");\n  Serial.println(\"    3 - 3G/UMTS preferred, 2G as failover (default)\");\n  Serial.println();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "String uratChoice;\n\n  Serial.print(\"> \");\n\n  Serial.setTimeout(-1);\n  while (Serial.available() == 0);\n  String uratInput = Serial.readStringUntil('\\n');\n  uratInput.trim();\n  int urat = uratInput.toInt();\n  Serial.println(urat);\n\n  switch (urat) {\n    case 0:\n      uratChoice = \"0\";\n      break;\n    case 1:\n      uratChoice = \"2\";\n      break;\n    case 2:\n      uratChoice = \"1,0\";\n      break;\n    case 3:\n      uratChoice = \"1,2\";\n      break;\n    default:\n      Serial.println(\"Invalid input. Please, retry.\");\n      return;\n  }\n\n  setRAT(uratChoice);\n  apply();\n\n  Serial.println();\n  Serial.println(\"Radio Access Technology selected.\");\n  Serial.println(\"Now you can upload your 2G or 3G application sketch.\");\n  while (true);"
        },
        {
          "name": "setRAT",
          "parameters": "String choice",
          "body": "String response;\n\n  Serial.print(\"Disconnecting from network: \");\n  MODEM.sendf(\"AT+COPS=2\");\n  MODEM.waitForResponse(10000);\n  Serial.println(\"done.\");\n\n  Serial.print(\"Setting Radio Access Technology: \");\n  MODEM.sendf(\"AT+URAT=%s\", choice.c_str());\n  MODEM.waitForResponse(10000, &response);\n  Serial.println(\"done.\");\n\n  return true;"
        },
        {
          "name": "apply",
          "parameters": "",
          "body": "Serial.print(\"Applying changes and saving configuration: \");\n  MODEM.reset();\n  delay(5000);\n  Serial.println(\"Modem restart\");\n  MODEM.begin(true);\n\n  do {\n    delay(1000);\n    MODEM.noop();\n  } while (MODEM.waitForResponse(1000) != 1);\n\n  Serial.println(\"done.\");\n  \n  return true;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "key",
        "delay"
      ],
      "libraries": [
        "Audio.h",
        "Adafruit_Keypad.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial) ;\n  delay(3000);\n\n  customKeypad.begin();\n\n  // Maximum memory usage was reported as 4\n  // Proc = 9 (9),  Mem = 4 (4)\n  AudioMemory(4);\n\n  // Initialize the effect - left channel\n  // address of delayline\n  // total number of samples in the delay line\n  // number of voices in the chorus INCLUDING the original voice\n  if(!l_myEffect.begin(l_delayline,CHORUS_DELAY_LENGTH,n_chorus)) {\n    Serial.println(\"AudioEffectChorus - left channel begin failed\");\n    while(1);\n  }\n\n  // Initialize the effect - right channel\n  // address of delayline\n  // total number of samples in the delay line\n  // number of voices in the chorus INCLUDING the original voice\n  if(!r_myEffect.begin(r_delayline,CHORUS_DELAY_LENGTH,n_chorus)) {\n    Serial.println(\"AudioEffectChorus - left channel begin failed\");\n    while(1);\n  }\n  // Initially the effect is off. It is switched on when the\n  // PASSTHRU button is pushed.\n  l_myEffect.voices(0);\n  r_myEffect.voices(0);\n\n  Serial.println(\"setup done\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "customKeypad.tick();\n  \n  while(customKeypad.available())\n  {\n    keypadEvent e = customKeypad.read();\n    if(e.bit.KEY == PASSTHRU_KEY){\n      if(e.bit.EVENT == KEY_JUST_PRESSED){\n        // switch on the chorus when the button is pressed\n        l_myEffect.voices(n_chorus);\n        r_myEffect.voices(n_chorus);\n      }\n      else if(e.bit.EVENT == KEY_JUST_RELEASED){\n        // switch off the chorus when button is released\n        l_myEffect.voices(0);\n        r_myEffect.voices(0);\n      }\n    }\n  }\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "ssl",
        "certificate",
        "https",
        "stream",
        "buffer",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266HTTPClient.h",
        "ESP8266WiFi.h",
        "HTTPClient.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "StreamUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize Serial Port\n  Serial.begin(115200);\n  while (!Serial)\n    continue;\n\n  // Connect to the WLAN\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.println(F(\"Connecting to Wifi...\"));\n    delay(500);\n  }\n\n  // Initialize the SSL library\n  WiFiClientSecure client;\n  client.setInsecure();  // ignore server's certificate\n\n  // Send the request\n  HTTPClient http;\n  http.begin(client, F(\"https://jigsaw.w3.org/HTTP/ChunkedScript\"));\n\n  // Ask HTTPClient to collect the Transfer-Encoding header\n  // (by default it discards all headers)\n  const char* keys[] = {\"Transfer-Encoding\"};\n  http.collectHeaders(keys, 1);\n\n  Serial.println(F(\"Sending request...\"));\n  int status = http.GET();\n  if (status != 200) {\n    Serial.print(F(\"Unexpected HTTP status: \"));\n    Serial.println(status);\n    return;\n  }\n\n  // Get a reference to the stream\n  Stream& rawStream = http.getStream();\n  ChunkDecodingStream decodedStream(http.getStream());\n  Stream& response =\n      http.header(\"Transfer-Encoding\") == \"chunked\" ? decodedStream : rawStream;\n\n  // Read and print the response\n  char buffer[256];\n  size_t n = 0;\n  do {\n    n = response.readBytes(buffer, sizeof(buffer));\n    Serial.write(buffer, n);\n  } while (n == sizeof(buffer));\n\n  // Disconnect\n  http.end();\n\n  Serial.println(F(\"Done!\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "display"
      ],
      "libraries": [
        "Adafruit_CircuitPlayground.h",
        "Adafruit_ZeroFFT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "CircuitPlayground.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "CircuitPlayground.mic.capture(inputData, DATA_SIZE);\n\n  /*******************************\n   *   REMOVE DC OFFSET\n   ******************************/\n  int32_t avg = 0;\n  int16_t *ptr = inputData;\n  for(int i=0; i<DATA_SIZE; i++) avg += *ptr++;\n  avg = avg/DATA_SIZE;\n\n  ptr = inputData;\n  for(int i=0; i<DATA_SIZE; i++){\n    *ptr -= avg;\n    *ptr++ = *ptr*SCALE_FACTOR;\n  }\n  \n  //run the FFT\n  ZeroFFT(inputData, DATA_SIZE);\n  \n  //set all to 0\n  memset(pixelData, 0, NUM_PIXELS*sizeof(int16_t));\n\n  //downsample into NUM_PIXELS bins\n  for(int i=MIN_INDEX; i<MAX_INDEX; i++){\n    int ix = map(i, MIN_INDEX, MAX_INDEX, 0, NUM_PIXELS);\n    pixelData[ix] += inputData[i];\n  }\n\n  //display the data\n  for(int i=0; i<NUM_PIXELS; i++)\n    CircuitPlayground.strip.setPixelColor(i, Wheel(pixelData[i]));\n\n  CircuitPlayground.strip.show();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "parse",
        "buffer",
        "stream",
        "current",
        "acceleration",
        "light",
        "spi",
        "i2c",
        "4g",
        "bluetooth",
        "tone",
        "millis",
        "delay",
        "servo",
        "digitalwrite",
        "analogwrite",
        "analogread",
        "rgb",
        "led",
        "eeprom",
        "timer",
        "interrupt",
        "pwm",
        "sensors",
        "meters",
        "devices",
        "sensors_event_t"
      ],
      "libraries": [
        "SPI.h",
        "Servo.h",
        "Wire.h",
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "wireWrite",
          "parameters": "byte data",
          "body": "#if ARDUINO >= 100\n  Wire.write((byte)data);\n#else\n  Wire.send(data);\n#endif"
        },
        {
          "name": "attachServo",
          "parameters": "byte pin, int minPulse, int maxPulse",
          "body": "if (servoCount < MAX_SERVOS) {\n    // reuse indexes of detached servos until all have been reallocated\n    if (detachedServoCount > 0) {\n      servoPinMap[pin] = detachedServos[detachedServoCount - 1];\n      if (detachedServoCount > 0) detachedServoCount--;\n    } else {\n      servoPinMap[pin] = servoCount;\n      servoCount++;\n    }\n    if (minPulse > 0 && maxPulse > 0) {\n      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);\n    } else {\n      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin));\n    }\n  } else {\n    Firmata.sendString(\"Max servos attached\");\n  }"
        },
        {
          "name": "detachServo",
          "parameters": "byte pin",
          "body": "servos[servoPinMap[pin]].detach();\n  // if we're detaching the last servo, decrement the count\n  // otherwise store the index of the detached servo\n  if (servoPinMap[pin] == servoCount && servoCount > 0) {\n    servoCount--;\n  } else if (servoCount > 0) {\n    // keep track of detached servos because we want to reuse their indexes\n    // before incrementing the count of attached servos\n    detachedServoCount++;\n    detachedServos[detachedServoCount - 1] = servoPinMap[pin];\n  }\n\n  servoPinMap[pin] = 255;"
        },
        {
          "name": "readAndReportData",
          "parameters": "byte address, int theRegister, byte numBytes",
          "body": "// allow I2C requests that don't require a register read\n  // for example, some devices using an interrupt pin to signify new data available\n  // do not always require the register read so upon interrupt you call Wire.requestFrom()\n  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {\n    Wire.beginTransmission(address);\n    wireWrite((byte)theRegister);\n    Wire.endTransmission();\n    // do not set a value of 0\n    if (i2cReadDelayTime > 0) {\n      // delay is necessary for some devices such as WiiNunchuck\n      delayMicroseconds(i2cReadDelayTime);\n    }\n  } else {\n    theRegister = 0;  // fill the register with a dummy value\n  }\n\n  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom\n\n  // check to be sure correct number of bytes were returned by slave\n  if (numBytes < Wire.available()) {\n    Firmata.sendString(\"I2C: Too many bytes received\");\n  } else if (numBytes > Wire.available()) {\n    Firmata.sendString(\"I2C: Too few bytes received\");\n  }\n\n  i2cRxData[0] = address;\n  i2cRxData[1] = theRegister;\n\n  for (int i = 0; i < numBytes && Wire.available(); i++) {\n    i2cRxData[2 + i] = wireRead();\n  }\n\n  // send slave address, register and received bytes\n  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);"
        },
        {
          "name": "outputPort",
          "parameters": "byte portNumber, byte portValue, byte forceSend",
          "body": "// pins not configured as INPUT are cleared to zeros\n  portValue = portValue & portConfigInputs[portNumber];\n  // only send if the value is different than previously sent\n  if (forceSend || previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;\n  }"
        },
        {
          "name": "checkDigitalInputs",
          "parameters": "void",
          "body": "/* Using non-looping code allows constants to be given to readPort().\n   * The compiler will apply substantial optimizations if the inputs\n   * to readPort() are compile-time constants. */\n  if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);\n  if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);\n  if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);\n  if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);\n  if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);\n  if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);\n  if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);\n  if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);\n  if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);\n  if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);\n  if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);\n  if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);\n  if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);\n  if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);\n  if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);\n  if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);"
        },
        {
          "name": "setPinModeCallback",
          "parameters": "byte pin, int mode",
          "body": "if (pinConfig[pin] == PIN_MODE_IGNORE)\n    return;\n\n  if (pinConfig[pin] == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) {\n    // disable i2c so pins can be used for other functions\n    // the following if statements should reconfigure the pins properly\n    disableI2CPins();\n  }\n  if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) {\n    if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) {\n      detachServo(pin);\n    }\n  }\n  if (IS_PIN_ANALOG(pin)) {\n    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting\n  }\n  if (IS_PIN_DIGITAL(pin)) {\n    if (mode == INPUT || mode == PIN_MODE_PULLUP) {\n      portConfigInputs[pin / 8] |= (1 << (pin & 7));\n    } else {\n      portConfigInputs[pin / 8] &= ~(1 << (pin & 7));\n    }\n  }\n  pinState[pin] = 0;\n  switch (mode) {\n    case PIN_MODE_ANALOG:\n      if (IS_PIN_ANALOG(pin)) {\n        if (IS_PIN_DIGITAL(pin)) {\n          pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver\n#if ARDUINO <= 100\n          // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6\n          digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups\n#endif\n        }\n        pinConfig[pin] = PIN_MODE_ANALOG;\n      }\n      break;\n    case INPUT:\n      if (IS_PIN_DIGITAL(pin)) {\n        pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver\n#if ARDUINO <= 100\n        // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6\n        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups\n#endif\n        pinConfig[pin] = INPUT;\n      }\n      break;\n    case PIN_MODE_PULLUP:\n      if (IS_PIN_DIGITAL(pin)) {\n        pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP);\n        pinConfig[pin] = PIN_MODE_PULLUP;\n        pinState[pin] = 1;\n      }\n      break;\n    case OUTPUT:\n      if (IS_PIN_DIGITAL(pin)) {\n        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable PWM\n        pinMode(PIN_TO_DIGITAL(pin), OUTPUT);\n        pinConfig[pin] = OUTPUT;\n      }\n      break;\n    case PIN_MODE_PWM:\n      if (IS_PIN_PWM(pin)) {\n        pinMode(PIN_TO_PWM(pin), OUTPUT);\n        analogWrite(PIN_TO_PWM(pin), 0);\n        pinConfig[pin] = PIN_MODE_PWM;\n      }\n      break;\n    case PIN_MODE_SERVO:\n      if (IS_PIN_DIGITAL(pin)) {\n        pinConfig[pin] = PIN_MODE_SERVO;\n        if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) {\n          // pass -1 for min and max pulse values to use default values set\n          // by Servo library\n          attachServo(pin, -1, -1);\n        }\n      }\n      break;\n    case PIN_MODE_I2C:\n      if (IS_PIN_I2C(pin)) {\n        // mark the pin as i2c\n        // the user must call I2C_CONFIG to enable I2C for a device\n        pinConfig[pin] = PIN_MODE_I2C;\n      }\n      break;\n    default:\n      Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM\n  }\n  // TODO: save status to EEPROM here, if changed"
        },
        {
          "name": "setPinValueCallback",
          "parameters": "byte pin, int value",
          "body": "if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) {\n    if (pinConfig[pin] == OUTPUT) {\n      pinState[pin] = value;\n      digitalWrite(PIN_TO_DIGITAL(pin), value);\n    }\n  }"
        },
        {
          "name": "analogWriteCallback",
          "parameters": "byte pin, int value",
          "body": "if (pin < TOTAL_PINS) {\n    switch (pinConfig[pin]) {\n      case PIN_MODE_SERVO:\n        if (IS_PIN_DIGITAL(pin))\n          servos[servoPinMap[pin]].write(value);\n        pinState[pin] = value;\n        break;\n      case PIN_MODE_PWM:\n        if (IS_PIN_PWM(pin))\n          analogWrite(PIN_TO_PWM(pin), value);\n        pinState[pin] = value;\n        break;\n    }\n  }"
        },
        {
          "name": "digitalWriteCallback",
          "parameters": "byte port, int value",
          "body": "byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;\n\n  if (port < TOTAL_PORTS) {\n    // create a mask of the pins on this port that are writable.\n    lastPin = port * 8 + 8;\n    if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS;\n    for (pin = port * 8; pin < lastPin; pin++) {\n      // do not disturb non-digital pins (eg, Rx & Tx)\n      if (IS_PIN_DIGITAL(pin)) {\n        // do not touch pins in PWM, ANALOG, SERVO or other modes\n        if (pinConfig[pin] == OUTPUT || pinConfig[pin] == INPUT) {\n          pinValue = ((byte)value & mask) ? 1 : 0;\n          if (pinConfig[pin] == OUTPUT) {\n            pinWriteMask |= mask;\n          } else if (pinConfig[pin] == INPUT && pinValue == 1 && pinState[pin] != 1) {\n            // only handle INPUT here for backwards compatibility\n#if ARDUINO > 100\n            pinMode(pin, INPUT_PULLUP);\n#else\n            // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier\n            pinWriteMask |= mask;\n#endif\n          }\n          pinState[pin] = pinValue;\n        }\n      }\n      mask = mask << 1;\n    }\n    writePort(port, (byte)value, pinWriteMask);\n  }"
        },
        {
          "name": "reportAnalogCallback",
          "parameters": "byte analogPin, int value",
          "body": "if (analogPin < TOTAL_ANALOG_PINS) {\n    if (value == 0) {\n      analogInputsToReport = analogInputsToReport & ~ (1 << analogPin);\n    } else {\n      analogInputsToReport = analogInputsToReport | (1 << analogPin);\n      // prevent during system reset or all analog pin values will be reported\n      // which may report noise for unconnected analog pins\n      if (!isResetting) {\n        // Send pin value immediately. This is helpful when connected via\n        // ethernet, wi-fi or bluetooth so pin states can be known upon\n        // reconnecting.\n        Firmata.sendAnalog(analogPin, analogRead(analogPin));\n      }\n    }\n  }\n  // TODO: save status to EEPROM here, if changed"
        },
        {
          "name": "reportDigitalCallback",
          "parameters": "byte port, int value",
          "body": "if (port < TOTAL_PORTS) {\n    reportPINs[port] = (byte)value;\n    // Send port value immediately. This is helpful when connected via\n    // ethernet, wi-fi or bluetooth so pin states can be known upon\n    // reconnecting.\n    if (value) outputPort(port, readPort(port, portConfigInputs[port]), true);\n  }\n  // do not disable analog reporting on these 8 pins, to allow some\n  // pins used for digital, others analog.  Instead, allow both types\n  // of reporting to be enabled, but check if the pin is configured\n  // as analog when sampling the analog inputs.  Likewise, while\n  // scanning digital pins, portConfigInputs will mask off values from any\n  // pins configured as analog"
        },
        {
          "name": "circuitPlaygroundCommand",
          "parameters": "byte command, byte argc, byte* argv",
          "body": "switch (command) {\n    case CP_PIXEL_SET:\n      // Set a NeoPixel to the specified RGB color.\n      // Expect: 1 byte pixel number, 4 bytes pixel RGB value (as 7-bit bytes)\n      if (argc >= 5) {\n        // Parse out the pixel number and R, G, B bytes.\n        uint8_t pixel = argv[0] & 0x7F;\n        uint8_t r = (argv[1] << 1) | ((argv[2] & 0x7F) >> 6);  // Red = 7 bits from byte 4 and 1 bit from byte 5\n        uint8_t g = ((argv[2] & 0x3F) << 2) | (((argv[3]) & 0x7F) >> 5);  // Green = 6 bits from byte 5 and 2 bits from byte 6\n        uint8_t b = ((argv[3] & 0x1F) << 3) | (((argv[4]) & 0x7F) >> 4);  // Blue = 5 bits from byte 6 and 3 bits from byte 7\n        CircuitPlayground.strip.setPixelColor(pixel, r, g, b);\n      }\n      break;\n    case CP_PIXEL_SHOW:\n      // Light up the neopixels with their current buffer values.\n      CircuitPlayground.strip.show();\n      break;\n    case CP_PIXEL_CLEAR:\n      // Clear all the pixel color values.\n      CircuitPlayground.strip.clear();\n      break;\n    case CP_PIXEL_BRIGHTNESS:\n      // Set pixel brightness.\n      // Expects 1 byte with the brightness as a value 0-100.\n      if (argc >= 1) {\n        uint8_t brightness = argv[0];\n        if (brightness > 100) {\n          return;\n        }\n        CircuitPlayground.strip.setBrightness(brightness);\n      }\n    case CP_TONE:\n      // Play a tone on the speaker.\n      // Expect: 2 bytes tone frequency, 2 bytes tone duration\n      if (argc >= 4) {\n        uint16_t frequency = ((argv[1] & 0x7F) << 7) | (argv[0] & 0x7F);\n        uint16_t duration = ((argv[3] & 0x7F) << 7) | (argv[2] & 0x7F);\n        // If duration is zero then interpret that as continuous tone playback.\n        if (duration == 0) {\n          tone(SPEAKER_PIN, frequency);\n        }\n        else {\n          tone(SPEAKER_PIN, frequency, duration);\n        }\n      }\n      break;\n    case CP_NO_TONE:\n      // Stop tone playback.\n      noTone(SPEAKER_PIN);\n      break;\n    case CP_ACCEL_READ:\n      sendAccelResponse();\n      break;\n    case CP_ACCEL_TAP:\n      sendTapResponse();\n      break;\n    case CP_ACCEL_TAP_STREAM_ON:\n      streamTap = true;\n      break;\n    case CP_ACCEL_TAP_STREAM_OFF:\n      streamTap = false;\n      break;\n    case CP_ACCEL_STREAM_ON:\n      streamAccel = true;\n      break;\n    case CP_ACCEL_STREAM_OFF:\n      streamAccel = false;\n      break;\n    case CP_CAP_READ:\n      // Flip the streaming bool on for the specified input.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t input = argv[0] & 0x7F;\n        // Now find the specified cap input and send a response with its current cap touch value.\n        for (int i=0; i<CAP_COUNT; ++i) {\n          if (cap_state[i].pin == input) {\n            sendCapResponse(input);\n          }\n        }\n      }\n      break;\n    case CP_CAP_ON:\n      // Flip the streaming bool on for the specified input.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t input = argv[0] & 0x7F;\n        // Now find the specified cap input and flip on its streaming bit.\n        for (int i=0; i<CAP_COUNT; ++i) {\n          if (cap_state[i].pin == input) {\n            cap_state[i].streaming = true;\n          }\n        }\n      }\n      break;\n    case CP_CAP_OFF:\n      // Flip the streaming bool off for the specified input.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t input = argv[0] & 0x7F;\n        // Now find the specified cap input and flip on its streaming bit.\n        for (int i=0; i<CAP_COUNT; ++i) {\n          if (cap_state[i].pin == input) {\n            cap_state[i].streaming = false;\n          }\n        }\n      }\n      break;\n    case CP_ACCEL_RANGE:\n      // Set the range of the accelerometer based on the passed in value.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t range = argv[0] & 0x7F;\n        // Check the range is an allowed value (0, 1, 2, 3).\n        if (range > 3) {\n          // Unknown range value, stop processing!\n          return;\n        }\n        // Set the range of the accelerometer.\n        CircuitPlayground.lis.setRange((lis3dh_range_t)range);\n      }\n      break;\n    case CP_ACCEL_TAP_CONFIG:\n      // Set the sensitivity of tap detection.\n      // Expects 4 7-bit firmata bytes as input, which expand to 2 bytes of 8-bit unsigned data.\n      // First check we have enough parameters.\n      if (argc >= 4) {\n        // Parse out paramemters.\n        uint8_t type = ((argv[1] & 0x01) << 7) | (argv[0] & 0x7F);\n        uint8_t threshold = ((argv[3] & 0x01) << 7) | (argv[2] & 0x7F);\n        // Set the click threshold values.\n        CircuitPlayground.lis.setClick(type, threshold);\n      }\n    case CP_SENSECOLOR:\n      // Sense the color of an object over the light sensor and send back\n      // a CP_SENSECOLOR_REPLY response.\n      sendColorSenseResponse();\n  }"
        },
        {
          "name": "sendColorSenseResponse",
          "parameters": "",
          "body": "// Perform a color sense with NeoPixel #1 and the light sensor.\n  uint8_t red, green, blue;\n  CircuitPlayground.senseColor(red, green, blue);\n  // Construct a response data packet and send it.\n  uint8_t data[4] = {0};\n  data[0] = CP_SENSECOLOR_REPLY;\n  data[1] = red;\n  data[2] = green;\n  data[3] = blue;\n  // Send the response.\n  Firmata.sendSysex(CP_COMMAND, 4, data);"
        },
        {
          "name": "sendAccelResponse",
          "parameters": "",
          "body": "// Get an accelerometer X, Y, Z reading.\n  sensors_event_t event;\n  CircuitPlayground.lis.getEvent(&event);\n  // Construct a response data packet.\n  uint8_t data[13] = {0};\n  data[0] = CP_ACCEL_READ_REPLY;\n  // Put the three 32-bit float X,Y,Z reading into the packet.\n  // Note that Firmata.sendSysex will automatically convert bytes into\n  // two 7-bit bytes that are Firmata/MIDI compatible.\n  // Use a union to easily grab the bytes of the float.\n  union {\n    float value;\n    uint8_t bytes[4];\n  } reading;\n  // Grab each X, Y, Z float byte value and copy it into the response.\n  reading.value = event.acceleration.x;\n  memcpy(data+1, reading.bytes, 4);\n  reading.value = event.acceleration.y;\n  memcpy(data+5, reading.bytes, 4);\n  reading.value = event.acceleration.z;\n  memcpy(data+9, reading.bytes, 4);\n  // Send the response.\n  Firmata.sendSysex(CP_COMMAND, 13, data);"
        },
        {
          "name": "sendTapResponse",
          "parameters": "",
          "body": "// Get the accelerometer tap detection state.\n  uint8_t click = CircuitPlayground.lis.getClick();\n  // Construct a response data packet and send it.\n  uint8_t data[2] = {0};\n  data[0] = CP_ACCEL_TAP_REPLY;\n  data[1] = click;\n  // Send the response.\n  Firmata.sendSysex(CP_COMMAND, 2, data);"
        },
        {
          "name": "sendCapResponse",
          "parameters": "uint8_t pin",
          "body": "// Get the cap sense value for the provided input pin.\n  int32_t value = CircuitPlayground.readCap(pin, CAP_SAMPLES);\n  // Build a response data packet and send it.  The response includes:\n  // - uint8_t: CP_CAP_REPLY value\n  // - uint8_t: pin number of the read input\n  // - int32_t: cap sensor value, large values mean the input was touched\n  union {\n    struct {\n      uint8_t type;\n      uint8_t pin;\n      int32_t value;\n    } data;\n    uint8_t bytes[6];\n  } response;\n  response.data.type = CP_CAP_REPLY;\n  response.data.pin = pin;\n  response.data.value = value;\n  // Send the response, this will expand each byte into 2 bytes of 7-bit data.\n  Firmata.sendSysex(CP_COMMAND, 6, response.bytes);"
        },
        {
          "name": "sysexCallback",
          "parameters": "byte command, byte argc, byte *argv",
          "body": "byte mode;\n  byte slaveAddress;\n  byte data;\n  int slaveRegister;\n  unsigned int delayTime;\n\n  switch (command) {\n    // Circuit playground command processing:\n    case CP_COMMAND:\n      if (argc < 1) return;\n      circuitPlaygroundCommand(argv[0], argc-1, argv+1);\n      break;\n    case I2C_REQUEST:\n      mode = argv[1] & I2C_READ_WRITE_MODE_MASK;\n      if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) {\n        Firmata.sendString(\"10-bit addressing not supported\");\n        return;\n      }\n      else {\n        slaveAddress = argv[0];\n      }\n\n      switch (mode) {\n        case I2C_WRITE:\n          Wire.beginTransmission(slaveAddress);\n          for (byte i = 2; i < argc; i += 2) {\n            data = argv[i] + (argv[i + 1] << 7);\n            wireWrite(data);\n          }\n          Wire.endTransmission();\n          delayMicroseconds(70);\n          break;\n        case I2C_READ:\n          if (argc == 6) {\n            // a slave register is specified\n            slaveRegister = argv[2] + (argv[3] << 7);\n            data = argv[4] + (argv[5] << 7);  // bytes to read\n          }\n          else {\n            // a slave register is NOT specified\n            slaveRegister = I2C_REGISTER_NOT_SPECIFIED;\n            data = argv[2] + (argv[3] << 7);  // bytes to read\n          }\n          readAndReportData(slaveAddress, (int)slaveRegister, data);\n          break;\n        case I2C_READ_CONTINUOUSLY:\n          if ((queryIndex + 1) >= I2C_MAX_QUERIES) {\n            // too many queries, just ignore\n            Firmata.sendString(\"too many queries\");\n            break;\n          }\n          if (argc == 6) {\n            // a slave register is specified\n            slaveRegister = argv[2] + (argv[3] << 7);\n            data = argv[4] + (argv[5] << 7);  // bytes to read\n          }\n          else {\n            // a slave register is NOT specified\n            slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED;\n            data = argv[2] + (argv[3] << 7);  // bytes to read\n          }\n          queryIndex++;\n          query[queryIndex].addr = slaveAddress;\n          query[queryIndex].reg = slaveRegister;\n          query[queryIndex].bytes = data;\n          break;\n        case I2C_STOP_READING:\n          byte queryIndexToSkip;\n          // if read continuous mode is enabled for only 1 i2c device, disable\n          // read continuous reporting for that device\n          if (queryIndex <= 0) {\n            queryIndex = -1;\n          } else {\n            // if read continuous mode is enabled for multiple devices,\n            // determine which device to stop reading and remove it's data from\n            // the array, shifiting other array data to fill the space\n            for (byte i = 0; i < queryIndex + 1; i++) {\n              if (query[i].addr == slaveAddress) {\n                queryIndexToSkip = i;\n                break;\n              }\n            }\n\n            for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) {\n              if (i < I2C_MAX_QUERIES) {\n                query[i].addr = query[i + 1].addr;\n                query[i].reg = query[i + 1].reg;\n                query[i].bytes = query[i + 1].bytes;\n              }\n            }\n            queryIndex--;\n          }\n          break;\n        default:\n          break;\n      }\n      break;\n    case I2C_CONFIG:\n      delayTime = (argv[0] + (argv[1] << 7));\n\n      if (delayTime > 0) {\n        i2cReadDelayTime = delayTime;\n      }\n\n      if (!isI2CEnabled) {\n        enableI2CPins();\n      }\n\n      break;\n    case SERVO_CONFIG:\n      if (argc > 4) {\n        // these vars are here for clarity, they'll optimized away by the compiler\n        byte pin = argv[0];\n        int minPulse = argv[1] + (argv[2] << 7);\n        int maxPulse = argv[3] + (argv[4] << 7);\n\n        if (IS_PIN_DIGITAL(pin)) {\n          if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) {\n            detachServo(pin);\n          }\n          attachServo(pin, minPulse, maxPulse);\n          setPinModeCallback(pin, PIN_MODE_SERVO);\n        }\n      }\n      break;\n    case SAMPLING_INTERVAL:\n      if (argc > 1) {\n        samplingInterval = argv[0] + (argv[1] << 7);\n        if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) {\n          samplingInterval = MINIMUM_SAMPLING_INTERVAL;\n        }\n      } else {\n        //Firmata.sendString(\"Not enough data\");\n      }\n      break;\n    case EXTENDED_ANALOG:\n      if (argc > 1) {\n        int val = argv[1];\n        if (argc > 2) val |= (argv[2] << 7);\n        if (argc > 3) val |= (argv[3] << 14);\n        analogWriteCallback(argv[0], val);\n      }\n      break;\n    case CAPABILITY_QUERY:\n      Firmata.write(START_SYSEX);\n      Firmata.write(CAPABILITY_RESPONSE);\n      for (byte pin = 0; pin < TOTAL_PINS; pin++) {\n        if (IS_PIN_DIGITAL(pin)) {\n          Firmata.write((byte)INPUT);\n          Firmata.write(1);\n          Firmata.write((byte)PIN_MODE_PULLUP);\n          Firmata.write(1);\n          Firmata.write((byte)OUTPUT);\n          Firmata.write(1);\n        }\n        if (IS_PIN_ANALOG(pin)) {\n          Firmata.write(PIN_MODE_ANALOG);\n          Firmata.write(10); // 10 = 10-bit resolution\n        }\n        if (IS_PIN_PWM(pin)) {\n          Firmata.write(PIN_MODE_PWM);\n          Firmata.write(8); // 8 = 8-bit resolution\n        }\n        if (IS_PIN_DIGITAL(pin)) {\n          Firmata.write(PIN_MODE_SERVO);\n          Firmata.write(14);\n        }\n        if (IS_PIN_I2C(pin)) {\n          Firmata.write(PIN_MODE_I2C);\n          Firmata.write(1);  // TODO: could assign a number to map to SCL or SDA\n        }\n        Firmata.write(127);\n      }\n      Firmata.write(END_SYSEX);\n      break;\n    case PIN_STATE_QUERY:\n      if (argc > 0) {\n        byte pin = argv[0];\n        Firmata.write(START_SYSEX);\n        Firmata.write(PIN_STATE_RESPONSE);\n        Firmata.write(pin);\n        if (pin < TOTAL_PINS) {\n          Firmata.write((byte)pinConfig[pin]);\n          Firmata.write((byte)pinState[pin] & 0x7F);\n          if (pinState[pin] & 0xFF80) Firmata.write((byte)(pinState[pin] >> 7) & 0x7F);\n          if (pinState[pin] & 0xC000) Firmata.write((byte)(pinState[pin] >> 14) & 0x7F);\n        }\n        Firmata.write(END_SYSEX);\n      }\n      break;\n    case ANALOG_MAPPING_QUERY:\n      Firmata.write(START_SYSEX);\n      Firmata.write(ANALOG_MAPPING_RESPONSE);\n      for (byte pin = 0; pin < TOTAL_PINS; pin++) {\n        Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);\n      }\n      Firmata.write(END_SYSEX);\n      break;\n  }"
        },
        {
          "name": "enableI2CPins",
          "parameters": "",
          "body": "byte i;\n  // is there a faster way to do this? would probaby require importing\n  // Arduino.h to get SCL and SDA pins\n  for (i = 0; i < TOTAL_PINS; i++) {\n    if (IS_PIN_I2C(i)) {\n      // mark pins as i2c so they are ignore in non i2c data requests\n      setPinModeCallback(i, PIN_MODE_I2C);\n    }\n  }\n\n  isI2CEnabled = true;\n\n  Wire.begin();"
        },
        {
          "name": "disableI2CPins",
          "parameters": "",
          "body": "isI2CEnabled = false;\n  // disable read continuous mode for all devices\n  queryIndex = -1;"
        },
        {
          "name": "systemResetCallback",
          "parameters": "",
          "body": "isResetting = true;\n\n  // initialize a defalt state\n  // TODO: option to load config from EEPROM instead of default\n\n  // Reset circuit playground components to a default state with nothing running.\n  // (i.e. no pixels lit, no sound, no data streaming back)\n  circuitPlaygroundReset();\n\n  if (isI2CEnabled) {\n    disableI2CPins();\n  }\n\n  for (byte i = 0; i < TOTAL_PORTS; i++) {\n    reportPINs[i] = false;    // by default, reporting off\n    portConfigInputs[i] = 0;  // until activated\n    previousPINs[i] = 0;\n  }\n\n  for (byte i = 0; i < TOTAL_PINS; i++) {\n    // pins with analog capability default to analog input\n    // otherwise, pins default to digital output\n    if (IS_PIN_ANALOG(i)) {\n      // turns off pullup, configures everything\n      setPinModeCallback(i, PIN_MODE_ANALOG);\n    } else if (IS_PIN_DIGITAL(i)) {\n      // sets the output to 0, configures portConfigInputs\n      setPinModeCallback(i, OUTPUT);\n    }\n\n    servoPinMap[i] = 255;\n  }\n  // by default, do not report any analog inputs\n  analogInputsToReport = 0;\n\n  detachedServoCount = 0;\n  servoCount = 0;\n\n  /* send digital inputs to set the initial state on the host computer,\n   * since once in the loop(), this firmware will only send on change */\n  /*\n  TODO: this can never execute, since no pins default to digital input\n        but it will be needed when/if we support EEPROM stored config\n  for (byte i=0; i < TOTAL_PORTS; i++) {\n    outputPort(i, readPort(i, portConfigInputs[i]), true);\n  }\n  */\n  isResetting = false;"
        },
        {
          "name": "circuitPlaygroundReset",
          "parameters": "",
          "body": "// Reset the circuit playground components into a default state\n  // with none of the pixels lit, no tones playing, and no cap touch\n  // or accelerometer data streaming back.\n\n  // Turn off all the NeoPixels.\n  CircuitPlayground.strip.clear();\n  CircuitPlayground.strip.show();\n\n  // Reset the accelerometer to a default range.\n  CircuitPlayground.lis.setRange(LIS3DH_RANGE_2_G);\n  delay(100);\n  CircuitPlayground.lis.setClick(2, 80);\n  delay(100);\n\n  // Turn off streaming of tap, accel, and cap touch data.\n  streamTap = false;\n  streamAccel = false;\n  for (int i=0; i<CAP_COUNT; ++i) {\n    cap_state[i].streaming = false;\n  }\n\n  // Stop any tones on the speaker.\n  noTone(SPEAKER_PIN);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Circuit playground debug setup\n  #ifdef DEBUG_MODE\n    DEBUG_OUTPUT.begin(DEBUG_BAUD);\n    DEBUG_PRINTLN(\"Circuit Playground Firmata starting up!\");\n  #endif\n\n  // Circuit playground setup:\n  if (!CircuitPlayground.begin()) {\n    // Failed to initialize circuit playground, fast blink the red LED on the board.\n    DEBUG_PRINTLN(\"Failed to initialize circuit playground!\");\n    pinMode(13, OUTPUT);\n    while (1) {\n      digitalWrite(13, LOW);\n      delay(100);\n      digitalWrite(13, HIGH);\n      delay(100);\n    }\n  }\n\n  Firmata.setFirmwareVersion(FIRMATA_MAJOR_VERSION, FIRMATA_MINOR_VERSION);\n\n  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);\n  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);\n  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);\n  Firmata.attach(SET_PIN_MODE, setPinModeCallback);\n  Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback);\n  Firmata.attach(START_SYSEX, sysexCallback);\n  Firmata.attach(SYSTEM_RESET, systemResetCallback);\n\n  // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega,\n  // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this:\n  // Serial1.begin(57600);\n  // Firmata.begin(Serial1);\n  // then comment out or remove lines 701 - 704 below\n  Firmata.begin(57600);\n\n  // Tell Firmata to ignore pins that are used by the Circuit Playground hardware.\n  // This MUST be called or else Firmata will 'clobber' pins like the SPI CS!\n  pinConfig[28] = PIN_MODE_IGNORE;   // Pin 28 = D8 = LIS3DH CS\n  pinConfig[26] = PIN_MODE_IGNORE;   // Messes with CS too?\n\n#if defined(DEMO_MODE)\n  while (!Serial) {\n     runDemo();   // this will 'demo' the board off, so you know its working, until the serial port is opened\n  }\n#endif\n\n  systemResetCallback();  // reset to default config"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "byte pin, analogPin;\n\n  /* DIGITALREAD - as fast as possible, check for changes and output them to the\n   * FTDI buffer using Serial.print()  */\n  checkDigitalInputs();\n\n  /* STREAMREAD - processing incoming messagse as soon as possible, while still\n   * checking digital inputs.  */\n  while (Firmata.available())\n    Firmata.processInput();\n\n  // TODO - ensure that Stream buffer doesn't go over 60 bytes\n\n  currentMillis = millis();\n  if (currentMillis - previousMillis > samplingInterval) {\n    previousMillis += samplingInterval;\n    /* ANALOGREAD - do all analogReads() at the configured sampling interval */\n    for (pin = 0; pin < TOTAL_PINS; pin++) {\n      if (IS_PIN_ANALOG(pin) && pinConfig[pin] == PIN_MODE_ANALOG) {\n        analogPin = PIN_TO_ANALOG(pin);\n        if (analogInputsToReport & (1 << analogPin)) {\n          Firmata.sendAnalog(analogPin, analogRead(analogPin));\n        }\n      }\n    }\n    // report i2c data for all device with read continuous mode enabled\n    if (queryIndex > -1) {\n      for (byte i = 0; i < queryIndex + 1; i++) {\n        readAndReportData(query[i].addr, query[i].reg, query[i].bytes);\n      }\n    }\n    // Check if a tap event should be streamed to the firmata client.\n    if (streamTap) {\n      sendTapResponse();\n    }\n    // Check if an accelerometer event should be streamed to the firmata client.\n    if (streamAccel) {\n      sendAccelResponse();\n    }\n    // Check if any cap touch inputs should be streamed to the firmata client.\n    for (int i=0; i<CAP_COUNT; ++i) {\n      if (cap_state[i].streaming) {\n        sendCapResponse(cap_state[i].pin);\n      }\n    }\n  }"
        },
        {
          "name": "runDemo",
          "parameters": "void",
          "body": "// test Red #13 LED\n  CircuitPlayground.redLED(pixeln % 1);\n\n  /************* TEST SLIDE SWITCH */\n  if (CircuitPlayground.slideSwitch()) {\n    pixeln++;\n    if (pixeln == 11) {\n      pixeln = 0;\n      CircuitPlayground.clearPixels();\n    }\n  } else {\n    if (pixeln == 0) {\n      pixeln = 10;\n      CircuitPlayground.clearPixels();\n    }\n    pixeln--;\n  }\n\n\n  /************* TEST 10 NEOPIXELS */\n  CircuitPlayground.setPixelColor(pixeln, CircuitPlayground.colorWheel(25 * pixeln));\n\n\n  /************* TEST BOTH BUTTONS */\n  if (CircuitPlayground.leftButton()) {\n    CircuitPlayground.playTone(500 + pixeln * 500, 100, false);\n  }\n  if (CircuitPlayground.rightButton()) {\n    CircuitPlayground.setBrightness(60);\n  } else {\n    CircuitPlayground.setBrightness(20);\n  }\n\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "parse",
        "buffer",
        "stream",
        "light",
        "current",
        "acceleration",
        "i2c",
        "spi",
        "4g",
        "bluetooth",
        "tone",
        "millis",
        "delay",
        "digitalread",
        "digitalwrite",
        "analogread",
        "analogwrite",
        "servo",
        "led",
        "rgb",
        "flash",
        "eeprom",
        "timer",
        "interrupt",
        "pwm",
        "sensors",
        "devices",
        "meters",
        "sensors_event_t"
      ],
      "libraries": [
        "SPI.h",
        "Servo.h",
        "Wire.h",
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "wireWrite",
          "parameters": "byte data",
          "body": "#if ARDUINO >= 100\n  Wire.write((byte)data);\n#else\n  Wire.send(data);\n#endif"
        },
        {
          "name": "shimDigitalClassicToExpress",
          "parameters": "int classic",
          "body": "switch (classic) {\n    case 19:           // CP classic D19 -> CP express D5\n      return 5;\n    case 21:           // CP classlic D21 -> CP expresss D7\n      return 7;\n    default:\n      return classic;  // All others are direct mapping of CP classic -> CP express.\n  }"
        },
        {
          "name": "shimAnalogClassicToExpress",
          "parameters": "int classic",
          "body": "switch (classic) {\n    case 5:\n      return A8;\n    case 0:\n      return A9;\n    case 4:\n      return -1;  // Request for A4 is the microphone and handled through\n                  // synthesis of a 10-bit sample from the PDM microphone.\n    case 11:\n      return A0;\n    case 7:\n      return A1;\n    case 9:\n      return A2;\n    case 10:\n      return A3;\n    default:\n      // Weird case, request for pin outside of that normally used on CP.\n      // Just do a direct mapping.\n      return classic;\n  }"
        },
        {
          "name": "shimPinMode",
          "parameters": "int pin, int mode",
          "body": "// Ignore pins above 13 as they are internal to classic/express (but not 19 or 21 as those are classic buttons).\n  if ((pin != 19) && (pin != 21) && (pin > 13)) {\n    return;\n  }\n  // Handle any shimmed pins to override their input mode.\n  if ((mode == INPUT) || (mode == INPUT_PULLUP)) {\n    switch(pin) {\n      case 4:\n      case 19:\n        mode = INPUT_PULLDOWN;\n        break;\n      case 21:\n        mode = INPUT_PULLUP;\n        break;\n    }\n  }\n  // Execute shimmed pinmode call.\n  pinMode(shimDigitalClassicToExpress(pin), mode);"
        },
        {
          "name": "shimDigitalWrite",
          "parameters": "uint8_t pin, uint8_t value",
          "body": "// Only write to pins below 13 as other pins are internal like chip selects, etc.\n  if (pin > 13) {\n    return;\n  }\n  digitalWrite(shimDigitalClassicToExpress(pin), value);"
        },
        {
          "name": "shimAnalogRead",
          "parameters": "uint8_t pin",
          "body": "int express = shimAnalogClassicToExpress(pin);\n  if (express == -1) {\n    // Special case to read the microphone and scale to an unsigned 10-bit value.\n    // Note that we get _signed_ 10-bit values from the mic capture call below, so just add 512 to readjust to unsigned.\n    // Read a single sample from the mic.\n    int16_t sample;\n    CircuitPlayground.mic.capture(&sample, 1);\n    return sample + 512;\n  }\n  else {\n    // Just read the shimmed input.\n    // However we'll take a few samples and average them as the ADC on the SAMD21 is a lot faster\n    // and gets more noisey results.  Just one sample usually reads a really low value.\n    // Take 5 readings from the sensor and average them.\n    uint32_t total = 0;\n    for (int i=0; i<ANALOG_SAMPLES; ++i) {\n      total += analogRead(express);\n    }\n    total /= ANALOG_SAMPLES;\n    return total;\n  }"
        },
        {
          "name": "shimAnalogWrite",
          "parameters": "uint8_t pin, uint8_t value",
          "body": "// Only write to pins below 13 as other pins are internal like chip selects, etc.\n  if (pin > 13) {\n    return;\n  }\n  analogWrite(shimDigitalClassicToExpress(pin), value);"
        },
        {
          "name": "attachServo",
          "parameters": "byte pin, int minPulse, int maxPulse",
          "body": "if (servoCount < MAX_SERVOS) {\n    // reuse indexes of detached servos until all have been reallocated\n    if (detachedServoCount > 0) {\n      servoPinMap[pin] = detachedServos[detachedServoCount - 1];\n      if (detachedServoCount > 0) detachedServoCount--;\n    } else {\n      servoPinMap[pin] = servoCount;\n      servoCount++;\n    }\n    if (minPulse > 0 && maxPulse > 0) {\n      servos[servoPinMap[pin]].attach(shimDigitalClassicToExpress(classic_PIN_TO_DIGITAL(pin)), minPulse, maxPulse);\n    } else {\n      servos[servoPinMap[pin]].attach(shimDigitalClassicToExpress(classic_PIN_TO_DIGITAL(pin)));\n    }\n  } else {\n    Firmata.sendString(\"Max servos attached\");\n  }"
        },
        {
          "name": "detachServo",
          "parameters": "byte pin",
          "body": "servos[servoPinMap[pin]].detach();\n  // if we're detaching the last servo, decrement the count\n  // otherwise store the index of the detached servo\n  if (servoPinMap[pin] == servoCount && servoCount > 0) {\n    servoCount--;\n  } else if (servoCount > 0) {\n    // keep track of detached servos because we want to reuse their indexes\n    // before incrementing the count of attached servos\n    detachedServoCount++;\n    detachedServos[detachedServoCount - 1] = servoPinMap[pin];\n  }\n\n  servoPinMap[pin] = 255;"
        },
        {
          "name": "readAndReportData",
          "parameters": "byte address, int theRegister, byte numBytes",
          "body": "// allow I2C requests that don't require a register read\n  // for example, some devices using an interrupt pin to signify new data available\n  // do not always require the register read so upon interrupt you call Wire.requestFrom()\n  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {\n    Wire.beginTransmission(address);\n    wireWrite((byte)theRegister);\n    Wire.endTransmission();\n    // do not set a value of 0\n    if (i2cReadDelayTime > 0) {\n      // delay is necessary for some devices such as WiiNunchuck\n      delayMicroseconds(i2cReadDelayTime);\n    }\n  } else {\n    theRegister = 0;  // fill the register with a dummy value\n  }\n\n  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom\n\n  // check to be sure correct number of bytes were returned by slave\n  if (numBytes < Wire.available()) {\n    Firmata.sendString(\"I2C: Too many bytes received\");\n  } else if (numBytes > Wire.available()) {\n    Firmata.sendString(\"I2C: Too few bytes received\");\n  }\n\n  i2cRxData[0] = address;\n  i2cRxData[1] = theRegister;\n\n  for (int i = 0; i < numBytes && Wire.available(); i++) {\n    i2cRxData[2 + i] = wireRead();\n  }\n\n  // send slave address, register and received bytes\n  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);"
        },
        {
          "name": "outputPort",
          "parameters": "byte portNumber, byte portValue, byte forceSend",
          "body": "// pins not configured as INPUT are cleared to zeros\n  portValue = portValue & portConfigInputs[portNumber];\n  // only send if the value is different than previously sent\n  if (forceSend || previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;\n  }"
        },
        {
          "name": "checkDigitalInputs",
          "parameters": "void",
          "body": "/* Using non-looping code allows constants to be given to readPort().\n   * The compiler will apply substantial optimizations if the inputs\n   * to readPort() are compile-time constants. */\n  if (classic_TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, shimReadPort(0, portConfigInputs[0]), false);\n  if (classic_TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, shimReadPort(1, portConfigInputs[1]), false);\n  if (classic_TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, shimReadPort(2, portConfigInputs[2]), false);\n  if (classic_TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, shimReadPort(3, portConfigInputs[3]), false);\n  if (classic_TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, shimReadPort(4, portConfigInputs[4]), false);\n  if (classic_TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, shimReadPort(5, portConfigInputs[5]), false);\n  if (classic_TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, shimReadPort(6, portConfigInputs[6]), false);\n  if (classic_TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, shimReadPort(7, portConfigInputs[7]), false);\n  if (classic_TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, shimReadPort(8, portConfigInputs[8]), false);\n  if (classic_TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, shimReadPort(9, portConfigInputs[9]), false);\n  if (classic_TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, shimReadPort(10, portConfigInputs[10]), false);\n  if (classic_TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, shimReadPort(11, portConfigInputs[11]), false);\n  if (classic_TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, shimReadPort(12, portConfigInputs[12]), false);\n  if (classic_TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, shimReadPort(13, portConfigInputs[13]), false);\n  if (classic_TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, shimReadPort(14, portConfigInputs[14]), false);\n  if (classic_TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, shimReadPort(15, portConfigInputs[15]), false);"
        },
        {
          "name": "setPinModeCallback",
          "parameters": "byte pin, int mode",
          "body": "if (pinConfig[pin] == PIN_MODE_IGNORE)\n    return;\n\n  if (pinConfig[pin] == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) {\n    // disable i2c so pins can be used for other functions\n    // the following if statements should reconfigure the pins properly\n    disableI2CPins();\n  }\n  if (classic_IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) {\n    if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) {\n      detachServo(pin);\n    }\n  }\n  if (classic_IS_PIN_ANALOG(pin)) {\n    reportAnalogCallback(classic_PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting\n  }\n  if (classic_IS_PIN_DIGITAL(pin)) {\n    if (mode == INPUT || mode == PIN_MODE_PULLUP) {\n      portConfigInputs[pin / 8] |= (1 << (pin & 7));\n    } else {\n      portConfigInputs[pin / 8] &= ~(1 << (pin & 7));\n    }\n  }\n  pinState[pin] = 0;\n  switch (mode) {\n    case PIN_MODE_ANALOG:\n      if (classic_IS_PIN_ANALOG(pin)) {\n        if (classic_IS_PIN_DIGITAL(pin)) {\n          shimPinMode(classic_PIN_TO_DIGITAL(pin), INPUT);    // disable output driver\n#if ARDUINO <= 100\n          // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6\n          shimDigitalWrite(classic_PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups\n#endif\n        }\n        pinConfig[pin] = PIN_MODE_ANALOG;\n      }\n      break;\n    case INPUT:\n      if (classic_IS_PIN_DIGITAL(pin)) {\n        shimPinMode(classic_PIN_TO_DIGITAL(pin), INPUT);    // disable output driver\n#if ARDUINO <= 100\n        // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6\n        shimDigitalWrite(classic_PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups\n#endif\n        pinConfig[pin] = INPUT;\n      }\n      break;\n    case PIN_MODE_PULLUP:\n      if (classic_IS_PIN_DIGITAL(pin)) {\n        shimPinMode(classic_PIN_TO_DIGITAL(pin), INPUT_PULLUP);\n        pinConfig[pin] = PIN_MODE_PULLUP;\n        pinState[pin] = 1;\n      }\n      break;\n    case OUTPUT:\n      if (classic_IS_PIN_DIGITAL(pin)) {\n        shimDigitalWrite(classic_PIN_TO_DIGITAL(pin), LOW); // disable PWM\n        shimPinMode(classic_PIN_TO_DIGITAL(pin), OUTPUT);\n        pinConfig[pin] = OUTPUT;\n      }\n      break;\n    case PIN_MODE_PWM:\n      if (classic_IS_PIN_PWM(pin)) {\n        shimPinMode(classic_PIN_TO_PWM(pin), OUTPUT);\n        shimAnalogWrite(classic_PIN_TO_PWM(pin), 0);\n        pinConfig[pin] = PIN_MODE_PWM;\n      }\n      break;\n    case PIN_MODE_SERVO:\n      if (classic_IS_PIN_DIGITAL(pin)) {\n        pinConfig[pin] = PIN_MODE_SERVO;\n        if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) {\n          // pass -1 for min and max pulse values to use default values set\n          // by Servo library\n          attachServo(pin, -1, -1);\n        }\n      }\n      break;\n    case PIN_MODE_I2C:\n      if (classic_IS_PIN_I2C(pin)) {\n        // mark the pin as i2c\n        // the user must call I2C_CONFIG to enable I2C for a device\n        pinConfig[pin] = PIN_MODE_I2C;\n      }\n      break;\n    default:\n      Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM\n  }\n  // TODO: save status to EEPROM here, if changed"
        },
        {
          "name": "setPinValueCallback",
          "parameters": "byte pin, int value",
          "body": "if (pin < classic_TOTAL_PINS && classic_IS_PIN_DIGITAL(pin)) {\n    if (pinConfig[pin] == OUTPUT) {\n      pinState[pin] = value;\n      shimDigitalWrite(classic_PIN_TO_DIGITAL(pin), value);\n    }\n  }"
        },
        {
          "name": "analogWriteCallback",
          "parameters": "byte pin, int value",
          "body": "if (pin < classic_TOTAL_PINS) {\n    switch (pinConfig[pin]) {\n      case PIN_MODE_SERVO:\n        if (classic_IS_PIN_DIGITAL(pin))\n          servos[servoPinMap[pin]].write(value);\n        pinState[pin] = value;\n        break;\n      case PIN_MODE_PWM:\n        if (classic_IS_PIN_PWM(pin))\n          shimAnalogWrite(classic_PIN_TO_PWM(pin), value);\n        pinState[pin] = value;\n        break;\n    }\n  }"
        },
        {
          "name": "digitalWriteCallback",
          "parameters": "byte port, int value",
          "body": "byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;\n\n  if (port < classic_TOTAL_PORTS) {\n    // create a mask of the pins on this port that are writable.\n    lastPin = port * 8 + 8;\n    if (lastPin > classic_TOTAL_PINS) lastPin = classic_TOTAL_PINS;\n    for (pin = port * 8; pin < lastPin; pin++) {\n      // do not disturb non-digital pins (eg, Rx & Tx)\n      if (classic_IS_PIN_DIGITAL(pin)) {\n        // do not touch pins in PWM, ANALOG, SERVO or other modes\n        if (pinConfig[pin] == OUTPUT || pinConfig[pin] == INPUT) {\n          pinValue = ((byte)value & mask) ? 1 : 0;\n          if (pinConfig[pin] == OUTPUT) {\n            pinWriteMask |= mask;\n          } else if (pinConfig[pin] == INPUT && pinValue == 1 && pinState[pin] != 1) {\n            // only handle INPUT here for backwards compatibility\n#if ARDUINO > 100\n            shimPinMode(pin, INPUT_PULLUP);\n#else\n            // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier\n            pinWriteMask |= mask;\n#endif\n          }\n          pinState[pin] = pinValue;\n        }\n      }\n      mask = mask << 1;\n    }\n    shimWritePort(port, (byte)value, pinWriteMask);\n  }"
        },
        {
          "name": "reportAnalogCallback",
          "parameters": "byte analogPin, int value",
          "body": "if (analogPin < classic_TOTAL_ANALOG_PINS) {\n    if (value == 0) {\n      analogInputsToReport = analogInputsToReport & ~ (1 << analogPin);\n    } else {\n      analogInputsToReport = analogInputsToReport | (1 << analogPin);\n      // prevent during system reset or all analog pin values will be reported\n      // which may report noise for unconnected analog pins\n      if (!isResetting) {\n        // Send pin value immediately. This is helpful when connected via\n        // ethernet, wi-fi or bluetooth so pin states can be known upon\n        // reconnecting.\n        Firmata.sendAnalog(analogPin, shimAnalogRead(analogPin));\n      }\n    }\n  }\n  // TODO: save status to EEPROM here, if changed"
        },
        {
          "name": "reportDigitalCallback",
          "parameters": "byte port, int value",
          "body": "if (port < classic_TOTAL_PORTS) {\n    reportPINs[port] = (byte)value;\n    // Send port value immediately. This is helpful when connected via\n    // ethernet, wi-fi or bluetooth so pin states can be known upon\n    // reconnecting.\n    if (value) outputPort(port, shimReadPort(port, portConfigInputs[port]), true);\n  }\n  // do not disable analog reporting on these 8 pins, to allow some\n  // pins used for digital, others analog.  Instead, allow both types\n  // of reporting to be enabled, but check if the pin is configured\n  // as analog when sampling the analog inputs.  Likewise, while\n  // scanning digital pins, portConfigInputs will mask off values from any\n  // pins configured as analog"
        },
        {
          "name": "circuitPlaygroundCommand",
          "parameters": "byte command, byte argc, byte* argv",
          "body": "switch (command) {\n    case CP_PIXEL_SET:\n      // Set a NeoPixel to the specified RGB color.\n      // Expect: 1 byte pixel number, 4 bytes pixel RGB value (as 7-bit bytes)\n      if (argc >= 5) {\n        // Parse out the pixel number and R, G, B bytes.\n        uint8_t pixel = argv[0] & 0x7F;\n        uint8_t r = (argv[1] << 1) | ((argv[2] & 0x7F) >> 6);  // Red = 7 bits from byte 4 and 1 bit from byte 5\n        uint8_t g = ((argv[2] & 0x3F) << 2) | (((argv[3]) & 0x7F) >> 5);  // Green = 6 bits from byte 5 and 2 bits from byte 6\n        uint8_t b = ((argv[3] & 0x1F) << 3) | (((argv[4]) & 0x7F) >> 4);  // Blue = 5 bits from byte 6 and 3 bits from byte 7\n        CircuitPlayground.strip.setPixelColor(pixel, r, g, b);\n      }\n      break;\n    case CP_PIXEL_SHOW:\n      // Light up the neopixels with their current buffer values.\n      CircuitPlayground.strip.show();\n      break;\n    case CP_PIXEL_CLEAR:\n      // Clear all the pixel color values.\n      CircuitPlayground.strip.clear();\n      break;\n    case CP_PIXEL_BRIGHTNESS:\n      // Set pixel brightness.\n      // Expects 1 byte with the brightness as a value 0-100.\n      if (argc >= 1) {\n        uint8_t brightness = argv[0];\n        if (brightness > 100) {\n          return;\n        }\n        CircuitPlayground.strip.setBrightness(brightness);\n      }\n    case CP_TONE:\n      // Play a tone on the speaker.\n      // Expect: 2 bytes tone frequency, 2 bytes tone duration\n      if (argc >= 4) {\n        uint16_t frequency = ((argv[1] & 0x7F) << 7) | (argv[0] & 0x7F);\n        uint16_t duration = ((argv[3] & 0x7F) << 7) | (argv[2] & 0x7F);\n        // If duration is zero then interpret that as continuous tone playback.\n        // Force output mode of speaker and speaker enable pin as it might have\n        // been clobbered by user code since A0 / D12 is also the speaker output.\n        pinMode(CPLAY_SPEAKER, OUTPUT);\n        pinMode(CPLAY_SPEAKER_SHUTDOWN, OUTPUT);\n        digitalWrite(CPLAY_SPEAKER_SHUTDOWN, HIGH);\n        if (duration == 0) {\n          tone(CPLAY_SPEAKER, frequency);\n        }\n        else {\n          tone(CPLAY_SPEAKER, frequency, duration);\n        }\n      }\n      break;\n    case CP_NO_TONE:\n      // Stop tone playback.\n      // Force output mode of speaker and speaker enable pin as it might have\n      // been clobbered by user code since A0 / D12 is also the speaker output.\n      pinMode(CPLAY_SPEAKER, OUTPUT);\n      pinMode(CPLAY_SPEAKER_SHUTDOWN, OUTPUT);\n      digitalWrite(CPLAY_SPEAKER_SHUTDOWN, LOW);\n      tone(CPLAY_SPEAKER, 100, 1);  // Very short tone to stop playback as noTone locks the board.\n      //noTone(CPLAY_SPEAKER);  TODO: Notone broken! Locks up\n      break;\n    case CP_ACCEL_READ:\n      sendAccelResponse();\n      break;\n    case CP_ACCEL_TAP:\n      sendTapResponse();\n      break;\n    case CP_ACCEL_TAP_STREAM_ON:\n      streamTap = true;\n      break;\n    case CP_ACCEL_TAP_STREAM_OFF:\n      streamTap = false;\n      break;\n    case CP_ACCEL_STREAM_ON:\n      streamAccel = true;\n      break;\n    case CP_ACCEL_STREAM_OFF:\n      streamAccel = false;\n      break;\n    case CP_CAP_READ:\n      // Flip the streaming bool on for the specified input.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t input = argv[0] & 0x7F;\n        // Now find the specified cap input and send a response with its current cap touch value.\n        for (int i=0; i<CAP_COUNT; ++i) {\n          if (cap_state[i].pin == input) {\n            sendCapResponse(input);\n          }\n        }\n      }\n      break;\n    case CP_CAP_ON:\n      // Flip the streaming bool on for the specified input.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t input = argv[0] & 0x7F;\n        // Now find the specified cap input and flip on its streaming bit.\n        for (int i=0; i<CAP_COUNT; ++i) {\n          if (cap_state[i].pin == input) {\n            cap_state[i].streaming = true;\n          }\n        }\n      }\n      break;\n    case CP_CAP_OFF:\n      // Flip the streaming bool off for the specified input.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t input = argv[0] & 0x7F;\n        // Now find the specified cap input and flip on its streaming bit.\n        for (int i=0; i<CAP_COUNT; ++i) {\n          if (cap_state[i].pin == input) {\n            cap_state[i].streaming = false;\n          }\n        }\n      }\n      break;\n    case CP_ACCEL_RANGE:\n      // Set the range of the accelerometer based on the passed in value.\n      // First check we have enough parameters and grab the input from the first byte.\n      if (argc >= 1) {\n        uint8_t range = argv[0] & 0x7F;\n        // Check the range is an allowed value (0, 1, 2, 3).\n        if (range > 3) {\n          // Unknown range value, stop processing!\n          return;\n        }\n        // Set the range of the accelerometer.\n        CircuitPlayground.lis.setRange((lis3dh_range_t)range);\n      }\n      break;\n    case CP_ACCEL_TAP_CONFIG:\n      // Set the sensitivity of tap detection.\n      // Expects 4 7-bit firmata bytes as input, which expand to 2 bytes of 8-bit unsigned data.\n      // First check we have enough parameters.\n      if (argc >= 4) {\n        // Parse out paramemters.\n        uint8_t type = ((argv[1] & 0x01) << 7) | (argv[0] & 0x7F);\n        uint8_t threshold = ((argv[3] & 0x01) << 7) | (argv[2] & 0x7F);\n        // Set the click threshold values.\n        CircuitPlayground.lis.setClick(type, threshold);\n      }\n    case CP_SENSECOLOR:\n      // Sense the color of an object over the light sensor and send back\n      // a CP_SENSECOLOR_REPLY response.\n      sendColorSenseResponse();\n  }"
        },
        {
          "name": "sendColorSenseResponse",
          "parameters": "",
          "body": "// Perform a color sense with NeoPixel #1 and the light sensor.\n  uint8_t red, green, blue;\n  CircuitPlayground.senseColor(red, green, blue);\n  // Construct a response data packet and send it.\n  uint8_t data[4] = {0};\n  data[0] = CP_SENSECOLOR_REPLY;\n  data[1] = red;\n  data[2] = green;\n  data[3] = blue;\n  // Send the response.\n  Firmata.sendSysex(CP_COMMAND, 4, data);"
        },
        {
          "name": "sendAccelResponse",
          "parameters": "",
          "body": "// Get an accelerometer X, Y, Z reading.\n  sensors_event_t event;\n  CircuitPlayground.lis.getEvent(&event);\n  // Construct a response data packet.\n  uint8_t data[13] = {0};\n  data[0] = CP_ACCEL_READ_REPLY;\n  // Put the three 32-bit float X,Y,Z reading into the packet.\n  // Note that Firmata.sendSysex will automatically convert bytes into\n  // two 7-bit bytes that are Firmata/MIDI compatible.\n  // Use a union to easily grab the bytes of the float.\n  union {\n    float value;\n    uint8_t bytes[4];\n  } reading;\n  // Grab each X, Y, Z float byte value and copy it into the response.\n  reading.value = event.acceleration.x;\n  memcpy(data+1, reading.bytes, 4);\n  reading.value = event.acceleration.y;\n  memcpy(data+5, reading.bytes, 4);\n  reading.value = event.acceleration.z;\n  memcpy(data+9, reading.bytes, 4);\n  // Send the response.\n  Firmata.sendSysex(CP_COMMAND, 13, data);"
        },
        {
          "name": "sendTapResponse",
          "parameters": "",
          "body": "// Get the accelerometer tap detection state.\n  uint8_t click = CircuitPlayground.lis.getClick();\n  // Construct a response data packet and send it.\n  uint8_t data[2] = {0};\n  data[0] = CP_ACCEL_TAP_REPLY;\n  data[1] = click;\n  // Send the response.\n  Firmata.sendSysex(CP_COMMAND, 2, data);"
        },
        {
          "name": "sendCapResponse",
          "parameters": "uint8_t pin",
          "body": "// Get the cap sense value for the provided input pin.\n  int32_t value = CircuitPlayground.readCap(pin, CAP_SAMPLES);\n  // Build a response data packet and send it.  The response includes:\n  // - uint8_t: CP_CAP_REPLY value\n  // - uint8_t: pin number of the read input\n  // - int32_t: cap sensor value, large values mean the input was touched\n  union {\n    struct {\n      uint8_t type;\n      uint8_t pin;\n      int32_t value;\n    } data;\n    uint8_t bytes[6];\n  } response;\n  response.data.type = CP_CAP_REPLY;\n  response.data.pin = pin;\n  response.data.value = value;\n  // Send the response, this will expand each byte into 2 bytes of 7-bit data.\n  Firmata.sendSysex(CP_COMMAND, 6, response.bytes);"
        },
        {
          "name": "sysexCallback",
          "parameters": "byte command, byte argc, byte *argv",
          "body": "byte mode;\n  byte slaveAddress;\n  byte data;\n  int slaveRegister;\n  unsigned int delayTime;\n\n  switch (command) {\n    // Circuit playground command processing:\n    case CP_COMMAND:\n      if (argc < 1) return;\n      circuitPlaygroundCommand(argv[0], argc-1, argv+1);\n      break;\n    case I2C_REQUEST:\n      mode = argv[1] & I2C_READ_WRITE_MODE_MASK;\n      if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) {\n        Firmata.sendString(\"10-bit addressing not supported\");\n        return;\n      }\n      else {\n        slaveAddress = argv[0];\n      }\n\n      switch (mode) {\n        case I2C_WRITE:\n          Wire.beginTransmission(slaveAddress);\n          for (byte i = 2; i < argc; i += 2) {\n            data = argv[i] + (argv[i + 1] << 7);\n            wireWrite(data);\n          }\n          Wire.endTransmission();\n          delayMicroseconds(70);\n          break;\n        case I2C_READ:\n          if (argc == 6) {\n            // a slave register is specified\n            slaveRegister = argv[2] + (argv[3] << 7);\n            data = argv[4] + (argv[5] << 7);  // bytes to read\n          }\n          else {\n            // a slave register is NOT specified\n            slaveRegister = I2C_REGISTER_NOT_SPECIFIED;\n            data = argv[2] + (argv[3] << 7);  // bytes to read\n          }\n          readAndReportData(slaveAddress, (int)slaveRegister, data);\n          break;\n        case I2C_READ_CONTINUOUSLY:\n          if ((queryIndex + 1) >= I2C_MAX_QUERIES) {\n            // too many queries, just ignore\n            Firmata.sendString(\"too many queries\");\n            break;\n          }\n          if (argc == 6) {\n            // a slave register is specified\n            slaveRegister = argv[2] + (argv[3] << 7);\n            data = argv[4] + (argv[5] << 7);  // bytes to read\n          }\n          else {\n            // a slave register is NOT specified\n            slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED;\n            data = argv[2] + (argv[3] << 7);  // bytes to read\n          }\n          queryIndex++;\n          query[queryIndex].addr = slaveAddress;\n          query[queryIndex].reg = slaveRegister;\n          query[queryIndex].bytes = data;\n          break;\n        case I2C_STOP_READING:\n          byte queryIndexToSkip;\n          // if read continuous mode is enabled for only 1 i2c device, disable\n          // read continuous reporting for that device\n          if (queryIndex <= 0) {\n            queryIndex = -1;\n          } else {\n            // if read continuous mode is enabled for multiple devices,\n            // determine which device to stop reading and remove it's data from\n            // the array, shifiting other array data to fill the space\n            for (byte i = 0; i < queryIndex + 1; i++) {\n              if (query[i].addr == slaveAddress) {\n                queryIndexToSkip = i;\n                break;\n              }\n            }\n\n            for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) {\n              if (i < I2C_MAX_QUERIES) {\n                query[i].addr = query[i + 1].addr;\n                query[i].reg = query[i + 1].reg;\n                query[i].bytes = query[i + 1].bytes;\n              }\n            }\n            queryIndex--;\n          }\n          break;\n        default:\n          break;\n      }\n      break;\n    case I2C_CONFIG:\n      delayTime = (argv[0] + (argv[1] << 7));\n\n      if (delayTime > 0) {\n        i2cReadDelayTime = delayTime;\n      }\n\n      if (!isI2CEnabled) {\n        enableI2CPins();\n      }\n\n      break;\n    case SERVO_CONFIG:\n      if (argc > 4) {\n        // these vars are here for clarity, they'll optimized away by the compiler\n        byte pin = argv[0];\n        int minPulse = argv[1] + (argv[2] << 7);\n        int maxPulse = argv[3] + (argv[4] << 7);\n\n        if (classic_IS_PIN_DIGITAL(pin)) {\n          if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) {\n            detachServo(pin);\n          }\n          attachServo(pin, minPulse, maxPulse);\n          setPinModeCallback(pin, PIN_MODE_SERVO);\n        }\n      }\n      break;\n    case SAMPLING_INTERVAL:\n      if (argc > 1) {\n        samplingInterval = argv[0] + (argv[1] << 7);\n        if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) {\n          samplingInterval = MINIMUM_SAMPLING_INTERVAL;\n        }\n      } else {\n        //Firmata.sendString(\"Not enough data\");\n      }\n      break;\n    case EXTENDED_ANALOG:\n      if (argc > 1) {\n        int val = argv[1];\n        if (argc > 2) val |= (argv[2] << 7);\n        if (argc > 3) val |= (argv[3] << 14);\n        analogWriteCallback(argv[0], val);\n      }\n      break;\n    case CAPABILITY_QUERY:\n      {\n        Firmata.write(START_SYSEX);\n        Firmata.write(CAPABILITY_RESPONSE);\n        // Again fake out the data here to exactly match circuit playground classic.  See the analog query\n        // below for more discussion of the need to do this.  This data was read by querying a classic board\n        // with the CAPABILITY_QUERY sysex command and recording the exact response to play back below.\n        const uint8_t shimmedCapabilitiesResponse[] {\n          0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e,\n          0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x06, 0x01, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01,\n          0x01, 0x03, 0x08, 0x04, 0x0e, 0x06, 0x01, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f,\n          0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x03, 0x08, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01,\n          0x03, 0x08, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b,\n          0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x03, 0x08, 0x04, 0x0e, 0x7f,\n          0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x03, 0x08, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01,\n          0x03, 0x08, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b,\n          0x01, 0x01, 0x01, 0x03, 0x08, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f,\n          0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e,\n          0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02,\n          0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01,\n          0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a,\n          0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b,\n          0x01, 0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a, 0x04,\n          0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01,\n          0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e,\n          0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01, 0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f, 0x00, 0x01, 0x0b, 0x01, 0x01,\n          0x01, 0x02, 0x0a, 0x04, 0x0e, 0x7f\n        };\n        for (int i=0; i<sizeof(shimmedCapabilitiesResponse); ++i) {\n          Firmata.write(shimmedCapabilitiesResponse[i]);\n        }\n        // Original code:\n        //for (byte pin = 0; pin < classic_TOTAL_PINS; pin++) {\n        //if (classic_IS_PIN_DIGITAL(pin)) {\n        //  Firmata.write((byte)INPUT);\n        //  Firmata.write(1);\n        //  Firmata.write((byte)PIN_MODE_PULLUP);\n        //  Firmata.write(1);\n        //  Firmata.write((byte)OUTPUT);\n        //  Firmata.write(1);\n        //}\n        //if (classic_IS_PIN_ANALOG(pin)) {\n        //  Firmata.write(PIN_MODE_ANALOG);\n        //  Firmata.write(10); // 10 = 10-bit resolution\n        //}\n        //if (classic_IS_PIN_PWM(pin)) {\n        //  Firmata.write(PIN_MODE_PWM);\n        //  Firmata.write(8); // 8 = 8-bit resolution\n        //}\n        //if (classic_IS_PIN_DIGITAL(pin)) {\n        //  Firmata.write(PIN_MODE_SERVO);\n        //  Firmata.write(14);\n        //}\n        //if (classic_IS_PIN_I2C(pin)) {\n        //  Firmata.write(PIN_MODE_I2C);\n        //  Firmata.write(1);  // TODO: could assign a number to map to SCL or SDA\n        //}\n        //Firmata.write(127);\n        //}\n        Firmata.write(END_SYSEX);\n        break;\n      }\n    case PIN_STATE_QUERY:\n      if (argc > 0) {\n        byte pin = argv[0];\n        Firmata.write(START_SYSEX);\n        Firmata.write(PIN_STATE_RESPONSE);\n        Firmata.write(pin);\n        if (pin < classic_TOTAL_PINS) {\n          Firmata.write((byte)pinConfig[pin]);\n          Firmata.write((byte)pinState[pin] & 0x7F);\n          if (pinState[pin] & 0xFF80) Firmata.write((byte)(pinState[pin] >> 7) & 0x7F);\n          if (pinState[pin] & 0xC000) Firmata.write((byte)(pinState[pin] >> 14) & 0x7F);\n        }\n        Firmata.write(END_SYSEX);\n      }\n      break;\n    case ANALOG_MAPPING_QUERY:\n      Firmata.write(START_SYSEX);\n      Firmata.write(ANALOG_MAPPING_RESPONSE);\n      // Fake out the analog mapping query response to mimic exactly circuit playground classic.\n      // This is _really_ ugly but necessary for now as code.org editor validates the contents\n      // and how firmata generates this is very tightly coupled to the board config (attempting to\n      // shim it is very, very difficult and bug prone--avoid at all costs!).\n      // First send 18 responses with value 127 to indicate no analog channels on first 18 pins.\n      for (int i=0; i<18; ++i) {\n        Firmata.write(127); // 127 means no analog channel for this pin.\n      }\n      // Then send 12 responses that increase by one for each ADC channel A0 to A11.\n      for (int i=0; i<12; ++i) {\n        Firmata.write(i);\n      }\n      // Old code that enumerated each pin and its state:\n      // Note the failed attempt to shim.\n      //for (byte pin = 0; pin < classic_TOTAL_PINS; pin++) {\n      //  Firmata.write(classic_IS_PIN_ANALOG(pin) ? classic_PIN_TO_ANALOG(pin) : 127);\n      //}\n      Firmata.write(END_SYSEX);\n      break;\n  }"
        },
        {
          "name": "enableI2CPins",
          "parameters": "",
          "body": "byte i;\n  // is there a faster way to do this? would probaby require importing\n  // Arduino.h to get SCL and SDA pins\n  for (i = 0; i < classic_TOTAL_PINS; i++) {\n    if (classic_IS_PIN_I2C(i)) {\n      // mark pins as i2c so they are ignore in non i2c data requests\n      setPinModeCallback(i, PIN_MODE_I2C);\n    }\n  }\n\n  isI2CEnabled = true;\n\n  Wire.begin();"
        },
        {
          "name": "disableI2CPins",
          "parameters": "",
          "body": "isI2CEnabled = false;\n  // disable read continuous mode for all devices\n  queryIndex = -1;"
        },
        {
          "name": "systemResetCallback",
          "parameters": "",
          "body": "isResetting = true;\n\n  // initialize a defalt state\n  // TODO: option to load config from EEPROM instead of default\n\n  // Reset circuit playground components to a default state with nothing running.\n  // (i.e. no pixels lit, no sound, no data streaming back)\n  circuitPlaygroundReset();\n\n  if (isI2CEnabled) {\n    disableI2CPins();\n  }\n\n  for (byte i = 0; i < classic_TOTAL_PORTS; i++) {\n    reportPINs[i] = false;    // by default, reporting off\n    portConfigInputs[i] = 0;  // until activated\n    previousPINs[i] = 0;\n  }\n\n  for (byte i = 0; i < classic_TOTAL_PINS; i++) {\n    // pins with analog capability default to analog input\n    // otherwise, pins default to digital output\n    if (classic_IS_PIN_ANALOG(i)) {\n      // turns off pullup, configures everything\n      setPinModeCallback(i, PIN_MODE_ANALOG);\n    } else if (classic_IS_PIN_DIGITAL(i)) {\n      // sets the output to 0, configures portConfigInputs\n      setPinModeCallback(i, OUTPUT);\n    }\n\n    servoPinMap[i] = 255;\n  }\n  // by default, do not report any analog inputs\n  analogInputsToReport = 0;\n\n  detachedServoCount = 0;\n  servoCount = 0;\n\n  /* send digital inputs to set the initial state on the host computer,\n   * since once in the loop(), this firmware will only send on change */\n  /*\n  TODO: this can never execute, since no pins default to digital input\n        but it will be needed when/if we support EEPROM stored config\n  for (byte i=0; i < classic_TOTAL_PORTS; i++) {\n    outputPort(i, readPort(i, portConfigInputs[i]), true);\n  }\n  */\n  isResetting = false;"
        },
        {
          "name": "circuitPlaygroundReset",
          "parameters": "",
          "body": "// Reset the circuit playground components into a default state\n  // with none of the pixels lit, no tones playing, and no cap touch\n  // or accelerometer data streaming back.\n\n  // Make speaker shutdown an output and turn off the speaker.\n  pinMode(CPLAY_SPEAKER_SHUTDOWN, OUTPUT);\n  digitalWrite(CPLAY_SPEAKER_SHUTDOWN, LOW);\n  //noTone(CPLAY_SPEAKER); //TODO: NOTONE BROKEN! LOCKS\n\n  // Turn off all the NeoPixels.\n  CircuitPlayground.strip.clear();\n  CircuitPlayground.strip.show();\n\n  // Reset the accelerometer to a default range.\n  CircuitPlayground.lis.setRange(LIS3DH_RANGE_2_G);\n  delay(100);\n  CircuitPlayground.lis.setClick(2, 80);\n  delay(100);\n\n  // Turn off streaming of tap, accel, and cap touch data.\n  streamTap = false;\n  streamAccel = false;\n  for (int i=0; i<CAP_COUNT; ++i) {\n    cap_state[i].streaming = false;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Circuit playground setup:\n  if (!CircuitPlayground.begin()) {\n    // Failed to initialize circuit playground, fast blink the red LED on the board.\n    pinMode(13, OUTPUT);\n    while (1) {\n      digitalWrite(13, LOW);\n      delay(100);\n      digitalWrite(13, HIGH);\n      delay(100);\n    }\n  }\n\n  // Circuit playground debug setup.\n  // Do this AFTER the CircuitPlayground library initialization or else the cap touch\n  // configuration inside it will clobber the debug serial port pins and break debug output.\n  #ifdef DEBUG_MODE\n    DEBUG_OUTPUT.begin(DEBUG_BAUD);\n    DEBUG_PRINTLN(\"Circuit Playground Firmata starting up!\");\n  #endif\n\n  Firmata.setFirmwareVersion(FIRMATA_MAJOR_VERSION, FIRMATA_MINOR_VERSION);\n\n  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);\n  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);\n  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);\n  Firmata.attach(SET_PIN_MODE, setPinModeCallback);\n  Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback);\n  Firmata.attach(START_SYSEX, sysexCallback);\n  Firmata.attach(SYSTEM_RESET, systemResetCallback);\n\n  // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega,\n  // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this:\n  // Serial1.begin(57600);\n  // Firmata.begin(Serial1);\n  // then comment out or remove lines 701 - 704 below\n  Firmata.begin(57600);\n\n#if defined(DEMO_MODE)\n  while (!Serial) {\n     runDemo();   // this will 'demo' the board off, so you know its working, until the serial port is opened\n  }\n#endif\n\n  systemResetCallback();  // reset to default config"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "byte pin, analogPin;\n\n  /* DIGITALREAD - as fast as possible, check for changes and output them to the\n   * FTDI buffer using Serial.print()  */\n  checkDigitalInputs();\n\n  /* STREAMREAD - processing incoming messagse as soon as possible, while still\n   * checking digital inputs.  */\n  while (Firmata.available()) {\n    Firmata.processInput();\n  }\n\n  // TODO - ensure that Stream buffer doesn't go over 60 bytes\n\n  currentMillis = millis();\n  if (currentMillis - previousMillis > samplingInterval) {\n    previousMillis += samplingInterval;\n    /* ANALOGREAD - do all analogReads() at the configured sampling interval */\n    for (pin = 0; pin < classic_TOTAL_PINS; pin++) {\n      if (classic_IS_PIN_ANALOG(pin) && pinConfig[pin] == PIN_MODE_ANALOG) {\n        analogPin = classic_PIN_TO_ANALOG(pin);\n        if (analogInputsToReport & (1 << analogPin)) {\n          Firmata.sendAnalog(analogPin, shimAnalogRead(analogPin));\n        }\n      }\n    }\n    // report i2c data for all device with read continuous mode enabled\n    if (queryIndex > -1) {\n      for (byte i = 0; i < queryIndex + 1; i++) {\n        readAndReportData(query[i].addr, query[i].reg, query[i].bytes);\n      }\n    }\n    // Check if a tap event should be streamed to the firmata client.\n    if (streamTap) {\n      sendTapResponse();\n    }\n    // Check if an accelerometer event should be streamed to the firmata client.\n    if (streamAccel) {\n      sendAccelResponse();\n    }\n    // Check if any cap touch inputs should be streamed to the firmata client.\n    for (int i=0; i<CAP_COUNT; ++i) {\n      if (cap_state[i].streaming) {\n        sendCapResponse(cap_state[i].pin);\n      }\n    }\n  }"
        },
        {
          "name": "runDemo",
          "parameters": "void",
          "body": "// test Red #13 LED\n  CircuitPlayground.redLED(pixeln % 1);\n\n  /************* TEST SLIDE SWITCH */\n  if (CircuitPlayground.slideSwitch()) {\n    pixeln++;\n    if (pixeln == 11) {\n      pixeln = 0;\n      CircuitPlayground.clearPixels();\n    }\n  } else {\n    if (pixeln == 0) {\n      pixeln = 10;\n      CircuitPlayground.clearPixels();\n    }\n    pixeln--;\n  }\n\n\n  /************* TEST 10 NEOPIXELS */\n  CircuitPlayground.setPixelColor(pixeln, CircuitPlayground.colorWheel(25 * pixeln));\n\n\n  /************* TEST BOTH BUTTONS */\n  if (CircuitPlayground.leftButton()) {\n    CircuitPlayground.playTone(500 + pixeln * 500, 100, false);\n  }\n  if (CircuitPlayground.rightButton()) {\n    CircuitPlayground.setBrightness(60);\n  } else {\n    CircuitPlayground.setBrightness(20);\n  }\n\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite",
        "digitalread",
        "delay",
        "led",
        "sd",
        "debounce"
      ],
      "libraries": [
        "ArduinoSound.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// setup the serial\n  Serial.begin(9600);\n\n  // configure the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n\n  // setup the I2S audio input for 44.1 kHz with 32-bits per sample\n  if (!AudioInI2S.begin(44100, 32)) {\n    Serial.println(\"Failed to initialize I2S input!\");\n    while (1); // do nothing\n  }\n\n  // configure the I2S input as the input for the amplitude analyzer\n  if (!amplitudeAnalyzer.input(AudioInI2S)) {\n    Serial.println(\"Failed to set amplitude analyzer input!\");\n    while (1); // do nothing\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check if a new analysis is available\n  if (amplitudeAnalyzer.available()) {\n    // read the new amplitude\n    int amplitude = amplitudeAnalyzer.read();\n\n    // find the difference between the new amplitude and the last\n    int delta = amplitude - lastAmplitude;\n  \n    // check if the difference is larger than the threshold\n    if (delta > amplitudeDeltaThreshold) {\n      // a clap was detected\n      Serial.println(\"clap detected\");\n  \n      // toggle the LED\n      digitalWrite(ledPin, !digitalRead(ledPin));\n  \n      // delay a bit to debounce\n      delay(100);\n    }\n  \n    // update the last amplitude with the new amplitude\n    lastAmplitude = amplitude;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "eeprom"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // write empty strings for the different fields\n  Robot.userNameWrite(\"\");\n  Robot.robotNameWrite(\"\");\n  Robot.cityNameWrite(\"\");\n  Robot.countryNameWrite(\"\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "rest",
        "https",
        "key",
        "certificate",
        "token",
        "auth",
        "callback",
        "json",
        "wifi",
        "millis",
        "delay",
        "sd",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "ESP_Google_Sheet_Client.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32) || defined(ESP8266)\n    WiFi.setAutoReconnect(true);\n#endif\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    // In case SD/SD_MMC storage file access, mount the SD/SD_MMC card.\n    // SD_Card_Mounting(); // See src/GS_SDHelper.h\n\n    // GSheet.setCert(rootCACert); // or GSheet.setCertFile(\"path/to/certificate/file.pem\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);\n\n    // Set the callback for Google API access token generation status (for debug only)\n    GSheet.setTokenCallback(tokenStatusCallback);\n\n    // The WiFi credentials are required for Pico W\n    // due to it does not have reconnect feature.\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    GSheet.clearAP();\n    GSheet.addAP(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    // Set the seconds to refresh the auth token before expire (60 to 3540, default is 300 seconds)\n    GSheet.setPrerefreshSeconds(10 * 60);\n\n    // Begin the access token generation for Google API authentication\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n    // Or begin with the Service Account JSON file\n    // GSheet.begin(\"path/to/serviceaccount/json/file\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\n    bool ready = GSheet.ready();\n\n    if (ready && !taskComplete)\n    {\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\n\n        // If you assign the spreadsheet id from your own spreadsheet,\n        // you need to set share access to the Service Account's CLIENT_EMAIL\n\n        FirebaseJson response;\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\n\n        Serial.println(\"\\nWrite spreadsheet values in range...\");\n        Serial.println(\"--------------------------------------------------------------\");\n\n        FirebaseJson valueRange;\n\n        valueRange.add(\"range\", \"Sheet1!A1:H10\");\n        valueRange.add(\"majorDimension\", \"ROWS\");\n\n        String path;\n        for (size_t i = 0; i < 8; i++)\n        {\n            for (size_t j = 0; j < 10; j++)\n            {\n                path = \"values/[\";\n                path += String(j);\n                path += \"]/[\";\n                path += String(i);\n                path += \"]\";\n                valueRange.set(path, \"x\");\n            }\n        }\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/update\n\n        bool success = GSheet.values.update(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to update */, \"Sheet1!A1:H10\" /* range to update */, &valueRange /* data to update */);\n        response.toString(Serial, true);\n        Serial.println();\n\n        Serial.println(\"\\nClear spreadsheet values in range...\");\n        Serial.println(\"--------------------------------------------------------------\");\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/clear\n\n        success = GSheet.values.clear(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to clear */, \"Sheet1!A1:A3\" /* range to clear */);\n        response.toString(Serial, true);\n        Serial.println();\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchClear\n\n        Serial.println(\"\\nClear spreadsheet values in multiple ranges...\");\n        Serial.println(\"--------------------------------------------------------------\");\n        success = GSheet.values.batchClear(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to clear */, \"Sheet1!A5:A8,Sheet1!B1:C10\" /* ranges to clear with comma separated */);\n        response.toString(Serial, true);\n        Serial.println();\n\n        Serial.println(\"\\nClear spreadsheet values from multiple ranges by data filter...\");\n        Serial.println(\"--------------------------------------------------------------\");\n\n        FirebaseJsonArray dataFiltersArr;\n\n        FirebaseJson dataFilters1;\n        dataFilters1.add(\"a1Range\", \"Sheet1!D5:E10\");\n        dataFiltersArr.add(dataFilters1);\n\n        FirebaseJson dataFilters2;\n        dataFilters2.add(\"a1Range\", \"Sheet1!F1:H3\");\n        dataFiltersArr.add(dataFilters2);\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/batchClearByDataFilter\n\n        success = GSheet.values.batchClearByDataFilter(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to clear */, &dataFiltersArr /* array of data range to read  with filter */);\n        if (success)\n            response.toString(Serial, true);\n        else\n            Serial.println(GSheet.errorReason());\n        Serial.println();\n\n#if defined(ESP32) || defined(ESP8266)\n        Serial.println(ESP.getFreeHeap());\n#elif defined(PICO_RP2040)\n        Serial.println(rp2040.getFreeHeap());\n#endif\n\n        taskComplete = true;\n    }"
        },
        {
          "name": "tokenStatusCallback",
          "parameters": "TokenInfo info",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());\n    }\n    else\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "spi",
        "delay",
        "millis",
        "tft",
        "lcd",
        "display",
        "timer",
        "interrupt",
        "html",
        "nodes",
        "devices"
      ],
      "libraries": [
        "Arduino.h",
        "TFT_eSPI.h",
        "menu.h",
        "menuIO/TFT_eSPIOut.h",
        "streamFlow.h",
        "ClickEncoder.h",
        "menuIO/clickEncoderIn.h",
        "menuIO/keyIn.h",
        "menuIO/chainStream.h",
        "menuIO/serialIO.h",
        "menuIO/serialOut.h",
        "menuIO/serialIn.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(3000);\n\n  clickEncoder.setAccelerationEnabled(true);\n  clickEncoder.setDoubleClickEnabled(false); // Disable doubleclicks makes the response faster.  See: https://github.com/soligen2010/encoder/issues/6\n\n  // // ESP32 timer\n  timer = timerBegin(0, 80, true);\n  timerAttachInterrupt(timer, &onTimer, true);\n  timerAlarmWrite(timer, 1000, true);\n  timerAlarmEnable(timer);\n\n  // Use this initializer if you're using a 1.8\" TFT\n  // SPI.begin();\n  gfx.init(); // Initialize a ST7735S chip\n  gfx.setRotation(0); // Set the rotation (0-3) to vertical\n  Serial.println(\"Initialized ST7735S TFT\");\n  gfx.fillScreen(TFT_BLACK);\n  Serial.println(\"done\");\n\n\n  nav.showTitle = true; // Show titles in the menus and submenus\n  //  nav.timeOut = 60;  // Timeout after 60 seconds of inactivity\n  //  nav.idleOn(); // Start with the main screen and not the menu"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Slow down the menu redraw rate\n  constexpr int menuFPS = 1000 / 30;\n  static unsigned long lastMenuFrame = -menuFPS;\n  unsigned long now = millis();\n  //... other stuff on loop, will keep executing\n  switch (exitMenuOptions)\n  {\n  case 1:\n  {\n    delay(500); // Pause to allow the button to come up\n    runCuts();\n    break;\n  }\n  case 2:\n  {\n    delay(500); // Pause to allow the button to come up\n    feedInOut();\n    break;\n  }\n  default: // Do the normal program functions with ArduinoMenu\n    if (now - lastMenuFrame >= menuFPS)\n    {\n      lastMenuFrame = millis();\n      nav.poll(); // Poll the input devices\n    }\n  }"
        },
        {
          "name": "runCuts",
          "parameters": "",
          "body": "exitMenuOptions = 0;   // Return to the menu\n  delay(500);\n  mainMenu.dirty = true; // Force the main menu to redraw itself"
        },
        {
          "name": "feedInOut",
          "parameters": "",
          "body": "exitMenuOptions = 0;   // Return to the menu\n  delay(500);\n  mainMenu.dirty = true; // Force the main menu to redraw itself"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "wifi",
        "delay",
        "schedule"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESPAsyncTCP.h",
        "osapi.h",
        "os_type.h",
        "config.h"
      ],
      "functions": [
        {
          "name": "replyToServer",
          "parameters": "void* arg",
          "body": "AsyncClient* client = reinterpret_cast<AsyncClient*>(arg);\n\n\t// send reply\n\tif (client->space() > 32 && client->canSend()) {\n\t\tchar message[32];\n\t\tsprintf(message, \"this is from %s\", WiFi.localIP().toString().c_str());\n\t\tclient->add(message, strlen(message));\n\t\tclient->send();\n\t}"
        },
        {
          "name": "handleData",
          "parameters": "void* arg, AsyncClient* client, void *data, size_t len",
          "body": "Serial.printf(\"\\n data received from %s \\n\", client->remoteIP().toString().c_str());\n\tSerial.write((uint8_t*)data, len);\n\n\tos_timer_arm(&intervalTimer, 2000, true); // schedule for reply to server at next 2s"
        },
        {
          "name": "onConnect",
          "parameters": "void* arg, AsyncClient* client",
          "body": "Serial.printf(\"\\n client has been connected to %s on port %d \\n\", SERVER_HOST_NAME, TCP_PORT);\n\treplyToServer(client);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\tdelay(20);\n\n\t// connects to access point\n\tWiFi.mode(WIFI_STA);\n\tWiFi.begin(SSID, PASSWORD);\n\twhile (WiFi.status() != WL_CONNECTED) {\n\t\tSerial.print('.');\n\t\tdelay(500);\n\t}\n\n\tAsyncClient* client = new AsyncClient;\n\tclient->onData(&handleData, client);\n\tclient->onConnect(&onConnect, client);\n\tclient->connect(SERVER_HOST_NAME, TCP_PORT);\n\n\tos_timer_disarm(&intervalTimer);\n\tos_timer_setfn(&intervalTimer, &replyToServer, client);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "millis",
        "lcd",
        "display"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "lcd.init();\n\n  zoom = (float)(std::min(lcd.width(), lcd.height())) / width; // 表示が画面にフィットするよう倍率を調整\n\n  lcd.setPivot(lcd.width() >> 1, lcd.height() >> 1); // 時計描画時の中心を画面中心に合わせる\n\n  canvas.setColorDepth(lgfx::palette_4bit);  // 各部品を４ビットパレットモードで準備する\n  clockbase.setColorDepth(lgfx::palette_4bit);\n  needle1.setColorDepth(lgfx::palette_4bit);\n  shadow1.setColorDepth(lgfx::palette_4bit);\n  needle2.setColorDepth(lgfx::palette_4bit);\n  shadow2.setColorDepth(lgfx::palette_4bit);\n// パレットの初期色はグレースケールのグラデーションとなっており、\n// 0番が黒(0,0,0)、15番が白(255,255,255)\n// 1番～14番は黒から白へ段階的に明るさが変化している\n//\n// パレットを使う場合、描画関数は色の代わりに0～15のパレット番号を指定する\n\n  canvas.createSprite(width, width); // メモリ確保\n  clockbase.createSprite(width, width);\n  needle1.createSprite(9, 119);\n  shadow1.createSprite(9, 119);\n  needle2.createSprite(3, 119);\n  shadow2.createSprite(3, 119);\n\n  canvas.fillScreen(transpalette); // 透過色で背景を塗り潰す (create直後は0埋めされているので省略可能)\n  clockbase.fillScreen(transpalette);\n  needle1.fillScreen(transpalette);\n  shadow1.fillScreen(transpalette);\n\n  clockbase.setTextFont(4);           // フォント種類を変更(時計盤の文字用)\n  clockbase.setTextDatum(lgfx::middle_center);\n  clockbase.fillCircle(halfwidth, halfwidth, halfwidth    ,  6); // 時計盤の背景の円を塗る\n  clockbase.drawCircle(halfwidth, halfwidth, halfwidth - 1, 15);\n  for (int i = 1; i <= 60; ++i) {\n    float rad = i * 6 * - 0.0174532925;              // 時計盤外周の目盛り座標を求める\n    float cosy = - cos(rad) * (halfwidth * 10 / 11);\n    float sinx = - sin(rad) * (halfwidth * 10 / 11);\n    bool flg = 0 == (i % 5);      // ５目盛り毎フラグ\n    clockbase.fillCircle(halfwidth + sinx + 1, halfwidth + cosy + 1, flg * 3 + 1,  4); // 目盛りを描画\n    clockbase.fillCircle(halfwidth + sinx    , halfwidth + cosy    , flg * 3 + 1, 12);\n    if (flg) {                    // 文字描画\n      cosy = - cos(rad) * (halfwidth * 10 / 13);\n      sinx = - sin(rad) * (halfwidth * 10 / 13);\n      clockbase.setTextColor(1);\n      clockbase.drawNumber(i/5, halfwidth + sinx + 1, halfwidth + cosy + 4);\n      clockbase.setTextColor(15);\n      clockbase.drawNumber(i/5, halfwidth + sinx    , halfwidth + cosy + 3);\n    }\n  }\n  clockbase.setTextFont(7);\n\n  needle1.setPivot(4, 100);  // 針パーツの回転中心座標を設定する\n  shadow1.setPivot(4, 100);\n  needle2.setPivot(1, 100);\n  shadow2.setPivot(1, 100);\n\n  for (int i = 6; i >= 0; --i) {  // 針パーツの画像を作成する\n    needle1.fillTriangle(4, - 16 - (i<<1), 8, needle1.height() - (i<<1), 0, needle1.height() - (i<<1), 15 - i);\n    shadow1.fillTriangle(4, - 16 - (i<<1), 8, shadow1.height() - (i<<1), 0, shadow1.height() - (i<<1),  1 + i);\n  }\n  for (int i = 0; i < 7; ++i) {\n    needle1.fillTriangle(4, 16 + (i<<1), 8, needle1.height() + 32 + (i<<1), 0, needle1.height() + 32 + (i<<1), 15 - i);\n    shadow1.fillTriangle(4, 16 + (i<<1), 8, shadow1.height() + 32 + (i<<1), 0, shadow1.height() + 32 + (i<<1),  1 + i);\n  }\n  needle1.fillTriangle(4, 32, 8, needle1.height() + 64, 0, needle1.height() + 64, 0);\n  shadow1.fillTriangle(4, 32, 8, shadow1.height() + 64, 0, shadow1.height() + 64, 0);\n  needle1.fillRect(0, 117, 9, 2, 15);\n  shadow1.fillRect(0, 117, 9, 2,  1);\n  needle1.drawFastHLine(1, 117, 7, 12);\n  shadow1.drawFastHLine(1, 117, 7,  4);\n\n  needle1.fillCircle(4, 100, 4, 15);\n  shadow1.fillCircle(4, 100, 4,  1);\n  needle1.drawCircle(4, 100, 4, 14);\n\n  needle2.fillScreen(9);\n  shadow2.fillScreen(3);\n  needle2.drawFastVLine(1, 0, 119, 8);\n  shadow2.drawFastVLine(1, 0, 119, 1);\n  needle2.fillRect(0, 99, 3, 3, 8);\n\n  lcd.startWrite();\n\n//  shadow1.pushSprite(&lcd,  0, 0); // デバッグ用、パーツを直接LCDに描画する\n//  needle1.pushSprite(&lcd, 10, 0);\n//  shadow2.pushSprite(&lcd, 20, 0);\n//  needle2.pushSprite(&lcd, 25, 0);"
        },
        {
          "name": "update7Seg",
          "parameters": "int32_t hour, int32_t min",
          "body": "// 時計盤のデジタル表示部の描画\n  int x = clockbase.getPivotX() - 69;\n  int y = clockbase.getPivotY();\n  clockbase.setCursor(x, y);\n  clockbase.setTextColor(5);  // 消去色で 88:88 を描画する\n  clockbase.print(\"88:88\");\n  clockbase.setCursor(x, y);\n  clockbase.setTextColor(12); // 表示色で時:分を描画する\n  clockbase.printf(\"%02d:%02d\", hour, min);"
        },
        {
          "name": "drawDot",
          "parameters": "int pos, int palette",
          "body": "bool flg = 0 == (pos % 5);      // ５目盛り毎フラグ\n  float rad = pos * 6 * - 0.0174532925;              // 時計盤外周の目盛り座標を求める\n  float cosy = - cos(rad) * (halfwidth * 10 / 11);\n  float sinx = - sin(rad) * (halfwidth * 10 / 11);\n  canvas.fillCircle(halfwidth + sinx, halfwidth + cosy, flg * 3 + 1, palette);"
        },
        {
          "name": "drawClock",
          "parameters": "uint64_t time",
          "body": "// 時計の描画\n  static int32_t p_min = -1;\n  int32_t sec = time / 1000;\n  int32_t min = sec / 60;\n  if (p_min != min) { // 分の値が変化していれば時計盤のデジタル表示部分を更新\n    p_min = min;\n    update7Seg(min / 60, min % 60);\n  }\n  clockbase.pushSprite(0, 0);  // 描画用バッファに時計盤の画像を上書き\n\n  drawDot(sec % 60, 14);\n  drawDot(min % 60, 15);\n  drawDot(((min/60)*5)%60, 15);\n\n  float fhour = (float)time / 120000;  // 短針の角度\n  float fmin  = (float)time /  10000;  // 長針の角度\n  float fsec  = (float)time*6 / 1000;  // 秒針の角度\n  int px = canvas.getPivotX();\n  int py = canvas.getPivotY();\n  shadow1.pushRotateZoom(px+2, py+2, fhour, 1.0, 0.7, transpalette); // 針の影を右下方向にずらして描画する\n  shadow1.pushRotateZoom(px+3, py+3, fmin , 1.0, 1.0, transpalette);\n  shadow2.pushRotateZoom(px+4, py+4, fsec , 1.0, 1.0, transpalette);\n  needle1.pushRotateZoom(            fhour, 1.0, 0.7, transpalette); // 針を描画する\n  needle1.pushRotateZoom(            fmin , 1.0, 1.0, transpalette);\n  needle2.pushRotateZoom(            fsec , 1.0, 1.0, transpalette);\n\n  canvas.pushRotateZoom(0, zoom, zoom, transpalette);    // 完了した時計盤をLCDに描画する\n  lcd.display();"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "static uint32_t p_milli = 0;\n  uint32_t milli = lgfx::millis() % 1000;\n  if (p_milli > milli) count += 1000 + (milli - p_milli);\n  else                 count +=        (milli - p_milli);\n  p_milli = milli;\n\n  int32_t tmp = (count % 1000) >> 3;\n  canvas.setPaletteColor(8, 255 - (tmp>>1), 255 - (tmp>>1), 200 - tmp); // 秒針の描画色を変化させる\n//count += 60000;\n  if ( count > oneday ) { count -= oneday; }\n  drawClock(count);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "digitalwrite",
        "led",
        "devices",
        "deviceevent"
      ],
      "libraries": [
        "Approximate.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    pinMode(LED_PIN, OUTPUT);\n\n    if (approx.init(\"MyHomeWiFi\", \"password\")) {\n        approx.setProximateDeviceHandler(onProximateDevice, APPROXIMATE_PERSONAL_RSSI);\n        approx.begin();\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "approx.loop();"
        },
        {
          "name": "onProximateDevice",
          "parameters": "Device *device, Approximate::DeviceEvent event",
          "body": "switch(event) {\n        case Approximate::ARRIVE:\n            digitalWrite(LED_PIN, HIGH);\n            Serial.println(\"ARRIVE\\t\" + device->getMacAddressAsString());\n            break;\n        case Approximate::DEPART:\n            digitalWrite(LED_PIN, LOW);\n            Serial.println(\"DEPART\\t\" + device->getMacAddressAsString());\n            break;\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mqtt",
        "pubsubclient",
        "wificlient",
        "https",
        "password",
        "json",
        "payload",
        "publish",
        "wifi",
        "digitalwrite",
        "delay",
        "led",
        "devices",
        "deviceevent"
      ],
      "libraries": [
        "Approximate.h",
        "PubSubClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n\n  if (approx.init(\"MyHomeWiFi\", \"password\")) {\n    approx.setProximateDeviceHandler(onProximateDevice);\n    approx.begin([]() {\n      mqttClient.setServer(\"192.168.XXX.XXX\", 1883);\n    });\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "approx.loop();\n  mqttClient.loop();"
        },
        {
          "name": "onProximateDevice",
          "parameters": "Device *device, Approximate::DeviceEvent event",
          "body": "if(event == Approximate::ARRIVE || event == Approximate::DEPART) {\n    digitalWrite(LED_PIN, event == Approximate::ARRIVE);\n\n    String json = \"{\\\"\" + device->getMacAddressAsString() + \"\\\":\\\"\" + Approximate::toString(event) + \"\\\"}\";\n    Serial.println(json);\n    \n    approx.onceWifiStatus(WL_CONNECTED, [](String payload) {\n      mqttClient.connect(WiFi.macAddress().c_str());\n      mqttClient.publish(\"closeby\", payload.c_str(), false); //false = don't retain message\n      \n      #if defined(ESP8266)\n        delay(20);\n        approx.disconnectWiFi();\n      #endif\n    }, json);\n    approx.connectWiFi();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "wificlient",
        "https",
        "password",
        "json",
        "digitalwrite",
        "delay",
        "led",
        "devices",
        "deviceevent",
        "deviceid"
      ],
      "libraries": [
        "Approximate.h",
        "ESP8266HTTPClient.h",
        "HTTPClient.h",
        "AceButton.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  pinMode(LED_PIN, OUTPUT);\n  digitalWrite(LED_PIN, false);\n\n  ButtonConfig* buttonConfig = button.getButtonConfig();\n  buttonConfig->setEventHandler(onButtonEvent);\n\n  if (approx.init(\"MyHomeWiFi\", \"password\", true)) {\n    approx.setProximateDeviceHandler(onProximateDevice, APPROXIMATE_SOCIAL_RSSI, 10000);\n    approx.begin();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "approx.loop();\n  button.check();"
        },
        {
          "name": "onProximateDevice",
          "parameters": "Device *device, Approximate::DeviceEvent event",
          "body": "switch (device->getOUI()) {\n    //D8F15B Sonoff (Expressif Inc) - see: http://standards-oui.ieee.org/oui.txt\n    case 0xD8F15B:\n      onCloseBySonoff(device, event);\n      break;\n    default:\n      Serial.printf(\"Unknown OUI:\\t0x%06X\\n\", device->getOUI());\n      break;\n  }"
        },
        {
          "name": "onCloseBySonoff",
          "parameters": "Device *device, Approximate::DeviceEvent event",
          "body": "switch (event) {\n    case Approximate::ARRIVE:\n      closeBySonoff = device;\n      digitalWrite(LED_PIN, HIGH);\n      Serial.printf(\"SONOFF\\t%s\\t(%s)\\tARRIVE\\n\", device -> getMacAddressAsString().c_str(), device -> getIPAddressAsString().c_str());\n      break;\n    case Approximate::DEPART:\n      if(*device == *closeBySonoff) {\n        closeBySonoff = NULL;\n        digitalWrite(LED_PIN, LOW);\n        Serial.printf(\"SONOFF\\t%s\\tDEPART\\n\", device -> getMacAddressAsString().c_str());\n      }\n      break;\n  }"
        },
        {
          "name": "onButtonEvent",
          "parameters": "AceButton* button, uint8_t eventType, uint8_t buttonState",
          "body": "if(closeBySonoff) {  \n    switch (eventType) {\n      case AceButton::kEventPressed:\n        Serial.println(\"AceButton::kEventPressed\");\n        switchCloseBySonoff(true);\n        break;\n      case AceButton::kEventReleased:\n        Serial.println(\"AceButton::kEventReleased\");\n        switchCloseBySonoff(false);\n        break;\n    }\n  }"
        },
        {
          "name": "switchCloseBySonoff",
          "parameters": "bool switchState",
          "body": "if(closeBySonoff) {\n    approx.onceWifiStatus(WL_CONNECTED, [](bool switchState) {\n      if(closeBySonoff) {\n        WiFiClient client;\n        HTTPClient http;\n        String url = \"http://\" + closeBySonoff->getIPAddressAsString() + \":8081/zeroconf/switch\";\n        http.begin(client, url);\n        http.addHeader(\"Content-Type\", \"application/json\");\n      \n        String switchValue = switchState?\"on\":\"off\";\n        String httpRequestData = \"{\\\"deviceid\\\": \\\"\\\",\\\"data\\\": {\\\"switch\\\": \\\"\" + switchValue + \"\\\"}}\";\n        \n        int httpResponseCode = http.POST(httpRequestData);\n        Serial.printf(\"%s\\t%s\\t%i\\n\",url.c_str(), httpRequestData.c_str(), httpResponseCode);\n        http.end();\n      }\n      \n      #if defined(ESP8266)\n        delay(20);\n        approx.disconnectWiFi();\n      #endif\n    }, switchState);\n    approx.connectWiFi();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "password",
        "wifi",
        "delay"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/extra/esp32/wifi/sta.h",
        "eloquent_esp32cam/viz/image_collection.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___IMAGE COLLECTION SERVER___\");\n\n    // camera settings\n    // replace with your own model!\n    camera.pinout.wroom_s3();\n    camera.brownout.disable();\n    // Edge Impulse models work on square images\n    // face resolution is 240x240\n    camera.resolution.face();\n    camera.quality.high();\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    // connect to WiFi\n    while (!wifi.connect().isOk())\n      Serial.println(wifi.exception.toString());\n\n    // init face detection http server\n    while (!collectionServer.begin().isOk())\n        Serial.println(collectionServer.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"WiFi OK\");\n    Serial.println(\"Image Collection Server OK\");\n    Serial.println(collectionServer.address());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// server runs in a separate thread, no need to do anything here"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "distance",
        "millis",
        "delay",
        "lcd",
        "display"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "diffDraw",
          "parameters": "LGFX_Sprite* sp0, LGFX_Sprite* sp1",
          "body": "union\n  {\n    std::uint32_t* s32;\n    std::uint8_t* s;\n  };\n  union\n  {\n    std::uint32_t* p32;\n    std::uint8_t* p;\n  };\n  s32 = (std::uint32_t*)sp0->getBuffer();\n  p32 = (std::uint32_t*)sp1->getBuffer();\n\n  auto width  = sp0->width();\n  auto height = sp0->height();\n\n  auto w32 = (width+3) >> 2;\n  std::int32_t y = 0;\n  do\n  {\n    std::int32_t x32 = 0;\n    do\n    {\n      while (s32[x32] == p32[x32] && ++x32 < w32);\n      if (x32 == w32) break;\n\n      std::int32_t xs = x32 << 2;\n      while (s[xs] == p[xs]) ++xs;\n\n      while (++x32 < w32 && s32[x32] != p32[x32]);\n\n      std::int32_t xe = (x32 << 2) - 1;\n      if (xe >= width) xe = width - 1;\n      while (s[xe] == p[xe]) --xe;\n\n      lcd.pushImage(xs, y, xe - xs + 1, 1, &s[xs]);\n    } while (x32 < w32);\n    s32 += w32;\n    p32 += w32;\n  } while (++y < height);\n  lcd.display();"
        },
        {
          "name": "drawfunc",
          "parameters": "void",
          "body": "ball_info_t *balls;\n  ball_info_t *a;\n  LGFX_Sprite *sprite;\n\n  auto width  = _sprites[0].width();\n  auto height = _sprites[0].height();\n\n  std::size_t flip = _draw_count & 1;\n  balls = &_balls[flip][0];\n\n  sprite = &(_sprites[flip]);\n  sprite->clear();\n\n  for (int32_t i = 8; i < width; i += 16) {\n    sprite->drawFastVLine(i, 0, height, 0x1F);\n  }\n  for (int32_t i = 8; i < height; i += 16) {\n    sprite->drawFastHLine(0, i, width, 0x1F);\n  }\n  for (std::uint32_t i = 0; i < _ball_count; i++) {\n    a = &balls[i];\n    sprite->fillCircle( a->x >> SHIFTSIZE\n                      , a->y >> SHIFTSIZE\n                      , a->r >> SHIFTSIZE\n                      , a->color);\n  }\n\n  sprite->setCursor(1,1);\n  sprite->setTextColor(TFT_BLACK);\n  sprite->printf(\"obj:%d fps:%d\", _ball_count, _fps);\n  sprite->setCursor(0,0);\n  sprite->setTextColor(TFT_WHITE);\n  sprite->printf(\"obj:%d fps:%d\", _ball_count, _fps);\n  diffDraw(&_sprites[flip], &_sprites[!flip]);\n  ++_draw_count;"
        },
        {
          "name": "mainfunc",
          "parameters": "void",
          "body": "static constexpr float e = 0.999; // Coefficient of friction\n\n  sec = lgfx::millis() / 1000;\n  if (psec != sec) {\n    psec = sec;\n    fps = frame_count;\n    frame_count = 0;\n\n    if (++ball_count >= BALL_MAX) { ball_count = 1; }\n    auto a = &_balls[_loop_count & 1][ball_count - 1];\n    a->color = lgfx::color888(100+(rand()%155), 100+(rand()%155), 100+(rand()%155));\n    a->x = 0;\n    a->y = 0;\n    a->dx = (rand() & (3 << SHIFTSIZE)) + 1;\n    a->dy = (rand() & (3 << SHIFTSIZE)) + 1;\n    a->r = (4 + (ball_count & 0x07)) << SHIFTSIZE;\n    a->m =  4 + (ball_count & 0x07);\n#if defined (ESP32) || defined (CONFIG_IDF_TARGET_ESP32) || defined (ESP_PLATFORM)\n    vTaskDelay(1);\n#endif\n  }\n\n  frame_count++;\n  _loop_count++;\n\n  ball_info_t *a, *b, *balls;\n  int32_t rr, len, vx2vy2;\n  float vx, vy, distance, t;\n\n  size_t f = _loop_count & 1;\n  balls = a = &_balls[f][0];\n  b = &_balls[!f][0];\n  memcpy(a, b, sizeof(ball_info_t) * ball_count);\n\n  for (int i = 0; i != ball_count; i++) {\n    a = &balls[i];\n//  a->dy += 4; // gravity\n\n    a->x += a->dx;\n    if (a->x < a->r) {\n      a->x = a->r;\n      if (a->dx < 0) a->dx = - a->dx*e;\n    } else if (a->x >= _width - a->r) {\n      a->x = _width - a->r -1;\n      if (a->dx > 0) a->dx = - a->dx*e;\n    }\n    a->y += a->dy;\n    if (a->y < a->r) {\n      a->y = a->r;\n      if (a->dy < 0) a->dy = - a->dy*e;\n    } else if (a->y >= _height - a->r) {\n      a->y = _height - a->r -1;\n      if (a->dy > 0) a->dy = - a->dy*e;\n    }\n    for (int j = i + 1; j != ball_count; j++) {\n      b = &balls[j];\n\n      rr = a->r + b->r;\n      vx = a->x - b->x;\n      if (abs(vx) > rr) continue;\n      vy = a->y - b->y;\n      if (abs(vy) > rr) continue;\n\n      len = sqrt(vx * vx + vy * vy);\n      if (len >= rr) continue;\n      if (len == 0.0) continue;\n      distance = (rr - len) >> 1;\n      vx *= distance / len;\n      vy *= distance / len;\n\n      a->x += vx;\n      b->x -= vx;\n      vx = b->x - a->x;\n\n      a->y += vy;\n      b->y -= vy;\n      vy = b->y - a->y;\n\n      vx2vy2 = vx * vx + vy * vy;\n\n      t = -(vx * a->dx + vy * a->dy) / vx2vy2;\n      float arx = a->dx + vx * t;\n      float ary = a->dy + vy * t;\n\n      t = -(-vy * a->dx + vx * a->dy) / vx2vy2;\n      float amx = a->dx - vy * t;\n      float amy = a->dy + vx * t;\n\n      t = -(vx * b->dx + vy * b->dy) / vx2vy2;\n      float brx = b->dx + vx * t;\n      float bry = b->dy + vy * t;\n\n      t = -(-vy * b->dx + vx * b->dy) / vx2vy2;\n      float bmx = b->dx - vy * t;\n      float bmy = b->dy + vx * t;\n\n      float adx = (a->m * amx + b->m * bmx + bmx * e * b->m - amx * e * b->m) / (a->m + b->m);\n      float bdx = - e * (bmx - amx) + adx;\n      float ady = (a->m * amy + b->m * bmy + bmy * e * b->m - amy * e * b->m) / (a->m + b->m);\n      float bdy = - e * (bmy - amy) + ady;\n\n      a->dx = roundf(adx + arx);\n      a->dy = roundf(ady + ary);\n      b->dx = roundf(bdx + brx);\n      b->dy = roundf(bdy + bry);\n    }\n  }\n\n  _fps = fps;\n  _ball_count = ball_count;"
        },
        {
          "name": "taskDraw",
          "parameters": "void*",
          "body": "while ( _is_running )\n  {\n    while (_loop_count == _draw_count) { taskYIELD(); }\n    drawfunc();\n  }\n  vTaskDelete(NULL);"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "lcd.begin();\n  lcd.startWrite();\n  lcd.setColorDepth(8);\n  if (lcd.width() < lcd.height()) lcd.setRotation(lcd.getRotation() ^ 1);\n\n  auto lcd_width = lcd.width();\n  auto lcd_height = lcd.height();\n\n  for (std::uint32_t i = 0; i < 2; ++i)\n  {\n    _sprites[i].setTextSize(2);\n    _sprites[i].setColorDepth(8);\n  }\n\n  bool fail = false;\n  for (std::uint32_t i = 0; !fail && i < 2; ++i)\n  {\n    fail = !_sprites[i].createSprite(lcd_width, lcd_height);\n  }\n\n  if (fail)\n  {\n    fail = false;\n    for (std::uint32_t i = 0; !fail && i < 2; ++i)\n    {\n      _sprites[i].setPsram(true);\n      fail = !_sprites[i].createSprite(lcd_width, lcd_height);\n    }\n\n    if (fail)\n    {\n      fail = false;\n      if (lcd_width > 320) lcd_width = 320;\n      if (lcd_height > 240) lcd_height = 240;\n\n      for (std::uint32_t i = 0; !fail && i < 2; ++i)\n      {\n        _sprites[i].setPsram(true);\n        fail = !_sprites[i].createSprite(lcd_width, lcd_height);\n      }\n      if (fail)\n      {\n        lcd.print(\"createSprite fail...\");\n        lgfx::delay(3000);\n      }\n    }\n  }\n\n  _width = lcd_width << SHIFTSIZE;\n  _height = lcd_height << SHIFTSIZE;\n\n  for (std::uint32_t i = 0; i < ball_count; ++i)\n  {\n    auto a = &_balls[_loop_count & 1][i];\n    a->color = lgfx::color888(100+(rand()%155), 100+(rand()%155), 100+(rand()%155));\n    a->x = 0;\n    a->y = 0;\n    a->dx = (rand() & (3 << SHIFTSIZE)) + 1;\n    a->dy = (rand() & (3 << SHIFTSIZE)) + 1;\n    a->r = (4 + (i & 0x07)) << SHIFTSIZE;\n    a->m =  4 + (i & 0x07);\n  }\n\n  _is_running = true;\n  _draw_count = 0;\n  _loop_count = 0;\n\n#if defined (CONFIG_IDF_TARGET_ESP32)\n  xTaskCreate(taskDraw, \"taskDraw\", 2048, NULL, 0, NULL);\n#endif"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "mainfunc();\n#if defined (CONFIG_IDF_TARGET_ESP32)\n  while (_loop_count != _draw_count) { taskYIELD(); }\n#else\n  drawfunc();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "delay",
        "rgb"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor.\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check if a color reading is available\n  while (! APDS.colorAvailable()) {\n    delay(5);\n  }\n  int r, g, b;\n\n  // read the color\n  APDS.readColor(r, g, b);\n\n  // print the values\n  Serial.print(\"r = \");\n  Serial.println(r);\n  Serial.print(\"g = \");\n  Serial.println(g);\n  Serial.print(\"b = \");\n  Serial.println(b);\n  Serial.println();\n\n  // wait a bit before reading again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n  Wire.begin();\n  if (!digital_inputs.init()){\n    Serial.println(\"GPIO expander initialization fail!!\");\n }\n if (!digital_programmables.init()){\n    Serial.println(\"GPIO expander initialization fail!!\");\n }\n\n  Serial.println(\"GPIO expander initialization done\");\n  digital_programmables.setLatch();\n  Serial.println(\"GPIO expander initialization done\");\n//  digital_inputs.setLatch();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Write the status value to On to Pin 3\n  digital_programmables.set(IO_WRITE_CH_PIN_03, SWITCH_ON);\n  delay(1000);\n\n  // Read from PROGRAMMABLE DIGITAL I/O Pin 3\n  Serial.println(\"Read IO Pin 03: \" + String(digital_programmables.read(IO_READ_CH_PIN_03)));\n  delay(1000);\n\n  // Read from DIGITAL INPUT Expander Pin 3 \n  Serial.println(\"Read DIN Pin 03: \" + String(digital_inputs.read(DIN_READ_CH_PIN_03)));\n  delay(1000);\n\n  // Write the status value to Off to Pin 3\n  digital_programmables.set(IO_WRITE_CH_PIN_03, SWITCH_OFF);\n  delay(1000);\n\n  Serial.println();\n  // Write the status value to On to all the Output Pins\n  digital_programmables.writeAll(SWITCH_ON_ALL);\n\n  // Reads from all Input Pins\n  readAll();\n  delay(1000);\n\n  // Write the status value to Off all to all the Output Pins\n  digital_programmables.writeAll(SWITCH_OFF_ALL);\n\n  // Reads from all Input Pins\n  readAll();\n  Serial.println();\n  delay(1000);"
        },
        {
          "name": "readAll",
          "parameters": "",
          "body": "uint32_t inputs = digital_programmables.readAll();\n  Serial.println(\"CH00: \" + String((inputs & (1 << IO_READ_CH_PIN_00)) >> IO_READ_CH_PIN_00));\n  Serial.println(\"CH01: \" + String((inputs & (1 << IO_READ_CH_PIN_01)) >> IO_READ_CH_PIN_01));\n  Serial.println(\"CH02: \" + String((inputs & (1 << IO_READ_CH_PIN_02)) >> IO_READ_CH_PIN_02));\n  Serial.println(\"CH03: \" + String((inputs & (1 << IO_READ_CH_PIN_03)) >> IO_READ_CH_PIN_03));\n  Serial.println(\"CH04: \" + String((inputs & (1 << IO_READ_CH_PIN_04)) >> IO_READ_CH_PIN_04));\n  Serial.println(\"CH05: \" + String((inputs & (1 << IO_READ_CH_PIN_05)) >> IO_READ_CH_PIN_05));\n  Serial.println(\"CH06: \" + String((inputs & (1 << IO_READ_CH_PIN_06)) >> IO_READ_CH_PIN_06));\n  Serial.println(\"CH07: \" + String((inputs & (1 << IO_READ_CH_PIN_07)) >> IO_READ_CH_PIN_07));\n  Serial.println(\"CH08: \" + String((inputs & (1 << IO_READ_CH_PIN_08)) >> IO_READ_CH_PIN_08));\n  Serial.println(\"CH09: \" + String((inputs & (1 << IO_READ_CH_PIN_09)) >> IO_READ_CH_PIN_09));\n  Serial.println(\"CH10: \" + String((inputs & (1 << IO_READ_CH_PIN_10)) >> IO_READ_CH_PIN_10));\n  Serial.println(\"CH11: \" + String((inputs & (1 << IO_READ_CH_PIN_11)) >> IO_READ_CH_PIN_11));\n  Serial.println();\n  inputs = digital_inputs.readAll();\n  Serial.println(\"CH00: \" + String((inputs & (1 << DIN_READ_CH_PIN_00)) >> DIN_READ_CH_PIN_00));\n  Serial.println(\"CH01: \" + String((inputs & (1 << DIN_READ_CH_PIN_01)) >> DIN_READ_CH_PIN_01));\n  Serial.println(\"CH02: \" + String((inputs & (1 << DIN_READ_CH_PIN_02)) >> DIN_READ_CH_PIN_02));\n  Serial.println(\"CH03: \" + String((inputs & (1 << DIN_READ_CH_PIN_03)) >> DIN_READ_CH_PIN_03));\n  Serial.println(\"CH04: \" + String((inputs & (1 << DIN_READ_CH_PIN_04)) >> DIN_READ_CH_PIN_04));\n  Serial.println(\"CH05: \" + String((inputs & (1 << DIN_READ_CH_PIN_05)) >> DIN_READ_CH_PIN_05));\n  Serial.println(\"CH06: \" + String((inputs & (1 << DIN_READ_CH_PIN_06)) >> DIN_READ_CH_PIN_06));\n  Serial.println(\"CH07: \" + String((inputs & (1 << DIN_READ_CH_PIN_07)) >> DIN_READ_CH_PIN_07));\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "dht11",
        "light",
        "pressure",
        "digitalwrite",
        "analogread",
        "digitalread",
        "tone",
        "delay",
        "display",
        "led",
        "oled",
        "devices",
        "sensorkit"
      ],
      "libraries": [
        "Arduino_SensorKit.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  pinMode(MIC , INPUT);\n  pinMode(LIGHT , INPUT);\n  pinMode(BUTTON , INPUT);\n  \n  pinMode(LED, OUTPUT);\n  digitalWrite(LED, LOW);\n  pinMode(BUZZER, OUTPUT);\n  \n  Environment.begin();\n\n  Oled.begin();\n  Oled.setFlipMode(true);\n\n  Accelerometer.begin();\n  Pressure.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Oled.setFont(u8x8_font_amstrad_cpc_extended_r); \n\n  //cursor values are in characters, not pixels\n  Oled.setCursor(0, 4);\n  \n  // If accelerometer and altimeter are queried too close to one another\n  // this causes a hang, so we read this first.\n  Oled.print(\"x:\"); \n  Oled.print(Accelerometer.readX()); \n  Oled.print(\" y:\"); \n  Oled.print(Accelerometer.readY());        \n  Oled.setCursor(0, 5);\n  Oled.print(\"z:\"); \n  Oled.print(Accelerometer.readZ());\n  Oled.print(\" T:\");\n  Oled.print(Environment.readTemperature());\n  Oled.print(\"C\");\n\n  Oled.setCursor(0, 0);\n  Oled.print(\"But:\"); \n\n  pot_value = analogRead(POT);\n  \n  button_state = digitalRead(BUTTON);\n  Oled.print(button_state); \n  \n  if (button_state == true) {\n    digitalWrite(LED, HIGH);\n    tone(BUZZER, pot_value);\n  } else {\n    digitalWrite(LED, LOW);\n    noTone(BUZZER);\n  }\n  \n  Oled.setCursor(0, 1);\n  Oled.print(\"BuzPot: \");\n  Oled.print(pot_value);\n  Oled.print(\"Hz  \");\n\n  mic_value = analogRead(MIC);\n  Oled.setCursor(0, 2);\n  Oled.print(\"Mic: \");\n  Oled.print(mic_value);\n  Oled.print(\"   \");\n\n  light_value = analogRead(LIGHT);\n  Oled.setCursor(0, 3);\n  Oled.print(\"Light: \");\n  Oled.print(light_value);\n  Oled.print(\"   \");\n\n  Oled.setCursor(0, 6);\n  Oled.print(\"Hum: \");\n  Oled.print(Environment.readHumidity());\n  Oled.print(\"%\");\n\n  Oled.setCursor(0, 7);\n  Oled.print(\"Alt:\"); \n  Oled.print(Pressure.readAltitude());\n\n  delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "delay"
      ],
      "libraries": [
        "HardwareBLESerial.h",
        "CommandParser.h"
      ],
      "functions": [
        {
          "name": "cmd_move",
          "parameters": "MyCommandParser::Argument *args, char *response",
          "body": "positionX = args[0].asInt64;\n  positionY = args[1].asInt64;\n  Serial.print(\"MOVING \"); Serial.print(args[0].asInt64); Serial.print(\" \"); Serial.println(args[1].asInt64);\n  snprintf(response, MyCommandParser::MAX_RESPONSE_SIZE, \"moved to %d, %d\", positionX, positionY);"
        },
        {
          "name": "cmd_jump",
          "parameters": "MyCommandParser::Argument *args, char *response",
          "body": "Serial.println(\"JUMPING!\");\n  snprintf(response, MyCommandParser::MAX_RESPONSE_SIZE, \"jumped at %d, %d\", positionX, positionY);"
        },
        {
          "name": "cmd_say",
          "parameters": "MyCommandParser::Argument *args, char *response",
          "body": "Serial.print(\"SAYING \"); Serial.println(args[0].asString);\n  snprintf(response, MyCommandParser::MAX_RESPONSE_SIZE, \"said %s at %d, %d\", args[0].asString, positionX, positionY);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!bleSerial.beginAndSetupBLE(\"CommandLine\")) {\n    while (true) {\n      Serial.println(\"failed to initialize HardwareBLESerial!\");\n      delay(1000);\n    }\n  }\n\n  parser.registerCommand(\"move\", \"ii\", &cmd_move); // two int64_t arguments\n  Serial.println(\"Registered command: move X Y\");\n  parser.registerCommand(\"jump\", \"\", &cmd_jump); // no arguments\n  Serial.println(\"Registered command: jump\");\n  parser.registerCommand(\"say\", \"s\", &cmd_say); // one string argument\n  Serial.println(\"Registered command: say \\\"SOMETHING\\\"\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// this must be called regularly to perform BLE updates\n  bleSerial.poll();\n\n  // read and process incoming commands\n  while (bleSerial.availableLines() > 0) {\n    // read line\n    char line[128];\n    bleSerial.readLine(line, 128);\n\n    // process line with CommandParser\n    char response[MyCommandParser::MAX_RESPONSE_SIZE]; parser.processCommand(line, response);\n    bleSerial.println(response);\n  }\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "light",
        "current",
        "power",
        "delay",
        "led",
        "display"
      ],
      "libraries": [
        "Arduino.h",
        "IRremoteESP8266.h",
        "IRac.h",
        "IRutils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(200);\n\n  // Set up what we want to send.\n  // See state_t, opmode_t, fanspeed_t, swingv_t, & swingh_t in IRsend.h for\n  // all the various options.\n  ac.next.protocol = decode_type_t::DAIKIN;  // Set a protocol to use.\n  ac.next.model = 1;  // Some A/Cs have different models. Try just the first.\n  ac.next.mode = stdAc::opmode_t::kCool;  // Run in cool mode initially.\n  ac.next.celsius = true;  // Use Celsius for temp units. False = Fahrenheit\n  ac.next.degrees = 25;  // 25 degrees.\n  ac.next.fanspeed = stdAc::fanspeed_t::kMedium;  // Start the fan at medium.\n  ac.next.swingv = stdAc::swingv_t::kOff;  // Don't swing the fan up or down.\n  ac.next.swingh = stdAc::swingh_t::kOff;  // Don't swing the fan left or right.\n  ac.next.light = false;  // Turn off any LED/Lights/Display that we can.\n  ac.next.beep = false;  // Turn off any beep from the A/C if we can.\n  ac.next.econo = false;  // Turn off any economy modes if we can.\n  ac.next.filter = false;  // Turn off any Ion/Mold/Health filters if we can.\n  ac.next.turbo = false;  // Don't use any turbo/powerful/etc modes.\n  ac.next.quiet = false;  // Don't use any quiet/silent/etc modes.\n  ac.next.sleep = -1;  // Don't set any sleep time or modes.\n  ac.next.clean = false;  // Turn off any Cleaning options if we can.\n  ac.next.clock = -1;  // Don't set any current time if we can avoid it.\n  ac.next.power = false;  // Initially start with the unit off.\n\n  Serial.println(\"Try to turn on & off every supported A/C type ...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// For every protocol the library has ...\n  for (int i = 1; i < kLastDecodeType; i++) {\n    decode_type_t protocol = (decode_type_t)i;\n    // If the protocol is supported by the IRac class ...\n    if (ac.isProtocolSupported(protocol)) {\n      Serial.println(\"Protocol \" + String(protocol) + \" / \" +\n                     typeToString(protocol) + \" is supported.\");\n      ac.next.protocol = protocol;  // Change the protocol used.\n      ac.next.power = true;  // We want to turn on the A/C unit.\n      Serial.println(\"Sending a message to turn ON the A/C unit.\");\n      ac.sendAc();  // Have the IRac class create and send a message.\n      delay(5000);  // Wait 5 seconds.\n      ac.next.power = false;  // Now we want to turn the A/C off.\n      Serial.println(\"Send a message to turn OFF the A/C unit.\");\n      ac.sendAc();  // Send the message.\n      delay(1000);  // Wait 1 second.\n    }\n  }\n  Serial.println(\"Starting from the begining again ...\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "publish",
        "delay"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h",
        "aunit/string_util.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "#ifndef EPOXY_DUINO\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "TestRunner::run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "tft"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // initialize the robot's screen\n  Robot.beginTFT();\n\n  // initialize the serial port\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the compass\n  int compass = Robot.compassRead();\n\n  // print out the sensor's value\n  Serial.println(compass);\n\n  // show the value on the robot's screen\n  Robot.drawCompass(compass);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "delay",
        "digitalwrite",
        "millis"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_DoubleResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_minimal on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION); \n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n  if (drd->detectDoubleReset()) { Serial.println(F(\"DRD\")); initialConfig = true; }\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnDoubleReset\");\n  if (ESP_wifiManager.WiFi_SSID() == \"\") { Serial.println(F(\"No AP credentials\")); initialConfig = true; }\n  if (initialConfig) {\n    Serial.println(F(\"Starting Config Portal\")); digitalWrite(PIN_LED, HIGH);\n    if (!ESP_wifiManager.startConfigPortal()) { Serial.println(F(\"Not connected to WiFi\")); }\n    else { Serial.println(F(\"connected\")); }\n  }\n  else { WiFi.mode(WIFI_STA); WiFi.begin(); } \n  unsigned long startedAt = millis();\n  digitalWrite(PIN_LED, LOW); Serial.print(F(\"After waiting \"));\n  int connRes = WiFi.waitForConnectResult();\n  float waited = (millis() - startedAt);\n  Serial.print(waited / 1000); Serial.print(F(\" secs , Connection result is \")); Serial.println(connRes);\n  if (WiFi.status() != WL_CONNECTED) { Serial.println(F(\"Failed to connect\")); }\n  else { Serial.print(F(\"Local IP: \")); Serial.println(WiFi.localIP()); }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "delay",
        "digitalwrite",
        "millis"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_DoubleResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_minimal on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION); \n  if (WiFi.SSID() == \"\") { Serial.println(F(\"No AP credentials\")); initialConfig = true; }\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n  if (drd->detectDoubleReset()) { Serial.println(F(\"DRD\")); initialConfig = true; }\n  if (initialConfig) {\n    Serial.println(F(\"Starting Config Portal\")); digitalWrite(PIN_LED, LOW);\n    ESP_WiFiManager ESP_wifiManager(\"ConfigOnDoubleReset\");\n    ESP_wifiManager.setConfigPortalTimeout(0);\n    if (!ESP_wifiManager.startConfigPortal()) { Serial.println(F(\"Not connected to WiFi\")); }\n    else { Serial.println(F(\"connected\")); }\n  }\n  digitalWrite(PIN_LED, HIGH); Serial.print(F(\"After waiting \")); //WiFi.mode(WIFI_STA);\n  unsigned long startedAt = millis();\n  int connRes = WiFi.waitForConnectResult();\n  float waited = (millis() - startedAt);\n  Serial.print(waited / 1000); Serial.print(F(\" secs , Connection result is \")); Serial.println(connRes);\n  if (WiFi.status() != WL_CONNECTED) { Serial.println(F(\"Failed to connect\")); }\n  else { Serial.print(F(\"Local IP: \")); Serial.println(WiFi.localIP()); }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "mqtt",
        "wificlient",
        "esp8266webserver",
        "webserver",
        "https",
        "password",
        "ssl",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "Arduino.h",
        "OneButton.h",
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESPAsync_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 5 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK\n    }\n    else \n    {\n      Serial.print(F(\"F\"));        // F means publishing failure\n    }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic,  Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnDRD_FS-MQTT\");;\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    ESP_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n\n  // AIO_SERVER\n  ESP_WMParameter AIO_SERVER_FIELD(AIO_SERVER_Label, \"AIO SERVER\", custom_AIO_SERVER, custom_AIO_SERVER_LEN + 1);\n\n  // AIO_SERVERPORT\n  ESP_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVERPORT_Label, \"AIO SERVER PORT\", custom_AIO_SERVERPORT, custom_AIO_PORT_LEN + 1);\n\n  // AIO_USERNAME\n  ESP_WMParameter AIO_USERNAME_FIELD(AIO_USERNAME_Label, \"AIO USERNAME\", custom_AIO_USERNAME, custom_AIO_USERNAME_LEN + 1);\n\n  // AIO_KEY\n  ESP_WMParameter AIO_KEY_FIELD(AIO_KEY_Label, \"AIO KEY\", custom_AIO_KEY, custom_AIO_KEY_LEN + 1);\n\n  // add all parameters here\n  // order of adding is not important\n  ESP_wifiManager.addParameter(&AIO_SERVER_FIELD);\n  ESP_wifiManager.addParameter(&AIO_SERVERPORT_FIELD);\n  ESP_wifiManager.addParameter(&AIO_USERNAME_FIELD);\n  ESP_wifiManager.addParameter(&AIO_KEY_FIELD);\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESP_wifiManager.setConfigPortalTimeout(120);\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESP_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n  \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n#if defined(HTTP_PORT_TO_USE)\n    Serial.print(F(\":\")); Serial.print(HTTP_PORT_TO_USE);\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESP_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                   WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n  \n  if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESP_wifiManager.getSSID(0)) != \"\" && String(ESP_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESP_wifiManager.getSSID(i);\n      String tempPW   = ESP_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n  \n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESP_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  strcpy(custom_AIO_SERVER, AIO_SERVER_FIELD.getValue());\n  strcpy(custom_AIO_SERVERPORT, AIO_SERVERPORT_FIELD.getValue());\n  strcpy(custom_AIO_USERNAME, AIO_USERNAME_FIELD.getValue());\n  strcpy(custom_AIO_KEY, AIO_KEY_FIELD.getValue());\n \n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    if (json.containsKey(AIO_SERVER_Label))\n    {\n      strcpy(custom_AIO_SERVER, json[AIO_SERVER_Label]);\n    }\n\n    if (json.containsKey(AIO_SERVERPORT_Label))\n    {\n      strcpy(custom_AIO_SERVERPORT, json[AIO_SERVERPORT_Label]);\n    }\n\n    if (json.containsKey(AIO_USERNAME_Label))\n    {\n      strcpy(custom_AIO_USERNAME, json[AIO_USERNAME_Label]);\n    }\n\n    if (json.containsKey(AIO_KEY_Label))\n    {\n      strcpy(custom_AIO_KEY, json[AIO_KEY_Label]);\n    }\n  }\n  \n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  json[AIO_SERVER_Label]      = custom_AIO_SERVER;\n  json[AIO_SERVERPORT_Label]  = custom_AIO_SERVERPORT;\n  json[AIO_USERNAME_Label]    = custom_AIO_USERNAME;\n  json[AIO_KEY_Label]         = custom_AIO_KEY;\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    \n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDRD_FS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  // Mount the filesystem\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n  \n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n  {\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n  }\n  else if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    //ESP_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n \n  if (initialConfig)\n  {\n    loadConfigData();\n    \n    wifi_manager();\n  }\n  else\n  {   \n    // Pretend CP is necessary as we have no AP Credentials\n    initialConfig = true;\n\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (loadConfigData())\n    {\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n          initialConfig = false;\n        }\n      }\n    }\n\n    if (initialConfig)\n    {\n      Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n    \n      wifi_manager();\n    }\n    else if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "mqtt",
        "wificlient",
        "webserver",
        "https",
        "password",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESPAsync_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h",
        "map"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 5 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK\n    }\n    else \n    {\n      Serial.print(F(\"F\"));        // F means publishing failure\n    }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic,  Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnSwichFS-MQTT\");\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    ESP_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n\n  // AIO_SERVER\n  ESP_WMParameter AIO_SERVER_FIELD(AIO_SERVER_TOTAL_DATA[\"Server\"]); \n  DATA_FIELD[\"Server\"] = &AIO_SERVER_FIELD;\n  \n  // AIO_SERVERPORT\n  ESP_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVER_TOTAL_DATA[\"ServerPort\"]); \n  DATA_FIELD[\"ServerPort\"] = &AIO_SERVERPORT_FIELD;\n\n  // AIO_USERNAME\n  ESP_WMParameter AIO_USERNAME_FIELD(AIO_SERVER_TOTAL_DATA[\"UserName\"]); \n  DATA_FIELD[\"UserName\"] = &AIO_USERNAME_FIELD;\n\n  // AIO_KEY\n  ESP_WMParameter AIO_KEY_FIELD(AIO_SERVER_TOTAL_DATA[\"Key\"]); \n  DATA_FIELD[\"Key\"] = &AIO_KEY_FIELD;\n   \n  // add all parameters here\n  // order of adding is not important\n  for (auto &data_field : DATA_FIELD) \n  {           \n    ESP_wifiManager.addParameter(data_field.second); \n  }\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESP_wifiManager.setConfigPortalTimeout(120);\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESP_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n  \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n#if defined(HTTP_PORT_TO_USE)\n    Serial.print(F(\":\")); Serial.print(HTTP_PORT_TO_USE);\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESP_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                   WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n  if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESP_wifiManager.getSSID(0)) != \"\" && String(ESP_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESP_wifiManager.getSSID(i);\n      String tempPW   = ESP_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n  \n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESP_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  for (auto &aio_data : AIO_SERVER_TOTAL_DATA) \n  {              \n    strcpy(aio_data.second._value, DATA_FIELD[aio_data.first]->getValue());\n  }\n \n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(AIO_SERVER_TOTAL_DATA[\"UserName\"]._value) + \"/feeds/Temperature\";\n  \n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    for (auto &aio_data : AIO_SERVER_TOTAL_DATA) \n    {           \n      if (json.containsKey(aio_data.second._id))\n      {\n        strcpy(aio_data.second._value, json[aio_data.second._id]);\n      }\n    }   \n  }\n\n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  for (auto &aio_data : AIO_SERVER_TOTAL_DATA) \n  {           \n    json[aio_data.second._id] = aio_data.second._value;\n  } \n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    \n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDRD_FS_MQTT_Ptr_Complex using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  // Mount the filesystem\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n  \n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n  {\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n  }\n  else if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    //ESP_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n \n  if (initialConfig)\n  {\n    loadConfigData();\n    \n    wifi_manager();\n  }\n  else\n  {   \n    // Pretend CP is necessary as we have no AP Credentials\n    initialConfig = true;\n\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (loadConfigData())\n    {\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n          initialConfig = false;\n        }\n      }\n    }\n\n    if (initialConfig)\n    {\n      Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n    \n      wifi_manager();\n    }\n    else if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "mqtt",
        "wificlient",
        "webserver",
        "https",
        "password",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "millis",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_DoubleResetDetector.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESPAsync_WiFiManager.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 5 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK\n    }\n    else \n    {\n      Serial.print(F(\"F\"));        // F means publishing failure\n    }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic,  Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnSwichFS-MQTT\");\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    ESP_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n  // AIO_SERVER\n  ESP_WMParameter AIO_SERVER_FIELD(AIO_SERVER_TOTAL_DATA[0]); \n  DATA_FIELD[0] = &AIO_SERVER_FIELD;\n  \n  // AIO_SERVERPORT\n  ESP_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVER_TOTAL_DATA[1]); \n  DATA_FIELD[1] = &AIO_SERVERPORT_FIELD;\n\n  // AIO_USERNAME\n  ESP_WMParameter AIO_USERNAME_FIELD(AIO_SERVER_TOTAL_DATA[2]); \n  DATA_FIELD[2] = &AIO_USERNAME_FIELD;\n\n  // AIO_KEY\n  ESP_WMParameter AIO_KEY_FIELD(AIO_SERVER_TOTAL_DATA[3]); \n  DATA_FIELD[3] = &AIO_KEY_FIELD;\n\n  // add all parameters here\n  // order of adding is not important\n  for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n  {\n    ESP_wifiManager.addParameter(DATA_FIELD[i]); \n  }\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESP_wifiManager.setConfigPortalTimeout(120);\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESP_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password   = \"My\" + ssid;\n\n  Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n  Serial.print(APStaticIP);\n#else\n  Serial.print(F(\"192.168.4.1\"));\n#endif\n\n#if defined(HTTP_PORT_TO_USE)\n    Serial.print(F(\":\")); Serial.print(HTTP_PORT_TO_USE);\n#endif\n\n  Serial.print(F(\", SSID = \"));\n  Serial.print(ssid);\n  Serial.print(F(\", PWD = \"));\n  Serial.println(password);\n  \n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESP_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                   WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n  if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESP_wifiManager.getSSID(0)) != \"\" && String(ESP_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESP_wifiManager.getSSID(i);\n      String tempPW   = ESP_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n  \n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESP_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n  {\n    strcpy(AIO_SERVER_TOTAL_DATA[i]._value, DATA_FIELD[i]->getValue());\n  }\n \n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(AIO_SERVER_TOTAL_DATA[2]._value) + \"/feeds/Temperature\";\n  \n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n    {\n      if (json.containsKey(AIO_SERVER_TOTAL_DATA[i]._id))\n      {\n        strcpy(AIO_SERVER_TOTAL_DATA[i]._value, json[AIO_SERVER_TOTAL_DATA[i]._id]);\n      }\n    }   \n  }\n\n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  for (unsigned int i = 0; i < NUMBER_PARAMETERS; i++)\n  {\n    json[AIO_SERVER_TOTAL_DATA[i]._id] = AIO_SERVER_TOTAL_DATA[i]._value;\n  }\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    \n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n  \n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDRD_FS_MQTT_Ptr_Medium using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n  \n  Serial.setDebugOutput(false);\n\n  // Mount the filesystem\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n  \n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n  {\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n  }\n  else if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    //ESP_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n \n  if (initialConfig)\n  {\n    loadConfigData();\n    \n    wifi_manager();\n  }\n  else\n  {   \n    // Pretend CP is necessary as we have no AP Credentials\n    initialConfig = true;\n\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (loadConfigData())\n    {\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n          initialConfig = false;\n        }\n      }\n    }\n\n    if (initialConfig)\n    {\n      Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n    \n      wifi_manager();\n    }\n    else if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "voltage",
        "wifi",
        "millis",
        "delay",
        "digitalwrite",
        "display",
        "led",
        "littlefs",
        "eeprom",
        "spiffs",
        "rtc",
        "gatewayip"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti_Generic.h",
        "LittleFS.h",
        "DoubleResetDetector_Generic.h",
        "WiFiManager_RP2040W.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3((\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1((\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR1((\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(\"\\nWiFi lost. Call connectMultiWiFi in loop\");\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = LittleFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR((\"LoadWiFiCfgFile \"));\n\n  memset((void*) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void*) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n\n    file.close();\n    LOGERROR((\"OK\"));\n   \n    return true;\n  }\n  else\n  {\n    LOGERROR((\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = LittleFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR((\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {   \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n\n    file.close();\n    LOGERROR((\"OK\"));\n  }\n  else\n  {\n    LOGERROR((\"failed\"));\n  }"
        },
        {
          "name": "processDataFromCP",
          "parameters": "WiFiManager_RP2040W &RP2040W_WiFiManager",
          "body": "// Stored  for later usage, from v1.1.0, but clear first\n  memset(&WM_config, 0, sizeof(WM_config));\n\n  for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n  {\n    String tempSSID = RP2040W_WiFiManager.getSSID(i);\n    String tempPW   = RP2040W_WiFiManager.getPW(i);\n\n    if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n    if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStarting ConfigOnDoubleReset with DoubleResetDetect on \"); Serial.println(BOARD_NAME);\n  Serial.println(WIFI_MANAGER_RP2040W_VERSION);\n\n  drd = new DoubleResetDetector_Generic(DRD_TIMEOUT, DRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager_RP2040W RP2040W_WiFiManager;\n\n  RP2040W_WiFiManager.setDebugOutput(true);\n\n  // Use only to erase stored WiFi Credentials\n  //RP2040W_WiFiManager.resetSettings();\n\n  RP2040W_WiFiManager.setMinimumSignalQuality(-1);\n\n#if USING_CORS_FEATURE\n  RP2040W_WiFiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    RP2040W_WiFiManager.setConfigPortalTimeout(0);\n\n    LOGERROR(\"Open Config Portal without Timeout: Double Reset Detected\");\n    initialConfig = true;\n  }\n  else\n  {\n    LOGERROR(\"No Double Reset Detected\");\n  }\n\n  // We can't use WiFi.SSID() in ESP32as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = RP2040W_WiFiManager.WiFi_SSID();\n  //Router_Pass = RP2040W_WiFiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  //Serial.println(\"Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // If no stored WiFi data, load from saved EEPROM \n  if ( (Router_SSID == \"\") /*|| (Router_Pass == \"\")*/ )\n  {\n    // Load stored data and verify CheckSum\n    if (loadConfigData())\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3((\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, (\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n  \n      if ( ( WiFi.status() != WL_CONNECTED ) && !initialConfig )\n      {\n        LOGERROR((\"ConnectWiFi in setup\"));\n  \n        if ( connectMultiWiFi() == WL_CONNECTED )\n        {\n          Serial.println(\"Connected to \" + Router_SSID);\n          return;\n        }\n      }\n    }\n  }\n  \n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\")  && !initialConfig )\n  {\n    LOGERROR3((\"* Add SSID = \"), Router_SSID, (\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    RP2040W_WiFiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    LOGERROR(\"Got stored Credentials. Timeout 120s for Config Portal\");\n  }\n  else\n  {\n    LOGERROR(\"Open Config Portal without Timeout: No stored Credentials.\");\n    digitalWrite(PIN_LED, LED_ON); // Turn led on as we are in configuration mode.\n\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    LOGERROR(\"Starting configuration portal.\");\n    digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //RP2040W_WiFiManager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!RP2040W_WiFiManager.startConfigPortal((const char *) ssid.c_str(), password))\n    {\n      LOGERROR(\"Not connected to WiFi but continuing anyway.\");\n    }\n    else\n    {\n      LOGERROR(\"WiFi connected...yeey :)\");\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = RP2040W_WiFiManager.getSSID(i);\n      String tempPW   = RP2040W_WiFiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3((\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, (\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    saveConfigData();\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3((\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, (\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      LOGERROR(\"ConnectMultiWiFi in setup\");\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(\"After waiting \");\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(\" secs more in setup(), connection result is \");\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.println(\"connected\");\n  }\n  else\n    Serial.println(RP2040W_WiFiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "webserver",
        "https",
        "password",
        "current",
        "voltage",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "digitalwrite",
        "display",
        "led",
        "eeprom",
        "spiffs",
        "littlefs",
        "flash",
        "rtc"
      ],
      "libraries": [
        "ESPAsync_WiFiManager.h",
        "ConfigOnDoubleReset_Multi.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_Multi with DoubleResetDetect using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESP_WiFiManager ESP_wifiManager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnDoubleReset\");\n\n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESP_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");  \n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID/PWD to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n\n    ESP_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESP_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\")); \n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESP_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n#if defined(HTTP_PORT_TO_USE)\n    Serial.print(F(\":\")); Serial.print(HTTP_PORT_TO_USE);\n#endif\n    \n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n    digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP_wifiManager.setConfigPortalTimeout(600);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESP_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                   WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), (const char *) password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESP_wifiManager.getSSID(i);\n      String tempPW   = ESP_wifiManager.getPW(i);\n\n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);\n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESP_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESP_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "current",
        "dns",
        "ntp",
        "spi",
        "millis",
        "delay",
        "digitalwrite",
        "display",
        "led",
        "littlefs",
        "spiffs",
        "eeprom",
        "flash",
        "rtc",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP_DoubleResetDetector.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "ETH_STA_IPConfig &in_EthSTA_IPconfig",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "ETH_STA_IPConfig in_EthSTA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n\n#endif"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n\n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadCfgFile \"));\n\n  memset((void *) &Ethconfig,       0, sizeof(Ethconfig));\n  memset((void *) &EthSTA_IPconfig, 0, sizeof(EthSTA_IPconfig));\n\n  if (file)\n  {\n    file.readBytes((char *) &Ethconfig,   sizeof(Ethconfig));\n    file.readBytes((char *) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n\n    if ( Ethconfig.checksum != calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) ) )\n    {\n      LOGERROR(F(\"Ethconfig checksum wrong\"));\n\n      return false;\n    }\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "beginEthernet",
          "parameters": "",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnDoubleReset_TZ using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  beginEthernet();\n\n  initSTAIPConfigStruct(EthSTA_IPconfig);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP32-XXXXXX\n  //ESP32_W6100_Manager ESP32_W6100_manager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP32_W6100_Manager ESP32_W6100_manager(\"ConfigOnDoubleReset_TZ\");\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask)\n  ESP32_W6100_manager.setSTAStaticIPConfig(EthSTA_IPconfig);\n#endif\n\n#if USING_CORS_FEATURE\n  ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  if (loadConfigData())\n  {\n    //If no access point name has been previously entered disable timeout.\n    ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_ETH_MANAGER_NTP\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored Credentials on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  //////////////////////////////////\n\n  // Connect ETH now if using STA\n  initEthernet();\n\n  //////////////////////////////////\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESP32_W6100_manager.setConfigPortalTimeout(0);\n\n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    Serial.println(ETH.localIP());\n\n    digitalWrite(LED_BUILTIN, LED_ON); // Turn led on as we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP32_W6100_manager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ   = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (ESP32_W6100_isConnected())\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(ETH.localIP());\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "delay",
        "digitalwrite",
        "millis",
        "littlefs",
        "spiffs",
        "eeprom"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_MultiResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnMRD_ESP32_minimal on \")); Serial.print(ARDUINO_BOARD);\n#if ESP_MRD_USE_LITTLEFS\n  Serial.println(F(\" using LittleFS\"));\n#elif ESP_MRD_USE_SPIFFS\n  Serial.println(F(\" using SPIFFS\"));\n#else\n  Serial.println(F(\" using EEPROM\"));\n#endif  \n  Serial.println(ESP_WIFIMANAGER_VERSION); Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  mrd = new MultiResetDetector(MRD_TIMEOUT, MRD_ADDRESS);\n  if (mrd->detectMultiReset()) { Serial.println(F(\"MRD\")); initialConfig = true; }\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnMRD_ESP32_minimal\");\n  if (ESP_wifiManager.WiFi_SSID() == \"\") { Serial.println(F(\"No AP credentials\")); initialConfig = true; }\n  if (initialConfig) {\n    Serial.println(F(\"Starting Config Portal\")); digitalWrite(PIN_LED, HIGH);\n    if (!ESP_wifiManager.startConfigPortal()) { Serial.println(F(\"Not connected to WiFi\")); }\n    else { Serial.println(F(\"connected\")); }\n  }\n  else { WiFi.mode(WIFI_STA); WiFi.begin(); } \n  unsigned long startedAt = millis();\n  digitalWrite(PIN_LED, LOW); Serial.print(F(\"After waiting \"));\n  int connRes = WiFi.waitForConnectResult();\n  float waited = (millis() - startedAt);\n  Serial.print(waited / 1000); Serial.print(F(\" secs , Connection result is \")); Serial.println(connRes);\n  if (WiFi.status() != WL_CONNECTED) { Serial.println(F(\"Failed to connect\")); }\n  else { Serial.print(F(\"Local IP: \")); Serial.println(WiFi.localIP()); }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "delay",
        "digitalwrite",
        "millis",
        "littlefs",
        "spiffs",
        "eeprom"
      ],
      "libraries": [
        "ESP_WiFiManager.h",
        "ESP_MultiResetDetector.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  Serial.begin(115200); while (!Serial); delay(200);\n  Serial.print(F(\"\\nStarting ConfigOnMRD_ES8266_minimal on \")); Serial.print(ARDUINO_BOARD);\n#if ESP_MRD_USE_LITTLEFS\n  Serial.println(F(\" using LittleFS\"));\n#elif ESP_MRD_USE_SPIFFS\n  Serial.println(F(\" using SPIFFS\"));\n#else\n  Serial.println(F(\" using EEPROM\"));\n#endif    \n  Serial.println(ESP_WIFIMANAGER_VERSION); Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  if (WiFi.SSID() == \"\") { Serial.println(F(\"No AP credentials\")); initialConfig = true; }\n  mrd = new MultiResetDetector(MRD_TIMEOUT, MRD_ADDRESS);\n  if (mrd->detectMultiReset()) { Serial.println(F(\"MRD\")); initialConfig = true; }\n  if (initialConfig) {\n    Serial.println(F(\"Starting Config Portal\")); digitalWrite(PIN_LED, LOW);\n    ESP_WiFiManager ESP_wifiManager(\"ConfigOnMRD_ES8266_minimal\");\n    ESP_wifiManager.setConfigPortalTimeout(0);\n    if (!ESP_wifiManager.startConfigPortal()) { Serial.println(F(\"Not connected to WiFi\")); }\n    else { Serial.println(F(\"connected\")); }\n  }\n  digitalWrite(PIN_LED, HIGH); Serial.print(F(\"After waiting \")); //WiFi.mode(WIFI_STA);\n  unsigned long startedAt = millis();\n  int connRes = WiFi.waitForConnectResult();\n  float waited = (millis() - startedAt);\n  Serial.print(waited / 1000); Serial.print(F(\" secs , Connection result is \")); Serial.println(connRes);\n  if (WiFi.status() != WL_CONNECTED) { Serial.println(F(\"Failed to connect\")); }\n  else { Serial.print(F(\"Local IP: \")); Serial.println(WiFi.localIP()); }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "esp8266webserver",
        "webserver",
        "https",
        "password",
        "voltage",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "digitalwrite",
        "led",
        "display",
        "littlefs",
        "spiffs",
        "eeprom",
        "flash",
        "rtc",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266WiFiMulti.h",
        "ESP_MultiResetDetector.h",
        "ESP_WiFiManager.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "check_WiFi",
          "parameters": "void",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(\"\\nWiFi lost. Call connectMultiWiFi in loop\");\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "void",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset(&WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset(&WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n    \n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n    \n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    file.write((uint8_t*) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n    \n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ConfigOnMultiReset with MultiResetDetect using \" + String(FS_Name));\n  Serial.println(\" on \" + String(ARDUINO_BOARD));\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n    Serial.print(FS_Name);\n    Serial.println(F(\" failed! AutoFormatting.\"));\n\n#ifdef ESP8266\n    FileFS.format();\n#endif\n  }\n\n  mrd = new MultiResetDetector(MRD_TIMEOUT, MRD_ADDRESS);\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESP_WiFiManager ESP_wifiManager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnMultiReset\");\n\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n\n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESP_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");  \n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n\n    ESP_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(\"Got stored Credentials. Timeout 120s for Config Portal\");\n  }\n  else\n  {\n    Serial.println(\"Open Config Portal without Timeout: No stored Credentials.\");\n    initialConfig = true;\n  }\n\n  if (mrd->detectMultiReset())\n  {\n    // MRD, disable timeout.\n    ESP_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.println(\"Open Config Portal without Timeout: Multi Reset Detected\");\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.println(\"Starting configuration portal.\");\n    digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP_wifiManager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), password))\n      Serial.println(\"Not connected to WiFi but continuing anyway.\");\n    else\n    {\n      Serial.println(\"WiFi connected...yeey :)\");\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESP_wifiManager.getSSID(i);\n      String tempPW   = ESP_wifiManager.getPW(i);\n\n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);\n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    // New in v1.4.0\n    ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED )\n    {\n      Serial.println(\"ConnectMultiWiFi in setup\");\n\n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(\"After waiting \");\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(\" secs more in setup(), connection result is \");\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(\"connected. Local IP: \");\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESP_wifiManager.getStatus(WiFi.status()));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the mlti reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call mrd.stop() when you wish to no longer\n  // consider the next reset as a mlti reset.\n  mrd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "voltage",
        "wifi",
        "millis",
        "delay",
        "digitalwrite",
        "display",
        "led",
        "littlefs",
        "eeprom",
        "gatewayip"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti_Generic.h",
        "LittleFS.h",
        "WiFiManager_RP2040W.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(\"\\nWiFi lost. Call connectMultiWiFi in loop\");\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = LittleFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR((\"LoadWiFiCfgFile \"));\n\n  memset((void*) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  //memset((void*) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n    //file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n\n    file.close();\n    LOGERROR((\"OK\"));\n   \n    return true;\n  }\n  else\n  {\n    LOGERROR((\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = LittleFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR((\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {   \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n    //file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n\n    file.close();\n    LOGERROR((\"OK\"));\n  }\n  else\n  {\n    LOGERROR((\"failed\"));\n  }"
        },
        {
          "name": "processDataFromCP",
          "parameters": "WiFiManager_RP2040W &RP2040W_WiFiManager",
          "body": "// Stored  for later usage, from v1.1.0, but clear first\n  memset(&WM_config, 0, sizeof(WM_config));\n\n  for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n  {\n    String tempSSID = RP2040W_WiFiManager.getSSID(i);\n    String tempPW   = RP2040W_WiFiManager.getPW(i);\n\n    if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n    if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n      strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n    else\n      strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n  \n  Serial.print(\"\\nStarting ConfigOnStartup on \"); Serial.println(BOARD_NAME);\n  Serial.println(WIFI_MANAGER_RP2040W_VERSION);\n\n  digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  unsigned long startedAt = millis();\n\n  bool beginOK = LittleFS.begin();\n\n  if (!beginOK)\n  {\n    Serial.println(\"\\nLittleFS error\");\n  }\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager_RP2040W RP2040W_WiFiManager;\n\n  RP2040W_WiFiManager.setDebugOutput(true);\n\n  // Use only to erase stored WiFi Credentials\n  //RP2040W_WiFiManager.resetSettings();\n\n  RP2040W_WiFiManager.setMinimumSignalQuality(-1);\n\n#if USING_CORS_FEATURE\n  RP2040W_WiFiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // If no stored WiFi data, load from saved EEPROM \n  if ( (Router_SSID == \"\") || (Router_Pass == \"\") )\n  {\n    // Load stored data and verify CheckSum\n    if (loadConfigData())\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n\n          Router_SSID = String(WM_config.WiFi_Creds[i].wifi_ssid);\n          Router_Pass = String(WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n    }\n  }\n  \n  //Remove this line if you do not want to see WiFi password printed\n  LOGERROR3(\"Stored: SSID =\", Router_SSID, \", Pass =\", Router_Pass);\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  LOGERROR(\"Opening configuration portal.\");\n\n  // Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    RP2040W_WiFiManager.setConfigPortalTimeout(CONFIG_PORTAL_TIMEOUT_SEC); //If no access point name has been previously entered disable timeout.\n    LOGERROR1(\"Got stored Credentials. Timeout for Config Portal =\", CONFIG_PORTAL_TIMEOUT_SEC);\n  }\n  else\n  {\n    LOGERROR(\"Open Config Portal without Timeout: No stored Credentials.\");\n    digitalWrite(PIN_LED, LED_ON); // Turn led on as we are in configuration mode.\n\n    initialConfig = true;\n  }\n\n  LOGERROR(\"Starting configuration portal.\");\n  digitalWrite(PIN_LED, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  // Starts an access point\n  if (!RP2040W_WiFiManager.startConfigPortal((const char *) ssid.c_str(), password))\n  {\n    LOGERROR(\"Not connected to WiFi but continuing anyway.\");\n  }\n  else\n  {\n    LOGERROR(\"WiFi connected...yeey :)\");\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(RP2040W_WiFiManager.getSSID(0)) != \"\" && String(RP2040W_WiFiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = RP2040W_WiFiManager.getSSID(i);\n      String tempPW   = RP2040W_WiFiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n  \n    saveConfigData();\n\n    initialConfig = true;\n  }\n\n  digitalWrite(PIN_LED, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      LOGERROR(\"ConnectMultiWiFi in setup\");\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(\"After waiting \");\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(\" secs more in setup(), connection result is \");\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.println(\"connected\");\n  }\n  else\n    Serial.println(RP2040W_WiFiManager.getStatus(WiFi.status()));\n\n  Serial.print(\"Local IP = \"); Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "voltage",
        "current",
        "dns",
        "ntp",
        "spi",
        "digitalwrite",
        "digitalread",
        "millis",
        "delay",
        "esp.restart",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "nodemcu",
        "devices",
        "gatewayip"
      ],
      "libraries": [
        "esp_wifi.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "ETH_STA_IPConfig &in_EthSTA_IPconfig",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "ETH_STA_IPConfig in_EthSTA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n\n#endif"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n\n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadCfgFile \"));\n\n  memset((void *) &Ethconfig,       0, sizeof(Ethconfig));\n  memset((void *) &EthSTA_IPconfig, 0, sizeof(EthSTA_IPconfig));\n\n  if (file)\n  {\n    file.readBytes((char *) &Ethconfig,   sizeof(Ethconfig));\n    file.readBytes((char *) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n\n    if ( Ethconfig.checksum != calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) ) )\n    {\n      LOGERROR(F(\"Ethconfig checksum wrong\"));\n\n      return false;\n    }\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "beginEthernet",
          "parameters": "",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnSwitch using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  unsigned long startedAt = millis();\n\n  beginEthernet();\n\n  initSTAIPConfigStruct(EthSTA_IPconfig);\n\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP32-XXXXXX\n  //ESP32_W6100_Manager ESP32_W6100_manager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP32_W6100_Manager ESP32_W6100_manager(\"ConfigOnSwitch\");\n\n  ESP32_W6100_manager.setDebugOutput(true);\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask)\n  ESP32_W6100_manager.setSTAStaticIPConfig(EthSTA_IPconfig);\n#endif\n\n#if USING_CORS_FEATURE\n  ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  if (loadConfigData())\n  {\n    //If no access point name has been previously entered disable timeout.\n    ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_ETH_MANAGER_NTP\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  //////////////////////////////////\n\n  // Connect ETH now if using STA\n  initEthernet();\n\n  //////////////////////////////////\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    Serial.println(ETH.localIP());\n\n    digitalWrite(LED_BUILTIN, LED_ON); // Turn led on as we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP32_W6100_manager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ   = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (ESP32_W6100_isConnected())\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(ETH.localIP());\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP32-XXXXXX\n    //ESP32_W6100_Manager ESP32_W6100_manager;\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    ESP32_W6100_Manager ESP32_W6100_manager(\"ConfigOnSwitch\");\n\n#if !USE_DHCP_IP\n#if USE_CONFIGURABLE_DNS\n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n#else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n#endif\n#endif\n\n#if USING_CORS_FEATURE\n    ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n    //Check if there is stored credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n\n    if (loadConfigData())\n    {\n      //If no access point name has been previously entered disable timeout.\n      ESP32_W6100_manager.setConfigPortalTimeout(120);\n      \n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n    }\n    else\n    {\n      // Enter CP only if no stored SSID on flash and file\n      ESP32_W6100_manager.setConfigPortalTimeout(0);\n      Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n      initialConfig = true;\n    }\n\n    //Starts an access point\n    //and goes into a blocking loop awaiting configuration\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n      Serial.print(F(\"Local IP: \"));\n      Serial.println(ETH.localIP());\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n\n#if !USE_DHCP_IP\n\n    // Reset to use new Static IP, if different from current ETH.localIP()\n    if (ETH.localIP() != EthSTA_IPconfig._sta_static_ip)\n    {\n      Serial.print(F(\"Current IP = \"));\n      Serial.print(ETH.localIP());\n      Serial.print(F(\". Reset to take new IP = \"));\n      Serial.println(EthSTA_IPconfig._sta_static_ip);\n\n      ESP.restart();\n      delay(2000);\n    }\n\n#endif\n\n    digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n  }\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "thingspeak",
        "webserver",
        "api",
        "https",
        "password",
        "key",
        "json",
        "buffer",
        "parse",
        "current",
        "voltage",
        "dns",
        "ntp",
        "spi",
        "i2c",
        "digitalwrite",
        "digitalread",
        "millis",
        "delay",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "nodemcu",
        "devices",
        "sensordht22",
        "sensordht22_label",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "ETH_STA_IPConfig &in_EthSTA_IPconfig",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "ETH_STA_IPConfig in_EthSTA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n\n#endif"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n\n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadCfgFile \"));\n\n  memset((void *) &Ethconfig,       0, sizeof(Ethconfig));\n  memset((void *) &EthSTA_IPconfig, 0, sizeof(EthSTA_IPconfig));\n\n  if (file)\n  {\n    file.readBytes((char *) &Ethconfig,   sizeof(Ethconfig));\n    file.readBytes((char *) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n\n    if ( Ethconfig.checksum != calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) ) )\n    {\n      LOGERROR(F(\"Ethconfig checksum wrong\"));\n\n      return false;\n    }\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(JSON_CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Configuration file not found\"));\n\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n\n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n\n      return false;\n    }\n\n    serializeJson(json, Serial);\n#else\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n\n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n\n    json.printTo(Serial);\n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    if (json.containsKey(ThingSpeakAPI_Label))\n    {\n      strcpy(thingspeakApiKey, json[ThingSpeakAPI_Label]);\n    }\n\n    if (json.containsKey(SensorDht22_Label))\n    {\n      sensorDht22 = json[SensorDht22_Label];\n    }\n\n    if (json.containsKey(PinSDA_Label))\n    {\n      pinSda = json[PinSDA_Label];\n    }\n\n    if (json.containsKey(PinSCL_Label))\n    {\n      pinScl = json[PinSCL_Label];\n    }\n  }\n\n  Serial.println(F(\"\\nConfig file was successfully parsed\"));\n\n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving config file\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  json[ThingSpeakAPI_Label] = thingspeakApiKey;\n  json[SensorDht22_Label] = sensorDht22;\n  json[PinSDA_Label] = pinSda;\n  json[PinSCL_Label] = pinScl;\n\n  // Open file for writing\n  File f = FileFS.open(JSON_CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open config file for writing\"));\n\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig file was successfully saved\"));\n\n  return true;"
        },
        {
          "name": "beginEthernet",
          "parameters": "",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnSwichFS using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  // Initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  beginEthernet();\n\n  initSTAIPConfigStruct(EthSTA_IPconfig);\n\n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Failed to read ConfigFile, using default values\"));\n  }\n\n  unsigned long startedAt = millis();\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP32-XXXXXX\n  //ESP32_W6100_Manager ESP32_W6100_manager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP32_W6100_Manager ESP32_W6100_manager(\"ConfigOnSwitchFS\");\n\n  ESP32_W6100_manager.setDebugOutput(true);\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask)\n  ESP32_W6100_manager.setSTAStaticIPConfig(EthSTA_IPconfig);\n#endif\n\n#if USING_CORS_FEATURE\n  ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  if (loadConfigData())\n  {\n    //If no access point name has been previously entered disable timeout.\n    ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_ETH_MANAGER_NTP\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n\n  //////////////////////////////////\n\n  // Connect ETH now if using STA\n  initEthernet();\n\n  //////////////////////////////////\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    Serial.println(ETH.localIP());\n\n    digitalWrite(LED_BUILTIN, LED_ON); // Turn led on as we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP32_W6100_manager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n    }\n\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ   = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (ESP32_W6100_isConnected())\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(ETH.localIP());\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP32-XXXXXX\n    //ESP32_W6100_Manager ESP32_W6100_manager;\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    ESP32_W6100_Manager ESP32_W6100_manager(\"ConfigOnSwitchFS\");\n\n    //Check if there is stored credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n\n    if (loadConfigData())\n    {\n      //If no access point name has been previously entered disable timeout.\n      ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n    }\n    else\n    {\n      // Enter CP only if no stored SSID on flash and file\n      Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n      initialConfig = true;\n    }\n\n    // Extra parameters to be configured\n    // After connecting, parameter.getValue() will get you the configured value\n    // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n\n    // Thingspeak API Key - this is a straight forward string parameter\n    ESP32_EMParameter p_thingspeakApiKey(ThingSpeakAPI_Label, \"Thingspeak API Key\", thingspeakApiKey, 17);\n\n    // DHT-22 sensor present or not - bool parameter visualized using checkbox, so couple of things to note\n    // - value is always 'T' for true. When the HTML form is submitted this is the value that will be\n    //   sent as a parameter. When unchecked, nothing will be sent by the HTML standard.\n    // - customhtml must be 'type=\"checkbox\"' for obvious reasons. When the default is checked\n    //   append 'checked' too\n    // - labelplacement parameter is WFM_LABEL_AFTER for checkboxes as label has to be placed after the input field\n\n    char customhtml[24] = \"type=\\\"checkbox\\\"\";\n\n    if (sensorDht22)\n    {\n      strcat(customhtml, \" checked\");\n    }\n\n    ESP32_EMParameter p_sensorDht22(SensorDht22_Label, \"DHT-22 Sensor\", \"T\", 2, customhtml, WFM_LABEL_AFTER);\n\n    // I2C SCL and SDA parameters are integers so we need to convert them to char array but\n    // no other special considerations\n    char convertedValue[3];\n    sprintf(convertedValue, \"%d\", pinSda);\n    ESP32_EMParameter p_pinSda(PinSDA_Label, \"I2C SDA pin\", convertedValue, 3);\n    sprintf(convertedValue, \"%d\", pinScl);\n    ESP32_EMParameter p_pinScl(PinSCL_Label, \"I2C SCL pin\", convertedValue, 3);\n\n    //add all parameters here\n    ESP32_W6100_manager.addParameter(&p_thingspeakApiKey);\n    ESP32_W6100_manager.addParameter(&p_sensorDht22);\n    ESP32_W6100_manager.addParameter(&p_pinSda);\n    ESP32_W6100_manager.addParameter(&p_pinScl);\n\n    // Sets timeout in seconds until configuration portal gets turned off.\n    // If not specified device will remain in configuration mode until\n    // switched off via webserver or device is restarted.\n    // ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n#if !USE_DHCP_IP\n#if USE_CONFIGURABLE_DNS\n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n#else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n#endif\n#endif\n\n#if USING_CORS_FEATURE\n    ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n    // Start an access point\n    // and goes into a blocking loop awaiting configuration.\n    // Once the user leaves the portal with the exit button\n    // processing will continue\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n      Serial.print(F(\"Local IP: \"));\n      Serial.println(ETH.localIP());\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ   = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n\n    // Getting posted form values and overriding local variables parameters\n    // Config file is written regardless the connection state\n    strcpy(thingspeakApiKey, p_thingspeakApiKey.getValue());\n    sensorDht22 = (strncmp(p_sensorDht22.getValue(), \"T\", 1) == 0);\n    pinSda = atoi(p_pinSda.getValue());\n    pinScl = atoi(p_pinScl.getValue());\n    // Writing JSON config file to flash for next boot\n    writeConfigFile();\n\n    digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n  }\n\n  // Configuration portal not requested, so run normal loop\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "mqtt",
        "wificlient",
        "esp8266webserver",
        "webserver",
        "https",
        "password",
        "ssl",
        "key",
        "publish",
        "json",
        "buffer",
        "parse",
        "temperature",
        "voltage",
        "current",
        "wifi",
        "i2c",
        "ntp",
        "millis",
        "delay",
        "esp.restart",
        "digitalwrite",
        "digitalread",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "pwm",
        "timer",
        "html",
        "nodemcu",
        "devices",
        "gatewayip"
      ],
      "libraries": [
        "Arduino.h",
        "OneButton.h",
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266WiFiMulti.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"W\"));        // W means connected to WiFi\n  else\n    Serial.print(F(\"N\"));        // N means not connected to WiFi\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 5 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n  // For debug only\n  //Serial.print(F(\"Published Temp = \"));\n  //Serial.println(some_number);\n    \n  MQTT_connect();\n  \n  if (Temperature->publish(some_number)) \n  {\n    //Serial.println(F(\"Failed to send value to Temperature feed!\"));\n    Serial.print(F(\"T\"));        // T means publishing OK\n  }\n  else \n  {\n    //Serial.println(F(\"Value to Temperature feed sucessfully sent!\"));\n    Serial.print(F(\"F\"));        // F means publishing failure\n  }"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      90000L\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  { \n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }\n\n  // Check every PUBLISH_INTERVAL (60) seconds.\n  if ((current_millis > mqtt_publish_timeout) || (mqtt_publish_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      publishMQTT();\n    }\n    \n    mqtt_publish_timeout = current_millis + PUBLISH_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    \n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));\n  }\n  \n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, custom_AIO_SERVER, atoi(custom_AIO_SERVERPORT), custom_AIO_USERNAME, custom_AIO_KEY);\n    \n    Serial.print(F(\"Creating new MQTT object : \"));\n    \n    if (mqtt)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"AIO_SERVER = \")    + custom_AIO_SERVER    + \", AIO_SERVERPORT = \"  + custom_AIO_SERVERPORT);\n      Serial.println(String(\"AIO_USERNAME = \")  + custom_AIO_USERNAME  + \", AIO_KEY = \"         + custom_AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n  }\n  \n  if (!Temperature)\n  {\n    Serial.print(F(\"Creating new MQTT_Pub_Topic,  Temperature = \"));\n    Serial.println(MQTT_Pub_Topic);\n    \n    Temperature = new Adafruit_MQTT_Publish(mqtt, MQTT_Pub_Topic.c_str());\n \n    Serial.print(F(\"Creating new Temperature object : \"));\n    \n    if (Temperature)\n    {\n      Serial.println(F(\"OK\"));\n      Serial.println(String(\"Temperature MQTT_Pub_Topic = \")  + MQTT_Pub_Topic);\n    }\n    else\n      Serial.println(F(\"Failed\"));\n    }"
        },
        {
          "name": "handleClick",
          "parameters": "",
          "body": "Serial.println(F(\"Button clicked!\"));\n  wifi_manager();"
        },
        {
          "name": "handleDoubleClick",
          "parameters": "",
          "body": "Serial.println(F(\"Button double clicked!\"));"
        },
        {
          "name": "handleLongPressStop",
          "parameters": "",
          "body": "Serial.println(F(\"Button pressed for long time and then released!\"));\n  newConfigData();"
        },
        {
          "name": "wifi_manager",
          "parameters": "",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  ESP_WiFiManager ESP_wifiManager(\"ConfigOnSwitchFS-MQTT\");\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n\n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESP_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));\n  }\n  else\n  {\n    ESP_wifiManager.setConfigPortalTimeout(0);\n\n    Serial.print(F(\"No timeout : \"));\n    \n    if (initialConfig)\n    {\n      Serial.println(F(\"DRD or No stored Credentials..\"));\n    }\n    else\n    {\n      Serial.println(F(\"No stored Credentials.\"));\n    }\n  }\n  \n  //Local intialization. Once its business is done, there is no need to keep it around\n\n  // Extra parameters to be configured\n  // After connecting, parameter.getValue() will get you the configured value\n  // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n  // (*** we are not using <custom HTML> and <label placement> ***)\n\n  // AIO_SERVER\n  ESP_WMParameter AIO_SERVER_FIELD(AIO_SERVER_Label, \"AIO SERVER\", custom_AIO_SERVER, custom_AIO_SERVER_LEN /*20*/);\n\n  // AIO_SERVERPORT\n  ESP_WMParameter AIO_SERVERPORT_FIELD(AIO_SERVERPORT_Label, \"AIO SERVER PORT\", custom_AIO_SERVERPORT, custom_AIO_PORT_LEN + 1);\n\n  // AIO_USERNAME\n  ESP_WMParameter AIO_USERNAME_FIELD(AIO_USERNAME_Label, \"AIO USERNAME\", custom_AIO_USERNAME, custom_AIO_USERNAME_LEN /*20*/);\n\n  // AIO_KEY\n  ESP_WMParameter AIO_KEY_FIELD(AIO_KEY_Label, \"AIO KEY\", custom_AIO_KEY, custom_AIO_KEY_LEN /*40*/);\n\n  ESP_wifiManager.addParameter(&AIO_SERVER_FIELD);\n  ESP_wifiManager.addParameter(&AIO_SERVERPORT_FIELD);\n  ESP_wifiManager.addParameter(&AIO_USERNAME_FIELD);\n  ESP_wifiManager.addParameter(&AIO_KEY_FIELD);\n\n  // Sets timeout in seconds until configuration portal gets turned off.\n  // If not specified device will remain in configuration mode until\n  // switched off via webserver or device is restarted.\n  //ESP_wifiManager.setConfigPortalTimeout(120);\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n  \n#if !USE_DHCP_IP    \n  #if USE_CONFIGURABLE_DNS\n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    ESP_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESP_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n  #endif \n#endif  \n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESP_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                   WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n  \n  // Start an access point\n  // and goes into a blocking loop awaiting configuration.\n  // Once the user leaves the portal with the exit button\n  // processing will continue\n  if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n  {\n    Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n  }\n  else\n  {\n    // If you get here you have connected to the WiFi\n    Serial.println(F(\"Connected...yeey :)\"));\n    Serial.print(F(\"Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n\n  // Only clear then save data if CP entered and with new valid Credentials\n  // No CP => stored getSSID() = \"\"\n  if ( String(ESP_wifiManager.getSSID(0)) != \"\" && String(ESP_wifiManager.getSSID(1)) != \"\" )\n  {\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESP_wifiManager.getSSID(i);\n      String tempPW   = ESP_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n  \n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESP_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  // Getting posted form values and overriding local variables parameters\n  // Config file is written regardless the connection state\n  strcpy(custom_AIO_SERVER, AIO_SERVER_FIELD.getValue());\n  strcpy(custom_AIO_SERVERPORT, AIO_SERVERPORT_FIELD.getValue());\n  strcpy(custom_AIO_USERNAME, AIO_USERNAME_FIELD.getValue());\n  strcpy(custom_AIO_KEY, AIO_KEY_FIELD.getValue());\n\n  // Writing JSON config file to flash for next boot\n  writeConfigFile();\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n\n  deleteOldInstances();\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n  createNewInstances();"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Config File not found\"));\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n    \n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    serializeJson(json, Serial);\n    \n#else\n\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n    \n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n    \n    json.printTo(Serial);\n    \n#endif\n\n    // Parse all config file parameters, override\n    // local config variables with parsed values\n    if (json.containsKey(AIO_SERVER_Label))\n    {\n      strcpy(custom_AIO_SERVER, json[AIO_SERVER_Label]);\n    }\n\n    if (json.containsKey(AIO_SERVERPORT_Label))\n    {\n      strcpy(custom_AIO_SERVERPORT, json[AIO_SERVERPORT_Label]);\n    }\n\n    if (json.containsKey(AIO_USERNAME_Label))\n    {\n      strcpy(custom_AIO_USERNAME, json[AIO_USERNAME_Label]);\n    }\n\n    if (json.containsKey(AIO_KEY_Label))\n    {\n      strcpy(custom_AIO_KEY, json[AIO_KEY_Label]);\n    }\n  }\n  \n  Serial.println(F(\"\\nConfig File successfully parsed\"));\n  \n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving Config File\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // JSONify local configuration parameters\n  json[AIO_SERVER_Label]      = custom_AIO_SERVER;\n  json[AIO_SERVERPORT_Label]  = custom_AIO_SERVERPORT;\n  json[AIO_USERNAME_Label]    = custom_AIO_USERNAME;\n  json[AIO_KEY_Label]         = custom_AIO_KEY;\n\n  // Open file for writing\n  File f = FileFS.open(CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open Config File for writing\"));\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig File successfully saved\"));\n  return true;"
        },
        {
          "name": "newConfigData",
          "parameters": "",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;\n  }\n\n  Serial.println(F(\"Connecting to WiFi MQTT (3 attempts)...\"));\n\n  uint8_t attempt = 3;\n  \n  while ((ret = mqtt->connect()) != 0) \n  { \n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 2 seconds...\"));\n    mqtt->disconnect();\n    delay(2000);  // wait 2 seconds\n    attempt--;\n    \n    if (attempt == 0) \n    {\n      Serial.println(F(\"WiFi MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n  \n  Serial.println(F(\"WiFi MQTT connection successful!\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigOnSwichFS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n\n  btn.attachClick(handleClick);\n  btn.attachDoubleClick(handleDoubleClick);\n  btn.attachLongPressStop(handleLongPressStop);\n\n  // Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Mount the filesystem\n  if (FORMAT_FILESYSTEM)\n  {\n    Serial.println(F(\"Forced Formatting.\"));\n    FileFS.format();\n  }\n\n  // Format FileFS if not yet\n#ifdef ESP32\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!FileFS.begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Failed to read configuration file, using default values\"));\n  }\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Can't read Config File, using default values\"));\n  }\n\n  // Load stored data, the addAP ready for MultiWiFi reconnection\n  bool configDataLoaded = loadConfigData();\n\n  // Pretend CP is necessary as we have no AP Credentials\n  initialConfig = true;\n\n  if (configDataLoaded)\n  {\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        initialConfig = false;\n      }\n    }\n  }\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"Open Config Portal without Timeout: No stored WiFi Credentials\"));\n\n    loadConfigData();\n  \n    wifi_manager();\n  }\n  else if ( WiFi.status() != WL_CONNECTED ) \n  {\n    Serial.println(F(\"ConnectMultiWiFi in setup\"));\n   \n    connectMultiWiFi();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// checking button state all the time\n  btn.tick();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "json",
        "buffer",
        "parse",
        "current",
        "voltage",
        "dns",
        "ntp",
        "spi",
        "digitalwrite",
        "digitalread",
        "millis",
        "delay",
        "display",
        "led",
        "flash",
        "littlefs",
        "spiffs",
        "eeprom",
        "rtc",
        "html",
        "nodemcu",
        "gatewayip"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "ETH_STA_IPConfig &in_EthSTA_IPconfig",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "ETH_STA_IPConfig in_EthSTA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n\n#endif"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n\n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadCfgFile \"));\n\n  memset((void *) &Ethconfig,       0, sizeof(Ethconfig));\n  memset((void *) &EthSTA_IPconfig, 0, sizeof(EthSTA_IPconfig));\n\n  if (file)\n  {\n    file.readBytes((char *) &Ethconfig,   sizeof(Ethconfig));\n    file.readBytes((char *) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n\n    if ( Ethconfig.checksum != calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) ) )\n    {\n      LOGERROR(F(\"Ethconfig checksum wrong\"));\n\n      return false;\n    }\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "readConfigFile",
          "parameters": "",
          "body": "// this opens the config file in read-mode\n  File f = FileFS.open(JSON_CONFIG_FILE, \"r\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Configuration file not found\"));\n\n    return false;\n  }\n  else\n  {\n    // we could open the file\n    size_t size = f.size();\n    // Allocate a buffer to store contents of the file.\n    std::unique_ptr<char[]> buf(new char[size + 1]);\n\n    // Read and store file contents in buf\n    f.readBytes(buf.get(), size);\n    // Closing file\n    f.close();\n    // Using dynamic JSON buffer which is not the recommended memory model, but anyway\n    // See https://github.com/bblanchon/ArduinoJson/wiki/Memory%20model\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n    DynamicJsonDocument json(1024);\n    auto deserializeError = deserializeJson(json, buf.get());\n\n    if ( deserializeError )\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n\n      return false;\n    }\n\n    serializeJson(json, Serial);\n#else\n    DynamicJsonBuffer jsonBuffer;\n    // Parse JSON string\n    JsonObject& json = jsonBuffer.parseObject(buf.get());\n\n    // Test if parsing succeeds.\n    if (!json.success())\n    {\n      Serial.println(F(\"JSON parseObject() failed\"));\n      return false;\n    }\n\n    json.printTo(Serial);\n#endif\n  }\n\n  Serial.println(F(\"\\nConfig file was successfully parsed\"));\n\n  return true;"
        },
        {
          "name": "writeConfigFile",
          "parameters": "",
          "body": "Serial.println(F(\"Saving config file\"));\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  DynamicJsonDocument json(1024);\n#else\n  DynamicJsonBuffer jsonBuffer;\n  JsonObject& json = jsonBuffer.createObject();\n#endif\n\n  // Open file for writing\n  File f = FileFS.open(JSON_CONFIG_FILE, \"w\");\n\n  if (!f)\n  {\n    Serial.println(F(\"Failed to open config file for writing\"));\n\n    return false;\n  }\n\n#if (ARDUINOJSON_VERSION_MAJOR >= 6)\n  serializeJsonPretty(json, Serial);\n  // Write data to file and close it\n  serializeJson(json, f);\n#else\n  json.prettyPrintTo(Serial);\n  // Write data to file and close it\n  json.printTo(f);\n#endif\n\n  f.close();\n\n  Serial.println(F(\"\\nConfig file was successfully saved\"));\n\n  return true;"
        },
        {
          "name": "beginEthernet",
          "parameters": "",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ConfigPortalParamsOnSwitch using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n#ifdef ESP32\n\n  if (!FileFS.begin(true))\n#else\n  if (!FileFS.begin())\n#endif\n  {\n#ifdef ESP8266\n    FileFS.format();\n#endif\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  if (!readConfigFile())\n  {\n    Serial.println(F(\"Failed to read configuration file, using default values\"));\n  }\n\n  unsigned long startedAt = millis();\n\n  beginEthernet();\n\n  initSTAIPConfigStruct(EthSTA_IPconfig);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP32-XXXXXX\n  //ESP32_W6100_Manager ESP32_W6100_manager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP32_W6100_Manager ESP32_W6100_manager(\"CP-ParamsOnSW\");\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask)\n  ESP32_W6100_manager.setSTAStaticIPConfig(EthSTA_IPconfig);\n#endif\n\n#if USING_CORS_FEATURE\n  ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  if (loadConfigData())\n  {\n    //If no access point name has been previously entered disable timeout.\n    ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_ETH_MANAGER_NTP\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  //////////////////////////////////\n\n  // Connect ETH now if using STA\n  initEthernet();\n\n  //////////////////////////////////\n\n  if (initialConfig)\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    Serial.println(ETH.localIP());\n\n    digitalWrite(LED_BUILTIN, LED_ON); // Turn led on as we are in configuration mode.\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP32_W6100_manager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ   = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n  }\n\n  digitalWrite(LED_BUILTIN, LED_OFF); // Turn led off as we are not in configuration mode.\n\n  startedAt = millis();\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (ESP32_W6100_isConnected())\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(ETH.localIP());\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP32-XXXXXX\n    //ESP32_W6100_Manager ESP32_W6100_manager;\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    ESP32_W6100_Manager ESP32_W6100_manager(\"CP-ParamsOnSW\");\n\n    //Check if there is stored credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal\"));\n\n    if (loadConfigData())\n    {\n      //If no access point name has been previously entered disable timeout.\n      ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n      Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n    }\n    else\n    {\n      // Enter CP only if no stored SSID on flash and file\n      Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n      initialConfig = true;\n    }\n\n    // Extra parameters to be configured\n    // After connecting, parameter.getValue() will get you the configured value\n    // Format: <ID> <Placeholder text> <default value> <length> <custom HTML> <label placement>\n\n    // Sets timeout in seconds until configuration portal gets turned off.\n    // If not specified device will remain in configuration mode until\n    // switched off via webserver or device is restarted.\n    //ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n#if !USE_DHCP_IP\n#if USE_CONFIGURABLE_DNS\n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n#else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESP32_W6100_manager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n#endif\n#endif\n\n#if USING_CORS_FEATURE\n    ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n    // Start an access point and goes into a blocking loop awaiting configuration.\n    // Once the user leaves the portal with the exit button\n    // processing will continue\n\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n      Serial.print(F(\"Local IP: \"));\n      Serial.println(ETH.localIP());\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ   = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n#if ESP8266\n      configTime(Ethconfig.TZ, \"pool.ntp.org\");\n#else\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n\n    // Getting posted form values and overriding local variables parameters\n    // Config file is written regardless the connection state\n\n    // Writing JSON config file to flash for next boot\n    writeConfigFile();\n\n    digitalWrite(LED_BUILTIN, LED_OFF); // Turn LED off as we are not in configuration mode.\n  }\n\n  // Put your main code here, to run repeatedly...\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "littlefs",
        "spiffs"
      ],
      "libraries": [
        "ArduinoJson.h",
        "ConfigStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    while (!Serial)\n        ;\n\n    delay(200);\n\n    // change parameters\n    exampleInt = configDoc[\"ParaInt\"] + 10;\n    exampleFloat = configDoc[\"ParaFloat\"] + 0.314;\n    exampleText = configDoc[\"ParaText\"] + \" and hello again\";\n\n    // set parameters\n    configDoc[\"ParaInt\"] = exampleInt;\n    configDoc[\"ParaFloat\"] = exampleFloat;\n    configDoc[\"ParaText\"] = exampleText;\n\n    // save configuration as file\n    CS.set(configDoc);\n    CS.save();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https"
      ],
      "libraries": [
        "ArduinoJson.h",
        "ConfigStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": ""
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wifiserver",
        "http",
        "wificlient",
        "https",
        "password",
        "parse",
        "wifi",
        "delay",
        "html"
      ],
      "libraries": [
        "WiFiEspAT.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(AT_BAUD_RATE);\n  WiFi.init(Serial1);\n\n  if (WiFi.status() == WL_NO_MODULE) {\n    Serial.println();\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }\n\n  WiFi.disconnect(); // stop the persistent connection to test the Configuration AP\n\n  // waiting for connection to Wifi network set with the SetupWiFiConnection sketch\n  Serial.println();\n  Serial.println(\"Waiting for connection to WiFi\");\n  for (int i = 0; i < 5; i++) {\n    if (WiFi.status() == WL_CONNECTED)\n      break;\n    delay(1000);\n    Serial.print('.');\n  }\n  Serial.println();\n\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println();\n    Serial.println(\"Could not connect to WiFi. Starting configuration AP...\");\n    configAP();\n  } else {\n    Serial.println(\"You're connected to the network\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        },
        {
          "name": "configAP",
          "parameters": "",
          "body": "WiFiServer server(80);\n\n  WiFi.beginAP(); // starts the default AP (factory default or setup as persistent)\n\n  char ssid[33];\n  WiFi.apSSID(ssid);\n  Serial.print(\"Connect your computer to the WiFi network \");\n  Serial.print(ssid);\n  Serial.println();\n  IPAddress ip = WiFi.apIP();\n  Serial.print(\"and enter http://\");\n  Serial.print(ip);\n  Serial.println(\" in a Web browser\");\n\n  server.begin();\n\n  while (true) {\n\n    WiFiClient client = server.available();\n    if (client && client.available()) { // if !available yet, we return to this client in next loop\n      char line[64];\n      int l = client.readBytesUntil('\\n', line, sizeof(line));\n      line[l] = 0;\n      client.find((char*) \"\\r\\n\\r\\n\");\n\n      if (strncmp_P(line, PSTR(\"POST\"), strlen(\"POST\")) == 0) {\n        l = client.readBytes(line, sizeof(line));\n        line[l] = 0;\n\n        // parse the parameters sent by the html form\n        const char* delims = \"=&\";\n        strtok(line, delims);\n        const char* ssid = strtok(NULL, delims);\n        strtok(NULL, delims);\n        const char* pass = strtok(NULL, delims);\n\n        // send a response before attemting to connect to the WiFi network\n        // because it will reset the SoftAP and disconnect the client station\n        client.println(F(\"HTTP/1.1 200 OK\"));\n        client.println(F(\"Connection: close\"));\n        client.println(F(\"Refresh: 10\"));\n        client.println();\n        client.println(F(\"<html><body><h3>Configuration AP</h3><br>connecting...</body></html>\"));\n        client.flush();\n        delay(1000);\n        client.stop();\n\n        Serial.println();\n        Serial.print(\"Attempting to connect to WPA SSID: \");\n        Serial.println(ssid);\n        // WiFi.setPersistent(); // to make a successful connection persistent\n        WiFi.begin(ssid, pass);\n\n        // configuration continues with the next request\n\n      } else {\n\n        client.println(F(\"HTTP/1.1 200 OK\"));\n        client.println(F(\"Connection: close\"));\n        client.println();\n        client.println(F(\"<html><body><h3>Configuration AP</h3><br>\"));\n\n        int status = WiFi.status();\n        if (status == WL_CONNECTED) {\n          client.println(F(\"Connection successful. Ending AP.\"));\n        } else {\n          client.println(F(\"<form action='/' method='POST'>WiFi connection failed. Enter valid parameters, please.<br><br>\"));\n          client.println(F(\"SSID:<br><input type='text' name='i'><br>\"));\n          client.println(F(\"Password:<br><input type='password' name='p'><br><br>\"));\n          client.println(F(\"<input type='submit' value='Submit'></form>\"));\n        }\n        client.println(F(\"</body></html>\"));\n        client.stop();\n\n        if (status == WL_CONNECTED) {\n          delay(1000); // to let the AT firmware finish the communication\n          Serial.println(\"Connection successful. Ending AP.\");\n          server.end();\n          WiFi.endAP(true);\n          return;\n        }\n      }\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "menu.h",
        "menuIO/serialOut.h",
        "menuIO/serialIn.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"menu 4.x custom sub-menu prompt example\");Serial.flush();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (running) nav.poll();\n  delay(100);//simulate a delay when other tasks are done"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "encryption",
        "wifi",
        "spi",
        "delay",
        "gatewayip"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\");\n    // don't continue:\n    while (true);\n  }\n\n  // attempt to connect to WiFi network:\n  while ( status != WL_CONNECTED) {\n    Serial.print(\"Attempting to connect to open SSID: \");\n    Serial.println(ssid);\n    status = WiFi.begin(ssid);\n\n    // wait 10 seconds for connection:\n    delay(10000);\n  }\n\n  // you're connected now, so print out the data:\n  Serial.print(\"You're connected to the network\");\n  printCurrentNet();\n  printWiFiData();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWiFiData",
          "parameters": "",
          "body": "// print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(\"MAC address: \");\n  printMacAddress(mac);\n\n  // print your subnet mask:\n  IPAddress subnet = WiFi.subnetMask();\n  Serial.print(\"NetMask: \");\n  Serial.println(subnet);\n\n  // print your gateway address:\n  IPAddress gateway = WiFi.gatewayIP();\n  Serial.print(\"Gateway: \");\n  Serial.println(gateway);"
        },
        {
          "name": "printCurrentNet",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(\"BSSID: \");\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(\"Encryption Type:\");\n  Serial.println(encryption, HEX);"
        },
        {
          "name": "printMacAddress",
          "parameters": "byte mac[]",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");\n    }\n    Serial.print(mac[i], HEX);\n    if (i > 0) {\n      Serial.print(\":\");\n    }\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "https",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "printWifiData",
          "parameters": "",
          "body": "// print your WiFi shield's IP address\n  IPAddress ip = WiFi.localIP();\n  \n  Serial.print(F(\"IP Address: \"));\n  Serial.println(ip);\n\n  // print your MAC address\n  byte mac[6];\n  WiFi.macAddress(mac);\n  \n  char buf[20];\n  \n  sprintf_P(buf, PSTR(\"%02X:%02X:%02X:%02X:%02X:%02X\"), mac[5], mac[4], mac[3], mac[2], mac[1], mac[0]);\n  \n  Serial.print(F(\"MAC address: \"));\n  Serial.println(buf);"
        },
        {
          "name": "printCurrentNet",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to\n  Serial.print(F(\"SSID: \"));\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  \n  char buf[20];\n  \n  sprintf_P(buf, PSTR(\"%02X:%02X:%02X:%02X:%02X:%02X\"), bssid[5], bssid[4], bssid[3], bssid[2], bssid[1], bssid[0]);\n  \n  Serial.print(F(\"BSSID: \"));\n  Serial.println(buf);\n\n  // print the received signal strength\n  long rssi = WiFi.RSSI();\n  Serial.print(F(\"Signal strength (RSSI): \"));\n  Serial.println(rssi);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting ConnectWPA on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE); \n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  }\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    Serial.print(F(\"Connecting to WPA SSID: \"));\n    Serial.println(ssid);\n    \n    // Connect to WPA/WPA2 network\n    status = WiFi.begin(ssid, pass);\n  }\n\n  Serial.println(F(\"You're connected to the network\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// print the network connection information every 10 seconds\n  Serial.println();\n  printCurrentNet();\n  printWifiData();\n\n  delay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h",
        "ESP_AT_Lib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(1000);\n\n#if defined(BOARD_NAME)\n  Serial.println(\"\\nStart ConnectWiFi on \" + String(BOARD_NAME));\n#else\n  Serial.println(\"\\nStart ConnectWiFi\");\n#endif\n\n  Serial.println(ESP_AT_LIB_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(ESP_AT_BAUD);\n\n  Serial.print(\"FW Version: \");\n  Serial.println(wifi.getVersion().c_str());\n\n\n  if (wifi.setOprToStation())\n  {\n    Serial.println(\"Set STA Mode OK\");\n  }\n  else\n  {\n    Serial.println(\"Set STA Mode failed\");\n  }\n\n  if (wifi.joinAP(SSID, PASSWORD))\n  {\n    Serial.println(\"Connect to WiFi OK\");\n    Serial.print(\"IP: \");\n    Serial.println(wifi.getLocalIP().c_str());\n  }\n  else\n  {\n    Serial.println(\"Connect to WiFi failed\");\n  }\n\n  Serial.println(\"Done\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "password",
        "encryption",
        "wifi",
        "spi",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\");\n    // don't continue:\n    while (true);\n  }\n\n  // attempt to connect to WiFi network:\n  while ( status != WL_CONNECTED) {\n    Serial.print(\"Attempting to connect to WEP network, SSID: \");\n    Serial.println(ssid);\n    status = WiFi.begin(ssid, keyIndex, key);\n\n    // wait 10 seconds for connection:\n    delay(10000);\n  }\n\n  // once you are connected :\n  Serial.print(\"You're connected to the network\");\n  printCurrentNet();\n  printWiFiData();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWiFiData",
          "parameters": "",
          "body": "// print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(\"MAC address: \");\n  printMacAddress(mac);"
        },
        {
          "name": "printCurrentNet",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(\"BSSID: \");\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(\"Encryption Type:\");\n  Serial.println(encryption, HEX);\n  Serial.println();"
        },
        {
          "name": "printMacAddress",
          "parameters": "byte mac[]",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");\n    }\n    Serial.print(mac[i], HEX);\n    if (i > 0) {\n      Serial.print(\":\");\n    }\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "key",
        "encryption",
        "wifi",
        "spi",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\");\n    // don't continue:\n    while (true);\n  }\n\n  // attempt to connect to WiFi network:\n  while ( status != WL_CONNECTED) {\n    Serial.print(\"Attempting to connect to WPA SSID: \");\n    Serial.println(ssid);\n    // Connect to WPA/WPA2 network:\n    status = WiFi.begin(ssid, pass);\n\n    // wait 10 seconds for connection:\n    delay(10000);\n  }\n\n  // you're connected now, so print out the data:\n  Serial.print(\"You're connected to the network\");\n  printCurrentNet();\n  printWiFiData();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWiFiData",
          "parameters": "",
          "body": "// print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(\"MAC address: \");\n  printMacAddress(mac);"
        },
        {
          "name": "printCurrentNet",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(\"BSSID: \");\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(\"Encryption Type:\");\n  Serial.println(encryption, HEX);\n  Serial.println();"
        },
        {
          "name": "printMacAddress",
          "parameters": "byte mac[]",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");\n    }\n    Serial.print(mac[i], HEX);\n    if (i > 0) {\n      Serial.print(\":\");\n    }\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "encryption",
        "current",
        "wifi",
        "spi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h",
        "arduino_secrets.h",
        "SPI.h",
        "WiFiNINA_Generic.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStart ConnectWithWPA2Enterprise on \"));\n  Serial.println(BOARD_NAME);\n  Serial.println(WIFININA_GENERIC_VERSION);\n  \n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"Communication with WiFi module failed!\"));\n\n    // don't continue\n    while (true);\n  }\n\n  String fv = WiFi.firmwareVersion();\n\n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.print(F(\"Your current firmware NINA FW v\"));\n    Serial.println(fv);\n    Serial.print(F(\"Please upgrade the firmware to NINA FW v\"));\n    Serial.println(WIFI_FIRMWARE_LATEST_VERSION);\n  }\n\n  // attempt to connect to WiFi network:\n  while (status != WL_CONNECTED)\n  {\n    Serial.print(F(\"Attempting to connect to open SSID: \"));\n    Serial.println(ssid);\n    // Connect to WPA2 enterprise network:\n    // - You can optionally provide additional identity and CA cert (string) parameters:\n    //      WiFi.beginEnterprise(ssid, user, pass, identity, caCert)\n    // . if your network requires them.\n    status = WiFi.beginEnterprise(ssid, user, pass);\n\n    // wait 10 seconds for connection:\n    delay(10000);\n  }\n\n  // you're connected now, so print out the data:\n  Serial.print(F(\"You're connected to the network\"));\n  printCurrentNet();\n  printWifiData();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check the network connection once every 10 seconds:\n  delay(10000);\n  printCurrentNet();"
        },
        {
          "name": "printWifiData",
          "parameters": "",
          "body": "// print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(F(\"IP Address: \"));\n  Serial.println(ip);\n  Serial.println(ip);\n\n  // print your MAC address:\n  byte mac[6];\n  WiFi.macAddress(mac);\n  Serial.print(F(\"MAC address: \"));\n  printMacAddress(mac);"
        },
        {
          "name": "printCurrentNet",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(F(\"SSID: \"));\n  Serial.println(WiFi.SSID());\n\n  // print the MAC address of the router you're attached to:\n  byte bssid[6];\n  WiFi.BSSID(bssid);\n  Serial.print(F(\"BSSID: \"));\n  printMacAddress(bssid);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(F(\"signal strength (RSSI):\"));\n  Serial.println(rssi);\n\n  // print the encryption type:\n  byte encryption = WiFi.encryptionType();\n  Serial.print(F(\"Encryption Type:\"));\n  Serial.println(encryption, HEX);"
        },
        {
          "name": "printMacAddress",
          "parameters": "byte mac[]",
          "body": "for (int i = 5; i >= 0; i--)\n  {\n    if (mac[i] < 16)\n    {\n      Serial.print(F(\"0\"));\n    }\n\n    Serial.print(mac[i], HEX);\n\n    if (i > 0)\n    {\n      Serial.print(F(\":\"));\n    }\n  }\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wifi"
      ],
      "libraries": [
        "WiFi.h",
        "Arduino_MultiWiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Wait until the serial port is connected\n    Serial.begin(9600);\n    while (!Serial) {}\n\n    // Configure the known networks (first one gets higher priority)\n    multi.add(\"myssid\", \"mypassphrase\");\n    multi.add(\"myssid_2\", \"mypassphrase_2\");\n\n    // Connect to the first available network\n    Serial.println(\"Looking for a network...\");\n    if (multi.run() == WL_CONNECTED) {\n        Serial.print(\"Successfully connected to network: \");\n        Serial.println(WiFi.SSID());\n    } else {\n        Serial.println(\"Failed to connect to a WiFi network\");\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wifi"
      ],
      "libraries": [
        "WiFiNINA.h",
        "Arduino_MultiWiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Wait until the serial port is connected\n    Serial.begin(9600);\n    while (!Serial) {}\n\n    // Configure the known networks (first one gets higher priority)\n    multi.add(\"myssid\", \"mypassphrase\");\n    multi.add(\"myssid_2\", \"mypassphrase_2\");\n\n    // Connect to the first available network\n    Serial.println(\"Looking for a network...\");\n    if (multi.run() == WL_CONNECTED) {\n        Serial.print(\"Successfully connected to network: \");\n        Serial.println(WiFi.SSID());\n    } else {\n        Serial.println(\"Failed to connect to a WiFi network\");\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "i2c",
        "lora",
        "uart",
        "millis",
        "delay",
        "display"
      ],
      "libraries": [
        "Notecard.h",
        "Arduino_ConnectionHandler.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial debug port and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n\n  /* Add callbacks to the ConnectionHandler object to get notified of network\n   * connection events. */\n  conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n  conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n  conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n  /* First call to `check()` initializes the connection to the Notecard. While\n   * not strictly necessary, it cleans up the logging from this application.\n   */\n  conMan.check();\n\n#ifndef USE_NOTE_LORA\n  /* Set the Wi-Fi credentials for the Notecard */\n  String ssid = SECRET_WIFI_SSID;\n  if (ssid.length() > 0 && ssid != \"NETWORK NAME\") {\n    conMan.setWiFiCredentials(SECRET_WIFI_SSID, SECRET_WIFI_PASS);\n  }\n#else\n  conMan.setNotehubPollingInterval(720);  // poll twice per day\n#endif\n\n  /* Confirm Interface */\n  Serial.print(\"Network Adapter Interface: \");\n  if (NetworkAdapter::NOTECARD == conMan.getInterface()) {\n    Serial.print(\"Notecard \");\n    Serial.print(conMan.getNotecardUid());\n#ifndef UART_INTERFACE\n    Serial.println(\" (via I2C)\");\n#else\n    Serial.println(\" (via UART)\");\n#endif\n  } else {\n    Serial.println(\"ERROR: Unexpected Interface\");\n    while(1);\n  }\n\n  /* Display the Arduino IoT Cloud Device ID */\n  displayCachedDeviceId();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Toggle the connection every `CONN_TOGGLE_MS` milliseconds */\n  if ((millis() - lastConnToggleMs) > CONN_TOGGLE_MS) {\n    Serial.println(\"Toggling connection...\");\n    if (attemptConnect) {\n      displayCachedDeviceId();\n      conMan.connect();\n    } else {\n      // Flush any queued Notecard requests before disconnecting\n      conMan.initiateNotehubSync(NotecardConnectionHandler::SyncType::Outbound);\n      conMan.disconnect();\n    }\n    attemptConnect = !attemptConnect;\n    lastConnToggleMs = millis();\n  }\n\n  /* The following code keeps on running connection workflows on our\n   * ConnectionHandler object, hence allowing reconnection in case of failure\n   * and notification of connect/disconnect event if enabled (see\n   * addConnectCallback/addDisconnectCallback) NOTE: any use of delay() within\n   * the loop or methods called from it will delay the execution of .update(),\n   * which might not guarantee the correct functioning of the ConnectionHandler\n   * object.\n   */\n  conMan.check();"
        },
        {
          "name": "displayCachedDeviceId",
          "parameters": "",
          "body": "Serial.print(\"Cached Arduino IoT Cloud Device ID: \");\n  Serial.println(conMan.getDeviceId());"
        },
        {
          "name": "onNetworkConnect",
          "parameters": "",
          "body": "Serial.println(\">>>> CONNECTED to network\");"
        },
        {
          "name": "onNetworkDisconnect",
          "parameters": "",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "parameters": "",
          "body": "Serial.println(\">>>> ERROR\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "password",
        "https",
        "wifi",
        "gsm",
        "lora",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino_ConnectionHandler.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/* Initialize serial debug port and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) { }\n\n#ifndef __AVR__\n  /* Set the debug message level:\n   * - DBG_ERROR: Only show error messages\n   * - DBG_WARNING: Show warning and error messages\n   * - DBG_INFO: Show info, warning, and error messages\n   * - DBG_DEBUG: Show debug, info, warning, and error messages\n   * - DBG_VERBOSE: Show all messages\n   */\n  setDebugMessageLevel(DBG_INFO);\n#endif\n\n  /* Add callbacks to the ConnectionHandler object to get notified of network\n   * connection events. */\n  conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n  conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n  conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n  Serial.print(\"Network Adapter Interface: \");\n  switch (conMan.getInterface()) {\n    case NetworkAdapter::WIFI:\n      Serial.println(\"Wi-Fi\");\n      break;\n    case NetworkAdapter::ETHERNET:\n      Serial.println(\"Ethernet\");\n      break;\n    case NetworkAdapter::NB:\n      Serial.println(\"Narrowband\");\n      break;\n    case NetworkAdapter::GSM:\n      Serial.println(\"GSM\");\n      break;\n    case NetworkAdapter::LORA:\n      Serial.println(\"LoRa\");\n      break;\n    case NetworkAdapter::CATM1:\n      Serial.println(\"Category M1\");\n      break;\n    case NetworkAdapter::CELL:\n      Serial.println(\"Cellular\");\n      break;\n    default:\n      Serial.println(\"Unknown\");\n      break;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Toggle the connection every `CONN_TOGGLE_MS` milliseconds */\n  if ((millis() - lastConnToggleMs) > CONN_TOGGLE_MS) {\n    Serial.println(\"Toggling connection...\");\n    if (attemptConnect) {\n      conMan.connect();\n    } else {\n      conMan.disconnect();\n    }\n    attemptConnect = !attemptConnect;\n    lastConnToggleMs = millis();\n  }\n\n  /* The following code keeps on running connection workflows on our\n   * ConnectionHandler object, hence allowing reconnection in case of failure\n   * and notification of connect/disconnect event if enabled (see\n   * addConnectCallback/addDisconnectCallback) NOTE: any use of delay() within\n   * the loop or methods called from it will delay the execution of .update(),\n   * which might not guarantee the correct functioning of the ConnectionHandler\n   * object.\n   */\n  conMan.check();"
        },
        {
          "name": "onNetworkConnect",
          "parameters": "",
          "body": "Serial.println(\">>>> CONNECTED to network\");"
        },
        {
          "name": "onNetworkDisconnect",
          "parameters": "",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "parameters": "",
          "body": "Serial.println(\">>>> ERROR\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "delay",
        "millis",
        "timer"
      ],
      "libraries": [
        "TinyMLShield.h",
        "Arduino_CRC32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!Camera.begin(QCIF, RGB565, 5, OV7675)) {\n    Serial.println(\"Failed to initialize camera!\");\n    while (1);\n  }\n\n  bytesPerFrame = Camera.width() * Camera.height() * Camera.bytesPerPixel();\n\n  // Enable the test pattern so we have a fixed image to run a checksum against\n  Camera.testPattern();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// sliding delay window to try different start times wrt camera VSYNC\n  if (delayTime>0) {delayTime=delayTime-10;}\n  delay(delayTime);\n  \n  // benchmarking\n  timer = millis();\n  Camera.readFrame(data);\n  timer = millis() - timer;\n  // Check if it is a best case or worse case time\n  bestTime = min(timer, bestTime);\n  worstTime = max(timer, worstTime);\n\n  // Test against known checksum values (minor pixel variations at the start but were visually confirmed to be a good test pattern)\n  uint32_t const crc32_res = crc32.calc(data, bytesPerFrame);\n  if (crc32_res != 0x15AB2939 && crc32_res != 0xD3EC95E && crc32_res != 0xB9C43ED9) {\n    errors++;\n  };\n\n  count++;\n\n  Serial.print(\" errors:\");\n  Serial.print(errors);\n  Serial.print(\"/\");\n  Serial.print(count);\n  Serial.print(\" best:\");\n  Serial.print(bestTime);\n  Serial.print(\"ms worst:\");\n  Serial.print(worstTime);\n  Serial.println(\"ms\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "buffer"
      ],
      "libraries": [
        "Console.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize Console and wait for port to open:\n  Bridge.begin();\n  Console.begin();\n\n  // Uncomment the following line to enable buffering:\n  // - better transmission speed and efficiency\n  // - needs to call Console.flush() to ensure that all\n  //   transmitted data is sent\n\n  //Console.buffer(64);\n\n  while (!Console) {\n    ; // wait for Console port to connect.\n  }\n\n  // prints title with ending line break\n  Console.println(\"ASCII Table ~ Character Map\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// prints value unaltered, i.e. the raw binary version of the\n  // byte. The Console monitor interprets all bytes as\n  // ASCII, so 33, the first number,  will show up as '!'\n  Console.write(thisByte);\n\n  Console.print(\", dec: \");\n  // prints value as string as an ASCII-encoded decimal (base 10).\n  // Decimal is the  default format for Console.print() and Console.println(),\n  // so no modifier is needed:\n  Console.print(thisByte);\n  // But you can declare the modifier for decimal if you want to.\n  //this also works if you uncomment it:\n\n  // Console.print(thisByte, DEC);\n\n  Console.print(\", hex: \");\n  // prints value as string in hexadecimal (base 16):\n  Console.print(thisByte, HEX);\n\n  Console.print(\", oct: \");\n  // prints value as string in octal (base 8);\n  Console.print(thisByte, OCT);\n\n  Console.print(\", bin: \");\n  // prints value as string in binary (base 2)\n  // also prints ending line break:\n  Console.println(thisByte, BIN);\n\n  // if printed last visible character '~' or 126, stop:\n  if (thisByte == 126) {    // you could also use if (thisByte == '~') {\n    // ensure the latest bit of data is sent\n    Console.flush();\n\n    // This loop loops forever and does nothing\n    while (true) {\n      continue;\n    }\n  }\n  // go on to the next character\n  thisByte++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "password",
        "buffer",
        "digitalwrite",
        "led"
      ],
      "libraries": [
        "Console.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Bridge.begin();   // Initialize Bridge\n  Console.begin();  // Initialize Console\n\n  // Wait for the Console port to connect\n  while (!Console);\n\n  Console.println(\"type H or L to turn pin 13 on or off\");\n\n  // initialize the LED pin as an output:\n  pinMode(ledPin, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// see if there's incoming Console data:\n  if (Console.available() > 0) {\n    // read the oldest byte in the Console buffer:\n    incomingByte = Console.read();\n    Console.println(incomingByte);\n    // if it's a capital H (ASCII 72), turn on the LED:\n    if (incomingByte == 'H') {\n      digitalWrite(ledPin, HIGH);\n    }\n    // if it's an L (ASCII 76) turn off the LED:\n    if (incomingByte == 'L') {\n      digitalWrite(ledPin, LOW);\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "password",
        "buffer",
        "delay"
      ],
      "libraries": [
        "Console.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize Console and wait for port to open:\n  Bridge.begin();\n  Console.begin();\n\n  // Wait for Console port to connect\n  while (!Console);\n\n  Console.println(\"Hi, what's your name?\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (Console.available() > 0) {\n    char c = Console.read(); // read the next char received\n    // look for the newline character, this is the last character in the string\n    if (c == '\\n') {\n      //print text with the name received\n      Console.print(\"Hi \");\n      Console.print(name);\n      Console.println(\"! Nice to meet you!\");\n      Console.println();\n      // Ask again for name and clear the old name\n      Console.println(\"Hi, what's your name?\");\n      name = \"\";  // clear the name string\n    } else {  \t // if the buffer is empty Cosole.read() returns -1\n      name += c; // append the read char from Console to the name string\n    }\n  } else {\n    delay(100);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "key",
        "callback",
        "wifi",
        "digitalread",
        "millis",
        "delay",
        "debounce",
        "nodebug_websockets",
        "deviceid",
        "devices"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "SinricPro_Generic.h",
        "SinricProContactsensor.h"
      ],
      "functions": [
        {
          "name": "handleContactsensor",
          "parameters": "",
          "body": "if (!myPowerState) return;                            // if device switched off...do nothing\n\n  unsigned long actualMillis = millis();\n  \n  if (actualMillis - lastChange < 250) \n    return;          // debounce contact state transitions (same as debouncing a pushbutton)\n\n  bool actualContactState = digitalRead(CONTACT_PIN);   // read actual state of contactsensor\n\n  if (actualContactState != lastContactState) \n  {         \n    // if state has changed\n    Serial.printf(\"Contactsensor is %s now\\r\\n\", actualContactState ? \"open\" : \"closed\");\n    \n    lastContactState = actualContactState;              // update last known state\n    lastChange = actualMillis;                          // update debounce time\n    SinricProContactsensor &myContact = SinricPro[CONTACT_ID]; // get contact sensor device\n    myContact.sendContactEvent(actualContactState);      // send event with actual state\n  }"
        },
        {
          "name": "onPowerState",
          "parameters": "const String &deviceId, bool &state",
          "body": "Serial.printf(\"Device %s turned %s (via SinricPro) \\r\\n\", deviceId.c_str(), state ? \"on\" : \"off\");\n  myPowerState = state;\n  \n  return true; // request handled properly"
        },
        {
          "name": "setupWiFi",
          "parameters": "",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);\n  }\n  \n  Serial.print(\"\\n[WiFi]: IP-Address is \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "setupSinricPro",
          "parameters": "",
          "body": "// add device to SinricPro\n  SinricProContactsensor& myContact = SinricPro[CONTACT_ID];\n\n  // set callback function to device\n  myContact.onPowerState(onPowerState);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");\n  });\n  \n  SinricPro.onDisconnected([]() \n  {\n    Serial.println(\"Disconnected from SinricPro\");\n  });\n  \n  SinricPro.begin(APP_KEY, APP_SECRET);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting ContactSensor on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n\n  pinMode(CONTACT_PIN, INPUT);\n\n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "handleContactsensor();\n  SinricPro.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "i2c",
        "digitalwrite",
        "digitalread",
        "lcd"
      ],
      "libraries": [
        "LCD_ST7032.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(contrastButtonPin, INPUT);\n  digitalWrite(contrastButtonPin, HIGH);\n  lcd.begin();\n  lcd.setcontrast(24); //contrast value range is 0-63, try 25@5V or 50@3.3V as a starting value"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "boolean a = digitalRead(contrastButtonPin);\n  if (a != lastButtonState) {\n    if (!a) {\n      lcd.adjcontrast(1); //increase contrast (-1 to decrease)\n    }\n    lastButtonState = a;\n  }\n\n  lcd.setCursor(0, 0);  //LINE 1 ADDRESS 0\n  lcd.print(\"Contrast value:\");\n  lcd.setCursor(1, 0);  //LINE 2 ADDRESS 0\n  byte c = lcd.getcontrast();\n  lcd.print(c, DEC);\n  lcd.write(' ');"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "key",
        "wifi",
        "millis",
        "analogread",
        "delay",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h",
        "adcMonitorPmem.h"
      ],
      "functions": [
        {
          "name": "initAdcadcPins",
          "parameters": "",
          "body": "for (byte i = 0; i < sizeof(adcPins) / sizeof(int); i++) {\n    LOG_I(\"Init pin no: %i\\n\", adcPins[i]);\n    pinMode(adcPins[i], INPUT);\n    ctrl.bind( (\"adc_\" + String(adcPins[i])).c_str() );\n  }\n  // Get positions of the variables\n  for (byte i = 0; i < sizeof(adcPins) / sizeof(int); i ++) {\n    ctrlsNdx[i] = ctrl.getKeyNdx((\"adc_\" + String(adcPins[i])).c_str());\n  }"
        },
        {
          "name": "readAdcadcPins",
          "parameters": "",
          "body": "for (byte i = 0; i < sizeof(adcPins) / sizeof(int); i++) {\n    uint16_t v = analogRead( adcPins[i]);\n    ctrl.set(ctrlsNdx[i], v);\n    LOG_N(\"Read pin no: %i = %u\\n\", adcPins[i], v);\n  }"
        },
        {
          "name": "speedChange",
          "parameters": "",
          "body": "LOG_V(\"speedChange  %s\\n\", ctrl[\"speed\"].c_str());\n speed = ctrl[\"speed\"].toInt();"
        },
        {
          "name": "changeOnOff",
          "parameters": "",
          "body": "LOG_V(\"changeOnOff  %li\\n\", ctrl[\"on-off\"].toInt());\n isPlaying = ctrl[\"on-off\"].toInt();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n  // Generate body html and JavaScripts\n  ctrl.setHtmlHeaders(CONTROLASSIST_HTML_HEADER);\n  static String htmlBody(CONTROLASSIST_HTML_BODY);\n  String barsScripts=\"\";\n  for (byte i = 0; i < sizeof(adcPins) / sizeof(int); i = i + 1) {\n    String bar(CONTROLASSIST_HTML_BAR);\n    bar.replace(\"{key}\", String(adcPins[i]));\n    htmlBody += bar;\n\n    String barScript(CONTROLASSIST_HTML_BAR_SCRIPT);\n    barScript.replace(\"{key}\", String(adcPins[i]));\n    barsScripts += barScript;\n  }\n\n  // Setup control assist\n  ctrl.setHtmlBody(htmlBody.c_str());\n  static String htmlFooter(CONTROLASSIST_HTML_FOOTER);\n  htmlFooter.replace(\"/*{SUB_SCRIPT}*/\",barsScripts);\n  ctrl.setHtmlFooter(htmlFooter.c_str());\n\n  // Bind controls\n  ctrl.bind(\"on-off\", isPlaying, changeOnOff);\n  ctrl.bind(\"speed\", speed, speedChange);\n  // Handle web server root request and send html to client\n  // Auto send all previous vars on ws connection\n  ctrl.setAutoSendOnCon(true);\n  // Init and bind all pins\n  initAdcadcPins();\n\n  // Start web sockets\n  ctrl.begin();\n  LOG_I(\"ControlAssist started.\\n\");\n\n  // Add a web server handler on url \"/\"\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n  // Dump binded controls handler\n  server.on(\"/d\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    server.sendContent(\"Serial dump\\n\");\n    String res = \"\";\n    while( ctrl.dump(res) ){\n      server.sendContent(res);\n    }\n  });\n   // Start webserver\n  server.begin();\n  LOG_I(\"HTTP server started\\n\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - pingMillis >= speed){\n    if(isPlaying) readAdcadcPins();\n    pingMillis = millis();\n  }\n\n  #if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); //Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "buffer",
        "wifi",
        "millis",
        "delay",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h",
        "remoteLogViewer.h"
      ],
      "functions": [
        {
          "name": "debugMemory",
          "parameters": "const char* caller",
          "body": "#if defined(ESP32)\n    LOG_D(\"%s > Free: heap %u, block: %u, pSRAM %u\\n\", caller, ESP.getFreeHeap(), heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL), ESP.getFreePsram());\n  #else\n    LOG_D(\"%s > Free: heap %u\\n\", caller, ESP.getFreeHeap());\n  #endif"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n\n  // Setup the remote web debugger in order to store log lines, url \"/log\"\n  // When no connection is present store log lines in a buffer until connection\n  remoteLogView.setup();\n\n  LOG_I(\"Starting..\\n\");\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_D(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n  // Start web lgo viewer sockets\n  remoteLogView.begin();\n  LOG_I(\"RemoteLogViewer started.\\n\");\n\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.send(200, \"text/html\", \"<h1>This is root page</h1><br><a target='_new' href='/log'>View log</a>\");\n  });\n\n  // Setup log handler\n  server.on(\"/log\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    while( remoteLogView.getHtmlChunk(res) ){\n      server.sendContent(res);\n    }\n    server.sendContent(\"\");\n  });\n\n  // Start webserver\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - pingMillis >= 2000){\n    debugMemory(\"Loop\");\n    pingMillis = millis();\n  }\n\n  #if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  remoteLogView.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "key",
        "wifi",
        "millis",
        "delay",
        "display",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "disconnect",
          "parameters": "",
          "body": "LOG_D(\"Disconnect WiFi for %s seconds\\n\", String(disconTime / 1000L).c_str());\n  ctrl.put(\"wifi_rssi\",  -120 );\n  ctrl.loop();\n  ctrl.sendSystemMsg(\"C\");\n  time_t s = millis();\n  while(millis() - s < 100 )\n    ctrl.loop();\n  WiFi.disconnect();\n  disconnMillis = millis();"
        },
        {
          "name": "changeHandler",
          "parameters": "uint8_t ndx",
          "body": "String key = ctrl[ndx].key;\n  if(key == \"sleep_time\" )\n    disconTime = ctrl[key].toInt() * 1000;\n  else if(key == \"disconnect_button\")\n    disconnect();\n\n  LOG_D(\"changeHandler: ndx: %02i, key: %s = %s\\n\",ndx, key.c_str(), ctrl[key].c_str());"
        },
        {
          "name": "connect",
          "parameters": "",
          "body": "if(WiFi.status() == WL_CONNECTED ) return;\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n  // Connect WiFi\n  connect();\n\n  // Control assist setup\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.bind(\"mac_address\", WiFi.macAddress().c_str() );\n  ctrl.bind(\"wifi_rssi\");\n  ctrl.bind(\"sleep_time\", disconTime / 1000);\n  ctrl.bind(\"disconnect_button\");\n  ctrl.setAutoSendOnCon(true);\n  // Every time a variable changed changeHandler will be called\n  ctrl.setGlobalCallback(changeHandler);\n\n  // Start web sockets\n  ctrl.begin();\n  //ctrl.put(\"sleep_time\", disconTime / 1000,true);\n  LOG_V(\"ControlAssist started.\\n\");\n\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n\n  // Start webs server\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Change html control values\n  if (millis() - pingMillis >= 3000){\n    // Update control assist variables\n    ctrl.put(\"wifi_rssi\", WiFi.RSSI() );\n\n    pingMillis = millis();\n  }\n  // Change html control values\n  if ( WiFi.status() != WL_CONNECTED && millis() - disconnMillis >= disconTime){\n    // Re connect\n    connect();\n    disconnMillis = millis();\n  }\n  #if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "key",
        "wifi",
        "millis",
        "digitalwrite",
        "digitalread",
        "delay",
        "led",
        "spiffs",
        "littlefs",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "SPIFFS.h",
        "ESP8266WebServer.h",
        "LittleFS.h",
        "ESP8266mDNS.h",
        "gpioPMemESP32.h",
        "gpioPMemESP8266.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "setLed",
          "parameters": "bool ledState",
          "body": "if( ledState ){\n    digitalWrite(LED_BUILTIN, LOW); // Turn LED ON\n    LOG_D(\"Led on\\n\");\n  }else{\n    digitalWrite(LED_BUILTIN, HIGH); // Turn LED OFF\n    LOG_D(\"Led off\\n\");\n  }"
        },
        {
          "name": "globalChangeHandler",
          "parameters": "uint8_t ndx",
          "body": "LOG_N(\"globalChangeHandler ndx: %02u, key: '%s', val: %s\\n\", ndx, ctrl[ndx].key.c_str(), ctrl[ndx].val.c_str());\n  if(ctrl[ndx].key == \"led\"){ // Led clicked in web page\n    // Incoming message, Toggle led and dont send update\n    setLed(ctrl[ndx].val.toInt());\n    LOG_I(\"Setting led to %i\\n\",(int)ctrl[ndx].val.toInt());\n    // Set the connected led pin\n    String ledKey = String(LED_BUILTIN);\n    if(LED_BUILTIN<10) ledKey = \"0\" + ledKey;\n    ctrl.put(ledKey.c_str(), !ctrl[ndx].val.toInt() );\n  }else{ // Pin clciked in web page\n    int pin = ctrl[ndx].key.toInt();\n    LOG_I(\"Change pin GPIO%i: %s\\n\", pin, ctrl[ndx].val.c_str());\n    // Set selected pin\n    pinMode(pin, OUTPUT);\n    digitalWrite(pin, ctrl[ndx].val.toInt());\n    // On led toggle connected pin\n    if(pin == LED_BUILTIN) ctrl.put(\"led\", !ctrl[ndx].val.toInt() );\n  }"
        },
        {
          "name": "readGPIO",
          "parameters": "int pinNo",
          "body": "//0-31\n  gpio_num_t pin = (gpio_num_t)(pinNo & 0x1F);\n  int state = 0;\n  if (GPIO_REG_READ(GPIO_ENABLE_REG) & BIT(pin)){   //pin is output - read the GPIO_OUT_REG register\n    state = (GPIO_REG_READ(GPIO_OUT_REG)  >> pin) & 1U;\n  }else{                                            //pin is input - read the GPIO_IN_REG registe\n    state = (GPIO_REG_READ(GPIO_IN_REG)  >> pin) & 1U;\n  }\n  return state;"
        },
        {
          "name": "readGPIO",
          "parameters": "int pinNo",
          "body": "//0-17\n  return digitalRead(pinNo);"
        },
        {
          "name": "readAllGpio",
          "parameters": "",
          "body": "for(uint i=0; i<TOTAL_PINS; i++){\n    int state = readGPIO(i);\n    String pin = String(i);\n    if (i<10) pin = \"0\" + pin;\n    ctrl.put(pin.c_str(), state, true);\n\n    /* Click on build in led pin\n    if(pin.toInt() == LED_BUILTIN){\n      setLed(!state);\n      ctrl.put(\"led\", !state);\n    }\n    */\n  }"
        },
        {
          "name": "listAllFilesInDir",
          "parameters": "String dir_path",
          "body": "Dir dir = LittleFS.openDir(dir_path);\n\twhile(dir.next()) {\n\t\tif (dir.isFile()) {\n\t\t\t// print file names\n\t\t\tSerial.print(\"File: \");\n\t\t\tSerial.println(dir_path + dir.fileName() + \" : \" + dir.fileSize());\n\t\t}\n\t\tif (dir.isDirectory()) {\n\t\t\t// print directory names\n\t\t\tSerial.print(\"Dir: \");\n\t\t\tSerial.println(dir_path + dir.fileName() + \"/\");\n\t\t\t// recursive file listing inside new directory\n\t\t\tlistAllFilesInDir(dir_path + dir.fileName() + \"/\");\n\t\t}\n\t}"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  if (!STORAGE.begin()) {\n    Serial.println(\"An Error has occurred while mounting SPIFFS\");\n    return;\n  }else{\n    LOG_I(\"Storage statred.\\n\");\n  }\n  LOG_I(\"Starting..\\n\");\n  listAllFilesInDir(\"/\");\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_D(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_I(\"AP MDNS responder Started\\n\");\n  }\n\n  // Use default CONTROLASSIST_HTML_HEADER and CONTROLASSIST_HTML_FOOTER\n  #if USE_SPIFFS_FOR_PAGES\n    ctrl.setHtmlBodyFile(BODY_FILE_NAME);\n  #else\n    ctrl.setHtmlBody(HTML_PAGE);\n  #endif\n  // Bind led\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH); // Turn LED OFF\n  ctrl.bind(\"led\", readGPIO(LED_BUILTIN));\n\n  // Bind all pins\n  for(int i=0; i<TOTAL_PINS; ++i){\n    String pin = String(i);\n    if (i<10) pin = \"0\" + pin;\n    int val = readGPIO(pin.toInt());\n    ctrl.bind(pin.c_str(), val);\n  }\n  // Auto send all vars values on connect\n  ctrl.setAutoSendOnCon(true);\n  // When a value is changed, globalChangeHandler will be called\n  ctrl.setGlobalCallback(globalChangeHandler);\n  ctrl.begin();\n  LOG_V(\"ControlAssist started.\\n\");\n\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n    server.sendContent(\"\");\n  });\n\n  // Dump binded controls handler\n  server.on(\"/d\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    server.sendContent(\"Serial dump\\n\");\n    String res = \"\";\n    while( ctrl.dump(res) ){\n      server.sendContent(res);\n    }\n    server.sendContent(\"\");\n  });\n\n  // Start webserver\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - pingMillis >= 5000){\n    // Toggle led\n    setLed(!ctrl[\"led\"].toInt());\n    // Update config assist variable and send ws message\n    ctrl.put(\"led\", !ctrl[\"led\"].toInt() );\n    // Read the state of all gpio\n    readAllGpio();\n    pingMillis = millis();\n  }\n\n  #if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "wifi",
        "millis",
        "analogwrite",
        "delay",
        "display",
        "led",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "lampLevel",
          "parameters": "",
          "body": "ledLevel = ctrl[\"lampLevel\"].toInt();\n  LOG_D(\"lampLevel: %i\\n\", ledLevel);\n  analogWrite(LED_BUILTIN, 255 - ledLevel);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP_STA);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n  // Setup control assist\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.bind(\"lampLevel\", ledLevel, lampLevel);\n  // Auto send on connect\n  ctrl.setAutoSendOnCon(\"lampLevel\", true);\n  // Start web sockets\n  ctrl.begin();\n  LOG_V(\"ControlAssist started.\\n\");\n\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n\n  // Dump binded controls handler\n  server.on(\"/d\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    server.sendContent(\"Serial dump\\n\");\n    String res = \"\";\n    while( ctrl.dump(res) ){\n      server.sendContent(res);\n    }\n  });\n\n  // Setup webserver\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");\n\n  // Setup led\n  pinMode(LED_BUILTIN, OUTPUT);\n  analogWrite(LED_BUILTIN, 1024);\n  LOG_I(\"Setup Lamp Led for ESP8266 board\\n\");\n\n  // Dump binded controls to serial\n  String res=\"\";\n  while(ctrl.dump(res)) Serial.print(res);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "key",
        "wifi",
        "millis",
        "delay",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h",
        "gaugePMem.h"
      ],
      "functions": [
        {
          "name": "changeHandler",
          "parameters": "uint8_t ndx",
          "body": "String key = ctrl[ndx].key;\n  if(key == \"check_ctrl\" )\n    buttonState = ctrl[\"check_ctrl\"].toInt();\n  LOG_D(\"changeHandler: ndx: %02i, key: %s = %s\\n\",ndx, key.c_str(), ctrl[key].c_str());"
        },
        {
          "name": "getMemPerc",
          "parameters": "",
          "body": "uint32_t freeHeapBytes = heap_caps_get_free_size(MALLOC_CAP_DEFAULT);\n  uint32_t totalHeapBytes = heap_caps_get_total_size(MALLOC_CAP_DEFAULT);\n  float percentageHeapUsed = 100 - freeHeapBytes * 100.0f / (float)totalHeapBytes;\n  return round(percentageHeapUsed);"
        },
        {
          "name": "getMemPerc",
          "parameters": "",
          "body": "uint32_t freeHeapBytes = ESP.getFreeHeap();\n  uint32_t totalHeapBytes = 96000; //1060000; //ESP.getFlashChipSizeByChipId();\n  float percentageHeapUsed = 100 - freeHeapBytes * 100.0f / (float)totalHeapBytes;\n  return round(percentageHeapUsed);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n   // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP_STA);\n    if(WiFi.softAP(hostName.c_str(),\"\",8))\n      LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    else\n      LOG_E(\"Wifi AP SSID: %s FAILED!\\n\", WiFi.softAPSSID().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n\n  // Control assist setup\n  ctrl.setHtmlHeaders(HTML_HEADERS);\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.bind(\"rssi\");\n  ctrl.bind(\"mem\");\n  #if defined(ESP32)\n    ctrl.bind(\"temp\");\n    ctrl.bind(\"hall\");\n  #else\n    ctrl.bind(\"vcc\");\n    ctrl.bind(\"hall\");\n  #endif\n  // Every time a variable changed changeHandler will be called\n  ctrl.setGlobalCallback(changeHandler);\n  // Add a web server handler on url \"/\"\n\n  ctrl.begin();\n  LOG_V(\"ControlAssist started.\\n\");\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n\n  // Dump binded controls handler\n  server.on(\"/d\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    server.sendContent(\"Serial dump\\n\");\n    String res = \"\";\n    while( ctrl.dump(res) ){\n      server.sendContent(res);\n    }\n  });\n  // Start web server\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "wifi",
        "millis",
        "delay",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h",
        "joystickPMem.h"
      ],
      "functions": [
        {
          "name": "xChange",
          "parameters": "",
          "body": "LOG_I(\"X pos: %lu\\n\", ctrl[\"x_coordinate\"].toInt());"
        },
        {
          "name": "yChange",
          "parameters": "",
          "body": "LOG_I(\"Y pos: %lu\\n\", ctrl[\"y_coordinate\"].toInt());"
        },
        {
          "name": "speedChange",
          "parameters": "",
          "body": "LOG_I(\"Speed: %lu %%\\n\", ctrl[\"speed\"].toInt());"
        },
        {
          "name": "angleChange",
          "parameters": "",
          "body": "LOG_I(\"Angle: %lu °\\n\", ctrl[\"angle\"].toInt());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP_STA);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n  // Control assist setup\n  ctrl.setHtmlHeaders(HTML_HEADERS);\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.setHtmlFooter(HTML_FOOTER);\n\n  // Bind span controls\n  ctrl.bind(\"x_coordinate\",\"0\", xChange);\n  ctrl.bind(\"y_coordinate\",\"0\", yChange);\n  ctrl.bind(\"speed\", speedChange);\n  ctrl.bind(\"angle\", angleChange);\n\n  // Start web sockets\n  ctrl.begin();\n  LOG_I(\"ControlAssist started.\\n\");\n\n  // Add a web server handler on url \"/\"\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n\n  // Start web server\n  server.begin();\n  LOG_I(\"HTTP server started\\n\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "wifi",
        "millis",
        "delay",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP_STA);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n  // Start web sockets\n  ctrl.begin();\n  LOG_I(\"ControlAssist started.\\n\");\n\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n  // Start web server\n  server.begin();\n  LOG_I(\"HTTP server started\\n\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "key",
        "wifi",
        "millis",
        "delay",
        "analogread",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h",
        "scopePMem.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n  String res = \"\";\n  res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n  while( ctrl.getHtmlChunk(res)){\n    server.sendContent(res);\n  }\n  server.sendContent(\"\");"
        },
        {
          "name": "changeOnOff",
          "parameters": "",
          "body": "LOG_V(\"changeOnOff  %li\\n\", ctrl[\"on-off\"].toInt());\n isPlaying = ctrl[\"on-off\"].toInt();"
        },
        {
          "name": "speedChange",
          "parameters": "",
          "body": "LOG_V(\"speedChange  %s\\n\", ctrl[\"speed\"].c_str());\n speed = ctrl[\"speed\"].toInt();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP_STA);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n  // Control assist setup\n  ctrl.setHtmlHeaders(HTML_HEADERS);\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.setHtmlFooter(HTML_SCRIPT);\n  // Bind controls\n  ctrl.bind(\"on-off\",isPlaying, changeOnOff);\n  ctrl.bind(\"speed\", speed, speedChange);\n  // Auto send key values on connection\n  ctrl.setAutoSendOnCon(\"on-off\",true);\n  ctrl.setAutoSendOnCon(\"speed\",true);\n  // Store key position on adc_val for speed\n  // Only on last bind call the position will be valid!\n  adc_pos = ctrl.bind(\"adc_val\");\n  // Start the server\n  ctrl.begin();\n  LOG_V(\"ControlAssist started.\\n\");\n\n  server.on(\"/\", handleRoot);\n  // Dump binded controls handler\n  server.on(\"/d\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    server.sendContent(\"Serial dump\\n\");\n    String res = \"\";\n    while( ctrl.dump(res) ){\n      server.sendContent(res);\n    }\n  });\n\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");\n#if defined(ESP32)\n  pinMode(ADC_PIN, INPUT);\n#endif\n\n  // Dump binded controls to serial\n  String res;\n  while(ctrl.dump(res)) Serial.print(res);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Run repeatedly\n\n  if (millis() - pingMillis >= speed){\n    // Set control at position to value\n    if(isPlaying)\n      ctrl.set(adc_pos, analogRead(ADC_PIN), true);\n    pingMillis = millis();\n  }\n\n  #if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "password",
        "key",
        "wifi",
        "millis",
        "delay",
        "analogread",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "changeHandler",
          "parameters": "uint8_t ndx",
          "body": "String key = ctrl[ndx].key;\n  if(key == \"check_ctrl\" )\n    buttonState = ctrl[\"check_ctrl\"].toInt();\n  LOG_D(\"changeHandler: ndx: %02i, key: %s = %s\\n\",ndx, key.c_str(), ctrl[key].c_str());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n   // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n\n  // Control assist setup\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.bind(\"span_ctrl\");\n  ctrl.bind(\"input_ctrl\");\n  ctrl.bind(\"text_ctrl\");\n  ctrl.bind(\"check_ctrl\");\n  ctrl.bind(\"range_ctrl\");\n  ctrl.bind(\"button_ctrl\");\n  // Every time a variable changed changeHandler will be called\n  ctrl.setGlobalCallback(changeHandler);\n\n  // Start web sockets\n  ctrl.begin();\n  LOG_V(\"ControlAssist started.\\n\");\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n\n  // Dump binded controls handler\n  server.on(\"/d\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    server.sendContent(\"Serial dump\\n\");\n    String res = \"\";\n    while( ctrl.dump(res) ){\n      server.sendContent(res);\n    }\n  });\n  // Start webs server\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");\n\n  pinMode(ADC_PIN, INPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Change html control values\n  if (millis() - pingMillis >= 3000){\n    // Update control assist variables\n    ctrl.put(\"span_ctrl\", analogRead(ADC_PIN) );\n    ctrl.put(\"input_ctrl\", String(ESP.getCycleCount()));\n    ctrl.put(\"text_ctrl\",  chBuff);\n    ctrl.put(\"check_ctrl\", buttonState );\n    ctrl.put(\"range_ctrl\", WiFi.RSSI() );\n    ctrl.put(\"button_ctrl\", buttonState );\n#if defined(ESP32)\n    //ctrl.put(\"input_ctrl\", String((temprature_sens_read() - 32) / 1.8 ) + \" °C\");\n    sprintf(chBuff, \"Memory Free: heap %u, block: %u, pSRAM %u\", ESP.getFreeHeap(), heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL), ESP.getFreePsram());\n#else\n    sprintf(chBuff,\"Memory free heap: %u, stack: %u ,block: %u\", ESP.getFreeHeap(), ESP.getFreeContStack(), ESP.getMaxFreeBlockSize());\n#endif\n    buttonState = !buttonState;\n    pingMillis = millis();\n  }\n\n  #if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "websocket",
        "wifi",
        "millis",
        "digitalwrite",
        "delay",
        "display",
        "led",
        "html",
        "clients"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WebServer.h",
        "ControlAssist.h"
      ],
      "functions": [
        {
          "name": "ledChangeHandler",
          "parameters": "",
          "body": "ledState = ctrl[\"toggleLed\"].toInt();\n  LOG_D(\"ledChangeHandler state: %i\\n\", ledState);\n  toggleLed(ledState);"
        },
        {
          "name": "toggleLed",
          "parameters": "bool ledState",
          "body": "if( ledState ){\n    digitalWrite(LED_BUILTIN, LOW); // Turn LED ON\n    LOG_D(\"Led on\\n\");\n  }else{\n    digitalWrite(LED_BUILTIN, HIGH); // Turn LED OFF\n    LOG_D(\"Led off\\n\");\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.print(\"\\n\\n\\n\\n\");\n  Serial.flush();\n  LOG_I(\"Starting..\\n\");\n\n  // Connect WIFI ?\n  if(strlen(st_ssid)>0){\n    LOG_E(\"Connect Wifi to %s.\\n\", st_ssid);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(st_ssid, st_pass);\n    uint32_t startAttemptTime = millis();\n    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000)  {\n      Serial.print(\".\");\n      delay(500);\n      Serial.flush();\n    }\n    Serial.println();\n  }\n\n  // Check connection\n  if(WiFi.status() == WL_CONNECTED ){\n    LOG_I(\"Wifi AP SSID: %s connected, use 'http://%s' to connect\\n\", st_ssid, WiFi.localIP().toString().c_str());\n  }else{\n    LOG_E(\"Connect failed.\\n\");\n    LOG_I(\"Starting AP.\\n\");\n    String mac = WiFi.macAddress();\n    mac.replace(\":\",\"\");\n    String hostName = \"ControlAssist_\" + mac.substring(6);\n    WiFi.mode(WIFI_AP_STA);\n    WiFi.softAP(hostName.c_str(),\"\",1);\n    LOG_I(\"Wifi AP SSID: %s started, use 'http://%s' to connect\\n\", WiFi.softAPSSID().c_str(), WiFi.softAPIP().toString().c_str());\n    if (MDNS.begin(hostName.c_str()))  LOG_V(\"AP MDNS responder Started\\n\");\n  }\n\n  // Setup control assist\n  ctrl.setHtmlBody(HTML_BODY);\n  ctrl.bind(\"toggleLed\", ledState, ledChangeHandler);\n  // Auto send on connect\n  ctrl.setAutoSendOnCon(\"toggleLed\", true);\n  ctrl.begin();\n  String res = \"\";\n  LOG_V(\"ControlAssist started.\\n\");\n\n  // Setup webserver\n  server.on(\"/\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    String res = \"\";\n    res.reserve(CTRLASSIST_STREAM_CHUNKSIZE);\n    while( ctrl.getHtmlChunk(res)){\n      server.sendContent(res);\n    }\n  });\n\n  // Dump binded controls handler\n  server.on(\"/d\", []() {\n    server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n    server.sendContent(\"Serial dump\\n\");\n    String res = \"\";\n    while( ctrl.dump(res) ){\n      server.sendContent(res);\n    }\n  });\n\n  // Start webserver\n  server.begin();\n  LOG_V(\"HTTP server started\\n\");\n\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, HIGH); // Turn LED OFF\n\n  // Dump binded controls to serial\n  while(ctrl.dump(res)) Serial.print(res);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if not defined(ESP32)\n    if(MDNS.isRunning()) MDNS.update(); // Handle MDNS\n  #endif\n  // Handler webserver clients\n  server.handleClient();\n  // Handle websockets\n  ctrl.loop();\n\n  if (millis() - pingMillis >= 5000){\n    ledState = !ledState;\n    toggleLed(ledState);\n    // Set the ledState and send a websocket update\n    ctrl.put(\"toggleLed\", ledState );\n    pingMillis = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "power",
        "delay",
        "display"
      ],
      "libraries": [
        "L298NX2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Used to display information\n  Serial.begin(9600);\n\n  // Wait for Serial Monitor to be opened\n  while (!Serial)\n  {\n    //do nothing\n  }\n\n  // Set initial speed for both motors\n  motors.setSpeed(80);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Tell both motors to go forward (may depend by your wiring)\n  motors.forward();\n\n  // Alternative method:\n  // motors.run(L298N::FORWARD);\n\n  //print the motor status in the serial monitor\n  printSomeInfo();\n\n  delay(3000);\n\n  // Stop\n  motors.stop();\n\n  // Alternative method:\n  // motors.run(L298N::STOP);\n\n  printSomeInfo();\n\n  delay(3000);\n\n  // Change individual speeds\n  motors.setSpeedA(255);\n  motors.setSpeedB(90);\n\n  // Tell motor A to go back (may depend by your wiring)\n  motors.backwardA();\n\n  // Alternative method:\n  // motors.runA(L298N::BACKWARD);\n\n  // Tell motor B to go forward (may depend by your wiring)\n  motors.backwardB();\n\n  // Alternative method:\n  // motors.runB(L298N::FORWARD);\n\n  printSomeInfo();\n\n  delay(3000);\n\n  // Stop\n  motors.stop();\n\n  printSomeInfo();\n\n  // Change individual speeds\n  motors.setSpeedA(90);\n  motors.setSpeedB(255);\n\n  delay(3000);"
        },
        {
          "name": "printSomeInfo",
          "parameters": "",
          "body": "Serial.print(\"Motor A is moving = \");\n  Serial.print(motors.isMovingA() ? \"YES\" : \"NO\");\n  Serial.print(\" at speed = \");\n  Serial.println(motors.getSpeedA());\n  Serial.print(\"Motor B is moving = \");\n  Serial.print(motors.isMovingB() ? \"YES\" : \"NO\");\n  Serial.print(\" at speed = \");\n  Serial.println(motors.getSpeedB());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "token",
        "wifi",
        "digitalwrite",
        "led",
        "deviceid",
        "devicetoken",
        "devicecreds",
        "deviceconfig",
        "devices"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                 // Baud rate: 115200, but you can define any baud rate you want\n  pinMode(ledPin, OUTPUT);              // Set the pin of our LED to OUTPUT\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.setActuationCallback(asset, actuation);  // \"asset\" - Variable we defined above, \"actuation\" - Name of the function below that does the work\n  device.createAsset(\"led-example\", \"LED (SDK Example)\", \"actuator\", \"boolean\"); // Create asset \"led-example\" on your AllThingsTalk to control the LED\n  device.init();                        // Initialize AllThingsTalk"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "device.loop();                        // Keep AllThingsTalk & WiFi alive"
        },
        {
          "name": "actuation",
          "parameters": "bool value",
          "body": "// Function called when message arrives to your specified asset. \"value\" is the actual value received.\n  if (value == true) {\n    digitalWrite(ledPin, HIGH);         // Set pin \"ledPin\" to HIGH (ON)\n    Serial.println(\"LED Turned ON\");    // Prints to serial port\n  } else {\n    digitalWrite(ledPin, LOW);          // Sets pin \"ledPin\" to LOW (OFF)\n    Serial.println(\"LED Turned OFF\");   // Prints to serial port\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "token",
        "wifi",
        "digitalwrite",
        "led",
        "deviceid",
        "devicetoken",
        "devicecreds",
        "deviceconfig",
        "devices"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                 // Baud rate: 115200, but you can define any baud rate you want\n  pinMode(ledPin, OUTPUT);              // Set the pin of our LED to OUTPUT\n  digitalWrite(ledPin, HIGH);           // Because the built-in LED is inverted, it's turned on at boot. We'll turn it off here.\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.connectionLed(false);          // Disable the Connection LED feature because we're going to control that exact LED\n  device.setActuationCallback(asset, actuation);  // \"asset\" - Variable we defined above, \"actuation\" - Name of the function below that does the work\n  device.createAsset(\"builtin-led-example\", \"Built-In LED (SDK Example)\", \"actuator\", \"boolean\"); // Create asset on your AllThingsTalk to control the LED\n  device.init();                        // Initialize AllThingsTalk"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "device.loop();                        // Keep AllThingsTalk & WiFi alive"
        },
        {
          "name": "actuation",
          "parameters": "bool value",
          "body": "// Function called when message arrives to your specified asset. \"value\" is the actual value received.\n  if (value == true) {\n    digitalWrite(ledPin, LOW);          // Set pin \"ledPin\" to LOW (ON, because it's inverted)\n    Serial.println(\"LED Turned ON\");    // Prints to serial port\n  } else {\n    digitalWrite(ledPin, HIGH);         // Sets pin \"ledPin\" to HIGH (OFF, because it's inverted)\n    Serial.println(\"LED Turned OFF\");   // Prints to serial port\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "delay"
      ],
      "libraries": [
        "BLVD20KM_asukiaaa.h",
        "rs485_asukiaaa.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  BLVD20KM_asukiaaa::beginModbus(&modbus, RS485_BAUDRATE);\n  motorA.beginWithoutModbus();\n  motorB.beginWithoutModbus();"
        },
        {
          "name": "readAndPrintSpeed",
          "parameters": "String motorLabel, BLVD20KM_asukiaaa* motor",
          "body": "uint16_t speed;\n  auto result = motor->readSpeed(&speed);\n  Serial.print(motorLabel);\n  Serial.print(\" \");\n  if (result == 0) {\n    Serial.println(\"Speed is \" + String(speed));\n  } else {\n    Serial.println(\"Cannot read speed. E:\" + String(result) + \" \" +\n                   BLVD20KM_asukiaaa::getStrOfError(result));\n  }"
        },
        {
          "name": "readAndPrintAlarm",
          "parameters": "String motorLabel, BLVD20KM_asukiaaa* motor",
          "body": "uint16_t alarmState;\n  auto result = motor->readAlarm(&alarmState);\n  Serial.print(motorLabel);\n  Serial.print(\" \");\n  if (result == 0) {\n    Serial.println(\"Current alarm:0x\" + String(alarmState, HEX) + \" \" +\n                   BLVD20KM_asukiaaa::getStrOfAlarm(alarmState));\n  } else {\n    Serial.println(\"Cannot read alarm. E:\" + String(result) + \" \" +\n                   BLVD20KM_asukiaaa::getStrOfError(result));\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "motorA.writeSpeed(500);\n  motorA.writeForward();\n  readAndPrintSpeed(\"motorA\", &motorA);\n  delay(2000);\n\n  motorB.writeSpeed(500);\n  motorB.writeForward();\n  readAndPrintSpeed(\"motorB\", &motorB);\n  delay(2000);\n\n  motorA.writeStop();\n  Serial.println(\"motorA stop\");\n  delay(2000);\n\n  motorB.writeStop();\n  Serial.println(\"motorB stop\");\n  delay(2000);\n\n  motorA.writeSpeed(200);\n  motorA.writeReverse();\n  readAndPrintSpeed(\"motorA\", &motorA);\n  delay(2000);\n\n  motorB.writeSpeed(200);\n  motorB.writeReverse();\n  readAndPrintSpeed(\"motorB\", &motorB);\n  delay(2000);\n\n  motorA.writeStop();\n  Serial.println(\"motorA stop\");\n  delay(2000);\n\n  motorB.writeStop();\n  Serial.println(\"motorB stop\");\n  delay(2000);\n\n  readAndPrintAlarm(\"motorA\", &motorA);\n  readAndPrintAlarm(\"motorB\", &motorB);\n  delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "password",
        "json",
        "wifi",
        "delay",
        "devices"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");\n    }else\n    {\n      Serial.println(\"WiFi connected !\");\n     }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*Read control panel status (Switch and Slider)*/\n  String control_panel_status = myiot.ReadControlPanel(userid,key);\n\n  /*Print out result: Output is JSON format*/\n  Serial.println(control_panel_status);\n\n  /*Delay interval time for read control status*/\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "password",
        "json",
        "wifi",
        "delay",
        "devices"
      ],
      "libraries": [
        "IoTtweetESP32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");\n    }else\n    {\n      Serial.println(\"WiFi connected !\");\n     }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*Read control panel status (Switch and Slider)*/\n  String control_panel_status = myiot.ReadControlPanel(userid,key);\n\n  /*Print out result: Output is JSON format*/\n  Serial.println(control_panel_status);\n\n  /*Delay interval time for read control status*/\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "password",
        "wifi",
        "delay",
        "devices"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");\n    }else\n    {\n      Serial.println(\"WiFi connected !\");\n     }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*Example : Read status slider no.1 on dashboard.\n   * This command will return data type as float to you \n   * command parameter : ReadAnalogSlider(userid,key,slider number);\n   */\n  float slider1_read = myiot.ReadAnalogSlider(userid,key,1);\n\n  /*Print output to serial monitor*/\n  Serial.println();\n  Serial.print(\"Analog Slider 1 value is \");\n  Serial.print(slider1_read);\n\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "password",
        "wifi",
        "delay",
        "digitalwrite",
        "led",
        "devices",
        "nodemcu"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  /*Set output pin of LED (Built-in LED of NodeMCU is IO no. 16)*/\n  pinMode(LED_BUILTIN,OUTPUT);\n\n  /*Get IoTtweet Library version*/\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  /*Connect WiFi*/\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");\n    }else\n    {\n      Serial.println(\"WiFi connected !\");\n     }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*Example : Read status switch no.1 on dashboard.\n   * This command will return \"ON\" or \"OFF\" string to you    \n   * command parameter : ReadDigitalSwitch(userid,ket,switch number);\n   */\n  String sw1_read = myiot.ReadDigitalSwitch(userid,key,1);\n\n  delay(10);\n\n  /*Drive to built-in LED*/\n  if(sw1_read == \"ON\")\n  {\n      digitalWrite(LED_BUILTIN,LOW);\n   }else\n    {\n      digitalWrite(LED_BUILTIN,HIGH);\n     }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "token",
        "callback",
        "light",
        "wifi",
        "analogwrite",
        "rgb",
        "led",
        "deviceid",
        "devicetoken",
        "devicecreds",
        "deviceconfig",
        "devices"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h",
        "WiFiNINA.h",
        "utility/wifi_drv.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                 // Baud rate for Serial output (debug), but you can define any baud rate you want\n  WiFiDrv::pinMode(25, OUTPUT);         // Initialize the Green LED pin on the MKR1010 board\n  WiFiDrv::pinMode(26, OUTPUT);         // Initialize the Red LED pin on the MKR1010 board\n  WiFiDrv::pinMode(27, OUTPUT);         // Initialize the Blue LED pin on the MKR1010 board\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.setActuationCallback(actuator, rgb); // Add an actuation callback for asset defined above and run function \"rgb\" once command is received\n  device.init();                        // Initialize WiFi and AllThingsTalk"
        },
        {
          "name": "rgb",
          "parameters": "String value",
          "body": "// Function that will be called when you pick a color on AllThingsTalk\n  Serial.println(\"RGB Color Changed!\"); // Outputs to Serial\n  // Parses the received RGB information into three separate variables (R, G, B)\n  long hexColor = (long) strtol(&value[1], NULL, 16);\n  r = hexColor >> 16;\n  g = hexColor >> 8 & 0xFF;\n  b = hexColor & 0xFF;\n  WiFiDrv::analogWrite(25, g);          // Set the Green LED to received value\n  WiFiDrv::analogWrite(26, r);          // Set the Red LED to received value\n  WiFiDrv::analogWrite(27, b);          // Set the Blue LED to received value"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Runs as long as the device in on\n  device.loop();                        // Keep AllThingsTalk & WiFi connection alive"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "current",
        "delay",
        "led",
        "display"
      ],
      "libraries": [
        "Arduino.h",
        "IRremoteESP8266.h",
        "IRsend.h",
        "ir_Samsung.h"
      ],
      "functions": [
        {
          "name": "printState",
          "parameters": "",
          "body": "// Display the settings.\n  Serial.println(\"Samsung A/C remote is in the following state:\");\n  Serial.printf(\"  %s\\n\", ac.toString().c_str());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "ac.begin();\n  Serial.begin(115200);\n  delay(200);\n\n  // Set up what we want to send. See ir_Samsung.cpp for all the options.\n  Serial.println(\"Default state of the remote.\");\n  printState();\n  Serial.println(\"Setting initial state for A/C.\");\n  ac.off();\n  ac.setFan(kSamsungAcFanLow);\n  ac.setMode(kSamsungAcCool);\n  ac.setTemp(25);\n  ac.setSwing(false);\n  printState();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Turn the A/C unit on\n  Serial.println(\"Turn on the A/C ...\");\n  ac.on();\n  ac.send();\n  printState();\n  delay(15000);  // wait 15 seconds\n  // and set to cooling mode.\n  Serial.println(\"Set the A/C mode to cooling ...\");\n  ac.setMode(kSamsungAcCool);\n  ac.send();\n  printState();\n  delay(15000);  // wait 15 seconds\n\n  // Increase the fan speed.\n  Serial.println(\"Set the fan to high and the swing on ...\");\n  ac.setFan(kSamsungAcFanHigh);\n  ac.setSwing(true);\n  ac.send();\n  printState();\n  delay(15000);\n\n  // Change to Fan mode, lower the speed, and stop the swing.\n  Serial.println(\"Set the A/C to fan only with a low speed, & no swing ...\");\n  ac.setSwing(false);\n  ac.setMode(kSamsungAcFan);\n  ac.setFan(kSamsungAcFanLow);\n  ac.send();\n  printState();\n  delay(15000);\n\n  // Turn the A/C unit off.\n  Serial.println(\"Turn off the A/C ...\");\n  ac.off();\n  ac.send();\n  printState();\n  delay(15000);  // wait 15 seconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "token",
        "current",
        "wifi",
        "servo",
        "delay",
        "flash",
        "deviceid",
        "devicetoken",
        "devicecreds",
        "deviceconfig",
        "devices"
      ],
      "libraries": [
        "AllThingsTalk_WiFi.h",
        "Servo.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);                 // Baud rate: 115200, but you can define any baud rate you want\n  device.debugPort(Serial);             // Set AllThingsTalk library to output its debug to \"Serial\"\n  device.wifiSignalReporting(true);     // Enables WiFi Signal Strength reporting to your AllThingsTalk\n  device.setActuationCallback(asset, controlServo);  // \"asset\" - Variable we defined above, \"controlServo\" - Name of the function below that does the work\n  device.createAsset(asset, \"Servo (SDK Example)\", \"actuator\", \"integer\"); // Create asset on your AllThingsTalk to control the Servo\n  device.init();                        // Initialize AllThingsTalk"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "device.loop();                        // Keep AllThingsTalk & WiFi alive"
        },
        {
          "name": "controlServo",
          "parameters": "int value",
          "body": "// Function called when message arrives to your specified asset. \"value\" is the actual value received.\n  servo.attach(servoPin);               // Activates the servo motor\n  Serial.println(\"Changing Servo Motor Position to: \");\n  Serial.println(value);                // Print current value of servo to serial monitor\n  servo.write(value);                   // Send the value to which the servo motor should move to\n  delay(700);                           // Give the servo motor some time to finish its movement\n  servo.detach();                       // Disactivate servo motor"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "millis"
      ],
      "libraries": [
        "Braccio++.h",
        "AppState.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();\n    }\n  }\n\n  /* Execute every 50 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 50)\n    {\n      prev = now;\n\n      if (Braccio.isJoystickPressed_UP())\n        app.update(Button::Up);\n      if (Braccio.isJoystickPressed_DOWN())\n        app.update(Button::Down);\n      if (Braccio.isJoystickPressed_LEFT())\n        app.update(Button::Left);\n      if (Braccio.isJoystickPressed_RIGHT())\n        app.update(Button::Right);\n    }\n  }"
        },
        {
          "name": "directionScreen",
          "parameters": "void",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "parameters": "",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);\n  }\n  prev_joystick_pressed_enter = curr_joystick_pressed_enter;\n\n  /* SELECT */\n\n  static bool prev_joystick_pressed_select = false;\n  bool const curr_joystick_pressed_select = Braccio.isJoystickPressed_SELECT();\n  if (!prev_joystick_pressed_select && curr_joystick_pressed_select) {\n    app.update(Button::Enter);\n  }\n  prev_joystick_pressed_select = curr_joystick_pressed_select;\n\n  /* DOWN */\n\n  static bool prev_joystick_pressed_down = false;\n  bool const curr_joystick_pressed_down = Braccio.isJoystickPressed_DOWN();\n  if (!prev_joystick_pressed_down && curr_joystick_pressed_down) {\n    handle_OnButtonDownPressed();\n  }\n  if (prev_joystick_pressed_down && !curr_joystick_pressed_down) {\n    handle_OnButtonDownReleased();\n  }\n  prev_joystick_pressed_down = curr_joystick_pressed_down;\n\n  /* UP */\n\n  static bool prev_joystick_pressed_up = false;\n  bool const curr_joystick_pressed_up = Braccio.isJoystickPressed_UP();\n  if (!prev_joystick_pressed_up && curr_joystick_pressed_up) {\n    handle_OnButtonUpPressed();\n  }\n  if (prev_joystick_pressed_up && !curr_joystick_pressed_up) {\n    handle_OnButtonUpReleased();\n  }\n  prev_joystick_pressed_up = curr_joystick_pressed_up;\n\n  /* LEFT */\n\n  static bool prev_joystick_pressed_left = false;\n  bool const curr_joystick_pressed_left = Braccio.isJoystickPressed_LEFT();\n  if (!prev_joystick_pressed_left && curr_joystick_pressed_left) {\n    handle_OnButtonLeftPressed();\n  }\n  if (prev_joystick_pressed_left && !curr_joystick_pressed_left) {\n    handle_OnButtonLeftReleased();\n  }\n  prev_joystick_pressed_left = curr_joystick_pressed_left;\n\n  /* RIGHT */\n\n  static bool prev_joystick_pressed_right = false;\n  bool const curr_joystick_pressed_right = Braccio.isJoystickPressed_RIGHT();\n  if (!prev_joystick_pressed_right && curr_joystick_pressed_right) {\n    handle_OnButtonRightPressed();\n  }\n  if (prev_joystick_pressed_right && !curr_joystick_pressed_right) {\n    handle_OnButtonRightReleased();\n  }\n  prev_joystick_pressed_right = curr_joystick_pressed_right;"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "parameters": "",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "millis",
        "delay",
        "sd",
        "flash"
      ],
      "libraries": [
        "SerialFlash.h",
        "SD.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//uncomment these if using Teensy audio shield\n  //SPI.setSCK(14);  // Audio shield has SCK on pin 14\n  //SPI.setMOSI(7);  // Audio shield has MOSI on pin 7\n\n  //uncomment these if you have other SPI chips connected\n  //to keep them disabled while using only SerialFlash\n  //pinMode(4, INPUT_PULLUP);\n  //pinMode(10, INPUT_PULLUP);\n\n  Serial.begin(9600);\n\n  // wait up to 10 seconds for Arduino Serial Monitor\n  unsigned long startMillis = millis();\n  while (!Serial && (millis() - startMillis < 10000)) ;\n  delay(100);\n  Serial.println(\"Copy all files from SD Card to SPI Flash\");\n\n  if (!SD.begin(SDchipSelect)) {\n    error(\"Unable to access SD card\");\n  }\n  if (!SerialFlash.begin(FlashChipSelect)) {\n    error(\"Unable to access SPI Flash chip\");\n  }\n\n  int count = 0;\n  File rootdir = SD.open(\"/\");\n  while (1) {\n    // open a file from the SD card\n    Serial.println();\n    File f = rootdir.openNextFile();\n    if (!f) break;\n    const char *filename = f.name();\n    Serial.print(filename);\n    Serial.print(\"    \");\n    unsigned long length = f.size();\n    Serial.println(length);\n\n    // check if this file is already on the Flash chip\n    if (SerialFlash.exists(filename)) {\n      Serial.println(\"  already exists on the Flash chip\");\n      SerialFlashFile ff = SerialFlash.open(filename);\n      if (ff && ff.size() == f.size()) {\n        Serial.println(\"  size is the same, comparing data...\");\n        if (compareFiles(f, ff) == true) {\n          Serial.println(\"  files are identical :)\");\n          f.close();\n          ff.close();\n          continue;  // advance to next file\n        } else {\n          Serial.println(\"  files are different\");\n        }\n      } else {\n        Serial.print(\"  size is different, \");\n        Serial.print(ff.size());\n        Serial.println(\" bytes\");\n      }\n      // delete the copy on the Flash chip, if different\n      Serial.println(\"  delete file from Flash chip\");\n      SerialFlash.remove(filename);\n    }\n\n    // create the file on the Flash chip and copy data\n    if (SerialFlash.create(filename, length)) {\n      SerialFlashFile ff = SerialFlash.open(filename);\n      if (ff) {\n        Serial.print(\"  copying\");\n        // copy data loop\n        unsigned long count = 0;\n        unsigned char dotcount = 9;\n        while (count < length) {\n          char buf[256];\n          unsigned int n;\n          n = f.read(buf, 256);\n          ff.write(buf, n);\n          count = count + n;\n          Serial.print(\".\");\n          if (++dotcount > 100) {\n             Serial.println();\n             dotcount = 0;\n          }\n        }\n        ff.close();\n        if (dotcount > 0) Serial.println();\n      } else {\n        Serial.println(\"  error opening freshly created file!\");\n      }\n    } else {\n      Serial.println(\"  unable to create file\");\n    }\n    f.close();\n  }\n  rootdir.close();\n  delay(10);\n  Serial.println(\"Finished All Files\");"
        },
        {
          "name": "compareFiles",
          "parameters": "File &file, SerialFlashFile &ffile",
          "body": "file.seek(0);\n  ffile.seek(0);\n  unsigned long count = file.size();\n  while (count > 0) {\n    char buf1[128], buf2[128];\n    unsigned long n = count;\n    if (n > 128) n = 128;\n    file.read(buf1, n);\n    ffile.read(buf2, n);\n    if (memcmp(buf1, buf2, n) != 0) return false; // differ\n    count = count - n;\n  }\n  return true;  // all data identical"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        },
        {
          "name": "error",
          "parameters": "const char *message",
          "body": "while (1) {\n    Serial.println(message);\n    delay(2500);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "publish",
        "buffer",
        "light",
        "spi",
        "delay",
        "digitalwrite",
        "millis",
        "led",
        "flash",
        "sd"
      ],
      "libraries": [
        "SerialFlash.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);  //Teensy serial is always at full USB speed and buffered... the baud rate here is required but ignored\n\n  pinMode(13, OUTPUT);\n  \n  //Set up SPI\n  SPI.setMOSI(MOSI);\n  SPI.setMISO(MISO);\n  SPI.setSCK(SCK);\n  SerialFlash.begin(CSPIN);\n\n  //We start by formatting the flash...\n  uint8_t id[5];\n  SerialFlash.readID(id);\n  SerialFlash.eraseAll();\n  \n  //Flash LED at 1Hz while formatting\n  while (!SerialFlash.ready()) {\n    delay(500);\n    digitalWrite(13, HIGH);\n    delay(500);\n    digitalWrite(13, LOW);\n  }\n\n  //Quickly flash LED a few times when completed, then leave the light on solid\n  for(uint8_t i = 0; i < 10; i++){\n    delay(100);\n    digitalWrite(13, HIGH);\n    delay(100);\n    digitalWrite(13, LOW);\n  }\n  digitalWrite(13, HIGH);\n  \n  //We are now going to wait for the upload program\n  while(!Serial.available());\n  \n  SerialFlashFile flashFile;\n  \n  uint8_t state = STATE_START;\n  uint8_t escape = 0;\n  uint8_t fileSizeIndex = 0;\n  uint32_t fileSize = 0;\n  char filename[FILENAME_STRING_SIZE];\n  \n  char usbBuffer[USB_BUFFER_SIZE];\n  uint8_t flashBuffer[FLASH_BUFFER_SIZE];\n  \n  uint16_t flashBufferIndex = 0;\n  uint8_t filenameIndex = 0;\n  \n  uint32_t lastReceiveTime = millis();\n  \n  //We assume the serial receive part is finished when we have not received something for 3 seconds\n  while(Serial.available() || lastReceiveTime + 3000 > millis()){\n    uint16_t available = Serial.readBytes(usbBuffer, USB_BUFFER_SIZE);\n    if (available){\n      lastReceiveTime = millis();\n    }\n\n    for (uint16_t usbBufferIndex = 0; usbBufferIndex < available; usbBufferIndex++){\n      uint8_t b = usbBuffer[usbBufferIndex];\n      \n      if (state == STATE_START){\n        //Start byte.  Repeat start is fine.\n        if (b == BYTE_START){\n          for (uint8_t i = 0; i < FILENAME_STRING_SIZE; i++){\n            filename[i] = 0x00;\n          }\n          filenameIndex = 0;\n        }\n        //Valid characters are A-Z, 0-9, comma, period, colon, dash, underscore\n        else if ((b >= 'A' && b <= 'Z') || (b >= '0' && b <= '9') || b == '.' || b == ',' || b == ':' || b == '-' || b == '_'){\n          filename[filenameIndex++] = b;\n          if (filenameIndex >= FILENAME_STRING_SIZE){\n            //Error name too long\n            flushError();\n            return;\n          }\n        }\n        //Filename end character\n        else if (b == BYTE_SEPARATOR){\n          if (filenameIndex == 0){\n            //Error empty filename\n            flushError();\n            return;\n          }\n          \n          //Change state\n          state = STATE_SIZE;\n          fileSizeIndex = 0;\n          fileSize = 0;\n          \n        }\n        //Invalid character\n        else {\n          //Error bad filename\n          flushError();\n          return;\n        }\n      }\n      //We read 4 bytes as a uint32_t for file size\n      else if (state == STATE_SIZE){\n        if (fileSizeIndex < 4){\n          fileSize = (fileSize << 8) + b;\n          fileSizeIndex++;\n        }\n        else if (b == BYTE_SEPARATOR){\n          state = STATE_CONTENT;\n          flashBufferIndex = 0;\n          escape = 0;\n          \n          if (SerialFlash.exists(filename)){\n            SerialFlash.remove(filename);  //It doesn't reclaim the space, but it does let you create a new file with the same name.\n          }\n          \n          //Create a new file and open it for writing\n          if (SerialFlash.create(filename, fileSize)) {\n            flashFile = SerialFlash.open(filename);\n            if (!flashFile) {\n              //Error flash file open\n              flushError();\n              return;\n            }\n          }\n          else {\n            //Error flash create (no room left?)\n            flushError();\n            return;\n          }\n        }\n        else {\n          //Error invalid length requested\n          flushError();\n          return;\n        }\n      }\n      else if (state == STATE_CONTENT){\n        //Previous byte was escaped; unescape and add to buffer\n        if (escape){\n          escape = 0;\n          flashBuffer[flashBufferIndex++] = b ^ 0x20;\n        }\n        //Escape the next byte\n        else if (b == BYTE_ESCAPE){\n          //Serial.println(\"esc\");\n          escape = 1;\n        }\n        //End of file\n        else if (b == BYTE_START){\n          //Serial.println(\"End of file\");\n          state = STATE_START;\n          flashFile.write(flashBuffer, flashBufferIndex);\n          flashFile.close();\n          flashBufferIndex = 0;\n        }\n        //Normal byte; add to buffer\n        else {\n          flashBuffer[flashBufferIndex++] = b;\n        }\n        \n        //The buffer is filled; write to SD card\n        if (flashBufferIndex >= FLASH_BUFFER_SIZE){\n          flashFile.write(flashBuffer, FLASH_BUFFER_SIZE);\n          flashBufferIndex = 0;\n        }\n      }\n    }\n  }\n\n  //Success!  Turn the light off.\n  digitalWrite(13, LOW);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//Do nothing."
        },
        {
          "name": "flushError",
          "parameters": "",
          "body": "uint32_t lastReceiveTime = millis();\n  char usbBuffer[USB_BUFFER_SIZE];\n  //We assume the serial receive part is finished when we have not received something for 3 seconds\n  while(Serial.available() || lastReceiveTime + 3000 > millis()){\n    if (Serial.readBytes(usbBuffer, USB_BUFFER_SIZE)){\n      lastReceiveTime = millis();\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "rest",
        "https",
        "key",
        "certificate",
        "token",
        "auth",
        "callback",
        "json",
        "wifi",
        "millis",
        "delay",
        "sd",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "ESP_Google_Sheet_Client.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32) || defined(ESP8266)\n    WiFi.setAutoReconnect(true);\n#endif\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    // In case SD/SD_MMC storage file access, mount the SD/SD_MMC card.\n    // SD_Card_Mounting(); // See src/GS_SDHelper.h\n\n    // GSheet.setCert(rootCACert); // or GSheet.setCertFile(\"path/to/certificate/file.pem\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);\n\n    // Set the callback for Google API access token generation status (for debug only)\n    GSheet.setTokenCallback(tokenStatusCallback);\n\n    // The WiFi credentials are required for Pico W\n    // due to it does not have reconnect feature.\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    GSheet.clearAP();\n    GSheet.addAP(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    // Set the seconds to refresh the auth token before expire (60 to 3540, default is 300 seconds)\n    GSheet.setPrerefreshSeconds(10 * 60);\n\n   // Begin the access token generation for Google API authentication\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n    // Or begin with the Service Account JSON file\n    // GSheet.begin(\"path/to/serviceaccount/json/file\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\n    bool ready = GSheet.ready();\n\n    if (ready && !taskComplete)\n    {\n\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\n\n        // If you assign the spreadsheet id from your own spreadsheet,\n        // you need to set share access to the Service Account's CLIENT_EMAIL\n\n        FirebaseJson response;\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\n\n        Serial.println(\"\\nCopy sheet of spreadsheet to another spreadsheet...\");\n        Serial.println(\"---------------------------------------------------\");\n\n        // The sheet id is the integer number which you can get it from gid parameter of spreadsheet URL when select the sheet tab\n        // For example, https://docs.google.com/spreadsheets/d/xxxxxxx/edit#gid=1180731163\n        // The sheet id of above case is 1180731163\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.sheets/copyTo\n\n        bool success = GSheet.sheets.copyTo(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to copy */, 0 /* sheet id */, \"<destination_spreadsheetId>\" /* destination spreadsheet id */);\n        if (success)\n            response.toString(Serial, true);\n        else\n            Serial.println(GSheet.errorReason());\n        Serial.println();\n\n#if defined(ESP32) || defined(ESP8266)\n        Serial.println(ESP.getFreeHeap());\n#elif defined(PICO_RP2040)\n        Serial.println(rp2040.getFreeHeap());\n#endif\n\n        taskComplete = true;\n    }"
        },
        {
          "name": "tokenStatusCallback",
          "parameters": "TokenInfo info",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());\n    }\n    else\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//init Ciao\n\tCiao.begin();\n\tSerial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//Run commands in Linino OS to get the CPU Usage\n\tCiaoData data = Ciao.write(\"shell\",ShellCommand, ShellArguments);\n\n\tif(!data.isEmpty()){\n\t\t//Get data back\n\t\tString usage = data.get(2);\n\t\tSerial.println(usage);\n\t}\n\n\tdelay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "key",
        "json",
        "flash"
      ],
      "libraries": [
        "Arduino.h",
        "FirebaseJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\r\n    Serial.println();\r\n    Serial.println();\r\n\r\n    //Create, parsing and modify JSON object and JSON array\r\n    //FirebaseJSON supports Arduino String, PROGMEM, flash string, std::string, char array, string literal, and sum of arduino String.\r\n\r\n    //All functions supported FPSTR, String, std::string, const char* and char array as parameters.\r\n\r\n    FirebaseJson json;       // or constructor with contents e.g. FirebaseJson json(\"{\\\"a\\\":true}\");\r\n    FirebaseJsonArray arr;   // or constructor with contents e.g. FirebaseJsonArray arr(\"[1,2,true,\\\"test\\\"]\");\r\n    FirebaseJsonData result; //object that keeps the deserializing result\r\n\r\n    //To set content\r\n    json.setJsonData(\"{\\\"a\\\":true}\");\r\n\r\n    arr.setJsonArrayData(\"[1,2,3]\");\r\n\r\n    //To add data to json\r\n    json.add(\"b\" /* key or name only */, 123 /* value of any type */); // or json[\"b\"] = 123;\r\n\r\n    //To set data to json\r\n    json.set(\"a/b/c\" /* key or relative path */, \"hello\" /* value */);\r\n\r\n    //To add value to array\r\n    arr.add(\"hello\").add(\"test\").add(99); // or arr.add(\"hello\", \"test\", 99);\r\n\r\n    //To add json into array\r\n    FirebaseJson json2(\"{\\\"d\\\":888,\\\"e\\\":false}\");\r\n    arr.add(json2);\r\n\r\n    //To set the value at index\r\n    arr.set(\"[0]\", 555); // or arr.set(0, 555) or arr[0] = 555;\r\n\r\n    //To set the value at specific path\r\n    arr.set(\"/[8]/i\", 111);\r\n    arr.set(\"/[8]/j\", 222);\r\n    arr.set(\"/[8]/k\", \"hi\");\r\n\r\n    //To add/set array into json\r\n    json.set(\"x/y/z\", arr);\r\n\r\n    //To serialize json to serial\r\n    json.toString(Serial, true /* prettify option */);\r\n\r\n    //To serialize array to string\r\n    String str;\r\n    arr.toString(str, true /* prettify option */);\r\n\r\n    Serial.println(\"\\n---------\");\r\n    Serial.println(str);\r\n\r\n    //To remove value from array at index or path\r\n    arr.remove(\"[6]/d\" /* path */);\r\n    arr.remove(7 /* index */);\r\n    Serial.println(\"\\n---------\");\r\n    Serial.println(arr.raw()); //print raw string\r\n\r\n    //To remove value from json\r\n    json.remove(\"x/y/z/[6]\");\r\n    Serial.println(\"\\n---------\");\r\n    Serial.println(json.raw()); //print raw string\r\n\r\n    //To get the value from json (deserializing)\r\n    json.get(result /* FirebaseJsonData */, \"a/b/c\" /* key or path */);\r\n\r\n    //To check the deserialized result and get its type and value\r\n    if (result.success)\r\n    {\r\n        Serial.println(\"\\n---------\");\r\n        if (result.type == \"string\") /* or result.typeNum == FirebaseJson::JSON_STRING */\r\n            Serial.println(result.to<String>().c_str());\r\n        else if (result.type == \"int\") /* or result.typeNum == FirebaseJson::JSON_INT */\r\n            Serial.println(result.to<int>());\r\n        else if (result.type == \"float\") /* or result.typeNum == FirebaseJson::JSON_FLOAT */\r\n            Serial.println(result.to<float>());\r\n        else if (result.type == \"double\") /* or result.typeNum == FirebaseJson::JSON_DOUBLE */\r\n            Serial.println(result.to<double>());\r\n        else if (result.type == \"bool\") /* or result.typeNum == FirebaseJson::JSON_BOOL */\r\n            Serial.println(result.to<bool>());\r\n        else if (result.type == \"object\") /* or result.typeNum == FirebaseJson::JSON_OBJECT */\r\n            Serial.println(result.to<String>().c_str());\r\n        else if (result.type == \"array\") /* or result.typeNum == FirebaseJson::JSON_ARRAY */\r\n            Serial.println(result.to<String>().c_str());\r\n        else if (result.type == \"null\") /* or result.typeNum == FirebaseJson::JSON_NULL */\r\n            Serial.println(result.to<String>().c_str());\r\n    }\r\n\r\n    //To get the json object from deserializing result\r\n    json.get(result /* FirebaseJsonData */, \"x/y/z/[7]\" /* key or path */);\r\n    if (result.success)\r\n    {\r\n\r\n        if (result.type == \"object\") /* or result.typeNum == FirebaseJson::JSON_OBJECT */\r\n        {\r\n            //Use result.get or result.getJSON instead of result.to\r\n            FirebaseJson json3;\r\n            result.get<FirebaseJson /* type e.g. FirebaseJson or FirebaseJsonArray */>(json3 /* object that used to store value */);\r\n            //or result.getJSON(json3);\r\n            Serial.println(\"\\n---------\");\r\n            json3.toString(Serial, true); //serialize contents to serial\r\n\r\n            //To iterate all values in Json object\r\n            size_t count = json3.iteratorBegin();\r\n            Serial.println(\"\\n---------\");\r\n            for (size_t i = 0; i < count; i++)\r\n            {\r\n                FirebaseJson::IteratorValue value = json3.valueAt(i);\r\n                Serial_Printf(\"Name: %s, Value: %s, Type: %s\\n\", value.key.c_str(), value.value.c_str(), value.type == FirebaseJson::JSON_OBJECT ? \"object\" : \"array\");\r\n            }\r\n\r\n            Serial.println();\r\n            json3.iteratorEnd(); //required for free the used memory in iteration (node data collection)\r\n        }\r\n    }\r\n\r\n    //To get the json array object from deserializing result\r\n    json.get(result /* FirebaseJsonData */, \"x/y/z\" /* key or path */);\r\n    if (result.success)\r\n    {\r\n\r\n        if (result.type == \"array\") /* or result.typeNum == FirebaseJson::JSON_ARRAY */\r\n        {\r\n            //Use result.get or result.getJSON instead of result.to\r\n            FirebaseJsonArray arr2;\r\n            result.get<FirebaseJsonArray /* type e.g. FirebaseJson or FirebaseJsonArray */>(arr2 /* object that used to store value */);\r\n            //or result.getArray(arr2);\r\n            Serial.println(\"\\n---------\");\r\n            arr2.toString(Serial, true); //serialize contents to serial\r\n\r\n            //To iterate all values in Json array object\r\n            Serial.println(\"\\n---------\");\r\n            FirebaseJsonData result2;\r\n            for (size_t i = 0; i < arr2.size(); i++)\r\n            {\r\n                arr2.get(result2, i);\r\n                if (result2.type == \"string\" /* result2.typeNum == FirebaseJson::JSON_STRING */)\r\n                    Serial_Printf(\"Array index %d, String Val: %s\\n\", i, result2.to<String>().c_str());\r\n                else if (result2.type == \"int\" /* result2.typeNum == FirebaseJson::JSON_INT */)\r\n                    Serial_Printf(\"Array index %d, Int Val: %d\\n\", i, result2.to<int>());\r\n                else if (result2.type == \"float\" /* result2.typeNum == FirebaseJson::JSON_FLOAT */)\r\n                    Serial_Printf(\"Array index %d, Float Val: %f\\n\", i, result2.to<float>());\r\n                else if (result2.type == \"double\" /* result2.typeNum == FirebaseJson::JSON_DOUBLE */)\r\n                    Serial_Printf(\"Array index %d, Double Val: %f\\n\", i, result2.to<double>());\r\n                else if (result2.type == \"bool\" /* result2.typeNum == FirebaseJson::JSON_BOOL */)\r\n                    Serial_Printf(\"Array index %d, Bool Val: %d\\n\", i, result2.to<bool>());\r\n                else if (result2.type == \"object\" /* result2.typeNum == FirebaseJson::JSON_OBJECT */)\r\n                    Serial_Printf(\"Array index %d, Object Val: %s\\n\", i, result2.to<String>().c_str());\r\n                else if (result2.type == \"array\" /* result2.typeNum == FirebaseJson::JSON_ARRAY */)\r\n                    Serial_Printf(\"Array index %d, Array Val: %s\\n\", i, result2.to<String>().c_str());\r\n                else if (result2.type == \"null\" /* result2.typeNum == FirebaseJson::JSON_NULL */)\r\n                    Serial_Printf(\"Array index %d, Null Val: %s\\n\", i, result2.to<String>().c_str());\r\n            }\r\n\r\n            //Or use the same method as iterate the object\r\n            /*\r\n            size_t count = arr2.iteratorBegin();\r\n            Serial.println(\"\\n---------\");\r\n            for (size_t i = 0; i < count; i++)\r\n            {\r\n                FirebaseJson::IteratorValue value = arr2.valueAt(i);\r\n                Serial_Printf(\"Name: %s, Value: %s, Type: %s\\n\", value.key.c_str(), value.value.c_str(), value.type == FirebaseJson::JSON_OBJECT ? \"object\" : \"array\");\r\n            }\r\n            */\r\n        }\r\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "password",
        "token",
        "database",
        "payload",
        "wifi",
        "delay",
        "millis",
        "timestamp"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Docs.resetApp();\n    app.getApp<Firestore::Documents>(Docs);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        // Note: If new document created under non-existent ancestor documents, that document will not appear in queries and snapshot\n        // https://cloud.google.com/firestore/docs/using-console#non-existent_ancestor_documents.\n\n        // We will create the document in the parent path \"a0/b?\n        // a0 is the collection id, b? is the document id in collection a0.\n\n        String documentPath = \"a0/b\" + String(cnt);\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // double\n        Values::DoubleValue dblV(random(1, 500) / 100.0);\n\n        // boolean\n        Values::BooleanValue bolV(true);\n\n        // integer\n        Values::IntegerValue intV(random(500, 1000));\n\n        // null\n        Values::NullValue nullV;\n\n        String doc_path = \"projects/\";\n        doc_path += FIREBASE_PROJECT_ID;\n        doc_path += \"/databases/(default)/documents/coll_id/doc_id\"; // coll_id and doc_id are your collection id and document id\n\n        // reference\n        Values::ReferenceValue refV(doc_path);\n\n        // timestamp\n        Values::TimestampValue tsV(getTimestampString(1712674441, 999999999));\n\n        // bytes\n        Values::BytesValue bytesV(\"aGVsbG8=\");\n\n        // string\n        Values::StringValue strV(\"hello\");\n\n        // array\n        Values::ArrayValue arrV(Values::StringValue(\"test\"));\n        arrV.add(Values::IntegerValue(20)).add(Values::BooleanValue(true));\n\n        // map\n        Values::MapValue mapV(\"name\", Values::StringValue(\"wrench\"));\n        mapV.add(\"mass\", Values::StringValue(\"1.3kg\")).add(\"count\", Values::IntegerValue(3));\n\n        // lat long\n        Values::GeoPointValue geoV(1.486284, 23.678198);\n\n        Document<Values::Value> doc(\"myDouble\", Values::Value(dblV));\n        doc.add(\"myBool\", Values::Value(bolV)).add(\"myInt\", Values::Value(intV)).add(\"myNull\", Values::Value(nullV));\n        doc.add(\"myRef\", Values::Value(refV)).add(\"myTimestamp\", Values::Value(tsV)).add(\"myBytes\", Values::Value(bytesV));\n        doc.add(\"myString\", Values::Value(strV)).add(\"myArr\", Values::Value(arrV)).add(\"myMap\", Values::Value(mapV));\n        doc.add(\"myGeo\", Values::Value(geoV));\n\n        // The value of Values::xxxValue, Values::Value and Document can be printed on Serial.\n\n        Serial.println(\"Create document... \");\n\n        String payload = Docs.createDocument(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), documentPath, DocumentMask(), doc);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "getTimestampString",
          "parameters": "uint64_t sec, uint32_t nano",
          "body": "if (sec > 0x3afff4417f)\n        sec = 0x3afff4417f;\n\n    if (nano > 0x3b9ac9ff)\n        nano = 0x3b9ac9ff;\n\n    time_t now;\n    struct tm ts;\n    char buf[80];\n    now = sec;\n    ts = *localtime(&now);\n\n    String format = \"%Y-%m-%dT%H:%M:%S\";\n\n    if (nano > 0)\n    {\n        String fraction = String(double(nano) / 1000000000.0f, 9);\n        fraction.remove(0, 1);\n        format += fraction;\n    }\n    format += \"Z\";\n\n    strftime(buf, sizeof(buf), format.c_str(), &ts);\n    return buf;"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "key",
        "json",
        "flash"
      ],
      "libraries": [
        "Arduino.h",
        "FirebaseJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    // Create, parsing and modify JSON object and JSON array\n    // FirebaseJSON supports Arduino String, PROGMEM, flash string, std::string, char array, string literal, and sum of arduino String.\n\n    // All functions supported FPSTR, String, std::string, const char* and char array as parameters.\n\n    FirebaseJson json;       // or constructor with contents e.g. FirebaseJson json(\"{\\\"a\\\":true}\");\n    FirebaseJsonArray arr;   // or constructor with contents e.g. FirebaseJsonArray arr(\"[1,2,true,\\\"test\\\"]\");\n    FirebaseJsonData result; // object that keeps the deserializing result\n\n    // To set content\n    json.setJsonData(\"{\\\"a\\\":true}\");\n\n    arr.setJsonArrayData(\"[1,2,3]\");\n\n    // To add data to json\n    json.add(\"b\" /* key or name only */, 123 /* value of any type */);\n\n    // To set data to json\n    json.set(\"a/b/c\" /* key or relative path */, \"hello\" /* value */);\n\n    // To add value to array\n    arr.add(\"hello\").add(\"test\").add(99); // or arr.add(\"hello\", \"test\", 99);\n\n    // To add json into array\n    FirebaseJson json2(\"{\\\"d\\\":888,\\\"e\\\":false}\");\n    arr.add(json2);\n\n    // To set the value at index\n    arr.set(\"[0]\", 555); // or arr.set(0, 555);\n\n    // To set the value at specific path\n    arr.set(\"/[8]/i\", 111);\n    arr.set(\"/[8]/j\", 222);\n    arr.set(\"/[8]/k\", \"hi\");\n\n    // To add/set array into json\n    json.set(\"x/y/z\", arr);\n\n    // To serialize json to serial\n    json.toString(Serial, true /* prettify option */);\n\n    // To serialize array to string\n    String str;\n    arr.toString(str, true /* prettify option */);\n\n    Serial.println(\"\\n---------\");\n    Serial.println(str);\n\n    // To remove value from array at index or path\n    arr.remove(\"[6]/d\" /* path */);\n    arr.remove(7 /* index */);\n    Serial.println(\"\\n---------\");\n    Serial.println(arr.raw()); // print raw string\n\n    // To remove value from json\n    json.remove(\"x/y/z/[6]\");\n    Serial.println(\"\\n---------\");\n    Serial.println(json.raw()); // print raw string\n\n    // To get the value from json (deserializing)\n    json.get(result /* FirebaseJsonData */, \"a/b/c\" /* key or path */);\n\n    // To check the deserialized result and get its type and value\n    if (result.success)\n    {\n        Serial.println(\"\\n---------\");\n        if (result.type == \"string\") /* or result.typeNum == FirebaseJson::JSON_STRING */\n            Serial.println(result.to<String>().c_str());\n        else if (result.type == \"int\") /* or result.typeNum == FirebaseJson::JSON_INT */\n            Serial.println(result.to<int>());\n        else if (result.type == \"float\") /* or result.typeNum == FirebaseJson::JSON_FLOAT */\n            Serial.println(result.to<float>());\n        else if (result.type == \"double\") /* or result.typeNum == FirebaseJson::JSON_DOUBLE */\n            Serial.println(result.to<double>());\n        else if (result.type == \"bool\") /* or result.typeNum == FirebaseJson::JSON_BOOL */\n            Serial.println(result.to<bool>());\n        else if (result.type == \"object\") /* or result.typeNum == FirebaseJson::JSON_OBJECT */\n            Serial.println(result.to<String>().c_str());\n        else if (result.type == \"array\") /* or result.typeNum == FirebaseJson::JSON_ARRAY */\n            Serial.println(result.to<String>().c_str());\n        else if (result.type == \"null\") /* or result.typeNum == FirebaseJson::JSON_NULL */\n            Serial.println(result.to<String>().c_str());\n    }\n\n    // To get the json object from deserializing result\n    json.get(result /* FirebaseJsonData */, \"x/y/z/[7]\" /* key or path */);\n    if (result.success)\n    {\n\n        if (result.type == \"object\") /* or result.typeNum == FirebaseJson::JSON_OBJECT */\n        {\n            // Use result.get or result.getJSON instead of result.to\n            FirebaseJson json3;\n            result.get<FirebaseJson /* type e.g. FirebaseJson or FirebaseJsonArray */>(json3 /* object that used to store value */);\n            // or result.getJSON(json3);\n            Serial.println(\"\\n---------\");\n            json3.toString(Serial, true); // serialize contents to serial\n\n            // To iterate all values in Json object\n            size_t count = json3.iteratorBegin();\n            Serial.println(\"\\n---------\");\n            for (size_t i = 0; i < count; i++)\n            {\n                FirebaseJson::IteratorValue value = json3.valueAt(i);\n                Serial.printf(\"Name: %s, Value: %s, Type: %s\\n\", value.key.c_str(), value.value.c_str(), value.type == FirebaseJson::JSON_OBJECT ? \"object\" : \"array\");\n            }\n\n            Serial.println();\n            json3.iteratorEnd(); // required for free the used memory in iteration (node data collection)\n        }\n    }\n\n    // To get the json array object from deserializing result\n    json.get(result /* FirebaseJsonData */, \"x/y/z\" /* key or path */);\n    if (result.success)\n    {\n\n        if (result.type == \"array\") /* or result.typeNum == FirebaseJson::JSON_ARRAY */\n        {\n            // Use result.get or result.getJSON instead of result.to\n            FirebaseJsonArray arr2;\n            result.get<FirebaseJsonArray /* type e.g. FirebaseJson or FirebaseJsonArray */>(arr2 /* object that used to store value */);\n            // or result.getArray(arr2);\n            Serial.println(\"\\n---------\");\n            arr2.toString(Serial, true); // serialize contents to serial\n\n            // To iterate all values in Json array object\n            Serial.println(\"\\n---------\");\n            FirebaseJsonData result2;\n            for (size_t i = 0; i < arr2.size(); i++)\n            {\n                arr2.get(result2, i);\n                if (result2.type == \"string\" /* result2.typeNum == FirebaseJson::JSON_STRING */)\n                    Serial.printf(\"Array index %d, String Val: %s\\n\", i, result2.to<String>().c_str());\n                else if (result2.type == \"int\" /* result2.typeNum == FirebaseJson::JSON_INT */)\n                    Serial.printf(\"Array index %d, Int Val: %d\\n\", i, result2.to<int>());\n                else if (result2.type == \"float\" /* result2.typeNum == FirebaseJson::JSON_FLOAT */)\n                    Serial.printf(\"Array index %d, Float Val: %f\\n\", i, result2.to<float>());\n                else if (result2.type == \"double\" /* result2.typeNum == FirebaseJson::JSON_DOUBLE */)\n                    Serial.printf(\"Array index %d, Double Val: %f\\n\", i, result2.to<double>());\n                else if (result2.type == \"bool\" /* result2.typeNum == FirebaseJson::JSON_BOOL */)\n                    Serial.printf(\"Array index %d, Bool Val: %d\\n\", i, result2.to<bool>());\n                else if (result2.type == \"object\" /* result2.typeNum == FirebaseJson::JSON_OBJECT */)\n                    Serial.printf(\"Array index %d, Object Val: %s\\n\", i, result2.to<String>().c_str());\n                else if (result2.type == \"array\" /* result2.typeNum == FirebaseJson::JSON_ARRAY */)\n                    Serial.printf(\"Array index %d, Array Val: %s\\n\", i, result2.to<String>().c_str());\n                else if (result2.type == \"null\" /* result2.typeNum == FirebaseJson::JSON_NULL */)\n                    Serial.printf(\"Array index %d, Null Val: %s\\n\", i, result2.to<String>().c_str());\n            }\n\n            // Or use the same method as iterate the object\n            /*\n            size_t count = arr2.iteratorBegin();\n            Serial.println(\"\\n---------\");\n            for (size_t i = 0; i < count; i++)\n            {\n                FirebaseJson::IteratorValue value = arr2.valueAt(i);\n                Serial.printf(\"Name: %s, Value: %s, Type: %s\\n\", value.key.c_str(), value.value.c_str(), value.type == FirebaseJson::JSON_OBJECT ? \"object\" : \"array\");\n            }\n            */\n        }\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "rest",
        "https",
        "key",
        "certificate",
        "token",
        "auth",
        "callback",
        "json",
        "parse",
        "wifi",
        "millis",
        "delay",
        "sd",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "ESP_Google_Sheet_Client.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32) || defined(ESP8266)\n    WiFi.setAutoReconnect(true);\n#endif\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    // In case SD/SD_MMC storage file access, mount the SD/SD_MMC card.\n    // SD_Card_Mounting(); // See src/GS_SDHelper.h\n\n    // GSheet.setCert(rootCACert); // or GSheet.setCertFile(\"path/to/certificate/file.pem\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);\n\n    // Set the callback for Google API access token generation status (for debug only)\n    GSheet.setTokenCallback(tokenStatusCallback);\n\n    // The WiFi credentials are required for Pico W\n    // due to it does not have reconnect feature.\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    GSheet.clearAP();\n    GSheet.addAP(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    // Set the seconds to refresh the auth token before expire (60 to 3540, default is 300 seconds)\n    GSheet.setPrerefreshSeconds(10 * 60);\n\n    // Begin the access token generation for Google API authentication\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n    // Or begin with the Service Account JSON file\n    // GSheet.begin(\"path/to/serviceaccount/json/file\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\n    bool ready = GSheet.ready();\n\n    if (ready && !taskComplete)\n    {\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\n\n        FirebaseJson response;\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\n\n        Serial.println(\"\\nCreate spreadsheet...\");\n        Serial.println(\"------------------------\");\n\n        FirebaseJson spreadsheet;\n        spreadsheet.set(\"properties/title\", \"Test - Create Update and Read\");\n\n        String spreadsheetId, spreadsheetURL;\n        bool success = false;\n\n        // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/create\n\n        success = GSheet.create(&response /* returned response */, &spreadsheet /* spreadsheet object */, USER_EMAIL /* your email that this spreadsheet shared to */);\n        response.toString(Serial, true);\n        Serial.println();\n\n        if (success)\n        {\n\n            // Get the spreadsheet id from already created file.\n            FirebaseJsonData result;\n            response.get(result, FPSTR(\"spreadsheetId\")); // parse or deserialize the JSON response\n            if (result.success)\n                spreadsheetId = result.to<const char *>();\n\n            // Get the spreadsheet URL.\n            result.clear();\n            response.get(result, FPSTR(\"spreadsheetUrl\")); // parse or deserialize the JSON response\n            if (result.success)\n            {\n                spreadsheetURL = result.to<const char *>();\n                Serial.println(\"\\nThe spreadsheet URL\");\n                Serial.println(spreadsheetURL);\n            }\n\n            // If you assign the spreadsheet id from your own spreadsheet,\n            // to update and read, you need to set share access to the Service Account's CLIENT_EMAIL\n\n            Serial.println(\"\\nUpdate spreadsheet values...\");\n            Serial.println(\"------------------------------\");\n\n            FirebaseJson valueRange;\n\n            valueRange.add(\"range\", \"Sheet1!A1:C3\");\n            valueRange.add(\"majorDimension\", \"COLUMNS\");\n            valueRange.set(\"values/[0]/[0]\", \"A1\"); // column 1/row 1\n            valueRange.set(\"values/[0]/[1]\", \"A2\"); // column 1/row 2\n            valueRange.set(\"values/[0]/[2]\", \"A3\"); // column 1/row 3\n            valueRange.set(\"values/[1]/[0]\", \"B1\"); // column 2/row 1\n            valueRange.set(\"values/[1]/[1]\", \"B2\"); // column 2/row 2\n            valueRange.set(\"values/[1]/[2]\", \"B3\"); // column 2/row 3\n            valueRange.set(\"values/[2]/[0]\", \"C1\"); // column 3/row 1\n            valueRange.set(\"values/[2]/[1]\", \"C2\"); // column 3/row 2\n            valueRange.set(\"values/[2]/[2]\", \"C3\"); // column 3/row 3\n\n            // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/update\n\n            success = GSheet.values.update(&response /* returned response */, spreadsheetId /* spreadsheet Id to update */, \"Sheet1!A1:C3\" /* range to update */, &valueRange /* data to update */);\n            response.toString(Serial, true);\n            Serial.println();\n\n            Serial.println(\"\\nUpdate spreadsheet values...\");\n            Serial.println(\"------------------------------\");\n\n            valueRange.clear();\n\n            valueRange.add(\"range\", \"Sheet1!G1:I3\");\n            valueRange.add(\"majorDimension\", \"ROWS\");\n            valueRange.set(\"values/[0]/[0]\", \"G1\"); // row 1/column 7\n            valueRange.set(\"values/[1]/[0]\", \"G2\"); // row 2/column 7\n            valueRange.set(\"values/[2]/[0]\", \"G3\"); // row 3/column 7\n            valueRange.set(\"values/[0]/[1]\", \"H1\"); // row 1/column 8\n            valueRange.set(\"values/[1]/[1]\", \"H2\"); // row 2/column 8\n            valueRange.set(\"values/[2]/[1]\", \"H3\"); // row 3/column 8\n            valueRange.set(\"values/[0]/[2]\", \"I1\"); // row 1/column 9\n            valueRange.set(\"values/[1]/[2]\", \"I2\"); // row 2/column 9\n            valueRange.set(\"values/[2]/[2]\", \"I3\"); // row 3/column 9\n\n            success = GSheet.values.update(&response /* returned response */, spreadsheetId /* spreadsheet Id to update */, \"Sheet1!G1:I3\" /* range to update */, &valueRange /* data to update */);\n            response.toString(Serial, true);\n            Serial.println();\n\n            if (success)\n            {\n\n                Serial.println(\"\\nGet spreadsheet values...\");\n                Serial.println(\"------------------------------\");\n\n                // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/get\n\n                success = GSheet.values.get(&response /* returned response */, spreadsheetId /* spreadsheet Id to read */, \"Sheet1!A1:C3\" /* range to read */);\n                response.toString(Serial, true);\n                Serial.println();\n\n                Serial.println(\"\\nGet spreadsheet values...\");\n                Serial.println(\"------------------------------\");\n\n                success = GSheet.values.get(&response /* returned response */, spreadsheetId /* spreadsheet Id to read */, \"Sheet1!G1:I3\" /* range to read */);\n                if (success)\n                    response.toString(Serial, true);\n                else\n                    Serial.println(GSheet.errorReason());\n                Serial.println();\n\n#if defined(ESP32) || defined(ESP8266)\n                Serial.println(ESP.getFreeHeap());\n#elif defined(PICO_RP2040)\n                Serial.println(rp2040.getFreeHeap());\n#endif\n            }\n        }\n\n        taskComplete = true;\n    }"
        },
        {
          "name": "tokenStatusCallback",
          "parameters": "TokenInfo info",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());\n    }\n    else\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay",
        "lcd",
        "display"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n  // Print a message to the LCD.\n  lcd.print(\"hello, world!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Turn off the cursor:\n  lcd.noCursor();\n  delay(500);\n  // Turn on the cursor:\n  lcd.cursor();\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "token",
        "auth",
        "key",
        "https",
        "callback",
        "json",
        "payload",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "timestamp",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    // Initialize the FirebaseApp or auth task handler.\n    // To deinitialize, use deinitializeApp(app).\n    initializeApp(aClient, app, getAuth(custom_auth), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);\n        }\n    }\n    ts = time(nullptr);\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\n    ts = WiFi.getTime();\n#endif"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "token",
        "auth",
        "key",
        "https",
        "callback",
        "json",
        "payload",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "spiffs",
        "timestamp",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FS.h",
        "SPIFFS.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n#if defined(ENABLE_FS)\n    MY_FS.begin();\n#endif\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    // Initialize the FirebaseApp or auth task handler.\n    // To deinitialize, use deinitializeApp(app).\n    initializeApp(aClient, app, getAuth(sa_file_auth), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);\n        }\n    }\n    ts = time(nullptr);\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\n    ts = WiFi.getTime();\n#endif"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "fileCallback",
          "parameters": "File &file, const char *filename, file_operating_mode mode",
          "body": "// FILE_OPEN_MODE_READ, FILE_OPEN_MODE_WRITE and FILE_OPEN_MODE_APPEND are defined in this library\n    // MY_FS is defined in this example\n    switch (mode)\n    {\n    case file_mode_open_read:\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_READ);\n        break;\n    case file_mode_open_write:\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_WRITE);\n        break;\n    case file_mode_open_append:\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_APPEND);\n        break;\n    case file_mode_remove:\n        MY_FS.remove(filename);\n        break;\n    default:\n        break;\n    }\n    // Set the internal FS object with global File object.\n    file = myFile;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "analogread",
        "delay",
        "lcd",
        "display",
        "sensorreading"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize LCD and set up the number of columns and rows:\n  lcd.begin(16, 2);\n\n  // create a new character\n  lcd.createChar(0, heart);\n  // create a new character\n  lcd.createChar(1, smiley);\n  // create a new character\n  lcd.createChar(2, frownie);\n  // create a new character\n  lcd.createChar(3, armsDown);\n  // create a new character\n  lcd.createChar(4, armsUp);\n\n  // set the cursor to the top left\n  lcd.setCursor(0, 0);\n\n  // Print a message to the lcd.\n  lcd.print(\"I \");\n  lcd.write(byte(0)); // when calling lcd.write() '0' must be cast as a byte\n  lcd.print(\" Arduino! \");\n  lcd.write((byte)1);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the potentiometer on A0:\n  int sensorReading = analogRead(A0);\n  // map the result to 200 - 1000:\n  int delayTime = map(sensorReading, 0, 1023, 200, 1000);\n  // set the cursor to the bottom row, 5th position:\n  lcd.setCursor(4, 1);\n  // draw the little man, arms down:\n  lcd.write(3);\n  delay(delayTime);\n  lcd.setCursor(4, 1);\n  // draw him arms up:\n  lcd.write(4);\n  delay(delayTime);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "i2c",
        "delay",
        "display",
        "lcd"
      ],
      "libraries": [
        "Wire.h",
        "LCD03.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialise a 20x4 LCD\n  lcd.begin(20, 4);\n  \n  // create a new character\n  lcd.createChar(0, smiley);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Write the first custom char to the LCD\n  lcd.write(0);\n\n  // Wait for 1 second\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "wificlient",
        "https",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting CustomHeader on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);\n  }\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n\n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n\n#endif\n\n#endif\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  // you're connected now, so print out the data\n  printWifiStatus();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Making GET request\");\n  httpClient.beginRequest();\n\n  httpClient.get(\"/\");\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"GET Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"GET Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);\n\n  Serial.println(\"Making POST request\");\n  String postData = \"name=Alice&age=12\";\n  httpClient.beginRequest();\n  httpClient.post(\"/\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_LENGTH, postData.length());\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n  httpClient.write((const byte*)postData.c_str(), postData.length());\n  // note: the above line can also be achieved with the simpler line below:\n  //httpClient.print(postData);\n\n  // read the status code and body of the response\n  statusCode = httpClient.responseStatusCode();\n  response = httpClient.responseBody();\n\n  Serial.print(\"POST Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"POST Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "delay",
        "millis"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStarting BasicAuthGet_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Making GET request\");\n  httpClient.beginRequest();\n  \n  httpClient.get(\"/\");\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"GET Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"GET Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);\n\n  Serial.println(\"Making POST request\");\n  String postData = \"name=Alice&age=12\";\n  httpClient.beginRequest();\n  httpClient.post(\"/\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n  httpClient.sendHeader(HTTP_HEADER_CONTENT_LENGTH, postData.length());\n  httpClient.sendHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n  httpClient.endRequest();\n  httpClient.write((const byte*)postData.c_str(), postData.length());\n  // note: the above line can also be achieved with the simpler line below:\n  //httpClient.print(postData);\n\n  // read the status code and body of the response\n  statusCode = httpClient.responseStatusCode();\n  response = httpClient.responseBody();\n\n  Serial.print(\"POST Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"POST Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key"
      ],
      "libraries": [
        "Keypad.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "char customKey = customKeypad.getKey();\n  \n  if (customKey){\n    Serial.println(customKey);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "digitalwrite",
        "millis",
        "delay",
        "led",
        "devices"
      ],
      "libraries": [
        "menu.h",
        "menuIO/serialOut.h",
        "menuIO/serialIn.h"
      ],
      "functions": [
        {
          "name": "changed",
          "parameters": "const navNode &nav,const menuOut& out,bool sub=true",
          "body": "t=millis()/1000;\n    return last!=t;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LEDPIN,OUTPUT);\n  digitalWrite(LEDPIN,HIGH);\n  Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"menu 4.x test\");Serial.flush();\n  nav.idleTask=idle;//point a function to be used when menu is suspended\n  // nav.idleOn(idle);//enter idle mode, this menu will start on idle state, press select  to enter menu\n  // nav.doInput(\"4\");//we can also provide input from string, this will enter idle mode by exiting the menu\n\n  //this is an example of driving the menu string input\n  //this however requires a known menu state and therefor is not recomended for complicated menus\n  // see async calls instead\n  // for(int c=0;c<3;c++) {//using the menu to blink the led\n  //   nav.doInput(\"2\");//led on\n  //   delay(1000);\n  //   nav.doInput(\"3\");//led off\n  //   delay(1000);\n  // }\n\n  //NOTE: async is disabled now define MENU_ASYNC to activate it\n  //following code is an async navigation example\n  //its async because it does not require a known menu state\n  //because you can indicate the zero indexed option positions separated by /\n  //it also works for field by accepting the input\n  //ex: \"/0/1/12\" -> will select first option on main menu,\n  // then the second option (eventually a field)\n  // and finally set the field value to 12 (or select 13th position on a menu)\n  //\n  // note that this is menu position starting at zero (not accel keys)\n  // this is experimental API base for web interface\n  // for(int c=0;c<3;c++) {//using the menu to blink the led\n  //   nav.async(\"/1\");\n  //   delay(1000);\n  //   nav.async(\"/2\");\n  //   delay(1000);\n  // }\n\n  //there is also the possibility of navigating the menu by calling api functions\n  //this is however indicated if you have custom input devices\n  //or building a driver for a new input.\n\n  for(int c=0;c<10;c++) {//using the menu to blink the led\n    nav.doNav(navCmd(idxCmd,1));\n    nav.doNav(navCmd(enterCmd));\n    delay(300);\n    nav.doNav(navCmd(idxCmd,3));\n    nav.doNav(navCmd(enterCmd));\n    delay(300);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "nav.poll();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "password",
        "token",
        "database",
        "payload",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "timestamp",
        "clients"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Database.resetApp();\n    app.getApp<RealtimeDatabase>(Database);\n\n    Database.url(DATABASE_URL);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Database.loop();\n\n    if (app.ready() && (ms == 0 || millis() - ms > 60000))\n    {\n        ms = millis();\n\n        String path = \"/test/int2/\" + genUUID();\n\n        // Push int\n        Serial.print(\"Push int... \");\n        String name = Database.push<int>(aClient, \"/test/int\", 12345);\n\n        if (aClient.lastError().code() == 0)\n            Firebase.printf(\"ok, name: %s\\n\", name.c_str());\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n\n        // Set int with custom UUID.\n        Serial.print(\"Set int with custom UUID... \");\n        bool status = Database.set<int>(aClient, path, 12345);\n\n        if (status)\n            Serial.println(\"ok\");\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        if (aResult.to<RealtimeDatabaseResult>().name().length())\n            Firebase.printf(\"task: %s, name: %s\\n\", aResult.uid().c_str(), aResult.to<RealtimeDatabaseResult>().name().c_str());\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);\n        }\n    }\n    ts = time(nullptr);\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\n    ts = WiFi.getTime();\n#endif"
        },
        {
          "name": "genUUID",
          "parameters": "",
          "body": "// This is how Firebase generate UUID when you calling Push.\n\n    // Push UUID generator, https://gist.github.com/mikelehen/3596a30bd69384624c11\n\n    /**\n     * Fancy ID generator that creates 20-character string identifiers with the following properties:\n     *\n     * 1. They're based on timestamp so that they sort *after* any existing ids.\n     * 2. They contain 72-bits of random data after the timestamp so that IDs won't collide with other clients' IDs.\n     * 3. They sort *lexicographically* (so the timestamp is converted to characters that will sort properly).\n     * 4. They're monotonically increasing.  Even if you generate more than one in the same timestamp, the\n     *    latter ones will sort after the former ones.  We do this by using the previous random bits\n     *    but \"incrementing\" them by 1 (only in the case of a timestamp collision).\n     */\n\n    // Modeled after base64 web-safe chars, but ordered by ASCII.\n    static char PUSH_CHARS[] = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n\n    // Timestamp of last push, used to prevent local collisions if you push twice in one ms.\n    static long long lastPushTime = 0;\n\n    // We generate 72-bits of randomness which get turned into 12 characters and appended to the\n    // timestamp to prevent collisions with other clients.  We store the last characters we\n    // generated because in the event of a collision, we'll use those same characters except\n    // \"incremented\" by one.\n    char lastRandChars[72] = \"\";\n    char timeStampChars[9] = \"\";\n\n    uint32_t ts = 0;\n    timeStatusCB(ts);\n\n    long long now = ts * 1000LL;\n\n    srand(now);\n\n    bool duplicateTime = (now == lastPushTime);\n    lastPushTime = now;\n\n    for (int i = 7; i >= 0; i--)\n    {\n        timeStampChars[i] = PUSH_CHARS[(int)(now % 64)];\n        now = now / 64;\n    }\n\n    // We should have converted the entire timestamp.\n    if (now != 0)\n        return String();\n\n    timeStampChars[8] = '\\0';\n\n    String id = timeStampChars;\n\n    if (!duplicateTime)\n    {\n        for (int i = 0; i < 12; i++)\n        {\n            double fl = ((double)rand() / (double)(RAND_MAX + 1.0)) * 64;\n            lastRandChars[i] = (char)floor(fl);\n        }\n    }\n    else\n    {\n        // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.\n        int val = 0;\n        for (int i = 11; i >= 0 && lastRandChars[i] == 63; i--)\n        {\n            val = i;\n            lastRandChars[i] = 0;\n        }\n\n        if (val >= 0)\n            lastRandChars[val]++;\n    }\n\n    for (int i = 0; i < 12; i++)\n        id += PUSH_CHARS[(int)lastRandChars[i]];\n\n    // Length should be 20.\n    if (id.length() != 20)\n        return String();\n\n    return id;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "wifi",
        "flash",
        "sd"
      ],
      "libraries": [
        "WiFiNINA.h",
        "ArduinoOTA.h",
        "SFU.h",
        "FileSystemStorage.h",
        "arduino_secrets.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial:\n  Serial.begin(9600);\n\n  // check for the presence of the shield:\n  if (WiFi.status() == WL_NO_SHIELD) {\n    Serial.println(\"WiFi shield not present\");\n    // don't continue:\n    while (true);\n  }\n\n  // attempt to connect to Wifi network:\n  while ( status != WL_CONNECTED) {\n    Serial.print(\"Attempting to connect to SSID: \");\n    Serial.println(ssid);\n    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:\n    status = WiFi.begin(ssid, pass);\n  }\n\n  // start the WiFi OTA library with SD based storage\n  ArduinoOTA.begin(WiFi.localIP(), \"Arduino\", \"password\", FSStorage);\n\n  // you're connected now, so print out the status:\n  printWifiStatus();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// check for WiFi OTA updates\n  ArduinoOTA.poll();\n\n  // add your normal loop code below ..."
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "certificate",
        "auth",
        "ssl",
        "database",
        "payload",
        "json",
        "buffer",
        "callback",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "client_email",
        "node1"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    /* Assign the certificate data (optional) */\n    // config.cert.data = rootCACert;\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the sevice account credentials and private key (required) */\n    config.service_account.data.client_email = FIREBASE_CLIENT_EMAIL;\n    config.service_account.data.project_id = FIREBASE_PROJECT_ID;\n    config.service_account.data.private_key = PRIVATE_KEY;\n\n    /** Assign the unique user ID (uid) (required)\n     * This uid will be compare to the auth.uid variable in the database rules.\n     *\n     * If the assigned uid (user UID) was not existed, the new user will be created.\n     *\n     * If the uid is empty or not assigned, the library will create the OAuth2.0 access token\n     * instead.\n     *\n     * With OAuth2.0 access token, the device will be signed in as admin which has\n     * the full ggrant access and no database rules and custom claims are applied.\n     * This similar to sign in using the database secret but no admin rights.\n     */\n    auth.token.uid = \"Node1\";\n\n    /** Assign the custom claims (optional)\n     * This uid will be compare to the auth.token.premium_account variable\n     * (for this case) in the database rules.\n     */\n    FirebaseJson claims;\n    claims.add(\"premium_account\", true);\n    claims.add(\"admin\", true);\n    auth.token.claims = claims.raw();\n\n    /* Assign the RTDB URL */\n    config.database_url = DATABASE_URL;\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    fbdo.setResponseSize(4096);\n\n    /* path for user data is now \"/UsersData/Node1\" */\n    String base_path = \"/UsersData/\";\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    /* Now we start to signin using custom token */\n\n    /** Initialize the library with the Firebase authen and config.\n     *\n     * The device time will be set by sending request to the NTP server\n     * befor token generation and exchanging.\n     *\n     * The signed RSA256 jwt token will be created and used for id token exchanging.\n     *\n     * Theses process may take time to complete.\n     */\n    Firebase.begin(&config, &auth);\n\n    /** Now modify the database rules (if not yet modified)\n     *\n     * The user, Node1 in this case will be granted to read and write\n     * at the curtain location i.e. \"/UsersData/Node1\" and we will also check the\n     * custom claims in the rules which must be matched.\n     *\n     * If you database rules has been modified, please comment this code out.\n     *\n     * The character $ is to make a wildcard variable (can be any name) represents any node key\n     * which located at some level in the rule structure and use as reference variable\n     * in .read, .write and .validate rules\n     *\n     * For this case $userId represents any <user uid> node that places under UsersData node i.e.\n     * /UsersData/<user uid> which <user uid> is user UID or \"Node1\" in this case.\n     *\n     * Please check your the database rules to see the changes after run the below code.\n     */\n    String var = \"$userId\";\n    String val = \"($userId === auth.uid && auth.token.premium_account === true && auth.token.admin === true)\";\n    Firebase.setReadWriteRules(fbdo, base_path, var, val, val, DATABASE_SECRET);\n\n    /**\n     * The custom token which created internally in this library will use\n     * to exchange with the id token returns from the server.\n     *\n     * The id token is the token which used to sign in as a user.\n     *\n     * The id token was already saved to the config data (FirebaseConfig data variable) that\n     * passed to the Firebase.begin function.\n     *\n     * The id token can be accessed from Firebase.getToken().\n     *\n     * The refresh token can be accessed from Firebase.getRefreshToken().\n     */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = \"/UsersData/\";\n        path += auth.token.uid.c_str(); //<- user uid or \"Node1\"\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "auth",
        "certificate",
        "ssl",
        "database",
        "payload",
        "json",
        "buffer",
        "callback",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "flash",
        "sd",
        "timestamp",
        "rtc",
        "node1"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    /* Assign the certificate file (optional) */\n    // config.cert.file = \"/cert.cer\";\n    // config.cert.file_storage = mem_storage_type_flash;\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* The file systems for flash and SD/SDMMC can be changed in FirebaseFS.h. */\n\n    /* Assign the sevice account JSON file and the file storage type (required) */\n    config.service_account.json.path = \"/service_account_file.json\"; // change this for your json file\n    config.service_account.json.storage_type = StorageType::FLASH;   // or StorageType::SD\n\n    /** Assign the unique user ID (uid) (required)\n     * This uid will be compare to the auth.uid variable in the database rules.\n     *\n     * If the assigned uid (user UID) was not existed, the new user will be created.\n     *\n     * If the uid is empty or not assigned, the library will create the OAuth2.0 access token\n     * instead.\n     *\n     * With OAuth2.0 access token, the device will be signed in as admin which has\n     * the full ggrant access and no database rules and custom claims are applied.\n     * This similar to sign in using the database secret but no admin rights.\n     */\n    auth.token.uid = \"Node1\";\n\n    /* Assign the RTDB URL */\n    config.database_url = DATABASE_URL;\n\n    /** Assign the custom claims (optional)\n     * This uid will be compare to the auth.token.premium_account variable\n     * (for this case) in the database rules.\n     */\n    FirebaseJson claims;\n    claims.add(\"premium_account\", true);\n    claims.add(\"admin\", true);\n    auth.token.claims = claims.raw();\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    fbdo.setResponseSize(4096);\n\n    /* path for user data is now \"/UsersData/Node1\" */\n    String base_path = \"/UsersData/\";\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    /** To set system time with the timestamp from RTC\n     * The internal NTP server time acquisition\n     * of token generation process will be skipped,\n     * if the system time is already set.\n     *\n     * sec is the seconds from midnight Jan 1, 1970\n     */\n    // Firebase.setSystemTime(sec);\n\n    /* Now we start to signin using custom token */\n\n    /** Initialize the library with the Firebase authen and config.\n     *\n     * The device time will be set by sending request to the NTP server\n     * befor token generation and exchanging.\n     *\n     * The signed RSA256 jwt token will be created and used for id token exchanging.\n     *\n     * Theses process may take time to complete.\n     */\n    Firebase.begin(&config, &auth);\n\n    /** Now modify the database rules (if not yet modified)\n     *\n     * The user, Node1 in this case will be granted to read and write\n     * at the curtain location i.e. \"/UsersData/Node1\" and we will also check the\n     * custom claims in the rules which must be matched.\n     *\n     * If you database rules has been modified, please comment this code out.\n     *\n     * The character $ is to make a wildcard variable (can be any name) represents any node key\n     * which located at some level in the rule structure and use as reference variable\n     * in .read, .write and .validate rules\n     *\n     * For this case $userId represents any <user uid> node that places under UsersData node i.e.\n     * /UsersData/<user uid> which <user uid> is user UID or \"Node1\" in this case.\n     *\n     * Please check your the database rules to see the changes after run the below code.\n     */\n    String var = \"$userId\";\n    String val = \"($userId === auth.uid && auth.token.premium_account === true && auth.token.admin === true)\";\n    Firebase.setReadWriteRules(fbdo, base_path, var, val, val, DATABASE_SECRET);\n\n    /**\n     * The custom token which created internally in this library will use\n     * to exchange with the id token returns from the server.\n     *\n     * The id token is the token which used to sign in as a user.\n     *\n     * The id token was already saved to the config data (FirebaseConfig data variable) that\n     * passed to the Firebase.begin function.\n     *\n     * The id token can be accessed from Firebase.getToken().\n     *\n     * The refresh token can be accessed from Firebase.getRefreshToken().\n     */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = \"/UsersData/\";\n        path += auth.token.uid.c_str(); //<- user uid is \"Node1\"\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "digitalwrite",
        "millis"
      ],
      "libraries": [
        "Wire.h",
        "reset.h",
        "Sodaq_wdt.h"
      ],
      "functions": [
        {
          "name": "requestEvent",
          "parameters": "",
          "body": "Wire.write(dest_addr);"
        },
        {
          "name": "receiveEvent",
          "parameters": "int howMany",
          "body": "command = Wire.read();\n  if (command == 'r') {\n    stay_in_bootloader = true;\n    while (Wire.available()) {\n      Wire.read();\n    }\n    return;\n  }\n\n  if (command == 'x') {\n    digitalWrite(LED_BUILTIN, HIGH);\n    stay_in_bootloader = false;\n  }\n\n  if (command == 'w') {\n    last_crc = (uint8_t)Wire.read();\n    while (Wire.available() && buf_available < 64) {\n      buffer[buf_available++] = (uint8_t)Wire.read();\n    }\n    return;\n  }\n\n  // empty the buffer in case of spurious data\n  while (Wire.available()) {\n    Wire.read();\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// put your setup code here, to run once:\n  Wire.begin(I2C_ADDRESS);\n  Wire.onRequest(requestEvent);\n  Wire.onReceive(receiveEvent);\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(3, INPUT_PULLUP);\n\n  setup_ptrs();\n  sodaq_wdt_enable(WDT_PERIOD_2X);\n\n  int start = millis();\n\n  if (system_get_reset_cause() == SYSTEM_RESET_CAUSE_WDT) {\n    stay_in_bootloader = true;\n  }\n\n  while (millis() - start < 100) {\n    if (stay_in_bootloader) {\n      erase_all();\n      break;\n    }\n  }\n\n  if (*flash_ptr != 0xFFFFFFFF && !stay_in_bootloader) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    boot_app();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if ((millis() % 1000 > 500) && ((millis() / 1000) % 2 != status)) {\n    digitalWrite(LED_BUILTIN, status);\n    status = (millis() / 1000) % 2;\n  }\n\n  if (sodaq_wdt_flag) {\n    sodaq_wdt_flag = false;\n    sodaq_wdt_reset();\n  }\n\n  if (stay_in_bootloader == false) {\n    NVIC_SystemReset();\n  }\n\n  if (buf_available == 64) {\n\n    uint8_t crc = 0;\n\n    for (int i = 0; i < 64; i++) {\n      crc ^= buffer[i];\n    }\n\n    if (crc != last_crc) {\n      buf_available = 0;\n      return;\n    }\n\n    noInterrupts();\n    nvm_write_buffer(dest_addr, (const uint8_t*)buffer, PAGE_SIZE);\n    dest_addr += PAGE_SIZE;\n    buf_available = 0;\n    interrupts();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "digitalwrite",
        "millis",
        "pid"
      ],
      "libraries": [
        "Wire.h",
        "EncoderWrapper.h",
        "Battery.h",
        "DCMotor.h",
        "ServoMotor.h",
        "Common.h",
        "Events.h",
        "PID.h",
        "FreeRAM.h"
      ],
      "functions": [
        {
          "name": "led_on",
          "parameters": "",
          "body": "digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "WDT->CTRL.reg &= ~WDT_CTRL_ENABLE;\n  while (WDT->STATUS.reg & WDT_STATUS_SYNCBUSY);\n\n  //temp_init();\n  battery = new Battery(ADC_BATTERY);\n\n  dcmotors[0] = new DCMotor(MOTOR_1_COUNTER, MOTOR_1_PIN_A, MOTOR_1_PIN_B);\n  dcmotors[1] = new DCMotor(MOTOR_2_COUNTER, MOTOR_2_PIN_A, MOTOR_2_PIN_B),\n\n  servos[0] = new ServoMotor(PWM_PIN_SERVO_1);\n  servos[1] = new ServoMotor(PWM_PIN_SERVO_2);\n  servos[2] = new ServoMotor(PWM_PIN_SERVO_3);\n  servos[3] = new ServoMotor(PWM_PIN_SERVO_4);\n\n  encoders[0] = new EncoderWrapper(ENCODER_2_PIN_A, ENCODER_2_PIN_B, 1);\n  encoders[1] = new EncoderWrapper(ENCODER_1_PIN_A, ENCODER_1_PIN_B, 0);\n\n  pid_control[0] = new PIDWrapper(encoders[0]->position, encoders[0]->velocity, dcmotors[0], 0, 10, 100); //10ms period velo, 100ms period pos\n  pid_control[1] = new PIDWrapper(encoders[1]->position, encoders[1]->velocity, dcmotors[1], 1, 10, 100),\n\n  Wire.begin(I2C_ADDRESS);\n  Wire.onRequest(requestEvent);\n  Wire.onReceive(receiveEvent);\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(IRQ_PIN, OUTPUT);\n  analogWriteResolution(8);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (command == RESET || ((lastMessageReceived != 0) && (millis() - lastMessageReceived > 10000))) {\n    reboot();\n  }\n  if (command == PING) {\n    lastMessageReceived = millis();\n  }\n  executeTimedEvents();"
        },
        {
          "name": "receiveEvent",
          "parameters": "int howMany",
          "body": "noInterrupts();\n  command = Wire.read();\n\n  if (command < GET_VERSION) {\n    // empty buffer\n    while (Wire.available()) {\n      Wire.read();\n    }\n    interrupts();\n    return;\n  }\n\n  if (Wire.available()) {\n    target = Wire.read();\n  } else {\n    interrupts();\n    return;\n  }\n  int value = 0;\n\n\n  if (!Wire.available()) {\n    interrupts();\n    return;\n  }\n\n  uint8_t buf[8];\n  int i = 0;\n  while (Wire.available() && i < sizeof(buf)) {\n    buf[i++] = (uint8_t)Wire.read();\n  }\n\n  // copies the bytes to int\n  memcpy(&value, buf, sizeof(value));\n\n  switch (command) {\n    case SET_PWM_DUTY_CYCLE_SERVO:\n      servos[target]->setDuty(value);\n      break;\n    case SET_PWM_FREQUENCY_SERVO:\n      servos[target]->setFrequency(value);\n      break;\n    case SET_PWM_DUTY_CYCLE_DC_MOTOR:\n      ((PIDWrapper*)dcmotors[target]->pid)->stop();\n      dcmotors[target]->setDuty(value);\n      break;\n    case SET_PWM_FREQUENCY_DC_MOTOR:\n      dcmotors[target]->setFrequency(value);\n      break;\n    case RESET_COUNT_ENCODER:\n      encoders[target]->resetCounter(value);\n      break;\n    case SET_INTERRUPT_ON_COUNT_ENCODER:\n      encoders[target]->setIrqOnCount(value);\n      break;\n    case SET_INTERRUPT_ON_VELOCITY_ENCODER:\n      encoders[target]->setIrqOnVelocity(value);\n      break;\n    case SET_PID_GAIN_CL_MOTOR:\n      {\n        int16_t P16 = *((int16_t*)&buf[0]);\n        int16_t I16 = *((int16_t*)&buf[2]);\n        int16_t D16 = *((int16_t*)&buf[4]);\n        Fix16 P = ((Fix16)P16) / short(1000);\n        Fix16 I = ((Fix16)I16) / short(1000);\n        Fix16 D = ((Fix16)D16) / short(1000);\n        pid_control[target]->setGains(P, I , D);\n        break;\n      }\n    case RESET_PID_GAIN_CL_MOTOR:\n      pid_control[target]->resetGains();\n      break;\n    case SET_CONTROL_MODE_CL_MOTOR:\n      pid_control[target]->setControlMode((cl_control)value);\n      break;\n    case SET_POSITION_SETPOINT_CL_MOTOR:\n      pid_control[target]->setSetpoint(TARGET_POSITION, Fix16(value * 1.0));\n      break;\n    case SET_VELOCITY_SETPOINT_CL_MOTOR:\n      pid_control[target]->setSetpoint(TARGET_VELOCITY, Fix16(value * 1.0));\n      break;\n    case SET_MAX_ACCELERATION_CL_MOTOR: {\n        pid_control[target]->setMaxAcceleration(Fix16(value * 1.0));\n        break;\n      }\n    case SET_MAX_VELOCITY_CL_MOTOR:\n      pid_control[target]->setMaxVelocity(Fix16(value * 1.0));\n      break;\n    case SET_MIN_MAX_DUTY_CYCLE_CL_MOTOR:\n      pid_control[target]->setLimits(*((int16_t*)&buf[0]), *((int16_t*)&buf[2]));\n      break;\n  }\n  interrupts();"
        },
        {
          "name": "requestEvent",
          "parameters": "",
          "body": "noInterrupts();\n  //deassert IRQ\n  if (irq_enabled) {\n    digitalWrite(IRQ_PIN, HIGH);\n  }\n\n  // Always reply with irq status\n  Wire.write(irq_status);\n\n  switch (command) {\n    case GET_VERSION:\n      getFWVersion();\n      break;\n    case GET_RAW_COUNT_ENCODER:\n      encoders[target]->getRawCount();\n      break;\n    case GET_OVERFLOW_UNDERFLOW_STATUS_ENCODER:\n      encoders[target]->getOverflowUnderflow();\n      break;\n    case GET_COUNT_PER_SECOND_ENCODER:\n      encoders[target]->getCountPerSecond();\n      break;\n    case GET_RAW_ADC_BATTERY:\n      battery->getRaw();\n      break;\n    case GET_CONVERTED_ADC_BATTERY:\n      battery->getConverted();\n      break;\n    case GET_FILTERED_ADC_BATTERY:\n      battery->getFiltered();\n      break;\n    case GET_INTERNAL_TEMP:\n      getInternalTemperature();\n      break;\n    case CLEAR_IRQ:\n      Wire.write((int)irq_status);\n      irq_status = 0;\n      break;\n    case GET_FREE_RAM:\n      Wire.write((int)FreeRam());\n      break;\n  }\n  interrupts();"
        },
        {
          "name": "requestAttention",
          "parameters": "int cause",
          "body": "irq_status |= (1 << cause);\n  if (irq_enabled) {\n    digitalWrite(IRQ_PIN, LOW);\n  }"
        },
        {
          "name": "getFWVersion",
          "parameters": "",
          "body": "Wire.write(FW_VERSION);"
        },
        {
          "name": "getInternalTemperature",
          "parameters": "",
          "body": "//Wire.write(temp_raw_to_mdeg(temp_read_raw()));"
        },
        {
          "name": "reboot",
          "parameters": "",
          "body": "NVIC_SystemReset();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "wifi",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Basic Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  dccexProtocol.setLogStream(&Serial);\n\n  dccexProtocol.enableHeartbeat();\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "power",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "parameters": "int major, int minor, int patch",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);\n  }\n\n  void receivedTrackPower(TrackPower state) {\n    Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");\n  }\n\n  void receivedLocoUpdate(Loco *loco) {\n    Serial.print(\"Received Loco update for DCC address: \");\n    Serial.println(loco->getAddress());\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Loco Control Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  // Logging on Serial\n  dccexProtocol.setLogStream(&Serial);\n\n  // Pass the delegate instance to wiThrottleProtocol\n  dccexProtocol.setDelegate(&myDelegate);\n\n  dccexProtocol.enableHeartbeat();\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");\n\n  dccexProtocol.requestServerVersion();\n\n  // Turn track power on for locos to move\n  dccexProtocol.powerOn();\n\n  lastTime = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  if (!consist) {\n    consist = new Consist();\n\n    // create a loco with DCC address 11 - LocoSourceEntry means it's not from the roster\n    Loco *loco1 = new Loco(11, LocoSource::LocoSourceEntry);\n    Serial.print(\"Created loco: \");\n    Serial.println(loco1->getAddress());\n\n    // add this loco to the consist\n    consist->addLoco(loco1, Facing::FacingForward);\n\n    // create a second loco with DCC address 12 - LocoSourceEntry means it's not from the roster\n    Loco *loco2 = new Loco(12, LocoSource::LocoSourceEntry);\n    Serial.print(\"Created loco: \");\n    Serial.println(loco2->getAddress());\n\n    // add this loco to the consist, and it will be running in reverse direction\n    consist->addLoco(loco2, Facing::FacingReversed);\n\n    // turn track power on or the loco won't move\n    dccexProtocol.powerOn();\n  }\n\n  if (consist) {\n    // every 10 seconds change speed and set a random function on or off\n    if ((millis() - lastTime) >= 10000) {\n      if (speed >= 100)\n        up = -1;\n      if (speed <= 0)\n        up = 1;\n      speed = speed + up;\n      dccexProtocol.setThrottle(consist, speed, Direction::Forward);\n\n      int fn = random(0, 27);\n      int fns = random(0, 100);\n      bool fnState = (fns < 50) ? false : true;\n\n      if (fnState) {\n        dccexProtocol.functionOn(consist, fn);\n      } else {\n        dccexProtocol.functionOff(consist, fn);\n      }\n\n      lastTime = millis();\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "wifi",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "parameters": "int major, int minor, int patch",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Delegate Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  // Setup logging to serial console\n  dccexProtocol.setLogStream(&Serial);\n\n  // Pass the delegate instance to wiThrottleProtocol\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");\n\n  dccexProtocol.requestServerVersion();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "power",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "parameters": "int major, int minor, int patch",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);\n  }\n\n  void receivedTrackPower(TrackPower state) {\n    Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");\n  }\n\n  void receivedLocoUpdate(Loco *loco) {\n    Serial.print(\"Received Loco update for DCC address: \");\n    Serial.println(loco->getAddress());\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Loco Control Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  // Logging on Serial\n  dccexProtocol.setLogStream(&Serial);\n\n  // Pass the delegate instance to wiThrottleProtocol\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");\n\n  dccexProtocol.requestServerVersion();\n\n  lastTime = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  if (!loco) {\n    // add a loco with DCC address 11 - LocoSourceEntry means it's not from the roster\n    loco = new Loco(11, LocoSource::LocoSourceEntry);\n    Serial.print(\"Added loco: \");\n    Serial.println(loco->getAddress());\n\n    // turn track power on or the loco won't move\n    dccexProtocol.powerOn();\n  }\n\n  if (loco) {\n    // every 10 seconds change speed and set a random function on or off\n    if ((millis() - lastTime) >= 10000) {\n      if (speed >= 100)\n        up = -1;\n      if (speed <= 0)\n        up = 1;\n      speed = speed + up;\n      dccexProtocol.setThrottle(loco, speed, Direction::Forward);\n\n      int fn = random(0, 27);\n      int fns = random(0, 100);\n      bool fnState = (fns < 50) ? false : true;\n\n      if (fnState) {\n        dccexProtocol.functionOn(loco, fn);\n      } else {\n        dccexProtocol.functionOff(loco, fn);\n      }\n\n      lastTime = millis();\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "power",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "parameters": "int major, int minor, int patch",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);\n  }\n\n  void receivedTrackPower(TrackPower state) {\n    Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");\n  }\n\n  void receivedLocoUpdate(Loco *loco) {\n    Serial.print(\"Received Loco update for DCC address: \");\n    Serial.println(loco->getAddress());\n  }"
        },
        {
          "name": "setLoco",
          "parameters": "Loco *loco",
          "body": "_loco = loco; }\n\n  Loco *getLoco() { return _loco; }\n\n  void setSpeed(int speed) {\n    if (!_loco)\n      return;\n    _dccexProtocol->setThrottle(_loco, speed, _loco->getDirection());\n  }\n\n  void setDirection(Direction direction) {\n    if (!_loco)\n      return;\n    _dccexProtocol->setThrottle(_loco, _loco->getSpeed(), direction);\n  }\n\n  void process() {\n    // Routine calls here included in the loop to read encoder or other inputs\n  }\n\nprivate:\n  DCCEXProtocol *_dccexProtocol;\n  Loco *_loco;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Loco Control Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  // Logging on Serial\n  dccexProtocol.setLogStream(&Serial);\n\n  // Pass the delegate instance to wiThrottleProtocol\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");\n\n  dccexProtocol.requestServerVersion();\n\n  lastTime = millis();\n\n  // Dummy loco starting address\n  int address = 12;\n\n  // Create the throttles and add a loco to each\n  for (int i = 0; i < numThrottles; i++) {\n    Serial.print(\"Create throttle|loco address: \");\n    Serial.print(i);\n    Serial.print(\"|\");\n    Serial.println(address + i);\n    throttles[i] = new Throttle(&dccexProtocol);\n    throttles[i]->setLoco(new Loco(address + i, LocoSource::LocoSourceEntry));\n  }\n\n  // Turn track power on so locos can move\n  dccexProtocol.powerOn();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // throttle processing example\n  for (int i = 0; i < numThrottles; i++) {\n    throttles[i]->process();\n  }\n\n  // every 10 seconds change speed and set a random function on or off\n  if ((millis() - lastTime) >= 10000) {\n    lastTime = millis();\n    for (int i = 0; i < numThrottles; i++) {\n      auto th = throttles[i];\n      Loco *loco = th->getLoco();\n      if (loco) {\n        if (speed >= 100)\n          up = -1;\n        if (speed <= 0)\n          up = 1;\n        speed = speed + up;\n        dccexProtocol.setThrottle(loco, speed, Direction::Forward);\n\n        int fn = random(0, 27);\n        int fns = random(0, 100);\n        bool fnState = (fns < 50) ? false : true;\n\n        if (fnState) {\n          dccexProtocol.functionOn(loco, fn);\n        } else {\n          dccexProtocol.functionOff(loco, fn);\n        }\n      }\n    }\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "buffer",
        "power",
        "wifi",
        "delay"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "parameters": "int major, int minor, int patch",
          "body": "Serial.print(\"\\n\\nReceived version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);\n  }\n\n  void receivedTrackPower(TrackPower state) {\n    Serial.print(\"\\n\\nReceived Track Power: \");\n    Serial.println(state);\n    Serial.println(\"\\n\\n\");\n  }\n\n  void receivedRosterList() {\n    Serial.println(\"\\n\\nReceived Roster\");\n    printRoster();\n  }\n  void receivedTurnoutList() {\n    Serial.print(\"\\n\\nReceived Turnouts/Points list\");\n    printTurnouts();\n    Serial.println(\"\\n\\n\");\n  }\n  void receivedRouteList() {\n    Serial.print(\"\\n\\nReceived Routes List\");\n    printRoutes();\n    Serial.println(\"\\n\\n\");\n  }\n  void receivedTurntableList() {\n    Serial.print(\"\\n\\nReceived Turntables list\");\n    printTurntables();\n    Serial.println(\"\\n\\n\");\n  }"
        },
        {
          "name": "printRoster",
          "parameters": "",
          "body": "for (Loco *loco = dccexProtocol.roster->getFirst(); loco; loco = loco->getNext()) {\n    int id = loco->getAddress();\n    char *name = loco->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");\n    for (int i = 0; i < 32; i++) {\n      char *fName = loco->getFunctionName(i);\n      if (fName != nullptr) {\n        Serial.print(\"loadFunctionLabels() \");\n        Serial.print(fName);\n        if (loco->isFunctionMomentary(i)) {\n          Serial.print(\" - Momentary\");\n        }\n        Serial.println();\n      }\n    }\n  }\n  Serial.println(\"\\n\");"
        },
        {
          "name": "printTurnouts",
          "parameters": "",
          "body": "for (Turnout *turnout = dccexProtocol.turnouts->getFirst(); turnout; turnout = turnout->getNext()) {\n    int id = turnout->getId();\n    char *name = turnout->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");\n  }\n  Serial.println(\"\\n\");"
        },
        {
          "name": "printRoutes",
          "parameters": "",
          "body": "for (Route *route = dccexProtocol.routes->getFirst(); route; route = route->getNext()) {\n    int id = route->getId();\n    char *name = route->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");\n  }\n  Serial.println(\"\\n\");"
        },
        {
          "name": "printTurntables",
          "parameters": "",
          "body": "for (Turntable *turntable = dccexProtocol.turntables->getFirst(); turntable; turntable = turntable->getNext()) {\n    int id = turntable->getId();\n    char *name = turntable->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");\n\n    int j = 0;\n    for (TurntableIndex *turntableIndex = turntable->getFirstIndex(); turntableIndex;\n         turntableIndex = turntableIndex->getNextIndex()) {\n      char *indexName = turntableIndex->getName();\n      Serial.print(\"  index\");\n      Serial.print(j);\n      Serial.print(\" ~\");\n      Serial.print(indexName);\n      Serial.println(\"~\");\n      j++;\n    }\n  }\n  Serial.println(\"\\n\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Roster and Objects Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  // Enable logging on Serial\n  dccexProtocol.setLogStream(&Serial);\n\n  // Pass the delegate instance to wiThrottleProtocol\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");\n\n  dccexProtocol.requestServerVersion();\n  dccexProtocol.powerOn();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // sequentially request and get the required lists. To avoid overloading the buffer\n  // getLists(bool rosterRequired, bool turnoutListRequired, bool routeListRequired, bool turntableListRequired)\n  dccexProtocol.getLists(true, true, true, true);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "printSsids",
          "parameters": "",
          "body": "Serial.println(\"\");\n  Serial.println(\"Browsing for SSIDs \");\n\n  double startTime = millis();\n  double nowTime = startTime;\n\n  int numSsids = WiFi.scanNetworks();\n  while ((numSsids == -1) && ((nowTime - startTime) <= 10000)) { // try for 10 seconds\n    delay(250);\n    Serial.print(\".\");\n    nowTime = millis();\n  }\n\n  int foundSsidsCount = 0;\n  if (numSsids == -1) {\n    Serial.println(\"Couldn't get a wifi connection\");\n\n  } else {\n    for (int thisSsid = 0; thisSsid < numSsids; thisSsid++) {\n      /// remove duplicates (repeaters and mesh networks)\n      boolean found = false;\n      for (int i = 0; i < foundSsidsCount && i < MAX_SSIDS; i++) {\n        if (WiFi.SSID(thisSsid) == foundSsids[i]) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        foundSsids[foundSsidsCount] = WiFi.SSID(thisSsid);\n        foundSsidRssis[foundSsidsCount] = WiFi.RSSI(thisSsid);\n        foundSsidsOpen[foundSsidsCount] = (WiFi.encryptionType(thisSsid) == 7) ? true : false;\n        foundSsidsCount++;\n      }\n    }\n    for (int i = 0; i < foundSsidsCount; i++) {\n      Serial.println(foundSsids[i]);\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol SSID example\");\n  Serial.println();\n\n  // browse for SSIDs\n  printSsids();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(20000);\n  // Redo every 20 seconds - For demonstration purposes only!\n  // Normally this will only be required once.\n  printSsids();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "parse",
        "power"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "parameters": "int major, int minor, int patch",
          "body": "CONSOLE.print(\"\\n\\nReceived version: \");\n    CONSOLE.print(major);\n    CONSOLE.print(\".\");\n    CONSOLE.print(minor);\n    CONSOLE.print(\".\");\n    CONSOLE.println(patch);\n  }\n\n  void receivedTrackPower(TrackPower state) {\n    CONSOLE.print(\"\\n\\nReceived Track Power: \");\n    CONSOLE.println(state);\n    CONSOLE.println(\"\\n\\n\");\n  }\n\n  void receivedRosterList() {\n    CONSOLE.println(\"\\n\\nReceived Roster\");\n    printRoster();\n  }\n  void receivedTurnoutList() {\n    CONSOLE.print(\"\\n\\nReceived Turnouts/Points list\");\n    printTurnouts();\n    CONSOLE.println(\"\\n\\n\");\n  }\n  void receivedRouteList() {\n    CONSOLE.print(\"\\n\\nReceived Routes List\");\n    printRoutes();\n    CONSOLE.println(\"\\n\\n\");\n  }\n  void receivedTurntableList() {\n    CONSOLE.print(\"\\n\\nReceived Turntables list\");\n    printTurntables();\n    CONSOLE.println(\"\\n\\n\");\n  }\n\n  void receivedScreenUpdate(int screen, int row, char *message) {\n    CONSOLE.println(\"\\n\\nReceived screen|row|message\");\n    CONSOLE.print(screen);\n    CONSOLE.print(\"|\");\n    CONSOLE.print(row);\n    CONSOLE.print(\"|\");\n    CONSOLE.println(message);\n  }"
        },
        {
          "name": "printRoster",
          "parameters": "",
          "body": "for (Loco *loco = dccexProtocol.roster->getFirst(); loco; loco = loco->getNext()) {\n    int id = loco->getAddress();\n    char *name = loco->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");\n    for (int i = 0; i < 32; i++) {\n      char *fName = loco->getFunctionName(i);\n      if (fName != nullptr) {\n        CONSOLE.print(\"loadFunctionLabels() \");\n        CONSOLE.print(fName);\n        if (loco->isFunctionMomentary(i)) {\n          CONSOLE.print(\" - Momentary\");\n        }\n        CONSOLE.println();\n      }\n    }\n  }\n  CONSOLE.println(\"\\n\");"
        },
        {
          "name": "printTurnouts",
          "parameters": "",
          "body": "for (Turnout *turnout = dccexProtocol.turnouts->getFirst(); turnout; turnout = turnout->getNext()) {\n    int id = turnout->getId();\n    char *name = turnout->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");\n  }\n  CONSOLE.println(\"\\n\");"
        },
        {
          "name": "printRoutes",
          "parameters": "",
          "body": "for (Route *route = dccexProtocol.routes->getFirst(); route; route = route->getNext()) {\n    int id = route->getId();\n    char *name = route->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");\n  }\n  CONSOLE.println(\"\\n\");"
        },
        {
          "name": "printTurntables",
          "parameters": "",
          "body": "for (Turntable *turntable = dccexProtocol.turntables->getFirst(); turntable; turntable = turntable->getNext()) {\n    int id = turntable->getId();\n    char *name = turntable->getName();\n    CONSOLE.print(id);\n    CONSOLE.print(\" ~\");\n    CONSOLE.print(name);\n    CONSOLE.println(\"~\");\n\n    int j = 0;\n    for (TurntableIndex *turntableIndex = turntable->getFirstIndex(); turntableIndex;\n         turntableIndex = turntableIndex->getNextIndex()) {\n      char *indexName = turntableIndex->getName();\n      CONSOLE.print(\"  index\");\n      CONSOLE.print(j);\n      CONSOLE.print(\" ~\");\n      CONSOLE.print(indexName);\n      CONSOLE.println(\"~\");\n      j++;\n    }\n  }\n  CONSOLE.println(\"\\n\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "CONSOLE.begin(115200);\n  CLIENT.begin(115200);\n  CONSOLE.println(F(\"DCCEXProtocol Serial Connection Demo\"));\n  CONSOLE.println(F(\"\"));\n\n  // Direct logs to CONSOLE\n  dccexProtocol.setLogStream(&CONSOLE);\n\n  // Set the delegate for broadcasts/responses\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Connect to the CS via CLIENT\n  dccexProtocol.connect(&CLIENT);\n  CONSOLE.println(F(\"DCC-EX connected\"));\n\n  dccexProtocol.requestServerVersion();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Parse incoming messages\n  dccexProtocol.check();\n\n  dccexProtocol.getLists(true, true, true, true);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedTrackType",
          "parameters": "char track, TrackManagerMode type, int address",
          "body": "Serial.print(\"\\n\\nReceived TrackType: \");\n    Serial.print(track);\n    Serial.print(\" : \");\n    Serial.print(type);\n    Serial.print(\" : \");\n    Serial.println(address);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Track Type Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  dccexProtocol.setLogStream(&Serial);\n\n  // Pass the delegate instance to wiThrottleProtocol\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // every 10 seconds change speed and set a random function on or off\n  if ((millis() - lastTime) >= 10000) {\n\n    lastTrackType++;\n    if (lastTrackType > 4)\n      lastTrackType = 0;\n\n    if (lastTrackType == 0) {\n      Serial.println(\"Set A:MAIN  B:PROG\");\n      dccexProtocol.setTrackType('A', MAIN, 0);\n      // dccexProtocol.setTrackType('B',PROG,0);\n    } else if (lastTrackType == 1) {\n      Serial.println(\"Set A:PROG  B:DC 10\");\n      dccexProtocol.setTrackType('A', PROG, 0);\n      dccexProtocol.setTrackType('B', DC, 10);\n    } else if (lastTrackType == 2) {\n      Serial.println(\"Set A:DC 10  B:DCX 11\");\n      dccexProtocol.setTrackType('A', DC, 10);\n      dccexProtocol.setTrackType('B', DCX, 11);\n    } else if (lastTrackType == 3) {\n      Serial.println(\"Set A:DCX 11  B:NONE\");\n      dccexProtocol.setTrackType('B', NONE, 0);\n      dccexProtocol.setTrackType('A', DCX, 11);\n    } else if (lastTrackType == 4) {\n      Serial.println(\"Set A:NONE  B:MAIN\");\n      dccexProtocol.setTrackType('A', NONE, 0);\n      dccexProtocol.setTrackType('B', MAIN, 0);\n    }\n\n    lastTime = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "parse",
        "buffer",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "DCCEXProtocol.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "receivedServerVersion",
          "parameters": "int major, int minor, int patch",
          "body": "Serial.print(\"Received version: \");\n    Serial.print(major);\n    Serial.print(\".\");\n    Serial.print(minor);\n    Serial.print(\".\");\n    Serial.println(patch);\n  }\n\n  void receivedTurnoutList() {\n    Serial.print(\"Received turnout list:\");\n    printTurnouts();\n  }\n\n  void receivedTurnoutAction(int turnoutId, bool thrown) {\n    Serial.print(\"Received turnout action ID|thrown: \");\n    Serial.print(turnoutId);\n    Serial.print(\"|\");\n    Serial.println(thrown);\n  }"
        },
        {
          "name": "printTurnouts",
          "parameters": "",
          "body": "for (Turnout *turnout = dccexProtocol.turnouts->getFirst(); turnout; turnout = turnout->getNext()) {\n    int id = turnout->getId();\n    char *name = turnout->getName();\n    Serial.print(id);\n    Serial.print(\" ~\");\n    Serial.print(name);\n    Serial.println(\"~\");\n  }\n  Serial.println(\"\\n\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol Turnout/Point Demo\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Connect to the server\n  Serial.println(\"Connecting to the server...\");\n  if (!client.connect(serverAddress, serverPort)) {\n    Serial.println(\"connection failed\");\n    while (1)\n      delay(1000);\n  }\n  Serial.println(\"Connected to the server\");\n\n  // Logging on Serial\n  dccexProtocol.setLogStream(&Serial);\n\n  // Pass the delegate instance to wiThrottleProtocol\n  dccexProtocol.setDelegate(&myDelegate);\n\n  // Pass the communication to wiThrottleProtocol\n  dccexProtocol.connect(&client);\n  Serial.println(\"DCC-EX connected\");\n\n  dccexProtocol.requestServerVersion();\n\n  lastTime = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// parse incoming messages\n  dccexProtocol.check();\n\n  // sequentially request and get the required lists. To avoid overloading the buffer\n  dccexProtocol.getLists(false, true, false, false);\n\n  if (dccexProtocol.receivedLists() && !doneTurnouts) {\n    if (dccexProtocol.getTurnoutCount() >= 2) {\n      turnout1 = dccexProtocol.turnouts->getFirst();\n      Serial.print(\"Turnout 1 id: \");\n      Serial.println(turnout1->getId());\n      turnout2 = turnout1->getNext();\n      Serial.print(\"Turnout 2 id: \");\n      Serial.println(turnout2->getId());\n    }\n    doneTurnouts = true;\n  }\n\n  if ((millis() - lastTime) >= 10000) {\n    if (doneTurnouts) {\n      int action = random(0, 100);\n      bool throwTurnout = (action > 50) ? 1 : 0;\n      if (throwTurnout) {\n        dccexProtocol.throwTurnout(turnout1->getId());\n      } else {\n        dccexProtocol.closeTurnout(turnout1->getId());\n      }\n      action = random(0, 100);\n      throwTurnout = (action > 50) ? 1 : 0;\n      if (throwTurnout) {\n        dccexProtocol.throwTurnout(turnout2->getId());\n      } else {\n        dccexProtocol.closeTurnout(turnout2->getId());\n      }\n    }\n\n    lastTime = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESPmDNS.h",
        "WiFi.h",
        "config.h",
        "config.example.h"
      ],
      "functions": [
        {
          "name": "setupMdnsListner",
          "parameters": "",
          "body": "// setup the bonjour listener\n\n  if (!MDNS.begin(\"mDNSTest\")) {\n    Serial.println(\"Error setting up MDNS responder!\");\n    return false;\n  } else {\n    Serial.println(\"MDNS responder started\");\n    return true;\n  }"
        },
        {
          "name": "printMdnsServers",
          "parameters": "",
          "body": "Serial.println(\"\");\n\n  double startTime = millis();\n  double nowTime = startTime;\n\n  const char *service = \"withrottle\";\n  const char *proto = \"tcp\";\n\n  Serial.print(\"Browsing for service \");\n  Serial.print(service);\n  Serial.print(\".\");\n  Serial.print(proto);\n  Serial.print(\".local. on \");\n  Serial.print(ssid);\n  Serial.println(\" ... \");\n\n  int noOfWitServices = 0;\n  while ((noOfWitServices == 0) && ((nowTime - startTime) <= 5000)) { // try for 5 seconds\n    noOfWitServices = MDNS.queryService(service, proto);\n    if (noOfWitServices == 0) {\n      delay(500);\n      Serial.print(\".\");\n    }\n    nowTime = millis();\n  }\n  Serial.println(\"\");\n\n  if (noOfWitServices > 0) {\n    for (int i = 0; ((i < noOfWitServices) && (i < MAX_SERVERS)); ++i) {\n      foundWitServersNames[i] = MDNS.hostname(i);\n      foundWitServersIPs[i] = MDNS.IP(i);\n      foundWitServersPorts[i] = MDNS.port(i);\n      if (MDNS.hasTxt(i, \"jmri\")) {\n        String node = MDNS.txt(i, \"node\");\n        node.toLowerCase();\n        if (foundWitServersNames[i].equals(node)) {\n          foundWitServersNames[i] = \"JMRI  (v\" + MDNS.txt(i, \"jmri\") + \")\";\n        }\n      }\n    }\n  }\n  foundWitServersCount = noOfWitServices;\n\n  // EX-CommnadStations in Access Point mode cannot advertise via mDNS,\n  // so we have to guess it based on the SSID name\n  String ssidString = String(ssid);\n  if (ssidString == \"DCCEX_\") {\n    foundWitServersIPs[foundWitServersCount].fromString(\"192.168.4.1\");\n    foundWitServersPorts[foundWitServersCount] = 2560;\n    foundWitServersNames[foundWitServersCount] = \"'Guessed' EX-CS WiT server\";\n    foundWitServersCount++;\n  }\n\n  for (int i = 0; ((i < foundWitServersCount) && (i < MAX_SERVERS)); ++i) {\n    Serial.print(\"Name: \");\n    Serial.print(foundWitServersNames[i]);\n    Serial.print(\" IP: \");\n    Serial.print(foundWitServersIPs[i]);\n    Serial.print(\" : \");\n    Serial.print(foundWitServersPorts[i]);\n    Serial.println();\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"DCCEXProtocol mDNS example\");\n  Serial.println();\n\n  // Connect to WiFi network\n  Serial.println(\"Connecting to WiFi..\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n    delay(1000);\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  // setup the mDNS listner\n  mdnsListenerStarted = setupMdnsListner();\n\n  // browse for services\n  if (mdnsListenerStarted) {\n    printMdnsServers();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(20000);\n  // Redo every 20 seconds - For demonstration purposes only!\n  // Normally this will only be required once, immediately after you connect to the ssid.\n  if (mdnsListenerStarted) {\n    printMdnsServers();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "i2c",
        "delay",
        "pwm"
      ],
      "libraries": [
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n  Serial.println(\"Adafruit Motorshield v2 - DC Motor test!\");\n\n  if (!AFMS.begin()) {         // create with the default frequency 1.6KHz\n  // if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz\n    Serial.println(\"Could not find Motor Shield. Check wiring.\");\n    while (1);\n  }\n  Serial.println(\"Motor Shield found.\");\n\n  // Set the speed to start, from 0 (off) to 255 (max speed)\n  myMotor->setSpeed(150);\n  myMotor->run(FORWARD);\n  // turn on motor\n  myMotor->run(RELEASE);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "uint8_t i;\n\n  Serial.print(\"tick\");\n\n  myMotor->run(FORWARD);\n  for (i=0; i<255; i++) {\n    myMotor->setSpeed(i);\n    delay(10);\n  }\n  for (i=255; i!=0; i--) {\n    myMotor->setSpeed(i);\n    delay(10);\n  }\n\n  Serial.print(\"tock\");\n\n  myMotor->run(BACKWARD);\n  for (i=0; i<255; i++) {\n    myMotor->setSpeed(i);\n    delay(10);\n  }\n  for (i=255; i!=0; i--) {\n    myMotor->setSpeed(i);\n    delay(10);\n  }\n\n  Serial.print(\"tech\");\n  myMotor->run(RELEASE);\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wifiserver",
        "password",
        "token",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266HTTPClient.h",
        "WiFi.h",
        "HTTPClient.h",
        "EasyDDNS.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(WiFi.localIP()); // Print the IP address\n  server.begin();\n\n  /*\n    List of supported DDNS providers:\n    - \"duckdns\"\n    - \"noip\"\n    - \"dyndns\"\n    - \"dynu\"\n    - \"enom\"\n    - \"all-inkl\"\n    - \"selfhost.de\"\n    - \"dyndns.it\"\n    - \"strato\"\n    - \"freemyip\"\n    - \"afraid.org\"\n  */\n  EasyDDNS.service(\"duckdns\");\n\n  /*\n    For DDNS Providers where you get a token:\n      Use this: EasyDDNS.client(\"domain\", \"token\");\n    \n    For DDNS Providers where you get username and password: ( Leave the password field empty \"\" if not required )\n      Use this: EasyDDNS.client(\"domain\", \"username\", \"password\");\n  */\n  EasyDDNS.client(\"12345.duckdns.org\", \"token\"); // Enter your DDNS Domain & Token\n\n  // Get Notified when your IP changes\n  EasyDDNS.onUpdate([&](const char* oldIP, const char* newIP){\n    Serial.print(\"EasyDDNS - IP Change Detected: \");\n    Serial.println(newIP);\n  });"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check for new public IP every 10 seconds\n  EasyDDNS.update(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "encryption",
        "key"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "DES.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"Key: \");\n  printHex(key, 8);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(enc_iv, 8);\n  Serial.println(\" \");\n  Serial.print(\"DES Encryption of '\");\n  printHex(input, 8);\n  Serial.print(\"' is 0x\");\n  DES.runEnc(key, 8, input, 8, enc_iv);   // expect 0x3C21EB6A62D372DB\n  printHex(input, 8);\n  Serial.println(\" \");\n  Serial.println(\" \");\n  Serial.print(\"Key: \");\n  printHex(key, 8);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(dec_iv, 8);\n  Serial.println(\" \");\n  Serial.print(\"DES Decryption of '\");\n  printHex(input, 8);\n  Serial.print(\"' is 0x\");\n  DES.runDec(key, 8, input, 8, dec_iv);\n  printHex(input, 8);\n  Serial.println(\" \");\n  while (1);"
        },
        {
          "name": "printHex",
          "parameters": "uint8_t *text, size_t size",
          "body": "for (byte i = 0; i < size; i = i + 1) {\n    if (text[i] < 16) {\n      Serial.print(\"0\");\n    }\n    Serial.print(text[i], HEX);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "ble"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleSerialBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  DebugSerial.println(\"Waiting for connections...\");\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(115200);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "dht11",
        "temperature",
        "humidity",
        "delay"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize serial communications at 9600 bps\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "dht11.update();\n\n  C = dht11.readCelsius();     \t// Reading the temperature in Celsius degrees and store in the C variable\n  F = dht11.readFahrenheit();  \t// Reading the temperature in Fahrenheit degrees and store in the F variable\n  H = dht11.readHumidity();     // Reading the humidity index\n\n  // Print the collected data in a row on the Serial Monitor\n  Serial.print(\"H: \");\n  Serial.print(H);\n  Serial.print(\"\\tC: \");\n  Serial.print(C);\n  Serial.print(\"\\tF: \");\n  Serial.println(F);\n\n  delay(1000);                // Wait one second before get another temperature reading"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "auth",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "littlefs",
        "spiffs",
        "eeprom",
        "timer",
        "html",
        ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(60 * 1000, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if (use_littlefs)\n    serial.println(f("
      ],
      "libraries": [
        "defines.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n\n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32 using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32 using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting DHT11ESP32 using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"DHT11_ESP32\");\n  Blynk.begin(HOST_NAME);\n#else\n  WiFi.begin(ssid, pass);\n\n#if USE_LOCAL_SERVER\n  Blynk.config(auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.config(auth);\n#endif\n\n  Blynk.connect();\n#endif\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if (USE_LITTLEFS)\n    Serial.println(F(\"\\nBlynk ESP32 using LittleFS connected\"));\n#elif (USE_SPIFFS)\n    Serial.println(F(\"\\nBlynk ESP32 using SPIFFS connected.\"));\n#else\n    Serial.println(F(\"\\nBlynk ESP32 using EEPROM connected.\"));\n    Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n#endif\n\n#if USE_BLYNK_WM\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n#endif\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "auth",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "littlefs",
        "spiffs",
        "eeprom",
        "timer",
        "html",
        ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(60 * 1000, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if (use_littlefs)\n    serial.println(f("
      ],
      "libraries": [
        "defines.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n\n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32_SSL using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP32_SSL using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting DHT11ESP32_SSL using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"DHT11_ESP32_SSL\");\n  Blynk.begin(HOST_NAME);\n#else\n  WiFi.begin(ssid, pass);\n\n#if USE_LOCAL_SERVER\n  Blynk.config(auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.config(auth);\n#endif\n\n  Blynk.connect();\n#endif\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if (USE_LITTLEFS)\n    Serial.println(F(\"\\nBlynk ESP32 using LittleFS connected\"));\n#elif (USE_SPIFFS)\n    Serial.println(F(\"\\nBlynk ESP32 using SPIFFS connected.\"));\n#else\n    Serial.println(F(\"\\nBlynk ESP32 using EEPROM connected.\"));\n    Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n#endif\n\n#if USE_BLYNK_WM\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n#endif\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "auth",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "eeprom",
        "timer",
        "html",
        ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(60 * 1000, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if ( use_littlefs || use_spiffs)\n    serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(\"B\");\n  }\n  else\n  {\n    Serial.print(\"F\");\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);;\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP8266 using \")); \n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(\"\\nStarting DHT11ESP8266 using EEPROM\");\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n  \n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  \n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"DHT11_ESP8266\");\n  Blynk.begin(HOST_NAME);\n#else\n  WiFi.begin(ssid, pass);\n\n#if USE_LOCAL_SERVER\n  Blynk.config(auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.config(auth);\n#endif\n\n  Blynk.connect();\n#endif\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8288 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8288 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n#if USE_BLYNK_WM\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n#endif\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "auth",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "eeprom",
        "timer",
        "html",
        ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(60 * 1000, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if ( use_littlefs || use_spiffs)\n    serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(\"B\");\n  }\n  else\n  {\n    Serial.print(\"F\");\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP8266_Debug using \"));  \n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting DHT11ESP8266_Debug using EEPROM\");\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n    \n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n  #if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"DHT11_ESP8266_Debug\");\n  Blynk.begin(HOST_NAME);\n#else\n  WiFi.begin(ssid, pass);\n\n#if USE_LOCAL_SERVER\n  Blynk.config(auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.config(auth);\n#endif\n\n  Blynk.connect();\n#endif\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8288 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8288 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n#if USE_BLYNK_WM\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n#endif\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "auth",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "eeprom",
        "timer",
        "html",
        ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(60 * 1000, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if ( use_littlefs || use_spiffs)\n    serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting DHT11ESP8266_SSL using \"));\n  Serial.print(CurrentFileFS);  \n#else\n  Serial.print(F(\"\\nStarting DHT11ESP8266_SSL using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  dht.begin();\n\n#if USE_BLYNK_WM\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, defalut = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"DHT11_ESP8266_SSL\");\n  Blynk.begin(HOST_NAME);\n#else\n  WiFi.begin(ssid, pass);\n\n#if USE_LOCAL_SERVER\n  Blynk.config(auth, blynk_server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.config(auth);\n#endif\n\n  Blynk.connect();\n#endif\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8288 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8288 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n#if USE_BLYNK_WM\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n#endif\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "dht11",
        "dht22",
        "oled",
        "display",
        "timer"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "DHT.h",
        "Arduino.h",
        "U8g2lib.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 31, 249), 8080);//自建服务器ip模式\n  dht.begin();\n  timer.setInterval(1000L, sendSensor);\n  u8g2.begin();"
        },
        {
          "name": "sendSensor",
          "parameters": "",
          "body": "float h = dht.readHumidity();\n  float t = dht.readTemperature(); //摄氏度\n  //float t = dht.readTemperature(true); //华氏度\n  Blynk.virtualWrite(V0, t);//将湿度发送给V0\n  Blynk.virtualWrite(V1, h);//将湿度发送给V1\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_ncenB08_tr); \n  u8g2.setFontPosTop();\n  u8g2.drawStr(0,0,\"WENDU:\");\n  u8g2.setCursor(60, 0);\n  u8g2.print(t);\n  u8g2.drawStr(0,20,\"SHIDU:\");\n  u8g2.setCursor(60, 20);\n  u8g2.print(h);\n  u8g2.sendBuffer();"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "dht11",
        "temperature",
        "humidity",
        "wifi",
        "millis",
        "delay",
        "digitalwrite",
        "sd",
        "timer"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, F(\"NAN\"));\n      Blynk.virtualWrite(V18, F(\"NAN\"));\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.println(F(\"R\"));"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart DHT11_W5100 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  dht.begin();\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }\n\n  timer.setInterval(60000L, readAndSendData);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "buffer",
        "temperature",
        "humidity",
        "spi",
        "wifi",
        "millis",
        "delay",
        "digitalwrite",
        "sd",
        "timer"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = 25.5;\n  float humidity    = 50.0;\n \n  if (Blynk.connected())\n  {   \n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, F(\"NAN\"));\n      Blynk.virtualWrite(V18, F(\"NAN\"));\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart DHT11_W5500 using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart DHT11_W5500 on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  #if USE_ETHERNET_WRAPPER\n\n    EthernetInit();\n\n  #else\n\n    #if USE_ETHERNET\n      Serial.println(F(\"=========== USE_ETHERNET ===========\"));\n    #elif USE_ETHERNET2\n      Serial.println(F(\"=========== USE_ETHERNET2 ===========\"));\n    #elif USE_ETHERNET3\n      Serial.println(F(\"=========== USE_ETHERNET3 ===========\"));\n    #elif USE_ETHERNET_LARGE\n      Serial.println(F(\"=========== USE_ETHERNET_LARGE ===========\"));\n    #elif USE_ETHERNET_ESP8266\n      Serial.println(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n    #else\n      Serial.println(F(\"=========================\"));\n    #endif\n   \n      Serial.println(F(\"Default SPI pinout:\"));\n      Serial.print(F(\"MOSI:\")); Serial.println(MOSI);\n      Serial.print(F(\"MISO:\")); Serial.println(MISO);\n      Serial.print(F(\"SCK:\"));  Serial.println(SCK);\n      Serial.print(F(\"SS:\"));   Serial.println(SS);\n      Serial.println(F(\"=========================\"));\n       \n    #if defined(ESP8266)\n      // For ESP8266, change for other boards if necessary\n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   D2    // For ESP8266\n      #endif\n      \n      Serial.print(F(\"ESP8266 setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n      \n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // For ESP8266\n        // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n        // Ethernet           0                 X            X            X            X        0\n        // Ethernet2          X                 X            X            X            X        0\n        // Ethernet3          X                 X            X            X            X        0\n        // EthernetLarge      X                 X            X            X            X        0\n        // Ethernet_ESP8266   0                 0            0            0            0        0\n        // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n        // Must use library patch for Ethernet, EthernetLarge libraries\n        //Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n        \n    #elif defined(ESP32)\n  \n      // You can use Ethernet.init(pin) to configure the CS pin\n      //Ethernet.init(10);  // Most Arduino shields\n      //Ethernet.init(5);   // MKR ETH shield\n      //Ethernet.init(0);   // Teensy 2.0\n      //Ethernet.init(20);  // Teensy++ 2.0\n      //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n      //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n      \n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   22    // For ESP32\n      #endif\n      \n      Serial.print(F(\"ESP32 setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n      \n      // For other boards, to change if necessary\n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // Must use library patch for Ethernet, EthernetLarge libraries\n        // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n        // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n           \n        //Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n              \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n  \n    #else   //defined(ESP8266)\n      // unknown board, do nothing, use default SS = 10\n      #ifndef USE_THIS_SS_PIN\n        #define USE_THIS_SS_PIN   10    // For other boards\n      #endif\n           \n      Serial.print(BOARD_NAME); Serial.print(F(\" setCsPin::\")); Serial.println(USE_THIS_SS_PIN);\n  \n      // For other boards, to change if necessary\n      #if ( USE_ETHERNET || USE_ETHERNET_LARGE || USE_ETHERNET2 )\n        // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n  \n        Ethernet.init (USE_THIS_SS_PIN);\n  \n      #elif USE_ETHERNET3\n        // Use  MAX_SOCK_NUM = 4 for 4K, 2 for 8K, 1 for 16K RX/TX buffer\n        #ifndef ETHERNET3_MAX_SOCK_NUM\n          #define ETHERNET3_MAX_SOCK_NUM      4\n        #endif\n        \n        Ethernet.setCsPin (USE_THIS_SS_PIN);\n        Ethernet.init (ETHERNET3_MAX_SOCK_NUM);\n                        \n      #endif  //( USE_ETHERNET || USE_ETHERNET2 || USE_ETHERNET3 || USE_ETHERNET_LARGE )\n      \n    #endif    //defined(ESP8266)\n  \n  \n  #endif  //USE_ETHERNET_WRAPPER\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n  #if USE_LOCAL_SERVER\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #else\n    //Blynk.begin(auth);\n    // You can also specify server:\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(BlynkServer);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }\n\n  timer.setInterval(60000L, readAndSendData);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "millis",
        "display"
      ],
      "libraries": [
        "DHT12.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT12 LIBRARY VERSION: \");\n  Serial.println(DHT12_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  DHT.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - DHT.lastRead() >= 2000)\n  {\n    //  READ DATA\n    Serial.print(\"DHT12, \\t\");\n    int status = DHT.read();\n    switch (status)\n    {\n    case DHT12_OK:\n      Serial.print(\"OK,\\t\");\n      break;\n    case DHT12_ERROR_CHECKSUM:\n      Serial.print(\"Checksum error,\\t\");\n      break;\n    case DHT12_ERROR_CONNECT:\n      Serial.print(\"Connect error,\\t\");\n      break;\n    case DHT12_MISSING_BYTES:\n      Serial.print(\"Missing bytes,\\t\");\n      break;\n    default:\n      Serial.print(\"Unknown error,\\t\");\n      break;\n    }\n    //  DISPLAY DATA, sensor has only one decimal.\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\",\\t\");\n    Serial.println(DHT.getTemperature(), 1);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "humidity",
        "temperature",
        "i2c",
        "millis"
      ],
      "libraries": [
        "DHT12.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Wire.begin();\n  DHT.begin();\n\n  Serial.begin(115200);\n  Serial.println(\"Humidity, Temperature\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    // note no error checking\n    DHT.read();\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\", \");\n    Serial.println(DHT.getTemperature(), 1);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "display"
      ],
      "libraries": [
        "DHT12.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT12 LIBRARY VERSION: \");\n  Serial.println(DHT12_LIB_VERSION);\n  Serial.println();\n\n  Wire.setSDA(12);\n  Wire.setSCL(13);\n  Wire.begin();\n\n  DHT.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//  READ DATA\n  Serial.print(\"DHT12, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT12_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT12_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT12_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT12_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;\n  }\n  //  DISPLAY DATA, sensor has only one decimal.\n  Serial.print(DHT.getHumidity(), 1);\n  Serial.print(\",\\t\");\n  Serial.println(DHT.getTemperature(), 1);\n\n  delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "display"
      ],
      "libraries": [
        "DHT12.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT12 LIBRARY VERSION: \");\n  Serial.println(DHT12_LIB_VERSION);\n  Serial.println();\n\n  Wire1.begin(12, 13);\n  DHT.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// READ DATA\n  Serial.print(\"DHT12, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT12_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT12_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT12_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT12_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;\n  }\n  // DISPLAY DATA, sensor has only one decimal.\n  Serial.print(DHT.getHumidity(), 1);\n  Serial.print(\",\\t\");\n  Serial.println(DHT.getTemperature(), 1);\n\n  delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "millis",
        "display"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  DHT.begin();    //  ESP32 default pins 21 22\n\n\n  delay(1000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    //  READ DATA\n    uint32_t start = micros();\n    int status = DHT.read();\n    uint32_t stop = micros();\n\n    if ((count % 10) == 0)\n    {\n      count = 0;\n      Serial.println();\n      Serial.println(\"Type\\tHumidity (%)\\tTemp (°C)\\tTime (µs)\\tStatus\");\n    }\n    count++;\n\n    Serial.print(\"DHT20 \\t\");\n    //  DISPLAY DATA, sensor has only one decimal.\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\"\\t\\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.print(\"\\t\\t\");\n    Serial.print(stop - start);\n    Serial.print(\"\\t\\t\");\n    switch (status)\n    {\n      case DHT20_OK:\n        Serial.print(\"OK\");\n        break;\n      case DHT20_ERROR_CHECKSUM:\n        Serial.print(\"Checksum error\");\n        break;\n      case DHT20_ERROR_CONNECT:\n        Serial.print(\"Connect error\");\n        break;\n      case DHT20_MISSING_BYTES:\n        Serial.print(\"Missing bytes\");\n        break;\n      case DHT20_ERROR_BYTES_ALL_ZERO:\n        Serial.print(\"All bytes read zero\");\n        break;\n      case DHT20_ERROR_READ_TIMEOUT:\n        Serial.print(\"Read time out\");\n        break;\n      case DHT20_ERROR_LASTREAD:\n        Serial.print(\"Error read too fast\");\n        break;\n      default:\n        Serial.print(\"Unknown error\");\n        break;\n    }\n    Serial.print(\"\\n\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Serial.println(\"\\nNOTE: datasheet states 400 KHz as maximum.\\n\");\n\n  Wire.begin();\n  DHT.begin();  //  ESP32 default pins 21, 22\n  delay(2000);\n\n  for (uint32_t speed = 50000; speed < 850000; speed += 50000)\n  {\n    Wire.setClock(speed);\n    Serial.print(speed);\n    Serial.print(\"\\t\");\n    Serial.print(DHT.read());  // status\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.println();\n    delay(1000);\n  }\n\n  Serial.println();\n  for (uint32_t speed = 50000; speed < 850000; speed += 50000)\n  {\n    Wire.setClock(speed);\n    start = micros();\n    DHT.read();\n    stop = micros();\n\n    Serial.print(speed);\n    Serial.print(\"\\t\");\n    Serial.print(stop - start);  //  time\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.println();\n    delay(1000);\n  }\n\n\n  Serial.println();\n  for (uint32_t speed = 50000; speed < 850000; speed += 50000)\n  {\n    DHT.requestData();\n    while (DHT.isMeasuring());\n    Wire.setClock(speed);\n    start = micros();\n    DHT.readData();\n    stop = micros();\n    DHT.convert();\n    Serial.print(speed);\n    Serial.print(\"\\t\");\n    Serial.print(stop - start);  // time\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.println();\n    delay(1000);\n  }\n\n  Serial.println(\"\\ndone...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "millis"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  Wire.setClock(400000);\n\n  DHT.begin();  //  ESP32 default 21, 22\n\n  delay(2000);\n\n  //  start with initial request\n  Serial.println(DHT.requestData());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "uint32_t now = millis();\n\n  if (now - DHT.lastRead() > 1000)\n  {\n    DHT.readData();\n    DHT.convert();\n\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\" %RH \\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.print(\" °C\\t\");\n    Serial.print(counter);\n    Serial.print(\"\\n\");\n    //  new request\n    counter = 0;\n    DHT.requestData();\n  }\n\n  //  other code here\n  counter++;  //  dummy counter to show async behaviour"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "millis",
        "lcd",
        "display"
      ],
      "libraries": [
        "DHT20.h",
        "Wire.h",
        "LCD.h",
        "LiquidCrystal_I2C.h"
      ],
      "functions": [
        {
          "name": "setupDisplay",
          "parameters": "",
          "body": "lcd = LiquidCrystal_I2C(displayAddress, En_pin, Rw_pin, Rs_pin, D4_pin, D5_pin, D6_pin, D7_pin);\n  lcd.begin(20, 4);\n  //  lcd.setBacklightPin(BACKLIGHT_PIN, NEGATIVE);\n  lcd.setBacklightPin(BACKLIGHT_PIN, POSITIVE);\n  lcd.setBacklight(BL_ON);"
        },
        {
          "name": "display",
          "parameters": "",
          "body": "lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"TEMP:\");\n  lcd.setCursor(6, 0);\n  lcd.print(DHT.getTemperature());\n\n  lcd.setCursor(0, 1);\n  lcd.print(\"HUM:\");\n  lcd.setCursor(6, 1);\n  lcd.print(DHT.getHumidity());\n\n  lcd.setCursor(0, 3);\n  lcd.print(\"TIME:\");\n  lcd.setCursor(6, 3);\n  lcd.print(stop - start);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  DHT.begin();    //  ESP32 default pins 21 22\n\n  setupDisplay();\n\n  delay(1000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    //  READ DATA\n    start = micros();\n    int status = DHT.read();\n    stop = micros();\n\n    display();\n\n    if ((count % 10) == 0)\n    {\n      count = 0;\n      Serial.println();\n      Serial.println(\"Type\\tHumidity (%)\\tTemp (°C)\\tTime (µs)\\tStatus\");\n    }\n    count++;\n\n    Serial.print(\"DHT20 \\t\");\n    //  DISPLAY DATA, sensor has only one decimal.\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\"\\t\\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.print(\"\\t\\t\");\n    Serial.print(stop - start);\n    Serial.print(\"\\t\\t\");\n    switch (status)\n    {\n      case DHT20_OK:\n        Serial.print(\"OK\");\n        break;\n      case DHT20_ERROR_CHECKSUM:\n        Serial.print(\"Checksum error\");\n        break;\n      case DHT20_ERROR_CONNECT:\n        Serial.print(\"Connect error\");\n        break;\n      case DHT20_MISSING_BYTES:\n        Serial.print(\"Missing bytes\");\n        break;\n      case DHT20_ERROR_BYTES_ALL_ZERO:\n        Serial.print(\"All bytes read zero\");\n        break;\n      case DHT20_ERROR_READ_TIMEOUT:\n        Serial.print(\"Read time out\");\n        break;\n      case DHT20_ERROR_LASTREAD:\n        Serial.print(\"Error read too fast\");\n        break;\n      default:\n        Serial.print(\"Unknown error\");\n        break;\n    }\n    Serial.print(\"\\n\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "millis",
        "display"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  Wire.setClock(400000);\n\n  DHT.begin();    //  ESP32 default pins 21 22\n\n  delay(1000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//  set an offset after 10 seconds.\n  if (millis() > 10000)\n  {\n    DHT.setTempOffset(1.7);\n    DHT.setHumOffset(-2.3);\n  }\n\n  //  make a measurement every 2 seconds\n  if (millis() - DHT.lastRead() >= 2000)\n  {\n    //  READ DATA\n    uint32_t start = micros();\n    int status = DHT.read();\n    uint32_t stop = micros();\n\n    if ((count % 10) == 0)\n    {\n      count = 0;\n      Serial.println();\n      Serial.println(\"Type\\tHumidity (%)\\tTemp (°C)\\tTime (µs)\\tStatus\\tOffset\");\n    }\n    count++;\n\n    Serial.print(\"DHT20 \\t\");\n    //  DISPLAY DATA, sensor has only one decimal.\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\"\\t\\t\");\n    Serial.print(DHT.getTemperature(), 1);\n    Serial.print(\"\\t\\t\");\n    Serial.print(stop - start);\n    Serial.print(\"\\t\\t\");\n    switch (status)\n    {\n      case DHT20_OK:\n        Serial.print(\"OK\");\n        break;\n      case DHT20_ERROR_CHECKSUM:\n        Serial.print(\"Checksum error\");\n        break;\n      case DHT20_ERROR_CONNECT:\n        Serial.print(\"Connect error\");\n        break;\n      case DHT20_MISSING_BYTES:\n        Serial.print(\"Missing bytes\");\n        break;\n      case DHT20_ERROR_BYTES_ALL_ZERO:\n        Serial.print(\"All bytes read zero\");\n        break;\n      case DHT20_ERROR_READ_TIMEOUT:\n        Serial.print(\"Read time out\");\n        break;\n      case DHT20_ERROR_LASTREAD:\n        Serial.print(\"Error read too fast\");\n        break;\n      default:\n        Serial.print(\"Unknown error\");\n        break;\n    }\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getHumOffset());\n    Serial.print(\"\\t\");\n    Serial.print(DHT.getTempOffset());\n    Serial.print(\"\\n\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "millis"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Wire.begin();\n  DHT.begin();  //  ESP32 default pins 21 22\n\n  Serial.begin(115200);\n  Serial.println(\"Humidity, Temperature\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - DHT.lastRead() >= 1000)\n  {\n    //  note no error checking\n    DHT.read();\n    Serial.print(DHT.getHumidity(), 1);\n    Serial.print(\", \");\n    Serial.println(DHT.getTemperature(), 1);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire.begin();\n  Wire.setClock(400000);\n\n  DHT.begin();    //  ESP32 default pins 21 22\n\n  delay(2000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int status = DHT.readStatus();\n  Serial.println(status);\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "display"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire1.begin(12, 13);  //  select your pin numbers here\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//  READ DATA\n  Serial.print(\"DHT20, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT20_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT20_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT20_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT20_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  case DHT20_ERROR_BYTES_ALL_ZERO:\n    Serial.print(\"All bytes read zero\");\n    break;\n  case DHT20_ERROR_READ_TIMEOUT:\n    Serial.print(\"Read time out\");\n    break;\n  case DHT20_ERROR_LASTREAD:\n    Serial.print(\"Error read too fast\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;\n  }\n\n  //  DISPLAY DATA, sensor has only one decimal.\n  Serial.print(DHT.getHumidity(), 1);\n  Serial.print(\",\\t\");\n  Serial.println(DHT.getTemperature(), 1);\n\n  delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "humidity",
        "temperature",
        "i2c",
        "delay",
        "display"
      ],
      "libraries": [
        "DHT20.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(__FILE__);\n  Serial.print(\"DHT20 LIBRARY VERSION: \");\n  Serial.println(DHT20_LIB_VERSION);\n  Serial.println();\n\n  Wire1.setSDA(12);  //  select your pin numbers here\n  Wire1.setSCL(13);  //  select your pin numbers here\n  Wire1.begin();\n\n  delay(2000);\n\n  Serial.println(\"Type,\\tStatus,\\tHumidity (%),\\tTemperature (C)\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//  READ DATA\n  Serial.print(\"DHT20, \\t\");\n  int status = DHT.read();\n  switch (status)\n  {\n  case DHT20_OK:\n    Serial.print(\"OK,\\t\");\n    break;\n  case DHT20_ERROR_CHECKSUM:\n    Serial.print(\"Checksum error,\\t\");\n    break;\n  case DHT20_ERROR_CONNECT:\n    Serial.print(\"Connect error,\\t\");\n    break;\n  case DHT20_MISSING_BYTES:\n    Serial.print(\"Missing bytes,\\t\");\n    break;\n  case DHT20_ERROR_BYTES_ALL_ZERO:\n    Serial.print(\"All bytes read zero\");\n    break;\n  case DHT20_ERROR_READ_TIMEOUT:\n    Serial.print(\"Read time out\");\n    break;\n  case DHT20_ERROR_LASTREAD:\n    Serial.print(\"Error read too fast\");\n    break;\n  default:\n    Serial.print(\"Unknown error,\\t\");\n    break;\n  }\n\n  //  DISPLAY DATA, sensor has only one decimal.\n  Serial.print(DHT.getHumidity(), 1);\n  Serial.print(\",\\t\");\n  Serial.println(DHT.getTemperature(), 1);\n\n  delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "dht11",
        "light",
        "temperature",
        "humidity",
        "delay",
        "yield",
        "timer",
        "sensors"
      ],
      "libraries": [
        "DHTesp.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "initTemp",
          "parameters": "",
          "body": "byte resultValue = 0;\n  // Initialize temperature sensor\n\tdht.setup(dhtPin, DHTesp::DHT11);\n\tSerial.println(\"DHT initiated\");\n\n  // Start task to get temperature\n\txTaskCreatePinnedToCore(\n\t\t\ttempTask,                       /* Function to implement the task */\n\t\t\t\"tempTask \",                    /* Name of the task */\n\t\t\t4000,                           /* Stack size in words */\n\t\t\tNULL,                           /* Task input parameter */\n\t\t\t5,                              /* Priority of the task */\n\t\t\t&tempTaskHandle,                /* Task handle. */\n\t\t\t1);                             /* Core where the task should run */\n\n  if (tempTaskHandle == NULL) {\n    Serial.println(\"Failed to start task for temperature update\");\n    return false;\n  } else {\n    // Start update of environment data every 20 seconds\n    tempTicker.attach(20, triggerGetTemp);\n  }\n  return true;"
        },
        {
          "name": "triggerGetTemp",
          "parameters": "",
          "body": "if (tempTaskHandle != NULL) {\n\t   xTaskResumeFromISR(tempTaskHandle);\n  }"
        },
        {
          "name": "tempTask",
          "parameters": "void *pvParameters",
          "body": "Serial.println(\"tempTask loop started\");\n\twhile (1) // tempTask loop\n  {\n    if (tasksEnabled) {\n      // Get temperature values\n\t\t\tgetTemperature();\n\t\t}\n    // Got sleep again\n\t\tvTaskSuspend(NULL);\n\t}"
        },
        {
          "name": "getTemperature",
          "parameters": "",
          "body": "// Reading temperature for humidity takes about 250 milliseconds!\n\t// Sensor readings may also be up to 2 seconds 'old' (it's a very slow sensor)\n  TempAndHumidity newValues = dht.getTempAndHumidity();\n\t// Check if any reads failed and exit early (to try again).\n\tif (dht.getStatus() != 0) {\n\t\tSerial.println(\"DHT11 error status: \" + String(dht.getStatusString()));\n\t\treturn false;\n\t}\n\n\tfloat heatIndex = dht.computeHeatIndex(newValues.temperature, newValues.humidity);\n  float dewPoint = dht.computeDewPoint(newValues.temperature, newValues.humidity);\n  float cr = dht.getComfortRatio(cf, newValues.temperature, newValues.humidity);\n\n  String comfortStatus;\n  switch(cf) {\n    case Comfort_OK:\n      comfortStatus = \"Comfort_OK\";\n      break;\n    case Comfort_TooHot:\n      comfortStatus = \"Comfort_TooHot\";\n      break;\n    case Comfort_TooCold:\n      comfortStatus = \"Comfort_TooCold\";\n      break;\n    case Comfort_TooDry:\n      comfortStatus = \"Comfort_TooDry\";\n      break;\n    case Comfort_TooHumid:\n      comfortStatus = \"Comfort_TooHumid\";\n      break;\n    case Comfort_HotAndHumid:\n      comfortStatus = \"Comfort_HotAndHumid\";\n      break;\n    case Comfort_HotAndDry:\n      comfortStatus = \"Comfort_HotAndDry\";\n      break;\n    case Comfort_ColdAndHumid:\n      comfortStatus = \"Comfort_ColdAndHumid\";\n      break;\n    case Comfort_ColdAndDry:\n      comfortStatus = \"Comfort_ColdAndDry\";\n      break;\n    default:\n      comfortStatus = \"Unknown:\";\n      break;\n  };\n\n  Serial.println(\" T:\" + String(newValues.temperature) + \" H:\" + String(newValues.humidity) + \" I:\" + String(heatIndex) + \" D:\" + String(dewPoint) + \" \" + comfortStatus);\n\treturn true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println(\"DHT ESP32 example with tasks\");\n  initTemp();\n  // Signal end of setup() to tasks\n  tasksEnabled = true;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (!tasksEnabled) {\n    // Wait 2 seconds to let system settle down\n    delay(2000);\n    // Enable task that will read values from the DHT sensor\n    tasksEnabled = true;\n    if (tempTaskHandle != NULL) {\n\t\t\tvTaskResume(tempTaskHandle);\n\t\t}\n  }\n  yield();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "dht22",
        "humidity",
        "temperature",
        "delay"
      ],
      "libraries": [
        "DHTesp.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println(\"Status\\tHumidity (%)\\tTemperature (C)\\t(F)\\tHeatIndex (C)\\t(F)\");\n  String thisBoard= ARDUINO_BOARD;\n  Serial.println(thisBoard);\n\n  // Autodetect is not working reliable, don't use the following line\n  // dht.setup(17);\n  // use this instead: \n  dht.setup(17, DHTesp::DHT22); // Connect DHT sensor to GPIO 17"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(dht.getMinimumSamplingPeriod());\n\n  float humidity = dht.getHumidity();\n  float temperature = dht.getTemperature();\n\n  Serial.print(dht.getStatusString());\n  Serial.print(\"\\t\");\n  Serial.print(humidity, 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(temperature, 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(dht.toFahrenheit(temperature), 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(dht.computeHeatIndex(temperature, humidity, false), 1);\n  Serial.print(\"\\t\\t\");\n  Serial.println(dht.computeHeatIndex(dht.toFahrenheit(temperature), humidity, true), 1);\n  delay(2000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "password",
        "json",
        "dht22",
        "temperature",
        "humidity",
        "wifi",
        "delay",
        "devices"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "IoTtweet.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  dht.begin();\n\n  //Get IoTtweet Library version\n  String libvers = myiot.getVersion();\n  Serial.println(\"IoTtweet Library vesion : \" + String(libvers));\n\n  //Connect WiFi\n  Serial.println(\"\\nConnect wifi...\");\n  bool conn = myiot.begin(ssid,password);\n\n    if(!conn)\n    {\n      Serial.println(\"WiFi connection failed.\");\n    }else\n    {\n      Serial.println(\"WiFi connected !\");\n     }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* - DHT sensor reading - */\n  t = dht.readTemperature();\n  h = dht.readHumidity();\n\n  if (isnan(t) || isnan(h)) {\n    Serial.println(\"Failed to read from DHT sensor!\");\n    return;\n  }\n\n  Serial.println(\"Temperature is \" + String(t) + \" celcuis\");\n  Serial.println(\"Humidity is \" + String(h) + \" %RH\");\n  Serial.println(\"----------------------------------------\");\n\n  //Send data from your iot to Dashboard\n  String response = myiot.WriteDashboard(userid,key,t,h,0,0,private_tweet,public_tweet);\n  Serial.println(response);   //Show response JSON from www.iottweet.com\n  \n  //Waiting storage data on IoTtweet cloud 15 sec.\n  delay(15000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "dht11",
        "light",
        "temperature",
        "humidity",
        "sensor1data",
        "sensor2data",
        "sensor3data",
        "sensors"
      ],
      "libraries": [
        "Arduino.h",
        "Ticker.h",
        "DHTesp.h"
      ],
      "functions": [
        {
          "name": "tempTask",
          "parameters": "void *pvParameters",
          "body": "Serial.println(\"tempTask loop started\");\n\twhile (1) // tempTask loop\n\t{\n\t\tif (tasksEnabled && !gotNewTemperature) { // Read temperature only if old data was processed already\n\t\t\t// Reading temperature for humidity takes about 250 milliseconds!\n\t\t\t// Sensor readings may also be up to 2 seconds 'old' (it's a very slow sensor)\n\t\t\tsensor1Data = dhtSensor1.getTempAndHumidity();\t// Read values from sensor 1\n\t\t\tsensor2Data = dhtSensor2.getTempAndHumidity();\t// Read values from sensor 1\n\t\t\tsensor3Data = dhtSensor3.getTempAndHumidity();\t// Read values from sensor 1\n\t\t\tgotNewTemperature = true;\n\t\t}\n\t\tvTaskSuspend(NULL);\n\t}"
        },
        {
          "name": "triggerGetTemp",
          "parameters": "",
          "body": "if (tempTaskHandle != NULL) {\n\t\t xTaskResumeFromISR(tempTaskHandle);\n\t}"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\tSerial.println(\"Example for 3 DHT11/22 sensors\");\n\n\t// Initialize temperature sensor 1\n\tdhtSensor1.setup(dhtPin1, DHTesp::DHT11);\n\t// Initialize temperature sensor 2\n\tdhtSensor2.setup(dhtPin2, DHTesp::DHT11);\n\t// Initialize temperature sensor 3\n\tdhtSensor3.setup(dhtPin3, DHTesp::DHT11);\n\n\t// Start task to get temperature\n\txTaskCreatePinnedToCore(\n\t\t\ttempTask,\t\t\t\t\t\t\t\t\t\t\t /* Function to implement the task */\n\t\t\t\"tempTask \",\t\t\t\t\t\t\t\t\t\t/* Name of the task */\n\t\t\t4000,\t\t\t\t\t\t\t\t\t\t\t\t\t /* Stack size in words */\n\t\t\tNULL,\t\t\t\t\t\t\t\t\t\t\t\t\t /* Task input parameter */\n\t\t\t5,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Priority of the task */\n\t\t\t&tempTaskHandle,\t\t\t\t\t\t\t\t/* Task handle. */\n\t\t\t1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t /* Core where the task should run */\n\n\tif (tempTaskHandle == NULL) {\n\t\tSerial.println(\"[ERROR] Failed to start task for temperature update\");\n\t} else {\n\t\t// Start update of environment data every 30 seconds\n\t\ttempTicker.attach(30, triggerGetTemp);\n\t}\n\n\t// Signal end of setup() to tasks\n\ttasksEnabled = true;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (gotNewTemperature) {\n\t\tSerial.println(\"Sensor 1 data:\");\n\t\tSerial.println(\"Temp: \" + String(sensor1Data.temperature,2) + \"'C Humidity: \" + String(sensor1Data.humidity,1) + \"%\");\n\t\tSerial.println(\"Sensor 2 data:\");\n\t\tSerial.println(\"Temp: \" + String(sensor2Data.temperature,2) + \"'C Humidity: \" + String(sensor2Data.humidity,1) + \"%\");\n\t\tSerial.println(\"Sensor 3 data:\");\n\t\tSerial.println(\"Temp: \" + String(sensor3Data.temperature,2) + \"'C Humidity: \" + String(sensor3Data.humidity,1) + \"%\");\n\t\tgotNewTemperature = false;\n\t}"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "dht11",
        "dht22",
        "temperature",
        "humidity",
        "delay",
        "sensor_t",
        "sensor_id",
        "sensors_event_t"
      ],
      "libraries": [
        "Adafruit_Sensor.h",
        "DHT.h",
        "DHT_U.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // Initialize device.\n  dht.begin();\n  Serial.println(F(\"DHTxx Unified Sensor Example\"));\n  // Print temperature sensor details.\n  sensor_t sensor;\n  dht.temperature().getSensor(&sensor);\n  Serial.println(F(\"------------------------------------\"));\n  Serial.println(F(\"Temperature Sensor\"));\n  Serial.print  (F(\"Sensor Type: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"Unique ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Max Value:   \")); Serial.print(sensor.max_value); Serial.println(F(\"°C\"));\n  Serial.print  (F(\"Min Value:   \")); Serial.print(sensor.min_value); Serial.println(F(\"°C\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"°C\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Print humidity sensor details.\n  dht.humidity().getSensor(&sensor);\n  Serial.println(F(\"Humidity Sensor\"));\n  Serial.print  (F(\"Sensor Type: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"Unique ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Max Value:   \")); Serial.print(sensor.max_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Min Value:   \")); Serial.print(sensor.min_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"%\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Set delay between sensor readings based on sensor details.\n  delayMS = sensor.min_delay / 1000;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Delay between measurements.\n  delay(delayMS);\n  // Get temperature event and print its value.\n  sensors_event_t event;\n  dht.temperature().getEvent(&event);\n  if (isnan(event.temperature)) {\n    Serial.println(F(\"Error reading temperature!\"));\n  }\n  else {\n    Serial.print(F(\"Temperature: \"));\n    Serial.print(event.temperature);\n    Serial.println(F(\"°C\"));\n  }\n  // Get humidity event and print its value.\n  dht.humidity().getEvent(&event);\n  if (isnan(event.relative_humidity)) {\n    Serial.println(F(\"Error reading humidity!\"));\n  }\n  else {\n    Serial.print(F(\"Humidity: \"));\n    Serial.print(event.relative_humidity);\n    Serial.println(F(\"%\"));\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "dht11",
        "dht22",
        "humidity",
        "temperature",
        "power",
        "current",
        "delay",
        "sensors"
      ],
      "libraries": [
        "DHT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Serial.println(F(\"DHTxx test!\"));\n\n  dht.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Wait a few seconds between measurements.\n  delay(2000);\n\n  // Reading temperature or humidity takes about 250 milliseconds!\n  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)\n  float h = dht.readHumidity();\n  // Read temperature as Celsius (the default)\n  float t = dht.readTemperature();\n  // Read temperature as Fahrenheit (isFahrenheit = true)\n  float f = dht.readTemperature(true);\n\n  // Check if any reads failed and exit early (to try again).\n  if (isnan(h) || isnan(t) || isnan(f)) {\n    Serial.println(F(\"Failed to read from DHT sensor!\"));\n    return;\n  }\n\n  // Compute heat index in Fahrenheit (the default)\n  float hif = dht.computeHeatIndex(f, h);\n  // Compute heat index in Celsius (isFahreheit = false)\n  float hic = dht.computeHeatIndex(t, h, false);\n\n  Serial.print(F(\"Humidity: \"));\n  Serial.print(h);\n  Serial.print(F(\"%  Temperature: \"));\n  Serial.print(t);\n  Serial.print(F(\"°C \"));\n  Serial.print(f);\n  Serial.print(F(\"°F  Heat index: \"));\n  Serial.print(hic);\n  Serial.print(F(\"°C \"));\n  Serial.print(hif);\n  Serial.println(F(\"°F\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "eeprom",
        "devices"
      ],
      "libraries": [
        "OneWireNg_CurrentPlatform.h"
      ],
      "functions": [
        {
          "name": "printId",
          "parameters": "const OneWireNg::Id& id",
          "body": "Serial.print(id[0], HEX);\n    for (size_t i = 1; i < sizeof(OneWireNg::Id); i++) {\n        Serial.print(':');\n        Serial.print(id[i], HEX);\n    }\n    Serial.println();"
        },
        {
          "name": "printMem",
          "parameters": "const OneWireNg::Id *id",
          "body": "static const char HEX_DIGS[] = \"0123456789ABCDEF\";\n    uint8_t cmd[DS2431_MEM_SIZE + 3];\n\n    cmd[0] = CMD_READ_MEMORY;\n    /* start reading from 0x0000 */\n    cmd[1] = 0x00; /* TA1 (LSB) */\n    cmd[2] = 0x00; /* TA2 (MSB) */\n\n    /* read memory will be placed here */\n    uint8_t *mem = &cmd[3];\n    memset(mem, 0xff, DS2431_MEM_SIZE);\n\n    if (id) {\n        ow->addressSingle(*id);\n    } else {\n        ow->resume();\n    }\n    ow->touchBytes(cmd, DS2431_MEM_SIZE + 3);\n\n    for (int i = 0; i < DS2431_MEM_SIZE; i++)\n    {\n        char hex[3] = {};\n\n        if (!(i % DS2431_ROW_SIZE))\n        {\n            hex[0] = HEX_DIGS[(i >> 4)];\n            hex[1] = HEX_DIGS[(i & 0x0f)];\n\n            Serial.print(\"00\");\n            Serial.print(hex);\n            Serial.print(' ');\n        }\n        hex[0] = HEX_DIGS[(mem[i] >> 4)];\n        hex[1] = HEX_DIGS[(mem[i] & 0x0f)];\n\n        Serial.print(hex);\n        if (((i+1) % DS2431_ROW_SIZE) != 0) {\n            Serial.print(':');\n        } else {\n            switch (i/DS2431_ROW_SIZE)\n            {\n            case 0:\n                Serial.println(\" Data Memory Page 0\");\n                break;\n            case 4:\n                Serial.println(\" Data Memory Page 1\");\n                break;\n            case 8:\n                Serial.println(\" Data Memory Page 2\");\n                break;\n            case 12:\n                Serial.println(\" Data Memory Page 3\");\n                break;\n            case 16:\n                Serial.println(\" Control Bytes: PCB0:PCB1:PCB2:PCB3:CPB:FACT:USR1:USR2\");\n                break;\n            case 17:\n                Serial.println(\" Reserved\");\n                break;\n            default:\n                Serial.println();\n                break;\n            }\n        }\n    }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "OneWireNg::Id id;\n\n    /* id of a DS2431 device for write demo;\n       if not set 1st available DS2431 device will be chosen */\n    OneWireNg::Id dev = {};\n\n    ow = new OneWireNg_CurrentPlatform(OW_PIN, false);\n\n    Serial.begin(115200);\n\n#ifdef USE_OD_MODE\n    ow->overdriveAll();\n#endif\n\n    /* search for DS2431 devices connected to the bus\n     */\n    ow->searchFilterAdd(DS2431);\n    Serial.println(\"Connected DS2431 devices:\");\n\n    ow->searchReset();\n    while (ow->search(id) == OneWireNg::EC_MORE) {\n        if (dev[0] != DS2431)\n            memcpy(&dev, &id[0], sizeof(OneWireNg::Id));\n\n        printId(id);\n        printMem(NULL);\n\n        Serial.println(\"----------\");\n    }\n\n#ifdef WRITE_DEMO\n    /* if no DS2431 found finish the demo */\n    if (dev[0] != DS2431) return;\n\n    uint8_t pageData[DS2431_PAGE_SIZE] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n        0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,\n        0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00\n    };\n    if (writePage(&dev, 1, pageData, true)) {\n        Serial.println(\"Page successfully written to EEPROM\");\n    }\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "power",
        "current",
        "delay",
        "digitalread",
        "rtc",
        "interrupt",
        "schedule"
      ],
      "libraries": [
        "RTClib.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n    // initializing the rtc\n    if(!rtc.begin()) {\n        Serial.println(\"Couldn't find RTC!\");\n        Serial.flush();\n        while (1) delay(10);\n    }\n\n    if(rtc.lostPower()) {\n        // this will adjust to the date and time at compilation\n        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));\n    }\n\n    //we don't need the 32K Pin, so disable it\n    rtc.disable32K();\n\n    // Making it so, that the alarm will trigger an interrupt\n    pinMode(CLOCK_INTERRUPT_PIN, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(CLOCK_INTERRUPT_PIN), onAlarm, FALLING);\n\n    // set alarm 1, 2 flag to false (so alarm 1, 2 didn't happen so far)\n    // if not done, this easily leads to problems, as both register aren't reset on reboot/recompile\n    rtc.clearAlarm(1);\n    rtc.clearAlarm(2);\n\n    // stop oscillating signals at SQW Pin\n    // otherwise setAlarm1 will fail\n    rtc.writeSqwPinMode(DS3231_OFF);\n\n    // turn off alarm 2 (in case it isn't off already)\n    // again, this isn't done at reboot, so a previously set alarm could easily go overlooked\n    rtc.disableAlarm(2);\n\n    // schedule an alarm 10 seconds in the future\n    if(!rtc.setAlarm1(\n            rtc.now() + TimeSpan(10),\n            DS3231_A1_Second // this mode triggers the alarm when the seconds match. See Doxygen for other options\n    )) {\n        Serial.println(\"Error, alarm wasn't set!\");\n    }else {\n        Serial.println(\"Alarm will happen in 10 seconds!\");\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// print current time\n    char date[10] = \"hh:mm:ss\";\n    rtc.now().toString(date);\n    Serial.print(date);\n\n    // the stored alarm value + mode\n    DateTime alarm1 = rtc.getAlarm1();\n    Ds3231Alarm1Mode alarm1mode = rtc.getAlarm1Mode();\n    char alarm1Date[12] = \"DD hh:mm:ss\";\n    alarm1.toString(alarm1Date);\n    Serial.print(\" [Alarm1: \");\n    Serial.print(alarm1Date);\n    Serial.print(\", Mode: \");\n    switch (alarm1mode) {\n      case DS3231_A1_PerSecond: Serial.print(\"PerSecond\"); break;\n      case DS3231_A1_Second: Serial.print(\"Second\"); break;\n      case DS3231_A1_Minute: Serial.print(\"Minute\"); break;\n      case DS3231_A1_Hour: Serial.print(\"Hour\"); break;\n      case DS3231_A1_Date: Serial.print(\"Date\"); break;\n      case DS3231_A1_Day: Serial.print(\"Day\"); break;\n    }\n\n    // the value at SQW-Pin (because of pullup 1 means no alarm)\n    Serial.print(\"] SQW: \");\n    Serial.print(digitalRead(CLOCK_INTERRUPT_PIN));\n\n    // whether a alarm fired\n    Serial.print(\" Fired: \");\n    Serial.print(rtc.alarmFired(1));\n\n    // Serial.print(\" Alarm2: \");\n    // Serial.println(rtc.alarmFired(2));\n    // control register values (see https://datasheets.maximintegrated.com/en/ds/DS3231.pdf page 13)\n    // Serial.print(\" Control: 0b\");\n    // Serial.println(read_i2c_register(DS3231_ADDRESS, DS3231_CONTROL), BIN);\n\n    // resetting SQW and alarm 1 flag\n    // using setAlarm1, the next alarm could now be configurated\n    if (rtc.alarmFired(1)) {\n        rtc.clearAlarm(1);\n        Serial.print(\" - Alarm cleared\");\n    }\n    Serial.println();\n\n    delay(2000);"
        },
        {
          "name": "onAlarm",
          "parameters": "",
          "body": "Serial.println(\"Alarm occured!\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "i2c",
        "delay",
        "rtc"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Start the I2C interface\n\tWire.begin();\n\t// Start the serial interface\n\tSerial.begin(57600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for (j=0;j<4;j++) {\n\t\t// invert state of 32kHz oscillator.\n\t\ton = !on;\n\t\tmyRTC.enable32kHz(on);\n\t\t// Turn on oscillator pin, frequency j\n\t\tmyRTC.enableOscillator(true, false, j);\n\t\tdelay(4000);\n\t}\n\t// So... The 32kHz oscillator (pin 1) will turn on or off once each 2s,\n\t// and the oscillator out pin (pin 3) will cycle through frequencies."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "i2c",
        "delay",
        "rtc",
        "interrupt"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Start the serial port\n    Serial.begin(57600);\n    \n    // Start the I2C interface\n    Wire.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// If something is coming in on the serial line, it's\n    // a time correction so set the clock accordingly.\n    if (Serial.available()) {\n        getDateStuff(year, month, date, dOW, hour, minute, second);\n        \n        myRTC.setClockMode(false);  // set to 24h\n        //setClockMode(true); // set to 12h\n        \n        myRTC.setYear(year);\n        myRTC.setMonth(month);\n        myRTC.setDate(date);\n        myRTC.setDoW(dOW);\n        myRTC.setHour(hour);\n        myRTC.setMinute(minute);\n        myRTC.setSecond(second);\n        \n        // Test of alarm functions\n        // set A1 to one minute past the time we just set the clock\n        // on current day of week.\n        myRTC.setA1Time(dOW, hour, minute+1, second, 0x0, true,\n                        false, false);\n        // set A2 to two minutes past, on current day of month.\n        myRTC.setA2Time(date, hour, minute+2, 0x0, false, false,\n                        false);\n        // Turn on both alarms, with external interrupt\n        myRTC.turnOnAlarm(1);\n        myRTC.turnOnAlarm(2);\n        \n    }\n    delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "temperature",
        "i2c",
        "delay",
        "display",
        "rtc"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Start the I2C interface\n\tWire.begin();\n \n\t// Start the serial interface\n\tSerial.begin(57600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// send what's going on to the serial monitor.\n\t\n\t// Start with the year\n\tSerial.print(\"2\");\n\tif (century) {\t\t\t// Won't need this for 89 years.\n\t\tSerial.print(\"1\");\n\t} else {\n\t\tSerial.print(\"0\");\n\t}\n\tSerial.print(myRTC.getYear(), DEC);\n\tSerial.print(' ');\n\t\n\t// then the month\n\tSerial.print(myRTC.getMonth(century), DEC);\n\tSerial.print(\" \");\n  \n\t// then the date\n\tSerial.print(myRTC.getDate(), DEC);\n\tSerial.print(\" \");\n  \n\t// and the day of the week\n\tSerial.print(myRTC.getDoW(), DEC);\n\tSerial.print(\" \");\n  \n\t// Finally the hour, minute, and second\n\tSerial.print(myRTC.getHour(h12Flag, pmFlag), DEC);\n\tSerial.print(\" \");\n\tSerial.print(myRTC.getMinute(), DEC);\n\tSerial.print(\" \");\n\tSerial.print(myRTC.getSecond(), DEC);\n \n\t// Add AM/PM indicator\n\tif (h12Flag) {\n\t\tif (pmFlag) {\n\t\t\tSerial.print(\" PM \");\n\t\t} else {\n\t\t\tSerial.print(\" AM \");\n\t\t}\n\t} else {\n\t\tSerial.print(\" 24h \");\n\t}\n \n\t// Display the temperature\n\tSerial.print(\"T=\");\n\tSerial.print(myRTC.getTemperature(), 2);\n  \n\t// Tell whether the time is (likely to be) valid\n\tif (myRTC.oscillatorCheck()) {\n\t\tSerial.print(\" O+\");\n\t} else {\n\t\tSerial.print(\" O-\");\n\t}\n \n\t// Indicate whether an alarm went off\n\tif (myRTC.checkIfAlarm(1)) {\n\t\tSerial.print(\" A1!\");\n\t}\n \n\tif (myRTC.checkIfAlarm(2)) {\n\t\tSerial.print(\" A2!\");\n\t}\n \n\t// New line on display\n\tSerial.println();\n\t\n\t// Display Alarm 1 information\n\tSerial.print(\"Alarm 1: \");\n\tmyRTC.getA1Time(alarmDay, alarmHour, alarmMinute, alarmSecond, alarmBits, alarmDy, alarmH12Flag, alarmPmFlag);\n\tSerial.print(alarmDay, DEC);\n\tif (alarmDy) {\n\t\tSerial.print(\" DoW\");\n\t} else {\n\t\tSerial.print(\" Date\");\n\t}\n\tSerial.print(' ');\n\tSerial.print(alarmHour, DEC);\n\tSerial.print(' ');\n\tSerial.print(alarmMinute, DEC);\n\tSerial.print(' ');\n\tSerial.print(alarmSecond, DEC);\n\tSerial.print(' ');\n\tif (alarmH12Flag) {\n\t\tif (alarmPmFlag) {\n\t\t\tSerial.print(\"pm \");\n\t\t} else {\n\t\t\tSerial.print(\"am \");\n\t\t}\n\t}\n\tif (myRTC.checkAlarmEnabled(1)) {\n\t\tSerial.print(\"enabled\");\n\t}\n\tSerial.println();\n \n\t// Display Alarm 2 information\n\tSerial.print(\"Alarm 2: \");\n\tmyRTC.getA2Time(alarmDay, alarmHour, alarmMinute, alarmBits, alarmDy, alarmH12Flag, alarmPmFlag);\n\tSerial.print(alarmDay, DEC);\n\tif (alarmDy) {\n\t\tSerial.print(\" DoW\");\n\t} else {\n\t\tSerial.print(\" Date\");\n\t}\n\tSerial.print(\" \");\n\tSerial.print(alarmHour, DEC);\n\tSerial.print(\" \");\n\tSerial.print(alarmMinute, DEC);\n\tSerial.print(\" \");\n\tif (alarmH12Flag) {\n\t\tif (alarmPmFlag) {\n\t\t\tSerial.print(\"pm\");\n\t\t} else {\n\t\t\tSerial.print(\"am\");\n\t\t}\n\t}\n\tif (myRTC.checkAlarmEnabled(2)) {\n\t\tSerial.print(\"enabled\");\n\t}\n \n\t// display alarm bits\n  Serial.println();\n\tSerial.print(\"Alarm bits: \");\n\tSerial.println(alarmBits, BIN);\n\n\tSerial.println();\n\tdelay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ds18b20",
        "temperature",
        "onewire",
        "schedule"
      ],
      "libraries": [
        "Tasker.h",
        "OneWire.h",
        "DallasTemperature.h"
      ],
      "functions": [
        {
          "name": "readSensor",
          "parameters": "",
          "body": "// read the actual temperature after it's been converted\n    float temperature = sensor.getTempC(0);\n    // do what you need with the temperature here"
        },
        {
          "name": "startConversion",
          "parameters": "",
          "body": "// start temperature conversion (does not block)\n    sensor.requestTemperatures();\n    // schedule reading the actual temperature in 750 milliseconds\n    tasker.setTimeout(readSensor, 750);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "sensor.begin();\n    // do not block during temperature conversion\n    sensor.setWaitForConversion(false);\n    // read temperature every 5 seconds\n    tasker.setInterval(startConversion, 5000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "tasker.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "payload",
        "database",
        "callback",
        "buffer",
        "json",
        "wifi",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the api key (required) */\n  config.api_key = API_KEY;\n\n  /* Assign the user sign in credentials */\n  auth.user.email = USER_EMAIL;\n  auth.user.password = USER_PASSWORD;\n\n  /* Assign the RTDB URL (required) */\n  config.database_url = DATABASE_URL;\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  // Or use legacy authenticate method\n  // config.database_url = DATABASE_URL;\n  // config.signer.tokens.legacy_token = \"<database secret>\";\n\n  // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n  Firebase.begin(&config, &auth);\n\n  // Or use legacy authenticate method\n  // Firebase.begin(DATABASE_URL, DATABASE_SECRET);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && !taskCompleted)\n  {\n\n    taskCompleted = true;\n\n    FirebaseJson json;\n\n    for (uint8_t i = 0; i < 30; i++)\n    {\n      json.set(\"Data1\", i + 1);\n      json.set(\"Data2\", i + 100);\n      Serial.printf(\"Push json... %s\\n\", Firebase.pushAsync(fbdo, \"/test/push\", json) ? \"ok\" : fbdo.errorReason().c_str());\n    }\n    Serial.println();\n\n    // Add an index to the node that is being queried.\n    // https://firebase.google.com/docs/database/security/indexing-data\n\n    // Update the existing database rules by adding key \"test/push/.indexOn\" and value \"Data2\"\n    // Check your database rules changes after running this function.\n\n    /** If the authentication type is OAuth2.0 which allows the admin right access,\n     * the database secret is not necessary by set this parameter with empty string \"\".\n     */\n    Firebase.setQueryIndex(fbdo, \"/test/push\" /* parent path of child's node that is being queried */, \"Data2\" /* the child node key that is being queried */, DATABASE_SECRET);\n\n    QueryFilter query;\n\n    query.orderBy(\"Data2\");\n    query.startAt(105);\n    query.endAt(120);\n    // get only last 8 results\n    query.limitToLast(8);\n\n    // Get filtered data\n    Serial.printf(\"Get json... %s\\n\", Firebase.getJSON(fbdo, \"/test/push\", query) ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK)\n      printResult(fbdo); // see addons/RTDBHelper.h\n\n    // Clear all query parameters\n    query.clear();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "parse",
        "acceleration",
        "uart",
        "delay",
        "sensorxyz",
        "sensor_id_acc_pass",
        "sensors"
      ],
      "libraries": [
        "Nicla_System.h",
        "Arduino_BHY2.h",
        "PacketSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "nicla::begin();\n    nicla::leds.begin();\n    BHY2.begin();\n    accel.begin();\n\n    // Init the PacketSerial communication\n    myPacketSerial.begin(115200);\n    // Set the function for handling commands from the companion app\n    myPacketSerial.setPacketHandler(&onPacketReceived);\n\n    pinMode(LED_BUILTIN, OUTPUT);\n    for (auto i = 0u; i < 10; i++) {\n        nicla::leds.setColor(green);\n        delay(25);\n        nicla::leds.setColor(off);\n        delay(25);\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Update communication-channel and sensors\n    myPacketSerial.update();\n    BHY2.update();\n\n    // Check for a receive buffer overflow (optional).\n    if (myPacketSerial.overflow()) {\n        for (auto i = 0u; i < 5; i++) {\n            nicla::leds.setColor(green);\n            delay(25);\n            nicla::leds.setColor(off);\n            delay(25);\n        }\n    }\n\n    // Capture and send data as soon as we read it\n    if (capture == true) {\n        auto now = micros() / 1000.0;\n\n        // Collect data from accel sensor\n        Data data { now, accel.x(), accel.y(), accel.z() };\n        constexpr size_t dataBufLen { sizeof(Data) };\n        uint8_t dataBuf[dataBufLen] {};\n\n        // Convert the Data struct to an array of bytes\n        memcpy(dataBuf, reinterpret_cast<void*>(&data), dataBufLen);\n        \n        // Send data\n        myPacketSerial.send(dataBuf, dataBufLen);\n    }"
        },
        {
          "name": "onPacketReceived",
          "parameters": "const uint8_t* buffer, size_t size",
          "body": "uint8_t tempBuffer[size];\n\n    for (auto i = 0u; i < 2; i++) {\n        nicla::leds.setColor(green);\n        delay(25);\n        nicla::leds.setColor(off);\n        delay(25);\n    }\n\n    memcpy(tempBuffer, buffer, size);\n\n    switch (tempBuffer[0]) {\n    case 'R':\n        nicla::leds.setColor(green);\n        capture = true;\n        break;\n    case 'S':\n        nicla::leds.setColor(off);\n        capture = false;\n        break;\n\n    default:\n        break;\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "payload",
        "database",
        "callback",
        "buffer",
        "json",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "timestamp",
        "nodes"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    // For the following credentials, see examples/Authentications/SignInAsUser/EmailPassword/EmailPassword.ino\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the user sign in credentials */\n    auth.user.email = USER_EMAIL;\n    auth.user.password = USER_PASSWORD;\n\n    /* Assign the RTDB URL (required) */\n    config.database_url = DATABASE_URL;\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    Firebase.begin(&config, &auth);\n\n    // NTP time sync\n    configTime(3 * 3600, 0, \"pool.ntp.org\", \"time.nist.gov\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (Firebase.ready())\n    {\n        if (!indexing)\n        {\n            indexing = true;\n            Serial.print(\"Set query index in database rules... \");\n\n            // If sign in with OAuth2.0 token, the database secret pass to this function can be empty string\n            if (Firebase.setQueryIndex(fbdo, \"test/log\", \"ts\", DATABASE_SECRET))\n                Serial.println(\"ok\");\n            else\n                Serial.println(fbdo.errorReason());\n        }\n\n        // push data every 30 sec\n        if (millis() - pushDataMillis > 30 * 1000)\n        {\n            pushDataMillis = millis();\n\n            count++;\n\n            FirebaseJson json;\n\n            json.add(\"ts\", (uint32_t)time(nullptr));\n            json.add(\"count\", count);\n\n            Serial.print(\"Push data... \");\n\n            if (Firebase.push(fbdo, \"test/log\", json))\n                Serial.println(\"ok\");\n            else\n                Serial.println(fbdo.errorReason());\n        }\n\n        // delete old data every 1 min\n        if (time(nullptr) > 1618971013 /* timestamp should be valid */ && millis() - deleteDataMillis > 60 * 1000)\n        {\n            deleteDataMillis = millis();\n\n            Serial.print(\"Delete history data older than 10 minutes... \");\n\n            if (Firebase.deleteNodesByTimestamp(fbdo, \"test/log\", \"ts\", 10 /* delete 10 nodes at once */, 10 * 60 /* retain data within 10 minutes */))\n                Serial.println(\"ok\");\n            else\n                Serial.println(fbdo.errorReason());\n        }\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "https",
        "json",
        "database",
        "wifi",
        "delay"
      ],
      "libraries": [
        "Firebase_Arduino_WiFiNINA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(100);\n  Serial.println();\n\n  Serial.print(\"Connecting to Wi-Fi\");\n  int status = WL_IDLE_STATUS;\n  while (status != WL_CONNECTED)\n  {\n    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\".\");\n    delay(100);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  //Provide the autntication data\n  Firebase.begin(DATABASE_URL, DATABASE_SECRET, WIFI_SSID, WIFI_PASSWORD);\n  Firebase.reconnectWiFi(true);\n\n  String jsonStr = \"\";\n\n  for (uint8_t i = 0; i < 30; i++)\n  {\n    Serial.print(\"Push json... \");\n\n    jsonStr = \"{\\\"data1\\\":\" + String(i + 1) + \",\\\"data2\\\":\\\"\" + String(i + 100) + \"\\\"}\";\n\n    if (Firebase.pushJSON(fbdo, \"/test/int\", jsonStr))\n    {\n      Serial.println(\"ok\");\n      Serial.println(\"path: \" + fbdo.dataPath());\n      Serial.print(\"push name: \");\n      Serial.println(fbdo.pushName());\n    }\n    else\n    {\n      Serial.println(\"error, \" + fbdo.errorReason());\n    }\n\n    Serial.println();\n  }\n\n  QueryFilter query;\n\n  //Clear query parameters\n  query.clearQuery();\n\n\n  query.orderBy(\"data2\");\n  //query.orderBy(\"data1\");\n  query.startAt(\"110\");\n  //query.startAt(5);\n  query.endAt(\"115\");\n  //query.endAt(20);\n  query.limitToLast(3);\n\n  /*\n\n    Begin data filtering test\n\n    Add the following rules in Firebase Database Rules Dashboard\n\n    \"rules\": {\n    ...\n    ...\n    ,\n\n    \"test\":{\n      \"int\":{\n        \".indexOn\":\"data2\"\n        //\".indexOn\":\"data1\"\n      }\n    }\n\n  */\n\n  Serial.print(\"Data filtering... \");\n\n  if (Firebase.getJSON(fbdo, \"/test/int\", query))\n  {\n\n    Serial.println(\"ok\");\n    Serial.println(fbdo.jsonData());\n  }\n  else\n  {\n    Serial.println(\"error, \" + fbdo.errorReason());\n  }\n\n  Serial.println();\n\n  //Release memory used by query object\n  query.end();\n\n  // clear internal memory used\n  fbdo.clear();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "auth",
        "ssl",
        "database",
        "payload",
        "json",
        "callback",
        "buffer",
        "wifi",
        "delay",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the api key (required) */\n  config.api_key = API_KEY;\n\n  /* Assign the RTDB URL (required) */\n  config.database_url = DATABASE_URL;\n\n  /* Assign the sevice account credentials and private key (required) */\n  config.service_account.data.client_email = FIREBASE_CLIENT_EMAIL;\n  config.service_account.data.project_id = FIREBASE_PROJECT_ID;\n  config.service_account.data.private_key = PRIVATE_KEY;\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  // Or use legacy authenticate method\n  // config.database_url = DATABASE_URL;\n  // config.signer.tokens.legacy_token = \"<database secret>\";\n\n  // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n  Firebase.begin(&config, &auth);\n\n#if defined(ESP8266)\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && !taskCompleted)\n  {\n    taskCompleted = true;\n\n    String rules;\n\n    Serial.printf(\"Get RTDB rules... %s\\n\", Firebase.getRules(fbdo) ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK)\n    {\n      FirebaseJson *json = fbdo.to<FirebaseJson *>();\n      json->toString(rules, true);\n      Serial.println(rules);\n      Serial.println();\n    }\n\n    Serial.printf(\"Set RTDB rules... %s\\n\", Firebase.setRules(fbdo, rules.c_str()) ? \"ok\" : fbdo.errorReason().c_str());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "current",
        "delay"
      ],
      "libraries": [
        "Ciao.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//init Ciao\n\tCiao.begin();\n\tSerial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//Run commands in Linino OS to get date\n\tCiaoData data = Ciao.write(\"shell\",\"date\");\n\n\tif(!data.isEmpty()){\n\t\t//Get data back\n\t\tString usage = data.get(2);\n\t\tSerial.println(usage);\n\t}\n\n\tdelay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "key",
        "current",
        "wifi",
        "digitalread",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  pinMode(INPUT_PIN_NUMBER, INPUT);\n  lastSwitchState = digitalRead(INPUT_PIN_NUMBER);\n\n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bool newSwitchState = digitalRead(INPUT_PIN_NUMBER);\n  \n  // if input state has changed\n  if(newSwitchState != lastSwitchState && WifiConnection::isConnected()) {\n    \n    // store the new state in the server\n    bool isOk = storage.put<bool>(\"switch_state\", newSwitchState);\n    \n    // Make sure `put` was successful\n    if(isOk) {\n      // save current time in the server in the key \"last_update_time\"\n      // `datetime` also returns the newly stored value \n      String time = storage.datetime(\"last_update_time\");\n      Serial.println(\"Last Update Time in the server now equals to: \");\n      Serial.println(time);\n    } else {\n      Serial.println(\"Something went wrong\");\n    }\n\n    // remember last state\n    lastSwitchState = newSwitchState;\n  } else if(WifiConnection::isConnected() == false) {\n    Serial.println(\"No Connection\");\n  }\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalread",
        "debounce"
      ],
      "libraries": [
        "AsyncTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  pinMode(BUTTON_PIN, INPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "t.handle();\n\n  if (digitalRead(BUTTON_PIN) == HIGH) {\n    if (timeoutId != 0)\n      t.reset(timeoutId);\n    else\n      timeoutId = t.setTimeout(\n          []() {\n            Serial.println(\"Button pressed!\");\n            timeoutId = 0;\n          },\n          50);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "password",
        "wifi",
        "digitalread",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "isButton1Pressed",
          "parameters": "",
          "body": "return digitalRead(BUTTON_PIN_1) == false;"
        },
        {
          "name": "isButton2Pressed",
          "parameters": "",
          "body": "return digitalRead(BUTTON_PIN_2) == false;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  pinMode(BUTTON_PIN_1, INPUT_PULLUP);\n  pinMode(BUTTON_PIN_2, INPUT_PULLUP);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(5 * 1000);\n\n  score = storage.get<int>(\"counter\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if(WifiConnection::isConnected() == false) {\n    Serial.println(\"No Connection\");\n    return;\n  }\n\n  // if first button is pressed, increment the counter\n  if(isButton1Pressed()) {\n      score = storage.inc(\"counter\");\n  }\n\n  // if second button is pressed, decrement the counter\n  if(isButton2Pressed()) {\n      score = storage.dec(\"counter\");\n  }\n\n  Serial.print(\"Latest Score: \");\n  Serial.println(score);\n\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "http",
        "https",
        "wifi",
        "delay"
      ],
      "libraries": [
        "WiFiEspAT.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial1.begin(AT_BAUD_RATE);\n  WiFi.init(Serial1, ESP_RESET_PIN);\n\n  if (WiFi.status() == WL_NO_MODULE) {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Waiting for connection to WiFi\");\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print('.');\n  }\n  Serial.println();\n  Serial.println(\"Connected to WiFi network.\");\n\n  doSomething();\n\n  Serial.println();\n  Serial.println(\"putting ESP to deep sleep...\");\n  WiFi.deepSleep();\n\n  delay(SLEEP_INTERVAL); // here the main MCU could be set to sleep too\n\n  WiFi.reset(ESP_RESET_PIN); // wake-up the esp from deep slepp\n\n  Serial.println();\n  Serial.println(\"wakeup\");"
        },
        {
          "name": "doSomething",
          "parameters": "",
          "body": "Serial.println();\n  Serial.println(\"Starting connection to server...\");\n  if (client.connect(server, 80)) {\n    Serial.println(\"connected to server\");\n\n    client.println(\"GET /asciilogo.txt HTTP/1.1\");\n    client.print(\"Host: \");\n    client.println(server);\n    client.println(\"Connection: close\");\n    client.println();\n    client.flush();\n    while (client.connected()) {\n      while (client.available()) {\n        char c = client.read();\n        Serial.write(c);\n      }\n    }\n    Serial.println();\n    Serial.println(\"disconnecting from server.\");\n    client.stop();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "key",
        "password",
        "token",
        "payload",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    printResult(aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "password",
        "key",
        "token",
        "payload",
        "wifi",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    wifimulti.addAP(WIFI_SSID1, WIFI_PASSWORD1);\n    wifimulti.addAP(WIFI_SSID2, WIFI_PASSWORD2);\n    wifimulti.addAP(WIFI_SSID3, WIFI_PASSWORD3);\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    printResult(aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay",
        "html"
      ],
      "libraries": [
        "Audio.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// allocate enough memory for the delay\n  AudioMemory(120);\n  \n  // configure a sine wave for the chirp\n  // the original is turned on/off by an envelope effect\n  // and output directly on the left channel\n  sine1.frequency(1000);\n  sine1.amplitude(0.5);\n\n  // create 3 delay taps, which connect through a\n  // mixer to the right channel output\n  delay1.delay(0, 110);\n  delay1.delay(1, 220);\n  delay1.delay(2, 330);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "envelope1.noteOn();\n  delay(36);\n  envelope1.noteOff();\n  delay(4000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "key",
        "certificate",
        "token",
        "auth",
        "callback",
        "json",
        "wifi",
        "millis",
        "delay",
        "sd",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "GS_SDHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\r\n    Serial.println();\r\n    Serial.println();\r\n\r\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\r\n\r\n#if defined(ESP32) || defined(ESP8266)\r\n    WiFi.setAutoReconnect(true);\r\n#endif\r\n\r\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\r\n    GSheet.clearAP();\r\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\r\n    multi.run();\r\n#else\r\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\r\n#endif\r\n\r\n    Serial.print(\"Connecting to Wi-Fi\");\r\n    unsigned long ms = millis();\r\n    while (WiFi.status() != WL_CONNECTED)\r\n    {\r\n        Serial.print(\".\");\r\n        delay(300);\r\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\r\n        if (millis() - ms > 10000)\r\n            break;\r\n#endif\r\n    }\r\n    Serial.println();\r\n    Serial.print(\"Connected with IP: \");\r\n    Serial.println(WiFi.localIP());\r\n    Serial.println();\r\n\r\n    // In case SD/SD_MMC storage file access, mount the SD/SD_MMC card.\r\n    // SD_Card_Mounting(); // See src/GS_SDHelper.h\r\n\r\n    // GSheet.setCert(rootCACert); // or GSheet.setCertFile(\"path/to/certificate/file.pem\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);\r\n\r\n    // Set the callback for Google API access token generation status (for debug only)\r\n    GSheet.setTokenCallback(tokenStatusCallback);\r\n\r\n    // The WiFi credentials are required for Pico W\r\n    // due to it does not have reconnect feature.\r\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\r\n    GSheet.addAP(WIFI_SSID, WIFI_PASSWORD);\r\n#endif\r\n\r\n    // Set the seconds to refresh the auth token before expire (60 to 3540, default is 300 seconds)\r\n    GSheet.setPrerefreshSeconds(10 * 60);\r\n\r\n    // Begin the access token generation for Google API authentication\r\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\r\n\r\n    // Or begin with the Service Account JSON file\r\n    // GSheet.begin(\"path/to/serviceaccount/json/file\", esp_google_sheet_file_storage_type_flash /* or esp_google_sheet_file_storage_type_sd */);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call ready() repeatedly in loop for authentication checking and processing\r\n    bool ready = GSheet.ready();\r\n\r\n    if (ready && !taskComplete)\r\n    {\r\n        // For basic FirebaseJson usage example, see examples/FirebaseJson/Create_Edit_Parse/Create_Edit_Parse.ino\r\n\r\n        FirebaseJson response;\r\n        // Instead of using FirebaseJson for response, you can use String for response to the functions\r\n        // especially in low memory device that deserializing large JSON response may be failed as in ESP8266\r\n\r\n        Serial.println(\"\\nDelete spreadsheet from Google Drive...\");\r\n        Serial.println(\"------------------------------------------------\");\r\n\r\n        bool success = GSheet.deleteFile(&response /* returned response */, \"<spreadsheetId>\" /* spreadsheet Id to delete */);\r\n        response.toString(Serial, true);\r\n        Serial.println();\r\n\r\n        Serial.println(\"\\nDelete last 5 spreadsheets from Google Drive...\");\r\n        Serial.println(\"------------------------------------------------\");\r\n\r\n        success = GSheet.deleteFiles(&response /* returned response */);\r\n\r\n        if (success)\r\n            Serial.println(\"ok\");\r\n\r\n        taskComplete = true;\r\n    }"
        },
        {
          "name": "tokenStatusCallback",
          "parameters": "TokenInfo info",
          "body": "if (info.status == token_status_error)\r\n    {\r\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\r\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());\r\n    }\r\n    else\r\n    {\r\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\r\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "auth",
        "https",
        "key",
        "token",
        "payload",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    UserAccount user(API_KEY);\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    Serial.println(\"Deleting user...\");\n\n    const char *idtoken = \"id token\";\n\n    deleteUser(aClient, app, getAuth(user.email(\"user@gmail.com\").idToken(idtoken)), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    app.loop();"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "light",
        "servo",
        "led"
      ],
      "libraries": [
        "Commanders.h",
        "Accessories.h"
      ],
      "functions": [
        {
          "name": "ReceiveEvent",
          "parameters": "unsigned long inId, COMMANDERS_EVENT_TYPE inEventType, int inEventData",
          "body": "Accessories::ReceiveEvent(inId, (ACCESSORIES_EVENT_TYPE)inEventType, inEventData);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\t//while (!Serial);\t\t// For Leonardo only. No effect on other Arduino.\n\n\tCommanders::begin(ReceiveEvent, LED_BUILTIN);\n\tAccessories::begin();\n\n\t// Commanders setup\n\n\tSerialCommander.begin();\n\tDccCommander.begin(0x00, 0x00, digitalPinToInterrupt(3));\n\n\t// Each button assigned to an accessory Dcc code.\n#ifdef VISUALSTUDIO\n\tpush0.begin(IDLEFT, '0');\n\tpush1.begin(IDRIGHT, '1');\n\tpush2.begin(IDDC, '2');\n\tpush3.begin(IDEPS, '3');\n\tpush4.begin(IDTJD, '4');\n\tpush5.begin(IDSERVOMIN, '5');\n\tpush6.begin(IDSERVOMAX, '6');\n\tpush7.begin(IDLIGHT, '7');\n#else\n\tpush0.begin(IDLEFT, 30);\n\tpush1.begin(IDRIGHT, 32);\n\tpush2.begin(IDDC, 34);\n\tpush3.begin(IDEPS, 36);\n\tpush4.begin(IDTJD, 38);\n\tpush5.begin(IDSERVOMIN, 40);\n\tpush6.begin(IDSERVOMAX, 42);\n\tpush7.begin(IDLIGHT, 44);\n#endif\n\t// Drivers setups\n\n\t// four turnouts are connected to the l293d shield.\n\t// l293d part\n\tPortLeft.begin(SHIELDL293D_PORT_M1, 200, MOTOR12_1KHZ);\n\tPortRight.begin(SHIELDL293D_PORT_M2, 200, MOTOR12_1KHZ);\n\tPortDc.begin(SHIELDL293D_PORT_M3, 200, MOTOR34_1KHZ);\n\tPortEps.begin(SHIELDL293D_PORT_M4, 200, MOTOR34_1KHZ);\n\tportServo.begin(SHIELDL293D_SERVO1_PIN);\n\n\t// l298n circuit.\n\tPortTjd.begin(50, 52, DIGITAL);\n\tPortLight.begin(46, 48, DIGITAL);\n\n\t// Accessories setups\n\n\t// Assign Dcc code for each accessory.\n\tturnoutLeft.begin(&PortLeft, IDLEFT, 50, 150);\n\tturnoutRight.begin(&PortRight, IDRIGHT, 3000, 150);\n\tturnoutDc.begin(&PortDc, IDDC, 500, 150);\n\tturnoutEps.begin(&PortEps, IDEPS, 3000, 150);\n\n\tturnoutTjd.begin(&PortTjd, IDTJD, 0, 150);\n\tlight.begin(&PortLight, IDLIGHT, 500, 150);\n\tservo.begin(&portServo, 1000, 40, 50, 2);\n\tservo.AddMinMaxMovingPositions(IDSERVOMIN, IDSERVOMAX);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Accessories::loop();\n\n\tCommanders::loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  // this check is only needed on the Leonardo:\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // start the Ethernet connection:\n  if (Ethernet.begin() == 0) {\n    Serial.println(\"Failed to configure Ethernet using DHCP\");\n    // no point in carrying on, so do nothing forevermore:\n    for (;;)\n      ;\n  }\n  // print your local IP address:\n  printIPAddress();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "switch (Ethernet.maintain())\n  {\n    case 1:\n      //renewed fail\n      Serial.println(\"Error: renewed fail\");\n      break;\n\n    case 2:\n      //renewed success\n      Serial.println(\"Renewed success\");\n\n      //print your local IP address:\n      printIPAddress();\n      break;\n\n    case 3:\n      //rebind fail\n      Serial.println(\"Error: rebind fail\");\n      break;\n\n    case 4:\n      //rebind success\n      Serial.println(\"Rebind success\");\n\n      //print your local IP address:\n      printIPAddress();\n      break;\n\n    default:\n      //nothing happened\n      break;\n\n  }"
        },
        {
          "name": "printIPAddress",
          "parameters": "",
          "body": "Serial.print(\"My IP address: \");\n  for (byte thisByte = 0; thisByte < 4; thisByte++) {\n    // print the value of each byte of the IP address:\n    Serial.print(Ethernet.localIP()[thisByte], DEC);\n    Serial.print(\".\");\n  }\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "clients"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  // this check is only needed on the Leonardo:\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n\n  // start the Ethernet connection:\n  Serial.println(\"Trying to get an IP address using DHCP\");\n  if (Ethernet.begin() == 0) {\n    Serial.println(\"Failed to configure Ethernet using DHCP\");\n    // initialize the Ethernet device not using DHCP:\n    Ethernet.begin(ip, subnet, gateway, myDns);\n  }\n  // print your local IP address:\n  Serial.print(\"My IP address: \");\n  ip = Ethernet.localIP();\n  for (byte thisByte = 0; thisByte < 4; thisByte++) {\n    // print the value of each byte of the IP address:\n    Serial.print(ip[thisByte], DEC);\n    Serial.print(\".\");\n  }\n  Serial.println();\n  // start listening for clients\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// wait for a new client:\n  EthernetClient client = server.available();\n\n  // when the client sends the first byte, say hello:\n  if (client) {\n    if (!gotAMessage) {\n      Serial.println(\"We have a new client\");\n      client.println(\"Hello, client!\");\n      gotAMessage = true;\n    }\n\n    // read the bytes incoming from the client:\n    char thisChar = client.read();\n    // echo the bytes back to the client:\n    server.write(thisChar);\n    // echo the bytes to the server as well:\n    Serial.print(thisChar);\n    Ethernet.maintain();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "ssl",
        "password",
        "buffer",
        "power",
        "gsm",
        "gprs",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h",
        "StreamDebugger.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // !!!!!!!!!!!\n  // Set your reset, enable, power pins here\n  // !!!!!!!!!!!\n\n  SerialMon.println(\"Wait...\");\n\n  // Set GSM module baud rate\n  TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n  // SerialAT.begin(9600);\n  delay(6000);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  SerialMon.print(\"Initializing modem...\");\n  if (!modem.restart()) {\n    // if (!modem.init()) {\n    SerialMon.println(F(\" [fail]\"));\n    SerialMon.println(F(\"************************\"));\n    SerialMon.println(F(\" Is your modem connected properly?\"));\n    SerialMon.println(F(\" Is your serial speed (baud rate) correct?\"));\n    SerialMon.println(F(\" Is your modem powered on?\"));\n    SerialMon.println(F(\" Do you use a good, stable power source?\"));\n    SerialMon.println(F(\" Try using File -> Examples -> TinyGSM -> tools -> \"\n                        \"AT_Debug to find correct configuration\"));\n    SerialMon.println(F(\"************************\"));\n    delay(10000);\n    return;\n  }\n  SerialMon.println(F(\" [OK]\"));\n\n  String modemInfo = modem.getModemInfo();\n  SerialMon.print(\"Modem Info: \");\n  SerialMon.println(modemInfo);\n\n#if TINY_GSM_USE_GPRS\n  // Unlock your SIM card with a PIN if needed\n  if (GSM_PIN && modem.getSimStatus() != 3) { modem.simUnlock(GSM_PIN); }\n#endif\n\n#if TINY_GSM_USE_WIFI\n  // Wifi connection parameters must be set before waiting for the network\n  SerialMon.print(F(\"Setting SSID/password...\"));\n  if (!modem.networkConnect(wifiSSID, wifiPass)) {\n    SerialMon.println(\" fail\");\n    delay(10000);\n    return;\n  }\n  SerialMon.println(\" success\");\n#endif\n\n#if TINY_GSM_USE_GPRS && defined TINY_GSM_MODEM_XBEE\n  // The XBee must run the gprsConnect function BEFORE waiting for network!\n  modem.gprsConnect(apn, gprsUser, gprsPass);\n#endif\n\n  SerialMon.print(\"Waiting for network...\");\n  if (!modem.waitForNetwork(\n          600000L)) {  // You may need lengthen this in poor service areas\n    SerialMon.println(F(\" [fail]\"));\n    SerialMon.println(F(\"************************\"));\n    SerialMon.println(F(\" Is your sim card locked?\"));\n    SerialMon.println(F(\" Do you have a good signal?\"));\n    SerialMon.println(F(\" Is antenna attached?\"));\n    SerialMon.println(F(\" Does the SIM card work with your phone?\"));\n    SerialMon.println(F(\"************************\"));\n    delay(10000);\n    return;\n  }\n  SerialMon.println(F(\" [OK]\"));\n\n#if TINY_GSM_USE_GPRS\n  // GPRS connection parameters are usually set after network registration\n  SerialMon.print(\"Connecting to \");\n  SerialMon.print(apn);\n  if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {\n    SerialMon.println(F(\" [fail]\"));\n    SerialMon.println(F(\"************************\"));\n    SerialMon.println(F(\" Is GPRS enabled by network provider?\"));\n    SerialMon.println(F(\" Try checking your card balance.\"));\n    SerialMon.println(F(\"************************\"));\n    delay(10000);\n    return;\n  }\n  SerialMon.println(F(\" [OK]\"));\n#endif\n\n  IPAddress local = modem.localIP();\n  SerialMon.print(\"Local IP: \");\n  SerialMon.println(local);\n\n  SerialMon.print(F(\"Connecting to \"));\n  SerialMon.print(server);\n  if (!client.connect(server, port)) {\n    SerialMon.println(F(\" [fail]\"));\n    delay(10000);\n    return;\n  }\n  SerialMon.println(F(\" [OK]\"));\n\n  // Make a HTTP GET request:\n  client.print(String(\"GET \") + resource + \" HTTP/1.0\\r\\n\");\n  client.print(String(\"Host: \") + server + \"\\r\\n\");\n  client.print(\"Connection: close\\r\\n\\r\\n\");\n\n  // Wait for data to arrive\n  while (client.connected() && !client.available()) {\n    delay(100);\n    SerialMon.print('.');\n  };\n  SerialMon.println();\n\n  // Skip all headers\n  client.find(\"\\r\\n\\r\\n\");\n\n  // Read data\n  uint32_t timeout       = millis();\n  uint32_t bytesReceived = 0;\n  while (client.connected() && millis() - timeout < 10000L) {\n    while (client.available()) {\n      char c = client.read();\n      // SerialMon.print(c);\n      bytesReceived += 1;\n      timeout = millis();\n    }\n  }\n\n  client.stop();\n  SerialMon.println(F(\"Server disconnected\"));\n\n#if TINY_GSM_USE_WIFI\n  modem.networkDisconnect();\n  SerialMon.println(F(\"WiFi disconnected\"));\n#endif\n#if TINY_GSM_USE_GPRS\n  modem.gprsDisconnect();\n  SerialMon.println(F(\"GPRS disconnected\"));\n#endif\n\n  SerialMon.println();\n  SerialMon.println(F(\"************************\"));\n  SerialMon.print(F(\" Received: \"));\n  SerialMon.print(bytesReceived);\n  SerialMon.println(F(\" bytes\"));\n  SerialMon.print(F(\" Test:     \"));\n  SerialMon.println((bytesReceived == 121) ? \"PASSED\" : \"FAILED\");\n  SerialMon.println(F(\"************************\"));\n\n  // Do nothing forevermore\n  while (true) { delay(1000); }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "spi",
        "tone",
        "delay",
        "digitalwrite",
        "segment",
        "display",
        "led",
        "sd",
        "detectors"
      ],
      "libraries": [
        "Audio.h",
        "Wire.h",
        "SPI.h",
        "SD.h",
        "SerialFlash.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(3);\n  \n  //while (!Serial) ;\n  //delay(100);\n  \n  // Configure the tone detectors with the frequency and number\n  // of cycles to match.  These numbers were picked for match\n  // times of approx 30 ms.  Longer times are more precise.\n  row1.frequency(697, 21);\n  row2.frequency(770, 23);\n  row3.frequency(852, 25);\n  row4.frequency(941, 28);\n  column1.frequency(1209, 36);\n  column2.frequency(1336, 40);\n  column3.frequency(1477, 44);\n  \n  // The 7 segment display is \"common anode), where the\n  // common pin connects to +3.3V.  LOW turns the LED on\n  // and HIGH turns the LED off.  If you use a common\n  // cathode display, you will need to change all the HIGH\n  // to LOW and LOW to HIGH.\n  pinMode(sevenseg_a, OUTPUT);\n  pinMode(sevenseg_b, OUTPUT);\n  pinMode(sevenseg_c, OUTPUT);\n  pinMode(sevenseg_d, OUTPUT);\n  pinMode(sevenseg_e, OUTPUT);\n  pinMode(sevenseg_f, OUTPUT);\n  pinMode(sevenseg_g, OUTPUT);\n  digitalWrite(sevenseg_a, HIGH);\n  digitalWrite(sevenseg_b, HIGH);\n  digitalWrite(sevenseg_c, HIGH);\n  digitalWrite(sevenseg_d, HIGH);\n  digitalWrite(sevenseg_e, HIGH);\n  digitalWrite(sevenseg_f, HIGH);\n  digitalWrite(sevenseg_g, HIGH);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float r1, r2, r3, r4, c1, c2, c3;\n  char digit=0;\n\n  // read all seven tone detectors\n  r1 = row1.read();\n  r2 = row2.read();\n  r3 = row3.read();\n  r4 = row4.read();\n  c1 = column1.read();\n  c2 = column2.read();\n  c3 = column3.read();\n\n  // print the raw data, for troubleshooting\n  Serial.print(\"tones: \");\n  Serial.print(r1);\n  Serial.print(\", \");\n  Serial.print(r2);\n  Serial.print(\", \");\n  Serial.print(r3);\n  Serial.print(\", \");\n  Serial.print(r4);\n  Serial.print(\",   \");\n  Serial.print(c1);\n  Serial.print(\", \");\n  Serial.print(c2);\n  Serial.print(\", \");\n  Serial.print(c3);\n\n  // check all 12 combinations for key press\n  if (r1 >= row_threshold) {\n    if (c1 > column_threshold) {\n      digit = '1';\n      digitalWrite(sevenseg_a, HIGH);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, HIGH);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, HIGH);\n      digitalWrite(sevenseg_g, HIGH);\n    } else if (c2 > column_threshold) {\n      digit = '2';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, HIGH);\n      digitalWrite(sevenseg_d, LOW);\n      digitalWrite(sevenseg_e, LOW);\n      digitalWrite(sevenseg_f, HIGH);\n      digitalWrite(sevenseg_g, LOW);\n    } else if (c3 > column_threshold) {\n      digit = '3';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, LOW);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, HIGH);\n      digitalWrite(sevenseg_g, LOW);\n    }\n  } else if (r2 >= row_threshold) { \n    if (c1 > column_threshold) {\n      digit = '4';\n      digitalWrite(sevenseg_a, HIGH);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, HIGH);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, LOW);\n      digitalWrite(sevenseg_g, LOW);\n    } else if (c2 > column_threshold) {\n      digit = '5';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, HIGH);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, LOW);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, LOW);\n      digitalWrite(sevenseg_g, LOW);\n    } else if (c3 > column_threshold) {\n      digit = '6';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, HIGH);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, LOW);\n      digitalWrite(sevenseg_e, LOW);\n      digitalWrite(sevenseg_f, LOW);\n      digitalWrite(sevenseg_g, LOW);\n    }\n  } else if (r3 >= row_threshold) { \n    if (c1 > column_threshold) {\n      digit = '7';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, HIGH);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, HIGH);\n      digitalWrite(sevenseg_g, HIGH);\n    } else if (c2 > column_threshold) {\n      digit = '8';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, LOW);\n      digitalWrite(sevenseg_e, LOW);\n      digitalWrite(sevenseg_f, LOW);\n      digitalWrite(sevenseg_g, LOW);\n    } else if (c3 > column_threshold) {\n      digit = '9';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, LOW);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, LOW);\n      digitalWrite(sevenseg_g, LOW);\n    }\n  } else if (r4 >= row_threshold) { \n    if (c1 > column_threshold) {\n      digit = '*';\n      digitalWrite(sevenseg_a, HIGH);\n      digitalWrite(sevenseg_b, HIGH);\n      digitalWrite(sevenseg_c, HIGH);\n      digitalWrite(sevenseg_d, HIGH);\n      digitalWrite(sevenseg_e, HIGH);\n      digitalWrite(sevenseg_f, HIGH);\n      digitalWrite(sevenseg_g, LOW);\n    } else if (c2 > column_threshold) {\n      digit = '0';\n      digitalWrite(sevenseg_a, LOW);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, LOW);\n      digitalWrite(sevenseg_e, LOW);\n      digitalWrite(sevenseg_f, LOW);\n      digitalWrite(sevenseg_g, HIGH);\n    } else if (c3 > column_threshold) {\n      digit = '#';\n      digitalWrite(sevenseg_a, HIGH);\n      digitalWrite(sevenseg_b, LOW);\n      digitalWrite(sevenseg_c, LOW);\n      digitalWrite(sevenseg_d, HIGH);\n      digitalWrite(sevenseg_e, LOW);\n      digitalWrite(sevenseg_f, LOW);\n      digitalWrite(sevenseg_g, LOW);\n    }\n  }\n\n  // print the key, if any found\n  if (digit > 0) {\n    Serial.print(\"  --> Key: \");\n    Serial.print(digit);\n  }\n  Serial.println();\n\n  // uncomment these lines to see how much CPU time\n  // the tone detectors and audio library are using\n  //Serial.print(\"CPU=\");\n  //Serial.print(AudioProcessorUsage());\n  //Serial.print(\"%, max=\");\n  //Serial.print(AudioProcessorUsageMax());\n  //Serial.print(\"%   \");\n\n  delay(25);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "spi",
        "tone",
        "delay",
        "sd",
        "detectors"
      ],
      "libraries": [
        "Audio.h",
        "Wire.h",
        "SPI.h",
        "SD.h",
        "SerialFlash.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(12);\n\n  // Enable the audio shield and set the output volume.\n  audioShield.enable();\n  audioShield.volume(0.5);\n  \n  while (!Serial) ;\n  delay(100);\n  \n  // Configure the tone detectors with the frequency and number\n  // of cycles to match.  These numbers were picked for match\n  // times of approx 30 ms.  Longer times are more precise.\n  row1.frequency(697, 21);\n  row2.frequency(770, 23);\n  row3.frequency(852, 25);\n  row4.frequency(941, 28);\n  column1.frequency(1209, 36);\n  column2.frequency(1336, 40);\n  column3.frequency(1477, 44);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float r1, r2, r3, r4, c1, c2, c3;\n  char digit=0;\n\n  // read all seven tone detectors\n  r1 = row1.read();\n  r2 = row2.read();\n  r3 = row3.read();\n  r4 = row4.read();\n  c1 = column1.read();\n  c2 = column2.read();\n  c3 = column3.read();\n\n  // print the raw data, for troubleshooting\n  Serial.print(\"tones: \");\n  Serial.print(r1);\n  Serial.print(\", \");\n  Serial.print(r2);\n  Serial.print(\", \");\n  Serial.print(r3);\n  Serial.print(\", \");\n  Serial.print(r4);\n  Serial.print(\",   \");\n  Serial.print(c1);\n  Serial.print(\", \");\n  Serial.print(c2);\n  Serial.print(\", \");\n  Serial.print(c3);\n\n  // check all 12 combinations for key press\n  if (r1 >= row_threshold) {\n    if (c1 > column_threshold) {\n      digit = '1';\n    } else if (c2 > column_threshold) {\n      digit = '2';\n    } else if (c3 > column_threshold) {\n      digit = '3';\n    }\n  } else if (r2 >= row_threshold) { \n    if (c1 > column_threshold) {\n      digit = '4';\n    } else if (c2 > column_threshold) {\n      digit = '5';\n    } else if (c3 > column_threshold) {\n      digit = '6';\n    }\n  } else if (r3 >= row_threshold) { \n    if (c1 > column_threshold) {\n      digit = '7';\n    } else if (c2 > column_threshold) {\n      digit = '8';\n    } else if (c3 > column_threshold) {\n      digit = '9';\n    }\n  } else if (r4 >= row_threshold) { \n    if (c1 > column_threshold) {\n      digit = '*';\n    } else if (c2 > column_threshold) {\n      digit = '0';\n    } else if (c3 > column_threshold) {\n      digit = '#';\n    }\n  }\n\n  // print the key, if any found\n  if (digit > 0) {\n    Serial.print(\"  --> Key: \");\n    Serial.print(digit);\n  }\n  Serial.println();\n\n  // uncomment these lines to see how much CPU time\n  // the tone detectors and audio library are using\n  //Serial.print(\"CPU=\");\n  //Serial.print(AudioProcessorUsage());\n  //Serial.print(\"%, max=\");\n  //Serial.print(AudioProcessorUsageMax());\n  //Serial.print(\"%   \");\n\n  // check if any data has arrived from the serial monitor\n  if (Serial.available()) {\n    char key = Serial.read();\n    int low=0;\n    int high=0;\n    if (key == '1') {\n      low = 697;\n      high = 1209;\n    } else if (key == '2') {\n      low = 697;\n      high = 1336;\n    } else if (key == '3') {\n      low = 697;\n      high = 1477;\n    } else if (key == '4') {\n      low = 770;\n      high = 1209;\n    } else if (key == '5') {\n      low = 770;\n      high = 1336;\n    } else if (key == '6') {\n      low = 770;\n      high = 1477;\n    } else if (key == '7') {\n      low = 852;\n      high = 1209;\n    } else if (key == '8') {\n      low = 852;\n      high = 1336;\n    } else if (key == '9') {\n      low = 852;\n      high = 1477;\n    } else if (key == '*') {\n      low = 941;\n      high = 1209;\n    } else if (key == '0') {\n      low = 941;\n      high = 1336;\n    } else if (key == '#') {\n      low = 941;\n      high = 1477;\n    }\n\n    // play the DTMF tones, if characters send from the Arduino Serial Monitor\n    if (low > 0 && high > 0) {\n      Serial.print(\"Output sound for key \");\n      Serial.print(key);\n      Serial.print(\", low freq=\");\n      Serial.print(low);\n      Serial.print(\", high freq=\");\n      Serial.print(high);\n      Serial.println();\n      AudioNoInterrupts();  // disable audio library momentarily\n      sine1.frequency(low);\n      sine1.amplitude(0.4);\n      sine2.frequency(high);\n      sine2.amplitude(0.45);\n      AudioInterrupts();    // enable, both tones will start together\n      delay(100);           // let the sound play for 0.1 second\n      AudioNoInterrupts();\n      sine1.amplitude(0);\n      sine2.amplitude(0);\n      AudioInterrupts();\n      delay(50);            // make sure we have 0.05 second silence after\n    }\n  }\n\n  delay(25);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token"
      ],
      "libraries": [
        "BlynkSimpleStream.h",
        "DigiCDC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Blynk will work through SerialUSB\n  // Do not read or write this serial manually in your sketch\n  SerialUSB.begin();\n  Blynk.begin(SerialUSB, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "wifi"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // Oak has already configured WiFi\n  Blynk.config(auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  //The loop starts only when the Serial Monitor is opened.\n  while(!Serial);\n  Wire.begin();\n\n  if (!digital_inputs.init()) {\n    Serial.println(\"Digital input GPIO expander initialization fail!!\");\n }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//Reads and Prints all channels (in a single operation)\n  readAll();\n\n  //Read one-by-one each channel and print them one-by-one\n  readings = digital_inputs.read(DIN_READ_CH_PIN_00);\n  Serial.println(\"CH00: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_01);\n  Serial.println(\"CH01: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_02);\n  Serial.println(\"CH02: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_03);\n  Serial.println(\"CH03: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_04);\n  Serial.println(\"CH04: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_05);\n  Serial.println(\"CH05: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_06);\n  Serial.println(\"CH06: \"+String(readings));\n\n  readings = digital_inputs.read(DIN_READ_CH_PIN_07);\n  Serial.println(\"CH07: \"+String(readings));\n\n  Serial.println();\n\n  delay(250);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  // The loop starts only when the Serial Monitor is opened.\n  while (!Serial);\n\n  //Set over current behavior of all channels to latch mode:\n  digital_outputs.setLatch();\n\n  // Uncomment this line to set over current behavior of all\n  // channels to auto retry mode instead of latch mode:\n  //digital_outputs.setRetry();\n  \n  //At startup set all channels to OPEN\n  digital_outputs.setAll(0);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"DIGITAL OUT:\");\n  \n  // Set all channels to CLOSED\n  digital_outputs.setAll(255);\n  Serial.print(\"All channels are CLOSED for 1 s...\");\n  delay(1000);\n  \n  // Set all channels to OPEN\n  digital_outputs.setAll(0);\n  Serial.println(\"now they are OPEN.\");\n  delay(1000);\n\n  // Toggle each channel for 1 s, one by one\n  \n  digital_outputs.set(0, HIGH);\n  Serial.print(\"CH0 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(0, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(1, HIGH);\n  Serial.print(\"CH1 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(1, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(2, HIGH);\n  Serial.print(\"CH2 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(2, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(3, HIGH);\n  Serial.print(\"CH3 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(3, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(4, HIGH);\n  Serial.print(\"CH4 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(4, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(5, HIGH);\n  Serial.print(\"CH5 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(5, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(6, HIGH);\n  Serial.print(\"CH6 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(6, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  digital_outputs.set(7, HIGH);\n  Serial.print(\"CH7 is CLOSED for 1 s...\");\n  delay(1000);\n  digital_outputs.set(7, LOW);\n  Serial.println(\"now is OPEN.\");\n\n  Serial.println();\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "key",
        "callback",
        "power",
        "wifi",
        "delay",
        "nodebug_websockets",
        "device_state",
        "deviceid"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "SinricPro_Generic.h",
        "SinricProDimSwitch.h"
      ],
      "functions": [
        {
          "name": "onPowerState",
          "parameters": "const String &deviceId, bool &state",
          "body": "Serial.printf(\"Device %s power turned %s \\r\\n\", deviceId.c_str(), state ? \"on\" : \"off\");\n  device_state.powerState = state;\n  return true; // request handled properly"
        },
        {
          "name": "onPowerLevel",
          "parameters": "const String &deviceId, int &powerLevel",
          "body": "device_state.powerLevel = powerLevel;\n  Serial.printf(\"Device %s power level changed to %d\\r\\n\", deviceId.c_str(), device_state.powerLevel);\n  return true;"
        },
        {
          "name": "onAdjustPowerLevel",
          "parameters": "const String &deviceId, int &levelDelta",
          "body": "device_state.powerLevel += levelDelta;\n  Serial.printf(\"Device %s power level changed about %i to %d\\r\\n\", deviceId.c_str(), levelDelta, device_state.powerLevel);\n  levelDelta = device_state.powerLevel;\n  return true;"
        },
        {
          "name": "setupWiFi",
          "parameters": "",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);\n  }\n  \n  Serial.print(\"\\n[WiFi]: IP-Address is \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "setupSinricPro",
          "parameters": "",
          "body": "SinricProDimSwitch &myDimSwitch = SinricPro[DIMSWITCH_ID];\n\n  // set callback function to device\n  myDimSwitch.onPowerState(onPowerState);\n  myDimSwitch.onPowerLevel(onPowerLevel);\n  myDimSwitch.onAdjustPowerLevel(onAdjustPowerLevel);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");\n  });\n  \n  SinricPro.onDisconnected([]() \n  {\n    Serial.println(\"Disconnected from SinricPro\");\n  });\n  \n  SinricPro.begin(APP_KEY, APP_SECRET);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting DimSwitch on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "SinricPro.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "stream",
        "current",
        "spi",
        "yield",
        "delay",
        "sd",
        "flash"
      ],
      "libraries": [
        "SdFat.h",
        "sdios.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();\n  }\n  delay(1000);\n  cout << F(\"Type any character to start\\n\");\n  while (!Serial.available()) {\n    yield();\n  }\n\n  // Initialize the SD card.\n  if (!sd.begin(SD_CONFIG)) {\n    sd.initErrorHalt(&Serial);\n  }\n  if (sd.exists(\"Folder1\")\n    || sd.exists(\"Folder1/file1.txt\")\n    || sd.exists(\"Folder1/File2.txt\")) {\n    error(\"Please remove existing Folder1, file1.txt, and File2.txt\");\n  }\n\n  int rootFileCount = 0;\n  if (!root.open(\"/\")) {\n    error(\"open root\");\n  }\n  while (file.openNext(&root, O_RDONLY)) {\n    if (!file.isHidden()) {\n      rootFileCount++;\n    }\n    file.close();\n    if (rootFileCount > 10) {\n      error(\"Too many files in root. Please use an empty SD.\");\n    }\n  }\n  if (rootFileCount) {\n    cout << F(\"\\nPlease use an empty SD for best results.\\n\\n\");\n    delay(1000);\n  }\n  // Create a new folder.\n  if (!sd.mkdir(\"Folder1\")) {\n    error(\"Create Folder1 failed\");\n  }\n  cout << F(\"Created Folder1\\n\");\n\n  // Create a file in Folder1 using a path.\n  if (!file.open(\"Folder1/file1.txt\", O_WRONLY | O_CREAT)) {\n    error(\"create Folder1/file1.txt failed\");\n  }\n  file.close();\n  cout << F(\"Created Folder1/file1.txt\\n\");\n\n  // Change volume working directory to Folder1.\n  if (!sd.chdir(\"Folder1\")) {\n    error(\"chdir failed for Folder1.\\n\");\n  }\n  cout << F(\"chdir to Folder1\\n\");\n\n  // Create File2.txt in current directory.\n  if (!file.open(\"File2.txt\", O_WRONLY | O_CREAT)) {\n    error(\"create File2.txt failed\");\n  }\n  file.close();\n  cout << F(\"Created File2.txt in current directory\\n\");\n\n  cout << F(\"\\nList of files on the SD.\\n\");\n  sd.ls(\"/\", LS_R);\n\n  // Remove files from current directory.\n  if (!sd.remove(\"file1.txt\") || !sd.remove(\"File2.txt\")) {\n    error(\"remove failed\");\n  }\n  cout << F(\"\\nfile1.txt and File2.txt removed.\\n\");\n\n  // Change current directory to root.\n  if (!sd.chdir()) {\n    error(\"chdir to root failed.\\n\");\n  }\n\n  cout << F(\"\\nList of files on the SD.\\n\");\n  sd.ls(LS_R);\n\n  // Remove Folder1.\n  if (!sd.rmdir(\"Folder1\")) {\n    error(\"rmdir for Folder1 failed\\n\");\n  }\n  cout << F(\"\\nFolder1 removed.\\n\");\n  cout << F(\"\\nList of files on the SD.\\n\");\n  sd.ls(LS_R);\n  cout << F(\"Done!\\n\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "callback",
        "spi",
        "dns",
        "delay",
        "html"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "EthernetUdp.h",
        "ArduinoMDNS.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// NOTE: Alternatively, you can assign a fixed IP to configure your\n//       Ethernet shield.\n//       Ethernet.begin(mac, ip);   \n  Ethernet.begin(mac); \n  \n  // Initialize the mDNS library. You can now reach or ping this\n  // Arduino via the host name \"arduino.local\", provided that your operating\n  // system is mDNS/Bonjour-enabled (such as macOS).\n  // Always call this before any other method!\n  mdns.begin(Ethernet.localIP(), \"arduino\");\n\n  // We specify the function that the mDNS library will call when it\n  // discovers a service instance. In this case, we will call the function\n  // named \"serviceFound\".\n  mdns.setServiceFoundCallback(serviceFound);\n\n  Serial.begin(9600);\n  Serial.println(\"Enter a mDNS service name via the Arduino Serial Monitor \"\n                 \"to discover instances\");\n  Serial.println(\"on the network.\");\n  Serial.println(\"Examples are \\\"_http\\\", \\\"_afpovertcp\\\" or \\\"_ssh\\\" (Note \"\n                 \"the underscores).\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "char serviceName[256];\n  int length = 0;\n  \n  // read in a service name from the Arduino IDE's Serial Monitor.\n  while (Serial.available()) {\n    serviceName[length] = Serial.read();\n    length = (length+1) % 256;\n    delay(5);\n  }\n  serviceName[length] = '\\0';\n  \n  // You can use the \"isDiscoveringService()\" function to find out whether the\n  // Bonjour library is currently discovering service instances.\n  // If so, we skip this input, since we want our previous request to continue.\n  if (!mdns.isDiscoveringService()) {\n    if (length > 0) {    \n      Serial.print(\"Discovering services of type '\");\n      Serial.print(serviceName);\n      Serial.println(\"' via Multi-Cast DNS (Bonjour)...\");\n\n      // Now we tell the mDNS library to discover the service. Below, I have\n      // hardcoded the TCP protocol, but you can also specify to discover UDP\n      // services.\n      // The last argument is a duration (in milliseconds) for which we will\n      // search (specify 0 to run the discovery indefinitely).\n      // Note that the library will resend the discovery message every 10\n      // seconds, so if you search for longer than that, you will receive\n      // duplicate instances.\n\n      mdns.startDiscoveringService(serviceName,\n                                    MDNSServiceTCP,\n                                    5000);\n    }  \n  }\n\n  // This actually runs the Bonjour module. YOU HAVE TO CALL THIS PERIODICALLY,\n  // OR NOTHING WILL WORK!\n  // Preferably, call it once per loop().\n  mdns.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay",
        "display",
        "lcd"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n  // Print a message to the LCD.\n  lcd.print(\"hello, world!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Turn off the display:\n  lcd.noDisplay();\n  delay(500);\n  // Turn on the display:\n  lcd.display();\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "buffer",
        "ina219",
        "power",
        "voltage",
        "current",
        "i2c",
        "delay",
        "display",
        "eeprom",
        "devices",
        "devicesfound"
      ],
      "libraries": [
        "Arduino.h",
        "WProgram.h",
        "INA.h",
        "avr/dtostrf.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "/*!\n   * @brief    Arduino method called once at startup to initialize the system\n   * @details  This is an Arduino IDE method which is called first upon boot or restart. It is only\n   *           called one time and then control goes to the \"loop()\" method, from which control\n   *           never returns. The serial port is initialized and the INA.begin() method called to\n   *           find all INA devices on the I2C bus and then the devices are initialized to given\n   *           conversion and averaging rates.\n   * @return   void\n   */\n  Serial.begin(SERIAL_SPEED);\n#ifdef __AVR_ATmega32U4__  // If a 32U4 processor, then wait 2 seconds to initialize\n  delay(2000);\n#endif\n  Serial.print(\"\\n\\nDisplay INA Readings V1.0.8\\n\");\n  Serial.print(\" - Searching & Initializing INA devices\\n\");\n  /************************************************************************************************\n  ** The INA.begin call initializes the device(s) found with an expected ±1 Amps maximum current **\n  ** and for a 0.1Ohm resistor, and since no specific device is given as the 3rd parameter all   **\n  ** devices are initially set to these values.                                                  **\n  ************************************************************************************************/\n  devicesFound = INA.begin(MAXIMUM_AMPS, SHUNT_MICRO_OHM);  // Expected max Amp & shunt resistance\n  while (devicesFound == 0) {\n    Serial.println(F(\"No INA device found, retrying in 10 seconds...\"));\n    delay(10000);                                             // Wait 10 seconds before retrying\n    devicesFound = INA.begin(MAXIMUM_AMPS, SHUNT_MICRO_OHM);  // Expected max Amp & shunt resistance\n  }                                                           // while no devices detected\n  Serial.print(F(\" - Detected \"));\n  Serial.print(devicesFound);\n  Serial.println(F(\" INA devices on the I2C bus\"));\n  INA.setBusConversion(8500);             // Maximum conversion time 8.244ms\n  INA.setShuntConversion(8500);           // Maximum conversion time 8.244ms\n  INA.setAveraging(128);                  // Average each reading n-times\n  INA.setMode(INA_MODE_CONTINUOUS_BOTH);  // Bus/shunt measured continuously\n  INA.alertOnBusOverVoltage(true, 5000);  // Trigger alert if over 5V on bus"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*!\n   * @brief    Arduino method for the main program loop\n   * @details  This is the main program for the Arduino IDE, it is an infinite loop and keeps on\n   * repeating. In order to format the output use is made of the \"sprintf()\" function, but in the\n   * Arduino implementation it has no support for floating point output, so the \"dtostrf()\" function\n   * is used to convert the floating point numbers into formatted strings.\n   * @return   void\n   */\n  static uint16_t loopCounter = 0;     // Count the number of iterations\n  static char     sprintfBuffer[100];  // Buffer to format output\n  static char     busChar[8], shuntChar[10], busMAChar[10], busMWChar[10];  // Output buffers\n\n  Serial.print(F(\"Nr Adr Type   Bus      Shunt       Bus         Bus\\n\"));\n  Serial.print(F(\"== === ====== ======== =========== =========== ===========\\n\"));\n  for (uint8_t i = 0; i < devicesFound; i++)  // Loop through all devices\n  {\n    dtostrf(INA.getBusMilliVolts(i) / 1000.0, 7, 4, busChar);      // Convert floating point to char\n    dtostrf(INA.getShuntMicroVolts(i) / 1000.0, 9, 4, shuntChar);  // Convert floating point to char\n    dtostrf(INA.getBusMicroAmps(i) / 1000.0, 9, 4, busMAChar);     // Convert floating point to char\n    dtostrf(INA.getBusMicroWatts(i) / 1000.0, 9, 4, busMWChar);    // Convert floating point to char\n    sprintf(sprintfBuffer, \"%2d %3d %s %sV %smV %smA %smW\\n\", i + 1, INA.getDeviceAddress(i),\n            INA.getDeviceName(i), busChar, shuntChar, busMAChar, busMWChar);\n    Serial.print(sprintfBuffer);\n  }  // for-next each INA device loop\n  Serial.println();\n  delay(10000);  // Wait 10 seconds before next reading\n  Serial.print(F(\"Loop iteration \"));\n  Serial.print(++loopCounter);\n  Serial.print(F(\"\\n\\n\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "delay",
        "display"
      ],
      "libraries": [
        "MicroGamer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "mg.boot();\n  mg.clear();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "mg.setCursor(0, 0);\n  if ( ! mg.doubleBuffer()) {\n    mg.println(\"Some text that\");\n    mg.println(\"glitches\");\n    mg.println(\"because double buffer\");\n    mg.println(\"is not enabled\");\n    mg.println(\"===============\"); \n  \n  } else {\n    mg.println(\"Some text that is now\");\n    mg.println(\"clean because\");\n    mg.println(\"double buffer is\");\n    mg.println(\"enabled\");\n    mg.println(\"===============\"); \n  }\n\n  mg.display();\n\n  delay(7 + rand() % 5);\n\n  // If double buffering is not enabled, the clear operation will modify the\n  // frame buffer while it is sent to the screen. This will create glitches.\n  // With double buffering enabled, drawing oprations will be preformed on\n  // buffer A while buffer B is sent to the screen, which means there will be\n  // no glitch.\n  mg.clear();\n\n  if (mg.pressed(Y_BUTTON)) {\n    mg.enableDoubleBuffer();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "token",
        "callback",
        "json",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "spiffs",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FS.h",
        "SPIFFS.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\r\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\r\n\r\n    Serial.print(\"Connecting to Wi-Fi\");\r\n    while (WiFi.status() != WL_CONNECTED)\r\n    {\r\n        Serial.print(\".\");\r\n        delay(300);\r\n    }\r\n    Serial.println();\r\n    Serial.print(\"Connected with IP: \");\r\n    Serial.println(WiFi.localIP());\r\n    Serial.println();\r\n\r\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\r\n\r\n    Serial.println(\"Initializing app...\");\r\n\r\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\r\n    ssl_client.setInsecure();\r\n#if defined(ESP8266)\r\n    ssl_client.setBufferSizes(4096, 1024);\r\n#endif\r\n#endif\r\n\r\n    initializeApp(aClient, app, getAuth(sa_auth), aResult_no_callback);\r\n\r\n    authHandler();\r\n\r\n    // Binding the FirebaseApp for authentication handler.\r\n    // To unbind, use cstorage.resetApp();\r\n    app.getApp<CloudStorage>(cstorage);\r\n\r\n    // In case setting the external async result to the sync task (optional)\r\n    // To unset, use unsetAsyncResult().\r\n    aClient.setAsyncResult(aResult_no_callback);\r\n\r\n#if defined(ENABLE_FS)\r\n    MY_FS.begin();\r\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\r\n\r\n    cstorage.loop();\r\n\r\n    if (app.ready() && !taskCompleted)\r\n    {\r\n        taskCompleted = true;\r\n\r\n        Serial.println(\"Download object...\");\r\n\r\n        GoogleCloudStorage::GetOptions options;\r\n\r\n#if defined(ENABLE_FS)\r\n\r\n#if defined(SHOW_PROGRESS)\r\n        cstorage.download(aClient, GoogleCloudStorage::Parent(STORAGE_BUCKET_ID, \"media.mp4\"), getFile(media_file), options, aResult_no_callback);\r\n\r\n        for (;;)\r\n        {\r\n            printResult(aResult_no_callback);\r\n            if (aResult_no_callback.downloadInfo().total == aResult_no_callback.downloadInfo().downloaded || aResult_no_callback.error().code() > 0)\r\n                break;\r\n        }\r\n#else\r\n        bool result = cstorage.download(aClient, GoogleCloudStorage::Parent(STORAGE_BUCKET_ID, \"media.mp4\"), getFile(media_file), options);\r\n\r\n        if (result)\r\n            Serial.println(\"Object downloaded.\");\r\n        else\r\n            printError(aClient.lastError().code(), aClient.lastError().message());\r\n#endif\r\n\r\n#endif\r\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\r\n    unsigned long ms = millis();\r\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\r\n    {\r\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\r\n        // JWT is a static object of JWTClass and it's not thread safe.\r\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\r\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\r\n        JWT.loop(app.getAuth());\r\n        printResult(aResult_no_callback);\r\n    }"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\r\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\r\n    {\r\n\r\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\r\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\r\n        {\r\n            delay(100);\r\n        }\r\n    }\r\n    ts = time(nullptr);\r\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\r\n    ts = WiFi.getTime();\r\n#endif"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\r\n    {\r\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\r\n    }\r\n\r\n    if (aResult.isDebug())\r\n    {\r\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\r\n    }\r\n\r\n    if (aResult.isError())\r\n    {\r\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\r\n    }\r\n\r\n    if (aResult.downloadProgress())\r\n    {\r\n        Firebase.printf(\"Downloaded, task: %s, %d%s (%d of %d)\\n\", aResult.uid().c_str(), aResult.downloadInfo().progress, \"%\", aResult.downloadInfo().downloaded, aResult.downloadInfo().total);\r\n        if (aResult.downloadInfo().total == aResult.downloadInfo().downloaded)\r\n        {\r\n            Firebase.printf(\"Download task: %s, completed!\", aResult.uid().c_str());\r\n        }\r\n    }\r\n\r\n    if (aResult.uploadProgress())\r\n    {\r\n        Firebase.printf(\"Uploaded, task: %s, %d%s (%d of %d)\\n\", aResult.uid().c_str(), aResult.uploadInfo().progress, \"%\", aResult.uploadInfo().uploaded, aResult.uploadInfo().total);\r\n        if (aResult.uploadInfo().total == aResult.uploadInfo().uploaded)\r\n        {\r\n            Firebase.printf(\"Upload task: %s, completed!\", aResult.uid().c_str());\r\n            Serial.print(\"Download URL: \");\r\n            Serial.println(aResult.uploadInfo().downloadUrl);\r\n        }\r\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        },
        {
          "name": "fileCallback",
          "parameters": "File &file, const char *filename, file_operating_mode mode",
          "body": "// FILE_OPEN_MODE_READ, FILE_OPEN_MODE_WRITE and FILE_OPEN_MODE_APPEND are defined in this library\r\n    // MY_FS is defined in this example\r\n    switch (mode)\r\n    {\r\n    case file_mode_open_read:\r\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_READ);\r\n        break;\r\n    case file_mode_open_write:\r\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_WRITE);\r\n        break;\r\n    case file_mode_open_append:\r\n        myFile = MY_FS.open(filename, FILE_OPEN_MODE_APPEND);\r\n        break;\r\n    case file_mode_remove:\r\n        MY_FS.remove(filename);\r\n        break;\r\n    default:\r\n        break;\r\n    }\r\n    // Set the internal FS object with global File object.\r\n    file = myFile;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "payload",
        "callback",
        "buffer",
        "database",
        "wifi",
        "delay",
        "esp.restart",
        "sd",
        "flash"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    // For the following credentials, see examples/Authentications/SignInAsUser/EmailPassword/EmailPassword.ino\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the user sign in credentials */\n    auth.user.email = USER_EMAIL;\n    auth.user.password = USER_PASSWORD;\n\n    /* Assign the RTDB URL (required) */\n    config.database_url = DATABASE_URL;\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    // For OTA file download in this example, the RX size will set to 16k during OTA file download and turns to\n    // the size that set by setBSSLBufferSize.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    // Or use legacy authenticate method\n    // config.database_url = DATABASE_URL;\n    // config.signer.tokens.legacy_token = \"<database secret>\";\n\n    // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n    Firebase.begin(&config, &auth);"
        },
        {
          "name": "rtdbDownloadCallback",
          "parameters": "RTDB_DownloadStatusInfo info",
          "body": "if (info.status == firebase_rtdb_download_status_init)\n    {\n        Serial.printf(\"Downloading firmware file %s (%d)\\n\", info.remotePath.c_str(), info.size);\n    }\n    else if (info.status == firebase_rtdb_download_status_download)\n    {\n        Serial.printf(\"Downloaded %d%s\\n\", (int)info.progress, \"%\");\n    }\n    else if (info.status == firebase_rtdb_download_status_complete)\n    {\n        Serial.println(\"Update firmware completed.\");\n        Serial.println();\n        Serial.println(\"Restarting...\\n\\n\");\n        delay(2000);\n        ESP.restart();\n    }\n    else if (info.status == firebase_rtdb_download_status_error)\n    {\n        Serial.printf(\"Download failed, %s\\n\", info.errorMsg.c_str());\n    }"
        },
        {
          "name": "rtdbUploadCallback",
          "parameters": "RTDB_UploadStatusInfo info",
          "body": "if (info.status == firebase_rtdb_upload_status_init)\n    {\n        Serial.printf(\"Uploading firmware file %s (%d) to %s\\n\", info.localFileName.c_str(), info.size, info.remotePath.c_str());\n    }\n    else if (info.status == firebase_rtdb_upload_status_upload)\n    {\n        Serial.printf(\"Uploaded %d%s\\n\", (int)info.progress, \"%\");\n    }\n    else if (info.status == firebase_rtdb_upload_status_complete)\n    {\n        Serial.println(\"Upload completed\\n\");\n    }\n    else if (info.status == firebase_rtdb_upload_status_error)\n    {\n        Serial.printf(\"Upload failed, %s\\n\", info.errorMsg.c_str());\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (Firebase.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        // Assume you use the following code to upload the firmware file stored on SD card to RTDB at path test/firmware/bin\n\n        /*\n        Serial.println(\"\\nUpload firmware to database...\\n\");\n        if (!Firebase.setFile(fbdo, StorageType::FLASH, \"test/firmware/bin\", \"<firmware.bin>\", rtdbUploadCallback))\n            Serial.println(fbdo.errorReason());\n        */\n\n        Serial.println(\"\\nDownload firmware file...\\n\");\n\n        // This function will allocate 16k+ memory for internal SSL client.\n        if (!Firebase.downloadOTA(fbdo, F(\"test/firmware/bin\"), rtdbDownloadCallback /* callback function */))\n            Serial.println(fbdo.errorReason());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "tft",
        "display"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "drawGrid",
          "parameters": "",
          "body": "randomValues_t v;\n  auto cv = v.constValues;\n\n  float theta = ( M_PI / 180.0f ) * 22.5; // angle\n  float sin0 = sinf(theta);\n  float cos0 = cosf(theta);\n  float sin1 = sinf(M_PI-theta);\n  float cos1 = cosf(M_PI-theta);\n\n  for( int32_t y=-tft.height()*2; y<tft.height()*2; y+=8 ) {\n    int32_t x0Pos = -tft.width();\n    int32_t y0Pos = tft.height()-y;\n    int32_t x1Pos = tft.width();\n    int32_t y1Pos = tft.height()-y;\n    float x0 = (x0Pos * cos0 - y0Pos * sin0)+cv.middleX;\n    float y0 = (y0Pos * cos0 + x0Pos * sin0)+cv.middleY;\n    float x1 = (x1Pos * cos0 - y1Pos * sin0)+cv.middleX;\n    float y1 = (y1Pos * cos0 + x1Pos * sin0)+cv.middleY;\n    tft.drawWideLine( x0, y0, x1, y1, 0.5f, heatMapGradient ); // gradient antialiased\n  }\n\n  for( int32_t x=-tft.width()*2; x<tft.width()*2; x+=8 ) {\n    int32_t x0Pos = tft.width()-x;\n    int32_t y0Pos = -tft.height();\n    int32_t x1Pos = tft.width()-x;\n    int32_t y1Pos = tft.height();\n    float x0 = (x0Pos * cos0 - y0Pos * sin0)+cv.middleX;\n    float y0 = (y0Pos * cos0 + x0Pos * sin0)+cv.middleY;\n    float x1 = (x1Pos * cos0 - y1Pos * sin0)+cv.middleX;\n    float y1 = (y1Pos * cos0 + x1Pos * sin0)+cv.middleY;\n    tft.drawWideLine( x0, y0, x1, y1, 0.5f, heatMapGradient ); // gradient antialiased\n  }\n\n  for( int32_t y=-tft.height()*2; y<tft.height()*2; y+=20 ) {\n    uint32_t color = y%100==0? 0xaaaaaau : 0xccccccu;\n    int32_t x0Pos = -tft.width();\n    int32_t y0Pos = tft.height()-y;\n    int32_t x1Pos = tft.width();\n    int32_t y1Pos = tft.height()-y;\n    float x0 = (x0Pos * cos1 - y0Pos * sin1)+cv.middleX;\n    float y0 = (y0Pos * cos1 + x0Pos * sin1)+cv.middleY;\n    float x1 = (x1Pos * cos1 - y1Pos * sin1)+cv.middleX;\n    float y1 = (y1Pos * cos1 + x1Pos * sin1)+cv.middleY;\n    y%100==0\n     ? tft.drawWideLine( x0, y0, x1, y1, 1.0f, color ) // slow but with thickness\n     : tft.drawSmoothLine( x0, y0, x1, y1, color ) // just antialiased\n    ;\n  }\n\n  for( int32_t x=-tft.width()*2; x<tft.width()*2; x+=20 ) {\n    uint32_t color = x%100==0? 0xaaaaaau : 0xccccccu;\n    int32_t x0Pos = tft.width()-x;\n    int32_t y0Pos = -tft.height();\n    int32_t x1Pos = tft.width()-x;\n    int32_t y1Pos = tft.height();\n    float x0 = (x0Pos * cos1 - y0Pos * sin1)+cv.middleX;\n    float y0 = (y0Pos * cos1 + x0Pos * sin1)+cv.middleY;\n    float x1 = (x1Pos * cos1 - y1Pos * sin1)+cv.middleX;\n    float y1 = (y1Pos * cos1 + x1Pos * sin1)+cv.middleY;\n    x%100==0\n     ? tft.drawWideLine( x0, y0, x1, y1, 1.0f, color ) // slow but with thickness\n     : tft.drawSmoothLine( x0, y0, x1, y1, color ) // just antialiased\n    ;\n  }"
        },
        {
          "name": "runRandomLinesDemo",
          "parameters": "",
          "body": "for( int i=0;i<256;i++) {\n    randomValues_t v;\n    switch( i++%5 ) {\n      case 0: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.gradient888 );  break;\n      case 1: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.colorstart );   break;\n      case 2: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.color24start ); break;\n      case 3: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.color16start ); break;\n      case 4: tft.drawWedgeLine( v.x0, v.y0, v.x1, v.y1, v.thickness0, v.thickness1, v.color8start );  break;\n    }\n  }"
        },
        {
          "name": "runGradientDemo",
          "parameters": "",
          "body": "drawGrid();\n\n  randomValues_t v;\n  auto cv = v.constValues;\n\n  const lgfx::rgb888_t colors888[] = { {0x00,0xff,0x00}, {0xff,0xff,0x00}, {0xff,0x80,0x00}, {0xff,0x00,0x00} };\n  auto gradient888 = tft.createGradient( colors888 );\n\n  // horizontal linear gradient in landscape mode (top left)\n  tft.fillGradientRect( cv.thick2, cv.thick2, cv.bw0, cv.bw1, heatMapGradient, lgfx::HLINEAR );\n  // vertical linear gradient in portrait mode (top right)\n  tft.fillGradientRect( tft.width()-(cv.bw1+cv.thick2+1), cv.thick2, cv.bw1, cv.bw0, heatMapGradient, lgfx::VLINEAR );\n\n  // horizontal linear grayscale gradient (top center)\n  tft.fillGradientRect( cv.middleX-(cv.bw0/2), cv.thick2, cv.bw0, cv.bw1/2, 0x000000u, 0xffffffu, lgfx::HLINEAR );\n  // horizontal linear inverted grayscale gradient (bottom center)\n  tft.fillGradientRect( cv.middleX-(cv.bw0/2), tft.height()-(1+cv.thick2+cv.bw1/2), cv.bw0, cv.bw1/2, 0xffffffu, 0x000000u, lgfx::HLINEAR );\n\n  // radial gradient in landscape mode (bottom left)\n  tft.fillGradientRect( cv.thick2, tft.height()-(1+cv.bw1+cv.thick2), cv.bw0, cv.bw1, heatMapGradient, lgfx::RADIAL );\n  // radial gradient in portrait mode (bottom right)\n  tft.fillGradientRect( tft.width()-(cv.bw1+cv.thick2+1), tft.height()-(1+cv.bw0+cv.thick2), cv.bw1, cv.bw0, heatMapGradient, lgfx::RADIAL );\n\n  // draw a big circle filled with default (rgb888) colored gradient\n  tft.drawGradientSpot( cv.middleX, cv.middleY, cv.r4, gradient888 );\n\n  int32_t last_x=-1, last_y=-1;\n  lgfx::rgb888_t last_color;\n\n  for( int i=0; i<360; i+=15 ) {\n    float a = i*deg2rad;\n\n    float s = sin(a);\n    float c = cos(a);\n\n    int32_t x0 = s*cv.r1 + cv.middleX;\n    int32_t y0 = c*cv.r1 + cv.middleY;\n    int32_t x1 = s*cv.r2 + cv.middleX;\n    int32_t y1 = c*cv.r2 + cv.middleY;\n\n    int32_t x2 = s*cv.r3 + cv.middleX;\n    int32_t y2 = c*cv.r3 + cv.middleY;\n\n    switch( (i/15)%8 ) {\n      case 0: tft.drawWedgeLine( x0, y0, x1, y1, cv.thick1, cv.thick3, heatMapGradient ); break;\n      case 1: tft.drawWedgeLine( x0, y0, x1, y1, cv.thick1, cv.thick3, gradient888 ); break;\n      case 2: tft.drawWedgeLine( x1, y1, x0, y0, cv.thick3, cv.thick1, gradient888 ); break;\n      case 3: tft.drawWedgeLine( x1, y1, x0, y0, cv.thick3, cv.thick1, heatMapGradient ); break;\n      case 4: tft.drawWedgeLine( x0, y0, x1, y1, cv.thick2, cv.thick3, 0xff0000u ); break; // red 24bits\n      case 5: tft.drawWedgeLine( x0, y0, x1, y1, cv.thick2, cv.thick3, (lgfx::rgb332_t)0x82 ); break; // purple 8bits\n      case 6: tft.drawWedgeLine( x0, y0, x1, y1, cv.thick2, cv.thick3, TFT_ORANGE ); break; // named colors default to 16bits rgb565_t\n      case 7: tft.drawWedgeLine( x0, y0, x1, y1, cv.thick2, cv.thick3, RGBColor{0x00,0xff,0x00} ); break; // green\n    }\n\n    auto _color = tft.mapGradient( i, 0, 359, heatMapGradient );\n    lgfx::rgb888_t color( _color.R8(), _color.G8(), _color.B8() );\n\n    if( last_x>=0 && last_y>=0 && (i/15)%2==1 ) {\n      lgfx::rgb888_t colorsRGB[] = { last_color, color };\n      auto gradientRGB = tft.createGradient( colorsRGB );\n      tft.drawWedgeLine( last_x, last_y, x2, y2, cv.thick1, cv.thick3, gradientRGB );\n    }\n    last_color = color;\n    last_x = x2;\n    last_y = y2;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "tft.init();\n  tft.fillScreen(TFT_WHITE);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "static bool toggler = true;\n  toggler = !toggler;\n  if( toggler ) {\n    runRandomLinesDemo();\n    vTaskDelay(1000);\n  } else {\n    runGradientDemo();\n    vTaskDelay(5000);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "i2c",
        "delay",
        "led"
      ],
      "libraries": [
        "KM1_I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "m1.led(1, 255, 0, 0); // Set LED color solid:red\n  m2.led(1, 0, 255, 0); // Set LED color solid:green\n  \n  m1.enable(); // Enable Motor Action\n  m2.enable();\n  m1.speedRpm(10);\n  m2.speedRpm(10);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "m1.moveByDistanceDegree(30);\n  m2.moveByDistanceDegree(-30);\n    \n  delay(3000);\n\n  m1.moveByDistanceDegree(-30);\n  m2.moveByDistanceDegree(30);\n  \n  delay(3000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initiate MIDI communications, listen to all channels\n    midiA.begin(MIDI_CHANNEL_OMNI);\n    midiB.begin(MIDI_CHANNEL_OMNI);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (midiA.read())\n    {\n        // Thru on A has already pushed the input message to out A.\n        // Forward the message to out B as well.\n        midiB.send(midiA.getType(),\n                   midiA.getData1(),\n                   midiA.getData2(),\n                   midiA.getChannel());\n    }\n\n    if (midiB.read())\n    {\n        // Thru on B has already pushed the input message to out B.\n        // Forward the message to out A as well.\n        midiA.send(midiB.getType(),\n                   midiB.getData1(),\n                   midiB.getData2(),\n                   midiB.getChannel());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "i2c",
        "delay",
        "analogread",
        "pid"
      ],
      "libraries": [
        "Adafruit_seesaw.h",
        "seesaw_neopixel.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  //while (!Serial) delay(10);   // wait until serial port is opened\n\n  Serial.println(F(\"Adafruit PID 5295 I2C QT Slide Potentiometer test!\"));\n\n  if (!seesaw1.begin(DEFAULT_I2C_ADDR) || !seesaw2.begin(DEFAULT_I2C_ADDR+1)) {\n    Serial.println(F(\"seesaws not found!\"));\n    while(1) delay(10);\n  }\n\n  uint16_t pid;\n  uint8_t year, mon, day;\n\n  seesaw1.getProdDatecode(&pid, &year, &mon, &day);\n  Serial.print(\"seesaw found PID: \");\n  Serial.print(pid);\n  Serial.print(\" datecode: \");\n  Serial.print(2000+year); Serial.print(\"/\");\n  Serial.print(mon); Serial.print(\"/\");\n  Serial.println(day);\n\n  if (pid != 5295) {\n    Serial.println(F(\"Wrong seesaw PID\"));\n    while (1) delay(10);\n  }\n\n  if (!pixels1.begin(DEFAULT_I2C_ADDR) || !pixels2.begin(DEFAULT_I2C_ADDR+1)){\n    Serial.println(\"seesaw pixels not found!\");\n    while(1) delay(10);\n  }\n\n  Serial.println(F(\"seesaw started OK!\"));\n\n  pixels1.setBrightness(255);  // half bright\n  pixels2.setBrightness(255);  // half bright\n  pixels1.show(); // Initialize all pixels to 'off'\n  pixels2.show(); // Initialize all pixels to 'off'"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the potentiometer\n  uint16_t slide1_val = seesaw1.analogRead(ANALOGIN);\n  uint16_t slide2_val = seesaw2.analogRead(ANALOGIN);\n  Serial.print(slide1_val);\n  Serial.print(\", \");\n  Serial.println(slide2_val);\n\n  for (uint8_t i=0; i< pixels1.numPixels(); i++) {\n    pixels1.setPixelColor(i, Wheel(slide1_val / 4));\n    pixels2.setPixelColor(i, Wheel(slide2_val / 4));\n  }\n  pixels1.show();\n  pixels2.show();\n\n  delay(50);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "token",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "onUpdateCallback",
          "parameters": "const char* oldIP, const char* newIP",
          "body": "Serial.print(F(\"DDNSGeneric - IP Change Detected: \"));\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "// For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif  // #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000)\n\n  Serial.print(\"\\nStart DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n#if DDNS_USING_WIFI_AT\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if (ESP8266 || ESP32)\n  WiFi.mode(WIFI_STA);\n  \n#elif USE_WIFI_NINA\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  }\n#elif (DDNS_USING_WIFI)\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  } \n#endif\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n  \n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n  \n#endif\n\n#if DDNS_USING_WIFI\n\n  WiFi.begin(ssid, password);\n  \n  Serial.println(\"Connecting to WiFi SSID: \" + String(ssid));\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(WiFi.localIP());\n  \n#elif (DDNS_USING_ETHERNET)\n\n  initEthernet();\n  \n#endif\n\n  server.begin();\n\n  DDNSGeneric.service(\"duckdns\");    // Enter your DDNS Service Name - \"duckdns\" / \"noip\"\n\n  /*\n    For DDNS Providers where you get a token:\n    DDNSGeneric.client(\"domain\", \"token\");\n\n    For DDNS Providers where you get username and password: ( Leave the password field empty \"\" if not required )\n    DDNSGeneric.client(\"domain\", \"username\", \"password\");\n  */\n  DDNSGeneric.client(\"account.duckdns.org\", \"12345678-1234-1234-1234-123456789012\");\n\n  DDNSGeneric.onUpdate(onUpdateCallback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "delay",
        "flash"
      ],
      "libraries": [
        "DueFlashStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  byte b1 = 3;\n  uint8_t b2 = 1;\n  dueFlashStorage.write(0,b1);\n  dueFlashStorage.write(1,b2);\n  //dueFlashStorage.write(2,b2);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read from flash at address 0 and 1 and print them\n  Serial.print(\"0:\");\n  Serial.print(dueFlashStorage.read(0));\n  Serial.print(\" 1:\");\n  Serial.print(dueFlashStorage.read(1));  \n  \n  // read from address 2, increment it, print and then write incremented value back to flash storage\n  uint8_t i = dueFlashStorage.read(2)+1;\n  Serial.print(\" 2:\");\n  Serial.print(dueFlashStorage.read(2)); \n  dueFlashStorage.write(2,i);\n  \n  Serial.println();\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "delay",
        "flash"
      ],
      "libraries": [
        "DueFlashStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(500);\n\n  /* Flash is erased every time new code is uploaded. Write the default configuration to flash if first time */\n  // running for the first time?\n  uint8_t codeRunningForTheFirstTime = dueFlashStorage.read(0); // flash bytes will be 255 at first run\n  Serial.print(\"codeRunningForTheFirstTime: \");\n  if (codeRunningForTheFirstTime) {\n    Serial.println(\"yes\");\n    /* OK first time running, set defaults */\n    configuration.a = 1;\n    configuration.b = 0;\n    configuration.bigInteger = 1147483647; // my lucky number\n    configuration.message = \"Hello world!\";\n    configuration.c = 's';\n\n    // write configuration struct to flash at adress 4\n    byte b2[sizeof(Configuration)]; // create byte array to store the struct\n    memcpy(b2, &configuration, sizeof(Configuration)); // copy the struct to the byte array\n    dueFlashStorage.write(4, b2, sizeof(Configuration)); // write byte array to flash\n\n    // write 0 to address 0 to indicate that it is not the first time running anymore\n    dueFlashStorage.write(0, 0); \n  }\n  else {\n    Serial.println(\"no\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* read configuration struct from flash */\n  byte* b = dueFlashStorage.readAddress(4); // byte array which is read from flash at adress 4\n  Configuration configurationFromFlash; // create a temporary struct\n  memcpy(&configurationFromFlash, b, sizeof(Configuration)); // copy byte array to temporary struct\n\n  // print the content\n  Serial.print(\"a:\");\n  Serial.print(configurationFromFlash.a);\n\n  Serial.print(\" b:\");\n  Serial.print(configurationFromFlash.b);\n\n  Serial.print(\" bigInteger:\");\n  Serial.print(configurationFromFlash.bigInteger);\n\n  Serial.print(\" message:\");\n  Serial.print(configurationFromFlash.message);\n\n  Serial.print(\" c:\");\n  Serial.print(configurationFromFlash.c);\n  Serial.println();\n  Serial.println();\n\n  /* change some values in the struct and write them back */\n  // increment b by 1 (modulus 100 to start over at 0 when 100 is reached)\n  configurationFromFlash.b = (configurationFromFlash.b+1) % 100;\n\n  // change the message\n  String message = configurationFromFlash.message;\n  if (configurationFromFlash.message == \"Hello world!\")\n    configurationFromFlash.message = \"Hello Arduino Due!\";\n  else\n    configurationFromFlash.message = \"Hello world!\";\n\n  // write configuration struct to flash at adress 4\n  byte b2[sizeof(Configuration)]; // create byte array to store the struct\n  memcpy(b2, &configurationFromFlash, sizeof(Configuration)); // copy the struct to the byte array\n  dueFlashStorage.write(4, b2, sizeof(Configuration)); // write byte array to flash\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "current",
        "delay",
        "millis",
        "yield",
        "led",
        "display",
        "timestamp"
      ],
      "libraries": [
        "Arduino.h",
        "IRsend.h",
        "IRrecv.h",
        "IRremoteESP8266.h",
        "IRutils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "irrecv.enableIRIn();  // Start up the IR receiver.\n  irsend.begin();       // Start up the IR sender.\n\n  Serial.begin(kBaudRate, SERIAL_8N1);\n  while (!Serial)  // Wait for the serial connection to be establised.\n    delay(50);\n  Serial.println();\n\n  Serial.print(\"DumbIRRepeater is now running and waiting for IR input \"\n               \"on Pin \");\n  Serial.println(kRecvPin);\n  Serial.print(\"and will retransmit it on Pin \");\n  Serial.println(kIrLedPin);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check if an IR message has been received.\n  if (irrecv.decode(&results)) {  // We have captured something.\n    // The capture has stopped at this point.\n\n    // Convert the results into an array suitable for sendRaw().\n    // resultToRawArray() allocates the memory we need for the array.\n    uint16_t *raw_array = resultToRawArray(&results);\n    // Find out how many elements are in the array.\n    uint16_t length = getCorrectedRawLength(&results);\n    // Send it out via the IR LED circuit.\n    irsend.sendRaw(raw_array, length, kFrequency);\n    // Resume capturing IR messages. It was not restarted until after we sent\n    // the message so we didn't capture our own message.\n    irrecv.resume();\n    // Deallocate the memory allocated by resultToRawArray().\n    delete [] raw_array;\n\n    // Display a crude timestamp & notification.\n    uint32_t now = millis();\n    Serial.printf(\n        \"%06u.%03u: A message that was %d entries long was retransmitted.\\n\",\n        now / 1000, now % 1000, length);\n  }\n  yield();  // Or delay(milliseconds); This ensures the ESP doesn't WDT reset."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "lora",
        "spi",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "LoRa.h",
        "MKRWAN.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  // No need to call modem.dumb() with arduino-LoRa >= 0.5.0\n  //modem.dumb();\n\n  Serial.println(\"LoRa Sender\");\n\n  // Configure LoRa module to transmit and receive at 915 MHz (915*10^6) \n  // Replace 915E6 with the frequency you need (eg. 433E6 for 433 MHz)\n  if (!LoRa.begin(915E6)) {\n    Serial.println(\"Starting LoRa failed!\");\n    while (1);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"Sending packet: \");\n  Serial.println(counter);\n\n  // send packet\n  LoRa.beginPacket();\n  LoRa.print(\"hello \");\n  LoRa.print(counter);\n  LoRa.endPacket();\n\n  counter++;\n\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "sd"
      ],
      "libraries": [
        "SD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  // wait for Serial Monitor to connect. Needed for native USB port boards only:\n  while (!Serial);\n\n  Serial.print(\"Initializing SD card...\");\n\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"initialization failed. Things to check:\");\n    Serial.println(\"1. is a card inserted?\");\n    Serial.println(\"2. is your wiring correct?\");\n    Serial.println(\"3. did you change the chipSelect pin to match your shield or module?\");\n    Serial.println(\"Note: press reset button on the board and reopen this Serial Monitor after fixing your issue!\");\n    while (true);\n  }\n\n  Serial.println(\"initialization done.\");\n\n  // open the file. note that only one file can be open at a time,\n  // so you have to close this one before opening another.\n  File dataFile = SD.open(\"datalog.txt\");\n\n  // if the file is available, write to it:\n  if (dataFile) {\n    while (dataFile.available()) {\n      Serial.write(dataFile.read());\n    }\n    dataFile.close();\n  }\n  // if the file isn't open, pop up an error:\n  else {\n    Serial.println(\"error opening datalog.txt\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "buffer",
        "power",
        "spi",
        "display",
        "interrupt"
      ],
      "libraries": [
        "MAX3100Serial.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "serialEvent",
          "parameters": "",
          "body": "internal = true;"
        },
        {
          "name": "max3100_irq",
          "parameters": "",
          "body": "detachInterrupt(0);\n  external = true;"
        },
        {
          "name": "setup",
          "parameters": "void",
          "body": "// Arduino USART setup.\n  Serial.begin(internalBaud);\n\n  // Display USART header on Arduino.\n  Serial.println();\n  Serial.println(\"Maxim Integrated MAX3100 testing.\");\n  Serial.println(\"(C) 2016 Ewan Parker.\");\n  Serial.print(\">>> Internal Arduino USART :: \");\n  Serial.print(internalBaud); Serial.println(\" bps <<<\");\n  Serial.println();\n\n  // MAX3100 USART setup.\n  serial2.begin(externalBaud);\n  // Disable MAX3100 interrupt processing while in SPI communications.\n  SPI.usingInterrupt(0);\n  // Attach an interrupt so we know when we have received input from the\n  // external USART.  Without this we would need to continually poll to see if\n  // a byte was available.\n  attachInterrupt(0, max3100_irq, LOW);\n\n  // Display USART header on MAX3100.\n  serial2.println(\"Maxim Integrated MAX3100 testing.\");\n  serial2.println(\"(C) 2016 Ewan Parker.\");\n  serial2.print(\">>> External MAX3100CPD USART :: \");\n  serial2.print(externalBaud); serial2.println(\" bps <<<\");\n  serial2.println();"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "// Incoming character from the Arduino's USART.\n  if (internal)\n  {\n    internal = false;\n    char c = Serial.read(); // Read the character from the Arduino\n    serial2.write(c);       // and write it to the MAX3100\n  }\n\n  // Incoming character from the MAX3100's USART.\n  if (external)\n  {\n    external = false;\n    if (serial2.available())        // If there is a character from the MAX3100\n      Serial.write(serial2.read()); // write it to the Arduino\n    attachInterrupt(0, max3100_irq, LOW); // Check for further serial input\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "wificlient",
        "https",
        "ssl",
        "parse",
        "wifi",
        "millis",
        "delay",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting DweetGet on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);\n  }\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n\n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n\n#endif\n\n#endif\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  // you're connected now, so print out the data\n  printWifiStatus();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// send the GET request\n  Serial.println(\"Making GET request\");\n  httpClient.get(path);\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  /*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456}}]}\n\n    You want \"content\": numberValue\n  */\n  // now parse the response looking for \"content\":\n  int labelStart = response.indexOf(\"content\\\":\");\n\n  // find the first { after \"content\":\n  int contentStart = response.indexOf(\"{\", labelStart);\n\n  // find the following } and get what's between the braces:\n  int contentEnd = response.indexOf(\"}\", labelStart);\n\n  String content = response.substring(contentStart + 1, contentEnd);\n  Serial.println(content);\n\n  // now get the value after the colon, and convert to an int:\n  int valueStart      = content.indexOf(\":\");\n  String valueString  = content.substring(valueStart + 1);\n  int number          = valueString.toInt();\n\n  Serial.print(\"Value string: \");\n  Serial.println(valueString);\n  Serial.print(\"Actual value: \");\n  Serial.println(number);\n\n  Serial.println(\"Wait ten seconds\\n\");\n  delay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "ssl",
        "parse",
        "delay",
        "millis",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n  \n  Serial.print(\"\\nStarting DweetGet_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// assemble the path for the GET message:\n  String path = \"/get/latest/dweet/for/\" + dweetName;\n\n  // send the GET request\n  Serial.println(\"Making GET request\");\n  httpClient.get(path);\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  /*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456}}]}\n\n    You want \"content\": numberValue\n  */\n  // now parse the response looking for \"content\":\n  int labelStart = response.indexOf(\"content\\\":\");\n  // find the first { after \"content\":\n  int contentStart = response.indexOf(\"{\", labelStart);\n  // find the following } and get what's between the braces:\n  int contentEnd = response.indexOf(\"}\", labelStart);\n  String content = response.substring(contentStart + 1, contentEnd);\n  Serial.println(content);\n\n  // now get the value after the colon, and convert to an int:\n  int valueStart = content.indexOf(\":\");\n  String valueString = content.substring(valueStart + 1);\n  int number = valueString.toInt();\n  Serial.print(\"Value string: \");\n  Serial.println(valueString);\n  Serial.print(\"Actual value: \");\n  Serial.println(number);\n\n  Serial.println(\"Wait ten seconds\\n\");\n  delay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "wificlient",
        "https",
        "parse",
        "json",
        "wifi",
        "millis",
        "delay",
        "analogread",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting DweetPost on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);\n  }\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n\n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n\n#endif\n\n#endif\n\n  Serial.print(F(\"Connecting to SSID: \"));\n  Serial.println(ssid);\n\n  status = WiFi.begin(ssid, pass);\n\n  delay(1000);\n\n  // attempt to connect to WiFi network\n  while ( status != WL_CONNECTED)\n  {\n    delay(500);\n\n    // Connect to WPA/WPA2 network\n    status = WiFi.status();\n  }\n\n  // you're connected now, so print out the data\n  printWifiStatus();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// assemble the body of the POST message:\n  int sensorValue = analogRead(A0);\n\n  String postData = \"{\\\"sensorValue\\\":\\\"\";\n  postData += sensorValue;\n  postData += \"\\\"}\";\n\n  Serial.println(\"making POST request\");\n\n  // send the POST request\n  httpClient.post(path, contentType, postData);\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait ten seconds\\n\");\n  delay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "parse",
        "json",
        "delay",
        "millis",
        "analogread",
        "sensorvalue"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStarting DweetPost_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// assemble the path for the POST message:\n  String dweetName = \"scandalous-cheese-hoarder\";\n  String path = \"/dweet/for/\" + dweetName;\n  String contentType = \"application/json\";\n\n  // assemble the body of the POST message:\n  int sensorValue = analogRead(A0);\n  String postData = \"{\\\"sensorValue\\\":\\\"\"; \n  postData += sensorValue;\n  postData += \"\\\"}\";\n\n  Serial.println(\"making POST request\");\n\n  // send the POST request\n  httpClient.post(path, contentType, postData);\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait ten seconds\\n\");\n  delay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "key",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "onUpdateCallback",
          "parameters": "const char* oldIP, const char* newIP",
          "body": "Serial.print(F(\"DDNSGeneric - IP Change Detected: \"));\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "// For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif  // #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000)\n\n  Serial.print(\"\\nStart DynDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n#if DDNS_USING_WIFI_AT\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if (ESP8266 || ESP32)\n  WiFi.mode(WIFI_STA);\n  \n#elif USE_WIFI_NINA\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  }\n#elif (DDNS_USING_WIFI)\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  } \n#endif\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n  \n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(F(\"Please upgrade the firmware\"));\n  }\n  \n#endif\n\n#if DDNS_USING_WIFI\n\n  WiFi.begin(ssid, password);\n  \n  Serial.println(\"Connecting to WiFi SSID: \" + String(ssid));\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(WiFi.localIP());\n  \n#elif (DDNS_USING_ETHERNET)\n\n  initEthernet();\n  \n#endif\n\n  server.begin();\n\n  DDNSGeneric.service(\"dyndns\");\n\n  DDNSGeneric.client(\"hostname\",\"username\",\"client-key\");    // Enter ddns Hostname - Username - Client-key"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "i2c",
        "delay",
        "digitalwrite",
        "millis",
        "digitalread",
        "led",
        "flash"
      ],
      "libraries": [
        "ctype.h",
        "Keypad.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    pinMode(ledPin, OUTPUT);\n    digitalWrite(ledPin, LOW);                 // Turns the LED on.\n    ltrpad.begin( makeKeymap(alphaKeys) );\n    numpad.begin( makeKeymap(numberKeys) );\n    ltrpad.addEventListener(keypadEvent_ltr);  // Add an event listener.\n    ltrpad.setHoldTime(500);                   // Default is 1000mS\n    numpad.addEventListener(keypadEvent_num);  // Add an event listener.\n    numpad.setHoldTime(500);                   // Default is 1000mS"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if( alpha )\n        key = ltrpad.getKey( );\n    else\n        key = numpad.getKey( );\n\n    if (alpha && millis()-startTime>100) {           // Flash the LED if we are using the letter keymap.\n        digitalWrite(ledPin,!digitalRead(ledPin));\n        startTime = millis();\n    }"
        },
        {
          "name": "keypadEvent_ltr",
          "parameters": "KeypadEvent key",
          "body": "// in here when in alpha mode.\n    kpadState = ltrpad.getState( );\n    swOnState( key );"
        },
        {
          "name": "keypadEvent_num",
          "parameters": "KeypadEvent key",
          "body": "// in here when using number keypad\n    kpadState = numpad.getState( );\n    swOnState( key );"
        },
        {
          "name": "swOnState",
          "parameters": "char key",
          "body": "switch( kpadState ) {\n        case PRESSED:\n            if (isalpha(key)) {              // This is a letter key so we're using the letter keymap.\n                if (physKey != key) {        // New key so start with the first of 3 characters.\n                    pressCount = 0;\n                    virtKey = key;\n                    physKey = key;\n                }\n                else {                       // Pressed the same key again...\n                    virtKey++;                   // so select the next character on that key.\n                    pressCount++;                // Tracks how many times we press the same key.\n                }\n                    if (pressCount > 2) {    // Last character reached so cycle back to start.\n                        pressCount = 0;\n                        virtKey = key;\n                    }\n                    Serial.print(virtKey);   // Used for testing.\n                }\n                if (isdigit(key) || key == ' ' || key == '.')\n                    Serial.print(key);\n                if (key == '#')\n                    Serial.println();\n                break;\n\n        case HOLD:\n            if (key == '#')  {               // Toggle between keymaps.\n                if (alpha == true)  {        // We are currently using a keymap with letters\n                    alpha = false;           // Now we want a keymap with numbers.\n                    digitalWrite(ledPin, LOW);\n                }\n                else  {                      // We are currently using a keymap with numbers\n                    alpha = true;            // Now we want a keymap with letters.\n                }\n            }\n            else  {                          // Some key other than '#' was pressed.\n                buildStr[buildCount++] = (isalpha(key)) ? virtKey : key;\n                buildStr[buildCount] = '\\0';\n                Serial.println();\n                Serial.println(buildStr);\n            }\n            break;\n\n        case RELEASED:\n            if (buildCount >= sizeof(buildStr))  buildCount = 0;  // Our string is full. Start fresh.\n            break;\n    }  // end switch-case"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "https",
        "password",
        "key",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "onUpdateCallback",
          "parameters": "const char* oldIP, const char* newIP",
          "body": "Serial.print(\"DDNSGeneric - IP Change Detected: \");\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "// For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif  // #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000)\n\n  Serial.print(\"\\nStart Dynu_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n#if DDNS_USING_WIFI_AT\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if (ESP8266 || ESP32)\n  WiFi.mode(WIFI_STA);\n  \n#elif USE_WIFI_NINA\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  }\n#elif (DDNS_USING_WIFI)\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);\n  } \n#endif\n\n#if USE_WIFI_NINA\n  String fv = WiFi.firmwareVersion();\n  \n  if (fv < WIFI_FIRMWARE_LATEST_VERSION)\n  {\n    Serial.println(\"Please upgrade the firmware\");\n  }\n  \n#endif\n\n#if DDNS_USING_WIFI\n\n  WiFi.begin(ssid, password);\n  \n  Serial.println(\"Connecting to WiFi SSID: \" + String(ssid));\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(WiFi.localIP());\n  \n#elif (DDNS_USING_ETHERNET)\n\n  initEthernet();\n  \n#endif\n\n  server.begin();\n\n  DDNSGeneric.service(\"dynu\");\n\n  DDNSGeneric.client(\"hostname\",\"username\",\"password\");    // Enter ddns Hostname - Username - Client-key"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "certificate",
        "key",
        "tls"
      ],
      "libraries": [
        "ArduinoECCX08.h",
        "utility/ECCX08CSR.h",
        "utility/ECCX08DefaultTLSConfig.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  String serialNumber = ECCX08.serialNumber();\n\n  Serial.print(\"ECCX08 Serial Number = \");\n  Serial.println(serialNumber);\n  Serial.println();\n\n  if (!ECCX08.locked()) {\n    String lock = promptAndReadLine(\"The ECCX08 on your board is not locked, would you like to PERMANENTLY configure and lock it now? (y/N)\", \"N\");\n    lock.toLowerCase();\n\n    if (!lock.startsWith(\"y\")) {\n      Serial.println(\"Unfortunately you can't proceed without locking it :(\");\n      while (1);\n    }\n\n    if (!ECCX08.writeConfiguration(ECCX08_DEFAULT_TLS_CONFIG)) {\n      Serial.println(\"Writing ECCX08 configuration failed!\");\n      while (1);\n    }\n\n    if (!ECCX08.lock()) {\n      Serial.println(\"Locking ECCX08 configuration failed!\");\n      while (1);\n    }\n\n    Serial.println(\"ECCX08 locked successfully\");\n    Serial.println();\n  }\n\n  Serial.println(\"Hi there, in order to generate a new CSR for your board, we'll need the following information ...\");\n  Serial.println();\n\n  String country            = promptAndReadLine(\"Country Name (2 letter code)\", \"\");\n  String stateOrProvince    = promptAndReadLine(\"State or Province Name (full name)\", \"\");\n  String locality           = promptAndReadLine(\"Locality Name (eg, city)\", \"\");\n  String organization       = promptAndReadLine(\"Organization Name (eg, company)\", \"\");\n  String organizationalUnit = promptAndReadLine(\"Organizational Unit Name (eg, section)\", \"\");\n  String common             = promptAndReadLine(\"Common Name (e.g. server FQDN or YOUR name)\", serialNumber.c_str());\n  String slot               = promptAndReadLine(\"What slot would you like to use? (0 - 4)\", \"0\");\n  String generateNewKey     = promptAndReadLine(\"Would you like to generate a new private key? (Y/n)\", \"Y\");\n\n  Serial.println();\n\n  generateNewKey.toLowerCase();\n\n  if (!ECCX08CSR.begin(slot.toInt(), generateNewKey.startsWith(\"y\"))) {\n    Serial.println(\"Error starting CSR generation!\");\n    while (1);\n  }\n\n  ECCX08CSR.setCountryName(country);\n  ECCX08CSR.setStateProvinceName(stateOrProvince);\n  ECCX08CSR.setLocalityName(locality);\n  ECCX08CSR.setOrganizationName(organization);\n  ECCX08CSR.setOrganizationalUnitName(organizationalUnit);\n  ECCX08CSR.setCommonName(common);\n\n  String csr = ECCX08CSR.end();\n\n  if (!csr) {\n    Serial.println(\"Error generating CSR!\");\n    while (1);\n  }\n\n  Serial.println(\"Here's your CSR, enjoy!\");\n  Serial.println();\n  Serial.println(csr);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        },
        {
          "name": "promptAndReadLine",
          "parameters": "const char* prompt, const char* defaultValue",
          "body": "Serial.print(prompt);\n  Serial.print(\" [\");\n  Serial.print(defaultValue);\n  Serial.print(\"]: \");\n\n  String s = readLine();\n\n  if (s.length() == 0) {\n    s = defaultValue;\n  }\n\n  Serial.println(s);\n\n  return s;"
        },
        {
          "name": "readLine",
          "parameters": "",
          "body": "String line;\n\n  while (1) {\n    if (Serial.available()) {\n      char c = Serial.read();\n\n      if (c == '\\r') {\n        // ignore\n        continue;\n      } else if (c == '\\n') {\n        break;\n      }\n\n      line += c;\n    }\n  }\n\n  return line;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"Failed to communicate with ECC508/ECC608!\");\n    while (1);\n  }\n  \n  if (!ECCX08.incrementCounter(keyId, counter)) {\n    Serial.println(\"Failed to increment counter\");\n    while (1);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (!ECCX08.readCounter(keyId, counter)) {\n    Serial.println(\"Failed to read counter\");\n    while (1);\n  }\n\n  Serial.print(\"Counter value = \");\n  Serial.println(counter);\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    while (!Serial);\n\n    if (!ECCX08.begin()) {\n        Serial.println(\"Failed to initialize ECCX08 board.\");\n        while (1);\n    }\n\n    // Perform nonce\n    if (!ECCX08.nonce(nonceKey))\n    {\n        Serial.println(\"Failed to perform nonce.\");\n        while (1);\n    }\n\n    // Starting HMAC operation on tempkey slot\n    if (!ECCX08.beginHMAC(TEMPKEY_SLOT)) {\n        Serial.println(\"Failed to start HMAC operation.\");\n        while (1);\n    }\n\n    if (!ECCX08.updateHMAC(data, dataLength)) {\n        Serial.println(\"Failed to update HMAC operation.\");\n        while (1);\n    }\n\n    byte resultHMAC[32];\n    if (!ECCX08.endHMAC(resultHMAC)) {\n        Serial.println(\"Failed to end HMAC operation\");\n        while (1);\n    }\n\n    Serial.println(\"HMAC Result: \");\n    for (int i = 0; i < sizeof(resultHMAC); i++) {\n        char hexChar[2];\n        sprintf(hexChar, \"%02X\", resultHMAC[i]);\n        Serial.print(hexChar);\n        Serial.print(\" \");\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "tls"
      ],
      "libraries": [
        "ArduinoECCX08.h",
        "utility/ECCX08JWS.h",
        "utility/ECCX08DefaultTLSConfig.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  if (!ECCX08.locked()) {\n    String lock = promptAndReadLine(\"The ECCX08 on your board is not locked, would you like to PERMANENTLY configure and lock it now? (y/N)\", \"N\");\n    lock.toLowerCase();\n\n    if (!lock.startsWith(\"y\")) {\n      Serial.println(\"Unfortunately you can't proceed without locking it :(\");\n      while (1);\n    }\n\n    if (!ECCX08.writeConfiguration(ECCX08_DEFAULT_TLS_CONFIG)) {\n      Serial.println(\"Writing ECCX08 configuration failed!\");\n      while (1);\n    }\n\n    if (!ECCX08.lock()) {\n      Serial.println(\"Locking ECCX08 configuration failed!\");\n      while (1);\n    }\n\n    Serial.println(\"ECCX08 locked successfully\");\n    Serial.println();\n  }\n\n  Serial.println(\"Hi there, in order to generate a PEM public key for your board, we'll need the following information ...\");\n  Serial.println();\n\n  String slot               = promptAndReadLine(\"What slot would you like to use? (0 - 4)\", \"0\");\n  String generateNewKey     = promptAndReadLine(\"Would you like to generate a new private key? (Y/n)\", \"Y\");\n\n  Serial.println();\n\n  generateNewKey.toLowerCase();\n\n  String publicKeyPem = ECCX08JWS.publicKey(slot.toInt(), generateNewKey.startsWith(\"y\"));\n\n  if (!publicKeyPem || publicKeyPem == \"\") {\n    Serial.println(\"Error generating public key!\");\n    while (1);\n  }\n\n  Serial.println(\"Here's your public key PEM, enjoy!\");\n  Serial.println();\n  Serial.println(publicKeyPem);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        },
        {
          "name": "promptAndReadLine",
          "parameters": "const char* prompt, const char* defaultValue",
          "body": "Serial.print(prompt);\n  Serial.print(\" [\");\n  Serial.print(defaultValue);\n  Serial.print(\"]: \");\n\n  String s = readLine();\n\n  if (s.length() == 0) {\n    s = defaultValue;\n  }\n\n  Serial.println(s);\n\n  return s;"
        },
        {
          "name": "readLine",
          "parameters": "",
          "body": "String line;\n\n  while (1) {\n    if (Serial.available()) {\n      char c = Serial.read();\n\n      if (c == '\\r') {\n        // ignore\n        continue;\n      } else if (c == '\\n') {\n        break;\n      }\n\n      line += c;\n    }\n  }\n\n  return line;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"Failed to communicate with ECC508/ECC608!\");\n    while (1);\n  }\n\n  if (!ECCX08.locked()) {\n    Serial.println(\"The ECC508/ECC608 is not locked!\");\n    while (1);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"Random number = \");\n  Serial.println(ECCX08.random(65535));\n\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "certificate",
        "key",
        "tls"
      ],
      "libraries": [
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "utility/ECCX08DefaultTLSConfig.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);\n  }\n\n  String serialNumber = ECCX08.serialNumber();\n\n  Serial.print(\"ECCX08 Serial Number = \");\n  Serial.println(serialNumber);\n  Serial.println();\n\n  if (!ECCX08.locked()) {\n    String lock = promptAndReadLine(\"The ECCX08 on your board is not locked, would you like to PERMANENTLY configure and lock it now? (y/N)\", \"N\");\n    lock.toLowerCase();\n\n    if (!lock.startsWith(\"y\")) {\n      Serial.println(\"Unfortunately you can't proceed without locking it :(\");\n      while (1);\n    }\n\n    if (!ECCX08.writeConfiguration(ECCX08_DEFAULT_TLS_CONFIG)) {\n      Serial.println(\"Writing ECCX08 configuration failed!\");\n      while (1);\n    }\n\n    if (!ECCX08.lock()) {\n      Serial.println(\"Locking ECCX08 configuration failed!\");\n      while (1);\n    }\n\n    Serial.println(\"ECCX08 locked successfully\");\n    Serial.println();\n  }\n\n  Serial.println(\"Hi there, in order to generate a new self signed cert for your board, we'll need the following information ...\");\n  Serial.println();\n\n  String issueYear          = promptAndReadLine(\"Please enter the issue year of the certificate? (2000 - 2031)\", \"2019\");\n  String issueMonth         = promptAndReadLine(\"Please enter the issue month of the certificate? (1 - 12)\", \"1\");\n  String issueDay           = promptAndReadLine(\"Please enter the issue day of the certificate? (1 - 31)\", \"1\");\n  String issueHour          = promptAndReadLine(\"Please enter the issue hour of the certificate? (0 - 23)\", \"0\");\n  String expireYears        = promptAndReadLine(\"Please enter how many years the certificate is valid for? (1 - 31)\", \"31\");\n  String privateKeySlot     = promptAndReadLine(\"What slot would you like to use for the private key? (0 - 4)\", \"0\");\n  String storageSlot        = promptAndReadLine(\"What slot would you like to use for storage? (8 - 15)\", \"8\");\n  String generateNewKey     = promptAndReadLine(\"Would you like to generate a new private key? (Y/n)\", \"Y\");\n\n  Serial.println();\n\n  generateNewKey.toLowerCase();\n\n  if (!ECCX08SelfSignedCert.beginStorage(privateKeySlot.toInt(), storageSlot.toInt(), generateNewKey.startsWith(\"y\"))) {\n    Serial.println(\"Error starting self signed cert generation!\");\n    while (1);\n  }\n\n  ECCX08SelfSignedCert.setCommonName(ECCX08.serialNumber());\n  ECCX08SelfSignedCert.setIssueYear(issueYear.toInt());\n  ECCX08SelfSignedCert.setIssueMonth(issueMonth.toInt());\n  ECCX08SelfSignedCert.setIssueDay(issueDay.toInt());\n  ECCX08SelfSignedCert.setIssueHour(issueHour.toInt());\n  ECCX08SelfSignedCert.setExpireYears(expireYears.toInt());\n\n  String cert = ECCX08SelfSignedCert.endStorage();\n\n  if (!cert) {\n    Serial.println(\"Error generating self signed cert!\");\n    while (1);\n  }\n\n  Serial.println(\"Here's your self signed cert, enjoy!\");\n  Serial.println();\n  Serial.println(cert);\n  Serial.println();\n\n  Serial.print(\"SHA1: \");\n  Serial.println(ECCX08SelfSignedCert.sha1());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        },
        {
          "name": "promptAndReadLine",
          "parameters": "const char* prompt, const char* defaultValue",
          "body": "Serial.print(prompt);\n  Serial.print(\" [\");\n  Serial.print(defaultValue);\n  Serial.print(\"]: \");\n\n  String s = readLine();\n\n  if (s.length() == 0) {\n    s = defaultValue;\n  }\n\n  Serial.println(s);\n\n  return s;"
        },
        {
          "name": "readLine",
          "parameters": "",
          "body": "String line;\n\n  while (1) {\n    if (Serial.available()) {\n      char c = Serial.read();\n\n      if (c == '\\r') {\n        // ignore\n        continue;\n      } else if (c == '\\n') {\n        break;\n      }\n\n      line += c;\n    }\n  }\n\n  return line;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key"
      ],
      "libraries": [
        "ArduinoECCX08.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  Serial.println(\"ECCX08 Signing\");\n  Serial.println();\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"Failed to communicate with ECC508/ECC608!\");\n    while (1);\n  }\n\n  if (!ECCX08.locked()) {\n    Serial.println(\"The ECC508/ECC608 is not locked!\");\n    while (1);\n  }\n\n  // print the input\n  Serial.print(\"Input is:                  \");\n  printBufferHex(input, sizeof(input));\n\n  // retrieve the public key\n  byte publicKey[64];\n  ECCX08.generatePublicKey(slot, publicKey);\n\n  // print the public key\n  Serial.print(\"Public key of slot \");\n  Serial.print(slot);\n  Serial.print(\" is:   \");\n  printBufferHex(publicKey, sizeof(publicKey));\n\n  // calculate the signature, input MUST be 32-byte array\n  byte signature[64];\n  ECCX08.ecSign(slot, input, signature);\n\n  // print the signature\n  Serial.print(\"Signature using slot \");\n  Serial.print(slot);\n  Serial.print(\" is: \");\n  printBufferHex(signature, sizeof(signature));\n\n  Serial.println();\n\n  // To make the signature verification fail, uncomment the next line:\n  //  signature[0] = 0x00;\n\n  // validate the signature\n  if (ECCX08.ecdsaVerify(input, signature, publicKey)) {\n    Serial.println(\"Verified signature successfully :D\");\n  } else {\n    Serial.println(\"Oh no! Failed to verify signature :(\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// do nothing"
        },
        {
          "name": "printBufferHex",
          "parameters": "const byte input[], int inputLength",
          "body": "for (int i = 0; i < inputLength; i++) {\n    Serial.print(input[i] >> 4, HEX);\n    Serial.print(input[i] & 0x0f, HEX);\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "delay",
        "eeprom",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_seesaw.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "uint8_t eepromval;\n  \n  Serial.begin(115200);\n  \n  while (!Serial) delay(10);   // wait until serial port is opened\n  \n  if(!ss.begin()){\n    Serial.println(F(\"seesaw not found!\"));\n    while(1) delay(10);\n  }\n  \n  Serial.println(F(\"seesaw started OK!\"));\n\n  Serial.print(F(\"Initial read from address 0x02...0x\"));\n  eepromval = ss.EEPROMRead8(0x02);\n  Serial.println(eepromval, HEX);\n\n  Serial.println(F(\"Incrementing value to address 0x02\"));\n  ss.EEPROMWrite8(0x02, eepromval+1);\n\n  Serial.print(F(\"Second read from address 0x02...0x\"));\n  Serial.println(ss.EEPROMRead8(0x02), HEX);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//DONT WRITE EEPROM IN A LOOP!!!! YOU WILL DESTROY YOUR FLASH!!!"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_CRC on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  //Print length of data to run CRC on.\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  //Print the result of calling eeprom_crc()\n  Serial.print(\"CRC32 of EEPROM data: 0x\");\n  Serial.println(eeprom_crc(), HEX);\n  Serial.print(\"Done!\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Empty loop */"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "digitalwrite",
        "millis",
        "led",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_Clear on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n  \n  // initialize the LED pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  Serial.print(\"Emulated EEPROM length (bytes) = \"); Serial.println(EEPROM.length());\n\n  unsigned long startMillis = millis();\n  \n  for (int i = 0 ; i < EEPROM.length() ; i++) \n  {\n    EEPROM.write(i, 0);\n  }\n\n  EEPROM.commit();\n\n  // The time spent can be very short (5-25ms) if the EEPROM is not dirty.\n  // For Seeed XIAO, the time is around 22 / 42 ms for 2048 / 4096 bytes of emulated-EEPROM\n  Serial.print(\"Done clearing emulated EEPROM. Time spent (ms) = \"); Serial.println(millis() - startMillis);\n\n  // turn the LED on when we're done\n  digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/** Empty loop. **/"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "printMyObject",
          "parameters": "MyObject &customVar",
          "body": "Serial.println(\"===============\");\n  Serial.print(\"Field1: \"); Serial.println(customVar.field1, 5);\n  Serial.print(\"Field2: \"); Serial.println(customVar.field2);\n  Serial.print(\"Name: \"); Serial.println(customVar.name);\n  Serial.println(\"===============\");"
        },
        {
          "name": "secondTest",
          "parameters": "",
          "body": "int eeAddress = START_ADDRESS + sizeof(WRITTEN_SIGNATURE) + sizeof(float); //Move address to the next byte after float 'f'.\n\n  MyObject customVar; //Variable to store custom object read from EEPROM.\n  EEPROM.get(eeAddress, customVar);\n\n  Serial.println(\"Read custom object from EEPROM: \");\n  printMyObject(customVar);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_get on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  // Check signature at address 0\n  int signature;\n\n  float f;\n  int eeAddress;\n\n  EEPROM.get(START_ADDRESS, signature);\n\n  // If the EEPROM doesn't store valid data, then no WRITTEN_SIGNATURE\n  if (signature != WRITTEN_SIGNATURE)\n  {\n    Serial.println(\"EEPROM doesn't store valid data, writing WRITTEN_SIGNATURE and some example data\");\n\n    EEPROM.put(START_ADDRESS, WRITTEN_SIGNATURE);\n\n    f = 123.456f;  //Variable to store in EEPROM.\n    eeAddress = START_ADDRESS + sizeof(WRITTEN_SIGNATURE);   //Location we want the data to be put.\n\n    //One simple call, with the address first and the object second.\n    EEPROM.put(eeAddress, f);\n\n    Serial.print(\"Float written to EEPROM: \");\n    Serial.println(f, 3);\n\n    /** Put is designed for use with custom structures also. **/\n\n    //Data to store.\n    MyObject customVar =\n    {\n      3.14159f,\n      65,\n      \"Working!\"\n    };\n\n    eeAddress += sizeof(float); //Move address to the next byte after float 'f'.\n\n    EEPROM.put(eeAddress, customVar);\n\n    if (!EEPROM.getCommitASAP())\n    {\n      Serial.println(\"CommitASAP not set. Need commit()\");\n      EEPROM.commit();\n    }\n\n    Serial.println(\"Done writing custom object to EEPROM: \");\n    printMyObject(customVar);\n    Serial.println(\"Reset to see how you can retrieve the values by using EEPROM_get!\");\n  }\n  else\n  {\n    Serial.println(\"EEPROM has valid data with WRITTEN_SIGNATURE. Now read some example data\");\n\n    f = 0.00f;   //Variable to store data read from EEPROM.\n    eeAddress = START_ADDRESS + sizeof(WRITTEN_SIGNATURE); //EEPROM address to start reading from\n\n    Serial.print(\"Read float from EEPROM: \");\n\n    //Get the float data from the EEPROM at position 'eeAddress'\n    EEPROM.get(eeAddress, f);\n    Serial.println(f, 3);    //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float.\n\n    secondTest(); //Run the next test.\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Empty loop */"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_iteration on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  /***\n    Iterate the EEPROM using a for loop.\n  ***/\n\n  for (int index = 0 ; index < EEPROM.length() ; index++) \n  {\n    // Add one to each cell in the EEPROM   \n    EEPROM.write(index, EEPROM.read(index) + 1);\n  }\n\n  EEPROM.commit();\n\n  Serial.println(\"Done for loop\");\n\n  /***\n    Iterate the EEPROM using a while loop.\n  ***/\n\n  int index = 0;\n\n  while (index < EEPROM.length()) \n  {\n    // Add one to each cell in the EEPROM   \n    EEPROM.write(index, EEPROM.read(index) + 1);\n    index++;\n  }\n\n  EEPROM.commit();\n\n  Serial.println(\"Done while loop\");\n\n  /***\n    Iterate the EEPROM using a do-while loop.\n  ***/\n\n  index = 0;  //Used 'idx' to avoid name conflict with 'index' above.\n\n  do\n  {\n    // Add one to each cell in the EEPROM\n    EEPROM.write(index, EEPROM.read(index) + 1);\n    index++;\n  } while (index < EEPROM.length());\n\n  EEPROM.commit();\n\n  Serial.println(\"Done do-while loop\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "printMyObject",
          "parameters": "MyObject &customVar",
          "body": "Serial.println(\"===============\");\n  Serial.print(\"Field1: \"); Serial.println(customVar.field1, 5);\n  Serial.print(\"Field2: \"); Serial.println(customVar.field2);\n  Serial.print(\"Name: \"); Serial.println(customVar.name);\n  Serial.println(\"===============\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_put on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  float f = 123.456f;  //Variable to store in EEPROM.\n  int eeAddress = START_ADDRESS + sizeof(WRITTEN_SIGNATURE);   //Location we want the data to be put.\n\n  //One simple call, with the address first and the object second.\n  EEPROM.put(eeAddress, f);\n\n  Serial.print(\"Float written to EEPROM: \");\n  Serial.println(f, 3);\n\n  /** Put is designed for use with custom structures also. **/\n\n  //Data to store.\n  MyObject customVar =\n  {\n    3.14159f,\n    65,\n    \"Working!\"\n  };\n\n  eeAddress += sizeof(float); //Move address to the next byte after float 'f'.\n\n  EEPROM.put(eeAddress, customVar);\n\n  if (!EEPROM.getCommitASAP())\n  {\n    Serial.println(\"CommitASAP not set. Need commit()\");\n    EEPROM.commit();\n  }\n\n  Serial.println(\"Done writing custom object to EEPROM: \");\n  printMyObject(customVar);\n  Serial.println(\"Use the EEPROM_get sketch to see how you can retrieve the data\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Empty loop */"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "current",
        "delay",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_read on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read a byte from the current address of the EEPROM\n  value = EEPROM.read(address);\n\n  Serial.print(address);\n  Serial.print(\"\\t\");\n  Serial.print(value, DEC);\n  Serial.println();\n \n  if (++address == EEPROM.length()) \n  {\n    address = 0;\n  }\n\n  /***\n    As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an\n    EEPROM address is also doable by a bitwise and of the length - 1.\n\n    ++address &= EEPROM.length() - 1;\n  ***/\n\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "current",
        "delay",
        "millis",
        "analogread",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_read on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "unsigned long startMillis = millis();\n  \n  for (int i = 0 ; i < EEPROM.length() ; i++) \n  {\n    /***\n      The function EEPROM.update(address, val) is equivalent to the following:\n  \n      if( EEPROM.read(address) != val )\n      {\n        EEPROM.write(address, val);\n      }\n    ***/\n    EEPROM.update(i, (uint8_t) analogRead(0));\n  }\n  \n  EEPROM.commit();\n\n  Serial.print(\"Done updating emulated EEPROM. Time spent (ms) = \"); Serial.println(millis() - startMillis);\n\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "millis",
        "analogread",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EEPROM_write on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "unsigned long startMillis = millis();\n  \n  for (int i = 0 ; i < EEPROM.length() ; i++) \n  {\n    /***\n      The function EEPROM.update(address, val) is equivalent to the following:\n  \n      if( EEPROM.read(address) != val )\n      {\n        EEPROM.write(address, val);\n      }\n    ***/\n    EEPROM.write(i, (uint8_t) analogRead(0));\n  }\n  \n  EEPROM.commit();\n\n  Serial.print(\"Done writing emulated EEPROM. Time spent (ms) = \"); Serial.println(millis() - startMillis);\n\n  delay(60000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_EPD.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  //while(!Serial);           // Wait for Serial Monitor before continuing\n\n  display.begin();\n\n#if defined(FLEXIBLE_213) || defined(FLEXIBLE_290)\n  // The flexible displays have different buffers and invert settings!\n  display.setBlackBuffer(1, false);\n  display.setColorBuffer(1, false);\n#endif\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Load full-screen BMP file 'blinka.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'epd' as an argument.\n  Serial.print(F(\"Loading blinka.bmp to canvas...\"));\n  stat = reader.drawBMP((char *)\"/blinka.bmp\", display, 0, 0);\n  reader.printStatus(stat); // How'd we do?\n  display.display();\n\n  // Query the dimensions of image 'blinka.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying blinka.bmp image size...\"));\n  stat = reader.bmpDimensions(\"blinka.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  delay(30 * 1000); // Pause 30 seconds before continuing because it's eInk\n\n  Serial.print(F(\"Drawing canvas to EPD...\"));\n  display.clearBuffer();\n\n  // Load small BMP 'blinka.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on larger ram boards like M4, etc.\n  stat = reader.loadBMP(\"/blinka.bmp\", img);\n  reader.printStatus(stat); // How'd we do?"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) {     // For each of 4 rotations...\n    display.setRotation(r);    // Set rotation\n    display.fillScreen(0);     // and clear screen\n    display.clearBuffer();\n    img.draw(display, 0, 0);\n    display.display();\n    delay(30 * 1000); // Pause 30 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "display",
        "sd",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_EPD.h",
        "SdFat.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(9600);\n  //while(!Serial);           // Wait for Serial Monitor before continuing\n\n  display.begin();\n\n#if defined(FLEXIBLE_213) || defined(FLEXIBLE_290)\n  // The flexible displays have different buffers and invert settings!\n  display.setBlackBuffer(1, false);\n  display.setColorBuffer(1, false);\n#endif\n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n#if defined(USE_SD_CARD)\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    for(;;); // Fatal error, do not continue\n  }\n#else\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    Serial.println(F(\"flash begin() failed\"));\n    for(;;);\n  }\n  if(!filesys.begin(&flash)) {\n    Serial.println(F(\"filesys begin() failed\"));\n    for(;;);\n  }\n#endif\n  Serial.println(F(\"OK!\"));\n\n  // Load full-screen BMP file 'blinka.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'epd' as an argument.\n  Serial.print(F(\"Loading blinka.bmp to canvas...\"));\n  stat = reader.drawBMP((char *)\"/blinka.bmp\", display, 0, 0);\n  reader.printStatus(stat); // How'd we do?\n  display.display();\n\n  // Query the dimensions of image 'blinka.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying blinka.bmp image size...\"));\n  stat = reader.bmpDimensions(\"blinka.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  delay(30 * 1000); // Pause 30 seconds before continuing because it's eInk\n\n  Serial.print(F(\"Drawing canvas to EPD...\"));\n  display.clearBuffer();\n\n  // Load small BMP 'blinka.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on larger ram boards like M4, etc.\n  stat = reader.loadBMP(\"/blinka.bmp\", img);\n  reader.printStatus(stat); // How'd we do?"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    display.setRotation(r);    // Set rotation\n    display.fillScreen(0);     // and clear screen\n    display.clearBuffer();\n    img.draw(display, 0, 0);\n    display.display();\n    delay(30 * 1000); // Pause 30 sec.\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "display",
        "flash",
        "devices"
      ],
      "libraries": [
        "Adafruit_ThinkInk.h",
        "Adafruit_SPIFlash.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "ImageReturnCode stat; // Status from image-reading functions\n\n  Serial.begin(115200);\n  //while(!Serial) delay(10);           // Wait for Serial Monitor before continuing\n\n  display.begin(THINKINK_TRICOLOR);\n  display.setRotation(3);  \n\n  // The Adafruit_ImageReader constructor call (above, before setup())\n  // accepts an uninitialized SdFat or FatVolume object. This MUST\n  // BE INITIALIZED before using any of the image reader functions!\n  Serial.print(F(\"Initializing filesystem...\"));\n  // SPI or QSPI flash requires two steps, one to access the bare flash\n  // memory itself, then the second to access the filesystem within...\n  if(!flash.begin()) {\n    errorEPD(\"Flash begin() failed\");\n  }\n  if(!filesys.begin(&flash)) {\n    errorEPD(\"filesys begin() failed\");\n  }\n\n  Serial.println(F(\"OK!\"));\n\n  // Load full-screen BMP file 'blinka.bmp' at position (0,0) (top left).\n  // Notice the 'reader' object performs this, with 'epd' as an argument.\n  Serial.print(F(\"Loading blinka.bmp to canvas...\"));\n  stat = reader.drawBMP((char *)\"/blinka.bmp\", display, 0, 0);\n  reader.printStatus(stat); // How'd we do?\n  if (stat != IMAGE_SUCCESS) {\n    errorEPD(\"Unable to draw image\");\n  }\n  display.display();\n\n  // Query the dimensions of image 'blinka.bmp' WITHOUT loading to screen:\n  Serial.print(F(\"Querying blinka.bmp image size...\"));\n  stat = reader.bmpDimensions(\"blinka.bmp\", &width, &height);\n  reader.printStatus(stat);   // How'd we do?\n  if(stat == IMAGE_SUCCESS) { // If it worked, print image size...\n    Serial.print(F(\"Image dimensions: \"));\n    Serial.print(width);\n    Serial.write('x');\n    Serial.println(height);\n  }\n\n  delay(30 * 1000); // Pause 30 seconds before continuing because it's eInk\n\n  Serial.print(F(\"Drawing canvas to EPD...\"));\n  display.clearBuffer();\n\n  // Load small BMP 'blinka.bmp' into a GFX canvas in RAM. This should fail\n  // gracefully on Arduino Uno and other small devices, meaning the image\n  // will not load, but this won't make the program stop or crash, it just\n  // continues on without it. Should work on larger ram boards like M4, etc.\n  stat = reader.loadBMP(\"/blinka.bmp\", img);\n  reader.printStatus(stat); // How'd we do?"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for(int r=0; r<4; r++) { // For each of 4 rotations...\n    display.setRotation(r);    // Set rotation\n    display.fillScreen(0);     // and clear screen\n    display.clearBuffer();\n    img.draw(display, 0, 0);\n    display.display();\n    delay(30 * 1000); // Pause 30 sec.\n  }"
        },
        {
          "name": "errorEPD",
          "parameters": "const char *errormsg",
          "body": "display.fillScreen(0);     // clear screen\n  display.clearBuffer();\n  display.setTextSize(2);\n  display.setCursor(10, 10);\n  display.setTextColor(EPD_BLACK);\n  display.print(errormsg); \n  display.display();\n\n  while (1) {\n    delay(10);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalread",
        "display",
        "sd"
      ],
      "libraries": [
        "Adafruit_GFX.h",
        "Adafruit_ThinkInk.h",
        "SdFat.h",
        "Adafruit_ImageReader_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "Serial.begin(9600);\n  //while(!Serial);           // Wait for Serial Monitor before continuing\n\n  display.begin();\n  display.clearBuffer();\n /*\n  Serial.print(\"Initializing filesystem...\");\n  display.setTextSize(3);\n  display.setCursor(10,10);\n  display.setTextColor(EPD_BLACK);\n  display.print(\"SD Card...\");\n  */\n  display.display();\n\n  // SD card is pretty straightforward, a single call...\n  if(!SD.begin(SD_CS, SD_SCK_MHZ(10))) { // Breakouts require 10 MHz limit due to longer wires\n    Serial.println(F(\"SD begin() failed\"));\n    display.println(\"failed!\");\n    display.display();\n    for(;;); // Fatal error, do not continue\n  }\n  Serial.println(\"OK!\");\n   /*\n  display.println(\"OK!\");\n  display.display();\n\n  display.setCursor(10,100);\n  display.setTextSize(1);\n  display.println(\"Press buttons to display images!\");\n  display.display();\n*/\n  pinMode(BUTTON1, INPUT_PULLUP); \n  pinMode(BUTTON2, INPUT_PULLUP); \n  pinMode(BUTTON3, INPUT_PULLUP);\n  delay(10);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "char selected_file[80] = {0};\n  ImageReturnCode stat; // Status from image-reading functions\n\n\n  if (!digitalRead(BUTTON1)) {\n    strcpy(selected_file, FILENAME1);\n    Serial.println(\"Button 1 pressed\");\n  }\n  if (!digitalRead(BUTTON2)) {\n    strcpy(selected_file, FILENAME2);\n    Serial.println(\"Button 2 pressed\");\n  }\n  if (!digitalRead(BUTTON3)) {\n    strcpy(selected_file, FILENAME3);\n    Serial.println(\"Button 3 pressed\");\n  }\n\n  \n  if (selected_file[0] != 0) {  \n    display.clearBuffer();\n    display.display();\n    delay(500);\n    Serial.print(\"Loading \");\n    Serial.print(selected_file);\n    Serial.println(\" to canvas...\");\n    display.clearBuffer();\n    stat = reader.drawBMP(selected_file, display, 0, 0);\n    reader.printStatus(stat); // How'd we do?    \n    display.display();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "blynk.cloud"
      ],
      "libraries": [
        "EthernetENC.h",
        "BlynkSimpleEthernetENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "delay",
        "millis"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n#if USE_BLYNK_WM\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart ENC28J60_Blynk using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart ENC28J60_Blynk on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Serial.println(\"\\nStart ENC28J60_Blynk, no WM, on \" + String(BOARD_TYPE) + String(\" using Local Server\"));\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Serial.println(\"\\nStart ENC28J60_Blynk, no WM, on \" + String(BOARD_TYPE) + String(\" using Cloud Server\"));\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n    Serial.print(F(\"Local IP = \"));       \n    Serial.println(Ethernet.localIP());\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "digitalread",
        "delay",
        "millis",
        "timer",
        "interrupt"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "parameters": "",
          "body": "//isButtonPressed = !digitalRead(BUTTON_PIN); // Invert state, since button is \"Active LOW\"\n\n  if ( !isButtonPressed && !digitalRead(BUTTON_PIN)) // You can write any condition to trigger e-mail sending\n  {\n    isButtonPressed = true;\n    count++;\n    Serial.println(\"Button pressed\");\n  }"
        },
        {
          "name": "processButton",
          "parameters": "",
          "body": "// *** WARNING: You are limited to send ONLY ONE E-MAIL PER 5 SECONDS! ***\n  // Let's send an e-mail when you press the button\n  // connected to digital pin BUTTON_PIN (2) on your Arduino\n  static String body;\n\n  if (isButtonPressed) // You can write any condition to trigger e-mail sending\n  {\n    body = String(\"You pushed the button \") + count + \" times.\";\n\n    // This can be seen in the Serial Monitor\n    Serial.println(body);\n\n    Blynk.email(\"your_email@gmail.com\", \"Subject: Button Logger\", body);\n\n    isButtonPressed = false;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n#if USE_BLYNK_WM\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart ENC28J60_Blynk_Email using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart ENC28J60_Blynk_Email on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Serial.println(\"\\nStart ENC28J60_Blynk_Email, no WM, on \" + String(BOARD_TYPE) + String(\" using Local Server\"));\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Serial.println(\"\\nStart ENC28J60_Blynk_Email, no WM, on \" + String(BOARD_TYPE) + String(\" using Cloud Server\"));\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }\n\n  // Attach pin BUTTON_PIN (2) interrupt to our handler\n  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), emailOnButtonPress, FALLING /*CHANGE*/);\n\n  timer.setInterval(30000L, processButton);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "temperature",
        "humidity",
        "spi",
        "wifi",
        "millis",
        "delay",
        "timer"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = 25.0;\n  float humidity    = 50.0;\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, F(\"NAN\"));\n      Blynk.virtualWrite(V18, F(\"NAN\"));\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if USE_BLYNK_WM\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart ENC28J60_WM_Config using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart ENC28J60_WM_Config on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Serial.println(\"\\nStart ENC28J60_WM_Config, no WM, on \" + String(BOARD_TYPE) + String(\" using Local Server\"));\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Serial.println(\"\\nStart ENC28J60_WM_Config, no WM, on \" + String(BOARD_TYPE) + String(\" using Cloud Server\"));\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }\n\n  timer.setInterval(60000L, readAndSendData);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "lcd",
        "display"
      ],
      "libraries": [
        "M5EPD.h",
        "M5CoreInk.h",
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "// M5.begin();\n\n  gfx.init();   // 初期化を行います。LCDもEPDも共通です。\n\n  gfx.setRotation(0);  // 回転方向の設定はLCDもEPDも共通です。0～3で右回りに90度ずつ回転します。4～7は上下反転になります。\n\n  w = gfx.width();\n  h = gfx.height();\n\n  gfx.setBrightness(128); // バックライトの輝度設定はEPDでは効果を持ちません。\n\n// EPDの動作モードを設定できます。描画用途に応じて 都度、変更してください。\n// ※ M5Stack CoreInk では epd_quality以外は差はありません。\n  gfx.setEpdMode(epd_mode_t::epd_fastest);  // 最速更新、白黒反転なし、残像が残りやすい\n  gfx.setEpdMode(epd_mode_t::epd_fast);     // 高速更新、白黒反転なし、残像が残りやすい\n  gfx.setEpdMode(epd_mode_t::epd_text);     // 高品質更新、白黒反転が一瞬起きる（白背景用）\n  gfx.setEpdMode(epd_mode_t::epd_quality);  // 高品質更新、白黒反転が一瞬起きる\n\n// M5Paper (IT8951)での各モードの特徴は以下の通りです。\n// epd_fastest = DU4  更新時間 120msec  完全な白と黒のみ描画でき、中間階調は描画されない。また、中間階調で表示されている箇所を更新できない。\n// epd_fast    = DU   更新時間 260msec  完全な白と黒のみ描画でき、中間階調は描画されない。\n// epd_text    = GL16 更新時間 450msec  グレースケール16階調で描画できる。白背景・黒文字 用途\n// epd_quality = GC16 更新時間 450msec  グレースケール16階調で描画できる。画像用途\n\n\n// 描画関数はすべてLCDと同様に利用可能です。\n// 色指定もLCDと同様に指定できますが、自動的にグレースケールに変換されます。\n// （グレースケール変換時の比率は R1:G2:B1 です。緑色がやや明るく表現されます。）\n\n  int rectwidth = std::min(w, h) / 2;\n  gfx.fillTriangle( w / 2, 0, 0, h - 1, w - 1, h - 1, TFT_RED);\n  gfx.fillCircle(w/2, h/2, rectwidth, TFT_GREEN);\n  gfx.fillRect((w-rectwidth)/2, (h-rectwidth)/2, rectwidth, rectwidth, TFT_BLUE);\n\n  delay(3000);\n\n\n// 描画処理をstartWrite/endWriteで囲むと、endWrite() のタイミングでまとめて画面に反映できます。\n// または、display() を呼んだ時点でも画面に反映できます。\n\n  gfx.startWrite(); // 描画内容の即時反映を抑止。\n\n  for (int i = 0; i < 20; ++i)\n  {\n    gfx.drawLine(i * w / 20, 0, w - 1, i * h / 20, TFT_BLACK);  // この時点では画面に反映されない。\n    gfx.drawLine(0, i * h / 20, i * w / 20, h - 1, TFT_BLACK);\n  }\n\n  gfx.endWrite();   // ここで画面に反映される。\n\n  delay(3000);\n\n  gfx.startWrite(); // 描画内容の即時反映を抑止。\n\n  for (int i = 0; i < 5; i++)\n  {\n    for (int j = 0; j < 20; j++)\n    {\n      gfx.fillRect(random(w-20), random(h-20), 20, 20, random(65535));  // この時点では画面に反映されない。\n    }\n    gfx.display();  // ここで画面に反映される。\n  }\n\n  gfx.endWrite();   // すでに画面に反映済みの場合は、この時点では何も起きない。\n\n  delay(3000);\n\n// ※ 正確には、  display() を呼んだ時にのみ 画面に反映される仕組みなのですが、\n// SPIバス解放のタイミングで display() を呼ぶ仕組みを用意しており、初期値で有効にしています。\n// この仕組みにより、描画関数やendWriteを呼んだ直後に自動で画面に反映されています。\n// なお、 setAutoDisplay(bool) でこの自動display呼出しの有効／無効を変更できます。\n\n  gfx.setAutoDisplay(false);  // 自動表示更新を無効にする。（以降は display()を呼ぶまで画面に反映されない。）\n\n  gfx.setFont(&fonts::Font4);\n  gfx.setTextColor(TFT_BLACK, TFT_WHITE); // 文字色を黒、背景色を白に指定\n  gfx.setTextDatum(textdatum_t::top_center);\n  for (int i = 0; i < 10; i++)\n  {\n    gfx.drawString(\"Hello World !!\", w / 2, i * h / 10);\n  }\n  gfx.qrcode(\"Hello world !\", (w-rectwidth)/2, (h-rectwidth)/2, rectwidth);\n\n  gfx.display();   // ここで画面に反映される。\n\n  gfx.setAutoDisplay(true);  // 自動表示更新を有効にする。\n\n  delay(3000);\n\n  gfx.fillScreen(TFT_WHITE);\n\n// M5Paper (IT8951)では epd_quality/epd_text を使用するとグレースケール16階調の表示が可能ですが、\n// epd_fast/epd_fastestを使用した場合は白黒２階調のみに制限されます。\n// この場合でもLovyanGFXのタイルパターン処理により疑似的に17階調を表現できます。\n\n  gfx.setEpdMode(epd_mode_t::epd_quality); // 高品質更新モードに設定（以後の描画はグレースケールを使用する）\n  gfx.startWrite();\n  for (int i = 0; i < 16; i++)\n  {\n    int level = 8 + i * 16;\n    gfx.fillRect(i * w / 16, 0, w / 16 + 1, h / 2, gfx.color888(level, level, level));\n  }\n  gfx.display();  // ここでの表示更新は高品質モードとなる。\n\n  gfx.waitDisplay(); // EPDの表示更新の完了待機。\n  // ※ 待機せずに表示更新中かどうかを調べたい場合は displayBusy() を使用します。\n  //    他の処理の合間に描画を行いたい場合などにご利用ください。\n  // 例 : while (gfx.displayBusy()) delay(10); // delayの代わりに何か他の処理を指定\n\n\n  gfx.setEpdMode(epd_mode_t::epd_fast);  // 高速更新モードに設定（以後の描画は白黒２値を使用する）\n  for (int i = 0; i < 17; i++)\n  {\n    int level = std::min(255, i * 16);\n    gfx.fillRect(i * w / 17, h / 2, w / 17+1, h / 2, gfx.color888(level, level, level));\n  }\n  gfx.display();  // ここでの描画は高速モードとなる。\n\n  delay(3000);\n\n  // M5Paper (IT8951)の高品質モードではグレースケール16階調＋タイルパターン処理により241階調が表現できます。\n  gfx.setEpdMode(epd_mode_t::epd_quality);\n\n  for (int i = 0; i < 256; ++i)\n  {\n    gfx.fillRect(0, (i * h) / 256, w, 4, gfx.color888(i, i, i));\n  }\n  gfx.display();\n\n  gfx.endWrite();\n\n  delay(3000);\n\n  // M5Paper (IT8951)の表示更新は複数個所を同時に行う事が可能です。\n  gfx.startWrite();\n  for (int i = 0; i < 16; ++i)\n  {\n    std::int32_t y1 = (i * h) / 16, y2 = ((i + 1) * h) / 16;\n    std::int32_t x1 = 0, x2 = 0;\n    for (int j = 0; j < 16; ++j)\n    {\n      x2 = ((j + 1) * w) / 16;\n      std::int_fast8_t l = 255 - (i * 16 + j);\n      gfx.fillRect(x1, y1, x2 - x1, y2 - y1, gfx.color888(l, l, l));\n      x1 = x2;\n      if ((j & 7) == 7)  gfx.display(); // ８回に１回 表示更新を行う\n    }\n  }\n  gfx.endWrite();\n\n  // ※ 表示更新中の範囲への描画をしないように注意してください。\n  //    表示更新の途中で内容が変更されると正しく描画されなくなります。\n\n  delay(3000);\n\n  gfx.fillScreen(TFT_WHITE);\n\n  // 前回の表示更新範囲と重なる範囲に描画する場合、\n  // LovyanGFX内部で表示更新が完了するのを待機する仕組みになっています。\n  // そのため特に意識しなくても表示が乱れることがありません。\n  gfx.setEpdMode(epd_mode_t::epd_quality);\n  gfx.fillRect(0, 0, w/2, h/2, TFT_BLUE);  // これらの描画は範囲が重なっているが、\n  gfx.fillRect(0, 0, w/3, h/3, TFT_YELLOW);// 表示更新を待機する仕組みが機能するため\n  gfx.fillRect(0, 0, w/4, h/4, TFT_BLUE);  // 特に意識しなくても描画が乱れることがない\n  gfx.fillRect(0, 0, w/5, h/5, TFT_YELLOW);\n  gfx.fillRect(0, 0, w/6, h/6, TFT_BLUE);\n  gfx.fillRect(0, 0, w/7, h/7, TFT_YELLOW);\n\n  gfx.waitDisplay();\n\n  // しかし自動チェックは完全ではありません。「前回の表示更新範囲」と比較する仕組みのため、\n  // 別の範囲への描画を間に挟むと範囲チェックが十分に機能しなくなります。\n  gfx.fillRect(w/2, 0, w/2, h/2, TFT_BLUE);  // 範囲が重ならない描画を交互に行うと、\n  gfx.drawPixel(0, 0);                       // 表示更新を待機する仕組みが機能せず、\n  gfx.fillRect(w/2, 0, w/3, h/3, TFT_YELLOW);// 正しく描画されないようになる。\n  gfx.drawPixel(0, 0);\n  gfx.fillRect(w/2, 0, w/4, h/4, TFT_BLUE);  // ※ 先の例と同じ色で描画しているのに\n  gfx.drawPixel(0, 0);                       // 表示される階調が違っていたり、\n  gfx.fillRect(w/2, 0, w/5, h/5, TFT_YELLOW);// 正しい描画が行われていないことを確認してください\n  gfx.drawPixel(0, 0);\n  gfx.fillRect(w/2, 0, w/6, h/6, TFT_BLUE);\n  gfx.drawPixel(0, 0);\n  gfx.fillRect(w/2, 0, w/7, h/7, TFT_YELLOW);\n\n  gfx.waitDisplay();\n\n  // また、表示更新モードが epd_fastest モードの場合は、レスポンスを最優先とするため、\n  // 表示更新範囲のチェック処理を省略するようになります。\n  gfx.setEpdMode(epd_mode_t::epd_fastest);    // 最速更新モードに設定する。\n  gfx.fillRect(0, h/2, w/2, h/2, TFT_BLUE);   // 以後の描画は表示更新範囲と重複していても、\n  gfx.fillRect(0, h/2, w/3, h/3, TFT_YELLOW); // 一切待機せずに描画するようになる。\n  gfx.fillRect(0, h/2, w/4, h/4, TFT_BLUE);   // そのため範囲の重なった描画を続けて行うと、\n  gfx.fillRect(0, h/2, w/5, h/5, TFT_YELLOW); // 表示更新中に内容を書き換えてしまい\n  gfx.fillRect(0, h/2, w/6, h/6, TFT_BLUE);   // 意図した描画結果にならない。\n  gfx.fillRect(0, h/2, w/7, h/7, TFT_YELLOW);\n\n  gfx.fillRect(w/2, h/2, w/2, h/2, TFT_BLUE);\n  gfx.waitDisplay();                           // 必要に応じてwaitDisplayで待機させる。\n  gfx.fillRect(w/2, h/2, w/3, h/3, TFT_YELLOW);// 正しく待機することで、\n  gfx.waitDisplay();                           // 描画結果の乱れを防止できる。\n  gfx.fillRect(w/2, h/2, w/4, h/4, TFT_BLUE);\n  gfx.waitDisplay();                           // 表示結果が先の例と違うことを確認してください\n  gfx.fillRect(w/2, h/2, w/5, h/5, TFT_YELLOW);\n  gfx.waitDisplay();\n  gfx.fillRect(w/2, h/2, w/6, h/6, TFT_BLUE);\n  gfx.waitDisplay();\n  gfx.fillRect(w/2, h/2, w/7, h/7, TFT_YELLOW);\n\n  delay(3000);\n\n\n  gfx.setEpdMode(epd_mode_t::epd_quality);\n\n  gfx.fillScreen(TFT_WHITE);\n\n  if (gfx.touch())  // touch関数の戻り値がnullかどうかでタッチコントローラの有無を判定できます。\n  {\n    gfx.startWrite();\n    for (int i = 0; i < 1024; i++)\n    {\n      if ((i & 255) == 0)\n      {\n        gfx.setEpdMode(epd_mode_t::epd_fast);\n        gfx.fillScreen(TFT_WHITE);\n        gfx.setTextColor(TFT_BLACK, TFT_WHITE);\n        gfx.setTextSize(3, 3);\n        gfx.drawString(\"Touch Test\", w / 2, h / 2);\n        gfx.display();\n        delay(100);\n        gfx.waitDisplay();\n        gfx.setEpdMode(epd_mode_t::epd_fastest);\n      }\n      delay(15);\n\n      std::int32_t x, y, number = 0;\n      while (gfx.getTouch(&x, &y, number))  // getTouch関数でタッチ中の座標を取得できます。\n      {\n        gfx.fillCircle(x, y, 5, (std::uint32_t)(number * 0x333333u));\n        gfx.display();\n        ++number;\n      }\n    }\n    gfx.endWrite();\n  }\n\n  gfx.setEpdMode(epd_mode_t::epd_fast);\n  gfx.fillScreen(TFT_WHITE);\n\n  sp.setColorDepth(4);\n  if (!sp.createSprite(w / 2, h / 2)) sp.createSprite(w / 4, h / 4);\n  sp.setFont(&fonts::Font8);"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "static int count = 0;\n\n  if (0 == (count & 15))\n  {\n    switch ((count >> 4) & 3)\n    {\n    case 0:  gfx.setEpdMode(epd_mode_t::epd_quality);  break;\n    case 1:  gfx.setEpdMode(epd_mode_t::epd_text   );  break;\n    case 2:  gfx.setEpdMode(epd_mode_t::epd_fast   );  break;\n    case 3:  gfx.setEpdMode(epd_mode_t::epd_fastest);  break;\n    }\n  }\n\n  for (int y = 0; y < sp.height(); y += 4) {\n    for (int x = 0; x < sp.width(); x += 4) {\n      std::uint32_t val = ((x+count*4)|(y+count*4)) >> 4;\n      sp.fillRect(x, y, 4, 4, val);\n    }\n  }\n\n  int x = 2;\n  int y = 2;\n  sp.setTextColor(TFT_BLACK);\n  sp.drawNumber(count, x-2, y-2);\n  sp.drawNumber(count, x+2, y-2);\n  sp.drawNumber(count, x+2, y+2);\n  sp.drawNumber(count, x-2, y+2);\n  sp.setTextColor(TFT_WHITE);\n  sp.drawNumber(count, x, y);\n\n  gfx.waitDisplay();\n  sp.pushSprite(count & 1 ? w / 2 : 0, count & 2 ? h / 2 : 0);\n  ++count;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay",
        "display"
      ],
      "libraries": [
        "Adafruit_EPD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  // while (!Serial) { delay(10); }\n  Serial.println(\"Adafruit EPD test\");\n\n  display.begin();\n\n#if defined(FLEXIBLE_213) || defined(FLEXIBLE_290)\n  // The flexible displays have different buffers and invert settings!\n  display.setBlackBuffer(1, false);\n  display.setColorBuffer(1, false);\n#endif\n\n  // large block of text\n  display.clearBuffer();\n  testdrawtext(\n      \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur \"\n      \"adipiscing ante sed nibh tincidunt feugiat. Maecenas enim massa, \"\n      \"fringilla sed malesuada et, malesuada sit amet turpis. Sed porttitor \"\n      \"neque ut ante pretium vitae malesuada nunc bibendum. Nullam aliquet \"\n      \"ultrices massa eu hendrerit. Ut sed nisi lorem. In vestibulum purus a \"\n      \"tortor imperdiet posuere. \",\n      COLOR1);\n  display.display();\n\n  delay(5000);\n\n  display.clearBuffer();\n  for (int16_t i = 0; i < display.width(); i += 4) {\n    display.drawLine(0, 0, i, display.height() - 1, COLOR1);\n  }\n\n  for (int16_t i = 0; i < display.height(); i += 4) {\n    display.drawLine(display.width() - 1, 0, 0, i,\n                     COLOR2); // on grayscale this will be mid-gray\n  }\n  display.display();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// don't do anything!"
        },
        {
          "name": "testdrawtext",
          "parameters": "const char *text, uint16_t color",
          "body": "display.setCursor(0, 0);\n  display.setTextColor(color);\n  display.setTextWrap(true);\n  display.print(text);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "telegram",
        "http",
        "api",
        "https",
        "token",
        "certificate",
        "wifi",
        "ntp",
        "digitalwrite",
        "delay",
        "millis",
        "led",
        "flash"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h",
        "esp_camera.h",
        "ArduinoJson.h",
        "camera_pins.h",
        "camera_code.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "parameters": "int numNewMessages",
          "body": "Serial.println(\"handleNewMessages\");\n  Serial.println(String(numNewMessages));\n\n  for (int i = 0; i < numNewMessages; i++)\n  {\n    String chat_id = String(bot.messages[i].chat_id);\n    String text = bot.messages[i].text;\n\n    String from_name = bot.messages[i].from_name;\n    if (from_name == \"\")\n      from_name = \"Guest\";\n\n    if (text == \"/flash\")\n    {\n      flashState = !flashState;\n      digitalWrite(FLASH_LED_PIN, flashState);\n    }\n\n    if (text == \"/photo\")\n    {\n      fb = NULL;\n      // Take Picture with Camera\n      fb = esp_camera_fb_get();\n      if (!fb)\n      {\n        Serial.println(\"Camera capture failed\");\n        bot.sendMessage(chat_id, \"Camera capture failed\", \"\");\n        return;\n      }\n      dataAvailable = true;\n      Serial.println(\"Sending\");\n      bot.sendPhotoByBinary(chat_id, \"image/jpeg\", fb->len,\n                            isMoreDataAvailable, nullptr,\n                            getNextBuffer, getNextBufferLen);\n\n      Serial.println(\"done!\");\n\n      esp_camera_fb_return(fb);\n    }\n\n    if (text == \"/start\")\n    {\n      String welcome = \"Welcome to the ESP32Cam Telegram bot.\\n\\n\";\n      welcome += \"/photo : will take a photo\\n\";\n      welcome += \"/flash : toggle flash LED (VERY BRIGHT!)\\n\";\n      bot.sendMessage(chat_id, welcome, \"Markdown\");\n    }\n  }"
        },
        {
          "name": "isMoreDataAvailable",
          "parameters": "",
          "body": "if (dataAvailable)\n  {\n    dataAvailable = false;\n    return true;\n  }\n  else\n  {\n    return false;\n  }"
        },
        {
          "name": "getNextBufferLen",
          "parameters": "",
          "body": "if (fb)\n  {\n    return fb->len;\n  }\n  else\n  {\n    return 0;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  pinMode(FLASH_LED_PIN, OUTPUT);\n  digitalWrite(FLASH_LED_PIN, flashState); //defaults to low\n\n  if (!setupCamera())\n  {\n    Serial.println(\"Camera Setup Failed!\");\n    while (true)\n    {\n      delay(100);\n    }\n  }\n\n  // attempt to connect to Wifi network:\n  Serial.print(\"Connecting to Wifi SSID \");\n  Serial.print(WIFI_SSID);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  secured_client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);\n  }\n  Serial.print(\"\\nWiFi connected. IP address: \");\n  Serial.println(WiFi.localIP());\n\n  Serial.print(\"Retrieving time: \");\n  configTime(0, 0, \"pool.ntp.org\"); // get UTC time via NTP\n  time_t now = time(nullptr);\n  while (now < 24 * 3600)\n  {\n    Serial.print(\".\");\n    delay(100);\n    now = time(nullptr);\n  }\n  Serial.println(now);\n\n  // Make the bot wait for a new message for up to 60seconds\n  bot.longPoll = 60;"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n    }\n\n    bot_lasttime = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "key",
        "token",
        "auth",
        "callback",
        "wifi",
        "interrupt",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "ESP_Google_Sheet_Client.h"
      ],
      "functions": [
        {
          "name": "WiFiEvent",
          "parameters": "WiFiEvent_t event",
          "body": "// Do not run any function here to prevent stack overflow or nested interrupt\n\n#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)\n\n    switch (event)\n    {\n    case ARDUINO_EVENT_ETH_START:\n        Serial.println(\"ETH Started\");\n        // set eth hostname here\n        ETH.setHostname(\"esp32-ethernet\");\n        break;\n    case ARDUINO_EVENT_ETH_CONNECTED:\n        Serial.println(\"ETH Connected\");\n        break;\n    case ARDUINO_EVENT_ETH_GOT_IP:\n        Serial.print(\"ETH MAC: \");\n        Serial.print(ETH.macAddress());\n        Serial.print(\", IPv4: \");\n        Serial.print(ETH.localIP());\n        if (ETH.fullDuplex())\n        {\n            Serial.print(\", FULL_DUPLEX\");\n        }\n        Serial.print(\", \");\n        Serial.print(ETH.linkSpeed());\n        Serial.println(\"Mbps\");\n        eth_connected = true;\n        break;\n    case ARDUINO_EVENT_ETH_DISCONNECTED:\n        Serial.println(\"ETH Disconnected\");\n        eth_connected = false;\n        break;\n    case ARDUINO_EVENT_ETH_STOP:\n        Serial.println(\"ETH Stopped\");\n        eth_connected = false;\n        break;\n    default:\n        break;\n    }\n\n#else\n    switch (event)\n    {\n    case SYSTEM_EVENT_ETH_START:\n        Serial.println(\"ETH Started\");\n        // set eth hostname here\n        ETH.setHostname(\"esp32-ethernet\");\n        break;\n    case SYSTEM_EVENT_ETH_CONNECTED:\n        Serial.println(\"ETH Connected\");\n        break;\n    case SYSTEM_EVENT_ETH_GOT_IP:\n        Serial.print(\"ETH MAC: \");\n        Serial.print(ETH.macAddress());\n        Serial.print(\", IPv4: \");\n        Serial.print(ETH.localIP());\n        if (ETH.fullDuplex())\n        {\n            Serial.print(\", FULL_DUPLEX\");\n        }\n        Serial.print(\", \");\n        Serial.print(ETH.linkSpeed());\n        Serial.println(\"Mbps\");\n        eth_connected = true;\n        break;\n    case SYSTEM_EVENT_ETH_DISCONNECTED:\n        Serial.println(\"ETH Disconnected\");\n        eth_connected = false;\n        break;\n    case SYSTEM_EVENT_ETH_STOP:\n        Serial.println(\"ETH Stopped\");\n        eth_connected = false;\n        break;\n    default:\n        break;\n    }\n#endif"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n\n#if defined(ESP32)\n    WiFi.onEvent(WiFiEvent);\n    ETH.begin(ETH_ADDR, ETH_POWER_PIN, ETH_MDC_PIN, ETH_MDIO_PIN, ETH_TYPE, ETH_CLK_MODE);\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if defined(ESP32)\n\n    if (eth_connected)\n    {\n        if (!gsheetSetupReady)\n            setupGsheet();\n\n        bool ready = GSheet.ready();\n\n        if (ready && !taskComplete)\n        {\n\n            // Google sheet code here\n\n            taskComplete = true;\n        }\n    }\n\n#endif"
        },
        {
          "name": "setupGsheet",
          "parameters": "",
          "body": "// Set the callback for Google API access token generation status (for debug only)\n    GSheet.setTokenCallback(tokenStatusCallback);\n\n    // Set the seconds to refresh the auth token before expire (60 to 3540, default is 300 seconds)\n    GSheet.setPrerefreshSeconds(10 * 60);\n\n    // Begin the access token generation for Google API authentication\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n    gsheetSetupReady = true;"
        },
        {
          "name": "tokenStatusCallback",
          "parameters": "TokenInfo info",
          "body": "if (info.status == token_status_error)\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n        GSheet.printf(\"Token error: %s\\n\", GSheet.getTokenError(info).c_str());\n    }\n    else\n    {\n        GSheet.printf(\"Token info: type = %s, status = %s\\n\", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "voltage",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "ESP32AnalogRead.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "adc.attach(33);\n\tSerial.begin(115200);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "delay(50);\n\tSerial.println(\"Voltage = \"+String(adc.readVoltage()));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "webserver",
        "rest",
        "light",
        "wifi",
        "delay",
        "rgb",
        "led",
        "eeprom",
        "flash"
      ],
      "libraries": [
        "ESPAutoWiFiConfig.h",
        "WiFi.h",
        "WiFiClient.h",
        "WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// setup code that must be run every time\n#ifdef DEBUG\n  Serial.begin(115200);\n  Serial.println();\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);\n  }\n  Serial.println();\n#endif\n\n#ifdef DEBUG\n  setESPAutoWiFiConfigDebugOut(Serial); // turns on debug output for the ESPAutoWiFiConfig code\n#endif\n  ESPAutoWiFiConfig_setColor(0, 0, 128); // make led flash Blue instead of default light GREEN\n  if (ESPAutoWiFiConfigSetup(ledPin, highForLedOn, 0)) { // check if we should start access point to configure WiFi settings\n    return; // in config mode so skip rest of setup\n  }\n\n  // when we get here the WiFi has connected !!\n\n  // normal setup code that is run when not configuring the WiFi settings\n  startWebServer();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//  .. other code that MUST run all the time\n  if (ESPAutoWiFiConfigLoop()) {  // handle WiFi config webpages\n    return;  // skip the rest of the loop until config finished\n  }\n\n  // .. normal loop code here that is run when not configuring the WiFi settings\n  server.handleClient();"
        },
        {
          "name": "notFound",
          "parameters": "",
          "body": "server.send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "server.send(200, \"text/plain\", \"hello from esp8266!\\r\\n\");"
        },
        {
          "name": "startWebServer",
          "parameters": "",
          "body": "server.on(\"/\", handleRoot);\n  server.onNotFound(notFound);\n  server.begin();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "webserver",
        "rest",
        "wifi",
        "delay",
        "led",
        "eeprom"
      ],
      "libraries": [
        "ESPAutoWiFiConfig.h",
        "WiFi.h",
        "WiFiClient.h",
        "WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// setup code that must be run every time\n#ifdef DEBUG\n  Serial.begin(115200);\n  Serial.println();\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);\n  }\n  Serial.println();\n#endif\n\n#ifdef DEBUG\n  setESPAutoWiFiConfigDebugOut(Serial); // turns on debug output for the ESPAutoWiFiConfig code\n#endif\n\n  if (ESPAutoWiFiConfigSetup(ledPin, highForLedOn,0)) { // check if we should start access point to configure WiFi settings\n    return; // in config mode so skip rest of setup\n  }\n  \n  // when we get here the WiFi has connected !!\n  \n  // normal setup code that is run when not configuring the WiFi settings\n  startWebServer();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//  .. other code that MUST run all the time\n  if (ESPAutoWiFiConfigLoop()) {  // handle WiFi config webpages\n    return;  // skip the rest of the loop until config finished\n  }\n  \n  // .. normal loop code here that is run when not configuring the WiFi settings\n  server.handleClient();"
        },
        {
          "name": "notFound",
          "parameters": "",
          "body": "server.send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "server.send(200, \"text/plain\", \"hello from esp8266!\\r\\n\");"
        },
        {
          "name": "startWebServer",
          "parameters": "",
          "body": "server.on(\"/\", handleRoot);\n  server.onNotFound(notFound);\n  server.begin();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "token",
        "buffer",
        "stream",
        "power",
        "temperature",
        "current",
        "bluetooth",
        "spi",
        "delay",
        "digitalwrite",
        "led",
        "html"
      ],
      "libraries": [
        "BluetoothSerial.h",
        "SafeString.h",
        "loopTimer.h",
        "BufferedOutput.h",
        "millisDelay.h",
        "SafeStringReader.h",
        "AccelStepper.h",
        "MAX31856_noDelay.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);\n  }\n  Serial.println();\n  //SafeString::setOutput(Serial); //uncomment this to enable error msgs\n  serialBufferedOut.connect(Serial); // for debug\n\n  SerialBT.begin(\"DamperCtrl\"); //Bluetooth device name\n  bufferedOut.connect(SerialBT, 115200); // connect a non-blocking buffered stream to SerialBT\n  sfReader.connect(bufferedOut);\n  sfReader.echoOn(); // echo goes out via bufferedOut\n  sfReader.setTimeout(100); // set 100ms == 0.1sec non-blocking timeout\n\n  //initialize digital pin led as an output.\n  pinMode(led, OUTPUT);\n\n  maxthermo.begin();\n  maxthermo.setThermocoupleType(MAX31856_TCTYPE_K);\n\n  ledDelay.start(1000); // start the ledDelay, toggle every 1000ms\n  printDelay.start(5000); // start the printDelay, print every 5000ms\n  Serial.println(F(\"Enter simulated temperature, 0 to 100, or run  to start damper control or close to close the damper.\"));\n\n  stepper.setMaxSpeed(1000);\n  stepper.setSpeed(500); // need to call atleast every 2ms\n  stepper.setAcceleration(50);\n  Serial.println(\"The device started, now you can pair it with Classic bluetooth!\");"
        },
        {
          "name": "blinkLed7",
          "parameters": "bool stop",
          "body": "if (ledDelay.justFinished()) {   // check if delay has timed out\n    ledDelay.repeat(); // start delay again without drift\n    if (stop) {\n      digitalWrite(led, LOW); // turn led on/off\n      ledOn = false;\n      return;\n    }\n    ledOn = !ledOn;     // toggle the led\n    digitalWrite(led, ledOn ? HIGH : LOW); // turn led on/off\n  } // else nothing to do this call just return, quickly"
        },
        {
          "name": "printTemp",
          "parameters": "",
          "body": "if (printDelay.justFinished()) {\n    printDelay.repeat(); // start delay again without drift\n    //  runStepper(); // <<<< extra call here\n    bufferedOut.print(F(\"Temp:\")); bufferedOut.println(simulatedTempReading);\n    //  runStepper(); // <<<< extra call here\n    bufferedOut.print(F(\"Position current:\")); bufferedOut.print(stepper.currentPosition());\n    //  runStepper(); // <<<< extra call here\n    if (closeDampler) {\n      bufferedOut.println(F(\" Close Damper\"));\n    } else {\n      bufferedOut.println(F(\" Damper running\"));\n    }\n    //  runStepper(); // <<<< extra call here\n  } // else nothing to do this call just return, quickly"
        },
        {
          "name": "processUserInput",
          "parameters": "",
          "body": "if (sfReader.read()) { // echo input and 100ms timeout, non-blocking!!\n    sfReader.toLowerCase(); // ignore case\n    if (sfReader == \"close\") { // all lower case\n      closeDampler = true;\n    } else if (sfReader ==  \"run\") {\n      closeDampler = false;\n    } else { //try and convert as temp\n      float newSimulatedTempReading = simulatedTempReading;\n      if (!sfReader.toFloat(newSimulatedTempReading)) {\n        // conversion failed,  newSimulatedTempReading unchanged\n        bufferedOut.print(F(\" -- Invalid SimulatedTemp or close or run cmds.\"));\n      } else { // have valid float, check range\n        if ((newSimulatedTempReading < 0.0) || (newSimulatedTempReading > 100.0)) {\n          bufferedOut.print(F(\" -- Invalid SimulatedTemp must be between 0.0 and 100.0 \")); bufferedOut.println();\n        } else {\n          simulatedTempReading = newSimulatedTempReading; // update it\n        }\n      }\n    }\n  } // else token is empty"
        },
        {
          "name": "readTemp",
          "parameters": "",
          "body": "if (!readingStarted) { // start one now\n    maxthermo.oneShotTemperature();\n    // start delay to pick up results\n    max31856Delay.start(MAX31856_DELAY_MS);\n  }\n  if (max31856Delay.justFinished()) {\n    readingStarted = false;\n    // can pick up both results now\n    tempReading = maxthermo.readThermocoupleTemperature();\n    return 0; // new reading\n  }\n  return -1; // no new reading"
        },
        {
          "name": "setDamperPosition",
          "parameters": "",
          "body": "if (closeDampler) {\n    stepper.moveTo(0);\n  } else {\n    long stepPosition = simulatedTempReading * 50;\n    stepper.moveTo(stepPosition);\n  }"
        },
        {
          "name": "runStepper",
          "parameters": "",
          "body": "loopTimer.check(serialBufferedOut); // moved here from loop()\n  stepper.run();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bufferedOut.nextByteOut(); // call this one or more times each loop() to release buffered chars\n  processUserInput();\n  blinkLed7(closeDampler); // call the method to blink the led\n  printTemp(); // print the temp\n  int rtn = readTemp(); // check for errors here\n  if (rtn == 0) {\n    // have new reading\n  }\n  setDamperPosition();\n  runStepper();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "light",
        "delay",
        "lcd"
      ],
      "libraries": [
        "LovyanGFX.hpp",
        "driver/rtc_io.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "switch(esp_sleep_get_wakeup_cause())\n  {\n  case ESP_SLEEP_WAKEUP_EXT0 :\n  case ESP_SLEEP_WAKEUP_EXT1 :\n  case ESP_SLEEP_WAKEUP_TIMER :\n  case ESP_SLEEP_WAKEUP_TOUCHPAD :\n  case ESP_SLEEP_WAKEUP_ULP :\n    lcd.init_without_reset(); // deep sleep からの復帰時はinit_without_resetを呼び出す。\n    break;\n\n  default :\n    lcd.init();            // 通常起動時はinitを呼び出す。\n    lcd.clear(TFT_WHITE);\n    lcd.clear(TFT_BLACK);\n    lcd.startWrite();      // 背景を描画しておく\n    lcd.setColorDepth(24);\n    {\n      LGFX_Sprite sp(&lcd);\n      sp.createSprite(128, 128);\n      sp.createPalette();\n      for (int y = 0; y < 128; y++)\n        for (int x = 0; x < 128; x++)\n          sp.writePixel(x, y, sp.color888(x << 1, x + y, y << 1));\n      for (int y = 0; y < lcd.height(); y += 128)\n        for (int x = 0; x < lcd.width(); x += 128)\n          sp.pushSprite(x, y);\n    }\n    lcd.endWrite();\n    break;\n  }\n\n  ++bootCount;\n  lcd.setCursor(bootCount*6, bootCount*8);\n  lcd.setTextColor(TFT_WHITE, TFT_BLACK);  // 一度白黒反転した状態を描画する\n  lcd.print(\"DeepSleep test : \" + String(bootCount));\n  lcd.setCursor(bootCount*6, bootCount*8);\n  lcd.setTextColor(TFT_BLACK, TFT_WHITE);\n  lcd.print(\"DeepSleep test : \" + String(bootCount));\n  lcd.powerSaveOn(); // 省電力指定 M5Stack CoreInkで電源オフ時に色が薄くならないようにする\n  lcd.waitDisplay(); // 待機\n\n  auto pin_rst = (gpio_num_t)lcd.getPanel()->config().pin_rst;\n  if ((uint32_t)pin_rst < GPIO_NUM_MAX)\n  {\n    // RSTピンをRTC_GPIOで管理しhigh状態を維持する\n    rtc_gpio_set_level(pin_rst, 1);\n    rtc_gpio_set_direction(pin_rst, RTC_GPIO_MODE_OUTPUT_ONLY);\n    rtc_gpio_init(pin_rst);\n    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);\n  }\n\n  auto light = lcd.getPanel()->getLight();\n  if (light)\n  {\n    auto pin_bl = (gpio_num_t)((lgfx::Light_PWM*)light)->config().pin_bl;\n    if ((uint32_t)pin_bl < GPIO_NUM_MAX)\n    {\n      // BackLightピンをRTC_GPIOで管理しhigh状態を維持する\n      rtc_gpio_set_level(pin_bl, 1);\n      rtc_gpio_set_direction(pin_bl, RTC_GPIO_MODE_OUTPUT_ONLY);\n      rtc_gpio_init(pin_bl);\n      esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);\n    }\n  }\n\n  ESP_LOGW(\"sleep\");\n  esp_sleep_enable_timer_wakeup(1 * 1000 * 1000); // micro sec\n\n  esp_deep_sleep_start();"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "delay(10000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "millis",
        "digitalwrite",
        "delay",
        "littlefs",
        "spiffs",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32_WM_Config using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32_WM_Config using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32_WM_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"ESP32-WM-Config\");\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if (USE_LITTLEFS)\n    Serial.println(F(\"\\nBlynk ESP32 using LittleFS connected\"));\n#elif (USE_SPIFFS)\n    Serial.println(F(\"\\nBlynk ESP32 using SPIFFS connected.\"));\n#else\n    Serial.println(F(\"\\nBlynk ESP32 using EEPROM connected.\"));\n    Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "delay",
        "esp.restart",
        "millis",
        "digitalwrite",
        "littlefs",
        "spiffs",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32WM_ForcedConfig using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32WM_ForcedConfig using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32WM_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"ESP32-WM-Config\");\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if (USE_LITTLEFS)\n    Serial.println(F(\"\\nBlynk ESP32 using LittleFS connected\"));\n#elif (USE_SPIFFS)\n    Serial.println(F(\"\\nBlynk ESP32 using SPIFFS connected.\"));\n#else\n    Serial.println(F(\"\\nBlynk ESP32 using EEPROM connected.\"));\n    Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "millis",
        "digitalwrite",
        "delay",
        "littlefs",
        "spiffs",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n#if ( ARDUINO_ESP32S2_DEV || ARDUINO_FEATHERS2 || ARDUINO_PROS2 || ARDUINO_MICROS2 )\n  delay(2000);\n#else  \n  delay(200);\n#endif\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_Config using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_Config using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"ESP32-WM-Config\");\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if (USE_LITTLEFS)\n    Serial.println(F(\"\\nBlynk ESP32 using LittleFS connected\"));\n#elif (USE_SPIFFS)\n    Serial.println(F(\"\\nBlynk ESP32 using SPIFFS connected.\"));\n#else\n    Serial.println(F(\"\\nBlynk ESP32 using EEPROM connected.\"));\n    Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (int i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "delay",
        "esp.restart",
        "millis",
        "digitalwrite",
        "littlefs",
        "spiffs",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V17, String(temperature, 1));\n    Blynk.virtualWrite(V18, String(humidity, 1));\n  }\n  else\n  {\n    Blynk.virtualWrite(V17, \"NAN\");\n    Blynk.virtualWrite(V18, \"NAN\");\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_ForcedConfig using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_ForcedConfig using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32WM_MRD_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(BLYNK_WM_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n\n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 220, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 230), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  //Blynk.begin(\"ESP32-WM-Config\");\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if (USE_LITTLEFS)\n    Serial.println(F(\"\\nBlynk ESP32 using LittleFS connected\"));\n#elif (USE_SPIFFS)\n    Serial.println(F(\"\\nBlynk ESP32 using SPIFFS connected.\"));\n#else\n    Serial.println(F(\"\\nBlynk ESP32 using EEPROM connected.\"));\n    Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "ble",
        "bluetooth"
      ],
      "libraries": [
        "BlynkSimpleEsp32_BLE.h",
        "BLEDevice.h",
        "BLEServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.setDeviceName(\"Blynk\");\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "auth",
        "password",
        "token",
        "wifi",
        "bluetooth",
        "ble",
        "dns",
        "digitalwrite",
        "millis",
        "delay",
        "digitalread",
        "flash",
        "eeprom",
        "spiffs",
        "littlefs",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "noticeAlive",
          "parameters": "void",
          "body": "if (USE_BLE)\n    Blynk_BLE.virtualWrite(V0, F(\"OK\"));\n  else\n    Blynk_WF.virtualWrite(V0, F(\"OK\"));"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));    \n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "checkStatus",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {     \n    if (!USE_BLE)\n    {\n      // report Blynk connection\n      heartBeatPrint();\n    }\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \"));\n#else\n  Serial.print(F(\" without SSL on \"));\n#endif\n\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(BLYNK_ESP32_BT_WF_VERSION);\n  \n#if USE_BLYNK_WM  \n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  pinMode(WIFI_BLE_SELECTION_PIN, INPUT_PULLUP);\n\n#if BLYNK_USE_BLE_ONLY\n  Blynk_BLE.setDeviceName(BLE_Device_Name);\n\n  #if ESP32_BLE_WF_DEBUG\n  Serial.println(F(\"Blynk_BLE begin\"));\n  #endif\n\n  Blynk_BLE.begin(auth);\n#else\n  if (digitalRead(WIFI_BLE_SELECTION_PIN) == HIGH)\n  {\n    USE_BLE = false;\n    Serial.println(F(\"GPIO14 HIGH, Use WiFi\"));\n#if USE_BLYNK_WM\n#if ESP32_BLE_WF_DEBUG\n    Serial.println(F(\"USE_BLYNK_WM: Blynk_WF begin\"));\n#endif\n\n    // Set config portal SSID and Password\n    Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    // Set config portal IP address\n    Blynk.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  \n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n    Blynk_WF.setConfigPortalChannel(0);\n\n    // From v1.0.6, select either one of these to set static IP + DNS\n    Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n\n  //////////////////////////////////////////////\n    \n  #if USING_CUSTOMS_STYLE\n    Blynk.setCustomsStyle(NewCustomsStyle);\n  #endif\n  \n  #if USING_CUSTOMS_HEAD_ELEMENT\n    Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n  #endif\n  \n  #if USING_CORS_FEATURE  \n    Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n  #endif\n  \n    //////////////////////////////////////////////\n  \n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //Blynk.begin();\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n    //Blynk.begin(\"ESP32-BLE-WM\");\n  \n    Blynk_WF.begin(BLE_Device_Name);\n#else\n    //Blynk_WF.begin(auth, ssid, pass);\n#if ESP32_BLE_WF_DEBUG    \n    Serial.println(F(\"Not USE_BLYNK_WM: Blynk_WF begin\"));\n#endif    \n    Blynk_WF.begin(auth, ssid, pass, cloudBlynkServer.c_str(), BLYNK_SERVER_HARDWARE_PORT);\n#endif\n  }\n  else\n  {\n    USE_BLE = true;\n    Serial.println(F(\"GPIO14 LOW, Use BLE\"));\n    Blynk_BLE.setDeviceName(BLE_Device_Name);\n#if USE_BLYNK_WM\n    if (Blynk_WF.getBlynkBLEToken() == NO_CONFIG)        //String(\"blank\"))\n    {\n      Serial.println(F(\"No valid stored BLE auth. Have to run WiFi then enter config portal\"));\n      USE_BLE = false;\n\n#if ESP32_BLE_WF_DEBUG\n      Serial.println(F(\"USE_BLYNK_WM: No BLE Token. Blynk_WF begin\"));\n#endif  \n      \n      Blynk_WF.begin(BLE_Device_Name);\n    }\n    String BLE_auth = Blynk_WF.getBlynkBLEToken();\n#else\n    String BLE_auth = auth;\n#endif\n\n    if (USE_BLE)\n    {\n      Serial.print(F(\"Connecting Blynk via BLE, using auth = \"));\n      Serial.println(BLE_auth);\n\n#if ESP32_BLE_WF_DEBUG      \n      Serial.println(F(\"USE_BLE: Blynk_BLE begin\"));\n#endif   \n      \n      Blynk_BLE.begin(BLE_auth.c_str());\n    }\n  }\n#endif\n\n  // Important, need to keep constant communication to Blynk Server at least once per ~25s\n  // Or Blynk will lost and have to (auto)reconnect\n  timer.setInterval(10000L, noticeAlive);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if BLYNK_USE_BLE_ONLY\n  Blynk_BLE.run();\n#else\n  if (USE_BLE)\n    Blynk_BLE.run();\n  else\n    Blynk_WF.run();\n#endif\n\n  timer.run(); \n  checkStatus();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "auth",
        "password",
        "token",
        "wifi",
        "bluetooth",
        "ble",
        "dns",
        "digitalwrite",
        "millis",
        "digitalread",
        "flash",
        "eeprom",
        "spiffs",
        "littlefs",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "noticeAlive",
          "parameters": "void",
          "body": "if (USE_BT)\n    Blynk_BT.virtualWrite(V0, F(\"OK\"));\n  else\n    Blynk_WF.virtualWrite(V0, F(\"OK\"));"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));    \n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "checkStatus",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    if (!USE_BT)\n    {\n      // report Blynk connection\n      heartBeatPrint();\n    }\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting ESP32_BLE_WF using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \"));\n#else\n  Serial.print(F(\" without SSL on \"));\n#endif\n\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(BLYNK_ESP32_BT_WF_VERSION);\n  \n#if USE_BLYNK_WM  \n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  pinMode(WIFI_BT_SELECTION_PIN, INPUT_PULLUP);\n\n#if BLYNK_USE_BT_ONLY\n  Blynk_BT.setDeviceName(BT_Device_Name);\n\n#if ESP32_BT_WF_DEBUG\n  Serial.println(F(\"Blynk_BT begin\"));\n#endif\n  \n  Blynk_BT.begin(auth);\n#else\n  if (digitalRead(WIFI_BT_SELECTION_PIN) == HIGH)\n  {\n    USE_BT = false;\n    Serial.println(F(\"GPIO14 HIGH, Use WiFi\"));\n#if USE_BLYNK_WM\n#if ESP32_BT_WF_DEBUG\n    Serial.println(F(\"USE_BLYNK_WM: Blynk_WF begin\"));\n#endif\n    // Set config portal SSID and Password\n    Blynk.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    // Set config portal IP address\n    Blynk.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  \n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13 to avoid conflict\n    Blynk_WF.setConfigPortalChannel(0);\n\n    // From v1.0.6, select either one of these to set static IP + DNS\n    Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n    //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n    //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n    //////////////////////////////////////////////\n    \n  #if USING_CUSTOMS_STYLE\n    Blynk.setCustomsStyle(NewCustomsStyle);\n  #endif\n  \n  #if USING_CUSTOMS_HEAD_ELEMENT\n    Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n  #endif\n  \n  #if USING_CORS_FEATURE  \n    Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n  #endif\n  \n    //////////////////////////////////////////////\n\n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //Blynk.begin();\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n    //Blynk.begin(\"ESP32-BT-WM\");\n    \n    Blynk_WF.begin(BT_Device_Name);\n#else\n    //Blynk_WF.begin(auth, ssid, pass);\n#if ESP32_BT_WF_DEBUG    \n    Serial.println(F(\"Not USE_BLYNK_WM: Blynk_WF begin\"));\n#endif    \n    Blynk_WF.begin(auth, ssid, pass, cloudBlynkServer.c_str(), BLYNK_SERVER_HARDWARE_PORT);\n#endif\n  }\n  else\n  {\n    USE_BT = true;\n    Serial.println(F(\"GPIO14 LOW, Use BT\"));\n    Blynk_BT.setDeviceName(BT_Device_Name);\n#if USE_BLYNK_WM\n    if (Blynk_WF.getBlynkBTToken() == NO_CONFIG)        //String(\"blank\"))\n    {\n      Serial.println(F(\"No valid stored BT auth. Have to run WiFi then enter config portal\"));\n      USE_BT = false;\n\n#if ESP32_BT_WF_DEBUG\n      Serial.println(F(\"USE_BLYNK_WM: No BT Token. Blynk_WF begin\"));\n#endif\n\n      Blynk_WF.begin(BT_Device_Name);\n    }\n    String BT_auth = Blynk_WF.getBlynkBTToken();\n#else\n    String BT_auth = auth;\n#endif\n\n    if (USE_BT)\n    {\n      Serial.print(F(\"Connecting Blynk via BT, using auth = \"));\n      Serial.println(BT_auth);\n\n#if ESP32_BT_WF_DEBUG      \n      Serial.println(F(\"USE_BT: Blynk_BT begin\"));\n#endif\n\n      Blynk_BT.begin(BT_auth.c_str());\n    }\n  }\n#endif\n\n  // Important, need to keep constant communication to Blynk Server at least once per ~25s\n  // Or Blynk will lost and have to (auto)reconnect\n  timer.setInterval(10000L, noticeAlive);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "#if BLYNK_USE_BT_ONLY\n  Blynk_BT.run();\n#else\n  if (USE_BT)\n    Blynk_BT.run();\n  else\n    Blynk_WF.run();\n#endif\n\n  timer.run();\n  checkStatus();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "password",
        "stream",
        "json",
        "callback",
        "current",
        "dns",
        "ntp",
        "spi",
        "wifi",
        "digitalwrite",
        "digitalread",
        "millis",
        "delay",
        "analogread",
        "display",
        "led",
        "spiffs",
        "littlefs",
        "eeprom",
        "sd",
        "html",
        "css",
        "javascript",
        "gatewayip"
      ],
      "libraries": [
        "WebServer.h",
        "ESPmDNS.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "ETH_STA_IPConfig &in_EthSTA_IPconfig",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "ETH_STA_IPConfig in_EthSTA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024)\n  {\n    return String(bytes) + \"B\";\n  }\n  else if (bytes < (1024 * 1024))\n  {\n    return String(bytes / 1024.0) + \"KB\";\n  }\n  else if (bytes < (1024 * 1024 * 1024))\n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  }\n  else\n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "getContentType",
          "parameters": "String filename",
          "body": "if (server.hasArg(\"download\"))\n  {\n    return \"application/octet-stream\";\n  }\n  else if (filename.endsWith(\".htm\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".html\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".css\"))\n  {\n    return \"text/css\";\n  }\n  else if (filename.endsWith(\".js\"))\n  {\n    return \"application/javascript\";\n  }\n  else if (filename.endsWith(\".png\"))\n  {\n    return \"image/png\";\n  }\n  else if (filename.endsWith(\".gif\"))\n  {\n    return \"image/gif\";\n  }\n  else if (filename.endsWith(\".jpg\"))\n  {\n    return \"image/jpeg\";\n  }\n  else if (filename.endsWith(\".ico\"))\n  {\n    return \"image/x-icon\";\n  }\n  else if (filename.endsWith(\".xml\"))\n  {\n    return \"text/xml\";\n  }\n  else if (filename.endsWith(\".pdf\"))\n  {\n    return \"application/x-pdf\";\n  }\n  else if (filename.endsWith(\".zip\"))\n  {\n    return \"application/x-zip\";\n  }\n  else if (filename.endsWith(\".gz\"))\n  {\n    return \"application/x-gzip\";\n  }\n\n  return \"text/plain\";"
        },
        {
          "name": "handleFileRead",
          "parameters": "String path",
          "body": "Serial.println(\"handleFileRead: \" + path);\n\n  if (path.endsWith(\"/\"))\n  {\n    path += \"index.htm\";\n  }\n\n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n\n  if (filesystem->exists(pathWithGz) || filesystem->exists(path))\n  {\n    if (filesystem->exists(pathWithGz))\n    {\n      path += \".gz\";\n    }\n\n    File file = filesystem->open(path, \"r\");\n    server.streamFile(file, contentType);\n    file.close();\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleFileUpload",
          "parameters": "",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;\n  }\n\n  HTTPUpload& upload = server.upload();\n\n  if (upload.status == UPLOAD_FILE_START)\n  {\n    String filename = upload.filename;\n\n    if (!filename.startsWith(\"/\"))\n    {\n      filename = \"/\" + filename;\n    }\n\n    Serial.print(F(\"handleFileUpload Name: \"));\n    Serial.println(filename);\n    fsUploadFile = filesystem->open(filename, \"w\");\n    filename.clear();\n  }\n  else if (upload.status == UPLOAD_FILE_WRITE)\n  {\n    //Serial.print(F(\"handleFileUpload Data: \")); Serial.println(upload.currentSize);\n    if (fsUploadFile)\n    {\n      fsUploadFile.write(upload.buf, upload.currentSize);\n    }\n  }\n  else if (upload.status == UPLOAD_FILE_END)\n  {\n    if (fsUploadFile)\n    {\n      fsUploadFile.close();\n    }\n\n    Serial.print(F(\"handleFileUpload Size: \"));\n    Serial.println(upload.totalSize);\n  }"
        },
        {
          "name": "handleFileDelete",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileDelete: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (!filesystem->exists(path))\n  {\n    return server.send(404, \"text/plain\", \"FileNotFound\");\n  }\n\n  filesystem->remove(path);\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileCreate",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileCreate: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (filesystem->exists(path))\n  {\n    return server.send(500, \"text/plain\", \"FILE EXISTS\");\n  }\n\n  File file = filesystem->open(path, \"w\");\n\n  if (file)\n  {\n    file.close();\n  }\n  else\n  {\n    return server.send(500, \"text/plain\", \"CREATE FAILED\");\n  }\n\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileList",
          "parameters": "",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;\n  }\n\n  String path = server.arg(\"dir\");\n  Serial.println(\"handleFileList: \" + path);\n\n  File root = filesystem->open(path);\n  path = String();\n\n  String output = \"[\";\n\n  if (root.isDirectory())\n  {\n    File file = root.openNextFile();\n\n    while (file)\n    {\n      if (output != \"[\")\n      {\n        output += ',';\n      }\n\n      output += \"{\\\"type\\\":\\\"\";\n      output += (file.isDirectory()) ? \"dir\" : \"file\";\n      output += \"\\\",\\\"name\\\":\\\"\";\n      //output += String(file.name()).substring(1);\n      output += String(file.name()).substring(0);\n      output += \"\\\"}\";\n      file = root.openNextFile();\n    }\n  }\n\n  output += \"]\";\n\n  Serial.println(\"handleFileList: \" + output);\n\n  server.send(200, \"text/json\", output);"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n\n#endif"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n\n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadCfgFile \"));\n\n  memset((void *) &Ethconfig,       0, sizeof(Ethconfig));\n  memset((void *) &EthSTA_IPconfig, 0, sizeof(EthSTA_IPconfig));\n\n  if (file)\n  {\n    file.readBytes((char *) &Ethconfig,   sizeof(Ethconfig));\n    file.readBytes((char *) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n\n    if ( Ethconfig.checksum != calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) ) )\n    {\n      LOGERROR(F(\"Ethconfig checksum wrong\"));\n\n      return false;\n    }\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "beginEthernet",
          "parameters": "",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP32_FSWebServer using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  File root = FileFS.open(\"/\");\n  File file = root.openNextFile();\n\n  while (file)\n  {\n    String fileName = file.name();\n    size_t fileSize = file.size();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n    file = root.openNextFile();\n  }\n\n  Serial.println();\n\n  unsigned long startedAt = millis();\n\n  beginEthernet();\n\n  initSTAIPConfigStruct(EthSTA_IPconfig);\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP32-XXXXXX\n  //ESP32_W6100_Manager ESP32_W6100_manager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP32_W6100_Manager ESP32_W6100_manager(\"ESP32-FSWebServer\");\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask)\n  ESP32_W6100_manager.setSTAStaticIPConfig(EthSTA_IPconfig);\n#endif\n\n#if USING_CORS_FEATURE\n  ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  bool configDataLoaded = loadConfigData();\n\n  //////////////////////////////////\n\n  // Connect ETH now if using STA\n  initEthernet();\n\n  //////////////////////////////////\n\n  if (configDataLoaded)\n  {\n#if USE_ESP_ETH_MANAGER_NTP\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n  }\n  else\n  {\n    Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n\n    initialConfig = true;\n\n    Serial.print(F(\"Starting configuration portal @ \"));\n    Serial.println(ETH.localIP());\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP32_W6100_manager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n  }\n\n  startedAt = millis();\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (ESP32_W6100_isConnected())\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(ETH.localIP());\n  }\n\n  //SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n\n  //load editor\n  server.on(\"/edit\", HTTP_GET, []()\n  {\n    if (!handleFileRead(\"/edit.htm\"))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //create file\n  server.on(\"/edit\", HTTP_PUT, handleFileCreate);\n\n  //delete file\n  server.on(\"/edit\", HTTP_DELETE, handleFileDelete);\n\n  //first callback is called after the request has ended with all parsed arguments\n  //second callback handles file uploads at that location\n  server.on(\"/edit\", HTTP_POST, []()\n  {\n    server.send(200, \"text/plain\", \"\");\n  }, handleFileUpload);\n\n  //called when the url is not defined here\n  //use it to load content from SPIFFS\n  server.onNotFound([]()\n  {\n    if (!handleFileRead(server.uri()))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //get heap status, analog input value and all GPIO statuses in one json call\n  server.on(\"/all\", HTTP_GET, []()\n  {\n    String json = \"{\";\n    json += \"\\\"heap\\\":\" + String(ESP.getFreeHeap());\n    json += \", \\\"analog\\\":\" + String(analogRead(A0));\n    json += \", \\\"gpio\\\":\" + String((uint32_t)(0));\n    json += \"}\";\n    server.send(200, \"text/json\", json);\n    json = String();\n  });\n\n  server.begin();\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(ETH.localIP());\n\n  MDNS.begin(host);\n  // Add service to MDNS-SD\n  MDNS.addService(\"http\", \"tcp\", HTTP_PORT);\n\n  //////////////////////////////////////////////////////////////\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(ETH.localIP());\n\n  Serial.println(separatorLine);\n  Serial.print(\"Open http://\");\n  Serial.print(ETH.localIP());\n  Serial.println(\"/edit to see the file browser\");\n  Serial.println(\"Using username = \" + http_username + \" and password = \" + http_password);\n  Serial.println(separatorLine);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();\n\n  // this is just for checking if we are alive and connected to WiFi\n  check_status();;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "asyncwebserver",
        "https",
        "password",
        "stream",
        "json",
        "callback",
        "current",
        "dns",
        "ntp",
        "spi",
        "wifi",
        "digitalwrite",
        "digitalread",
        "millis",
        "delay",
        "analogread",
        "display",
        "led",
        "spiffs",
        "littlefs",
        "eeprom",
        "flash",
        "sd",
        "rtc",
        "html",
        "css",
        "javascript",
        "gatewayip"
      ],
      "libraries": [
        "WebServer.h",
        "ESPmDNS.h",
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP32_W6100_Manager.h"
      ],
      "functions": [
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "ETH_STA_IPConfig &in_EthSTA_IPconfig",
          "body": "in_EthSTA_IPconfig._sta_static_ip   = stationIP;\n  in_EthSTA_IPconfig._sta_static_gw   = gatewayIP;\n  in_EthSTA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_EthSTA_IPconfig._sta_static_dns1 = dns1IP;\n  in_EthSTA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "ETH_STA_IPConfig in_EthSTA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_EthSTA_IPconfig._sta_static_ip, \", gatewayIP =\", in_EthSTA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_EthSTA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_EthSTA_IPconfig._sta_static_dns1, \", dns2IP =\", in_EthSTA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024)\n  {\n    return String(bytes) + \"B\";\n  }\n  else if (bytes < (1024 * 1024))\n  {\n    return String(bytes / 1024.0) + \"KB\";\n  }\n  else if (bytes < (1024 * 1024 * 1024))\n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  }\n  else\n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "getContentType",
          "parameters": "String filename",
          "body": "if (server.hasArg(\"download\"))\n  {\n    return \"application/octet-stream\";\n  }\n  else if (filename.endsWith(\".htm\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".html\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".css\"))\n  {\n    return \"text/css\";\n  }\n  else if (filename.endsWith(\".js\"))\n  {\n    return \"application/javascript\";\n  }\n  else if (filename.endsWith(\".png\"))\n  {\n    return \"image/png\";\n  }\n  else if (filename.endsWith(\".gif\"))\n  {\n    return \"image/gif\";\n  }\n  else if (filename.endsWith(\".jpg\"))\n  {\n    return \"image/jpeg\";\n  }\n  else if (filename.endsWith(\".ico\"))\n  {\n    return \"image/x-icon\";\n  }\n  else if (filename.endsWith(\".xml\"))\n  {\n    return \"text/xml\";\n  }\n  else if (filename.endsWith(\".pdf\"))\n  {\n    return \"application/x-pdf\";\n  }\n  else if (filename.endsWith(\".zip\"))\n  {\n    return \"application/x-zip\";\n  }\n  else if (filename.endsWith(\".gz\"))\n  {\n    return \"application/x-gzip\";\n  }\n\n  return \"text/plain\";"
        },
        {
          "name": "handleFileRead",
          "parameters": "String path",
          "body": "Serial.println(\"handleFileRead: \" + path);\n\n  if (path.endsWith(\"/\"))\n  {\n    path += \"index.htm\";\n  }\n\n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n\n  if (filesystem->exists(pathWithGz) || filesystem->exists(path))\n  {\n    if (filesystem->exists(pathWithGz))\n    {\n      path += \".gz\";\n    }\n\n    File file = filesystem->open(path, \"r\");\n    server.streamFile(file, contentType);\n    file.close();\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleFileUpload",
          "parameters": "",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;\n  }\n\n  HTTPUpload& upload = server.upload();\n\n  if (upload.status == UPLOAD_FILE_START)\n  {\n    String filename = upload.filename;\n\n    if (!filename.startsWith(\"/\"))\n    {\n      filename = \"/\" + filename;\n    }\n\n    Serial.print(F(\"handleFileUpload Name: \"));\n    Serial.println(filename);\n    fsUploadFile = filesystem->open(filename, \"w\");\n    filename.clear();\n  }\n  else if (upload.status == UPLOAD_FILE_WRITE)\n  {\n    //Serial.print(F(\"handleFileUpload Data: \")); Serial.println(upload.currentSize);\n    if (fsUploadFile)\n    {\n      fsUploadFile.write(upload.buf, upload.currentSize);\n    }\n  }\n  else if (upload.status == UPLOAD_FILE_END)\n  {\n    if (fsUploadFile)\n    {\n      fsUploadFile.close();\n    }\n\n    Serial.print(F(\"handleFileUpload Size: \"));\n    Serial.println(upload.totalSize);\n  }"
        },
        {
          "name": "handleFileDelete",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileDelete: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (!filesystem->exists(path))\n  {\n    return server.send(404, \"text/plain\", \"FileNotFound\");\n  }\n\n  filesystem->remove(path);\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileCreate",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileCreate: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (filesystem->exists(path))\n  {\n    return server.send(500, \"text/plain\", \"FILE EXISTS\");\n  }\n\n  File file = filesystem->open(path, \"w\");\n\n  if (file)\n  {\n    file.close();\n  }\n  else\n  {\n    return server.send(500, \"text/plain\", \"CREATE FAILED\");\n  }\n\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileList",
          "parameters": "",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;\n  }\n\n  String path = server.arg(\"dir\");\n  Serial.println(\"handleFileList: \" + path);\n\n  File root = filesystem->open(path);\n  path = String();\n\n  String output = \"[\";\n\n  if (root.isDirectory())\n  {\n    File file = root.openNextFile();\n\n    while (file)\n    {\n      if (output != \"[\")\n      {\n        output += ',';\n      }\n\n      output += \"{\\\"type\\\":\\\"\";\n      output += (file.isDirectory()) ? \"dir\" : \"file\";\n      output += \"\\\",\\\"name\\\":\\\"\";\n      //output += String(file.name()).substring(1);\n      output += String(file.name()).substring(0);\n      output += \"\\\"}\";\n      file = root.openNextFile();\n    }\n  }\n\n  output += \"]\";\n\n  Serial.println(\"handleFileList: \" + output);\n\n  server.send(200, \"text/json\", output);"
        },
        {
          "name": "toggleLED",
          "parameters": "",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000.\n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_ETH_MANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n\n#endif"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n\n  static ulong current_millis;\n\n#if USE_ESP_ETH_MANAGER_NTP\n#define HEARTBEAT_INTERVAL    60000L\n#else\n#define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n\n  if ((current_millis > LEDstatus_timeout) || (LEDstatus_timeout == 0))\n  {\n    // Toggle LED at LED_INTERVAL = 2s\n    toggleLED();\n    LEDstatus_timeout = current_millis + LED_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n\n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadCfgFile \"));\n\n  memset((void *) &Ethconfig,       0, sizeof(Ethconfig));\n  memset((void *) &EthSTA_IPconfig, 0, sizeof(EthSTA_IPconfig));\n\n  if (file)\n  {\n    file.readBytes((char *) &Ethconfig,   sizeof(Ethconfig));\n    file.readBytes((char *) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n\n    if ( Ethconfig.checksum != calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) ) )\n    {\n      LOGERROR(F(\"Ethconfig checksum wrong\"));\n\n      return false;\n    }\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveCfgFile \"));\n\n  if (file)\n  {\n    Ethconfig.checksum = calcChecksum( (uint8_t*) &Ethconfig, sizeof(Ethconfig) - sizeof(Ethconfig.checksum) );\n\n    file.write((uint8_t*) &Ethconfig, sizeof(Ethconfig));\n\n    displayIPConfigStruct(EthSTA_IPconfig);\n\n    file.write((uint8_t*) &EthSTA_IPconfig, sizeof(EthSTA_IPconfig));\n    file.close();\n\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "beginEthernet",
          "parameters": "",
          "body": "LOGWARN(F(\"Default SPI pinout:\"));\n  LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if !( USE_DHCP_IP )\n  displayIPConfigStruct(EthSTA_IPconfig);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(stationIP, gatewayIP, netMask, dns1IP, dns2IP);\n  ETH.config(EthSTA_IPconfig._sta_static_ip, EthSTA_IPconfig._sta_static_gw, EthSTA_IPconfig._sta_static_sn,\n             EthSTA_IPconfig._sta_static_dns1);\n#endif\n\n  ESP32_W6100_waitForConnect();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP32_FSWebServer_DRD using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP32_W6100_MANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n  Serial.setDebugOutput(false);\n\n  if (FORMAT_FILESYSTEM)\n    FileFS.format();\n\n  // Format FileFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      // prevents debug info from the library to hide err message.\n      delay(100);\n\n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  File root = FileFS.open(\"/\");\n  File file = root.openNextFile();\n\n  while (file)\n  {\n    String fileName = file.name();\n    size_t fileSize = file.size();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n    file = root.openNextFile();\n  }\n\n  Serial.println();\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n\n  if (!drd)\n    Serial.println(F(\"Can't instantiate. Disable DRD feature\"));\n\n  unsigned long startedAt = millis();\n\n  beginEthernet();\n\n  initSTAIPConfigStruct(EthSTA_IPconfig);\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP32-XXXXXX\n  //ESP32_W6100_Manager ESP32_W6100_manager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP32_W6100_Manager ESP32_W6100_manager(\"ESP32-FSWebServer_DRD\");\n\n#if !USE_DHCP_IP\n  // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask)\n  ESP32_W6100_manager.setSTAStaticIPConfig(EthSTA_IPconfig);\n#endif\n\n#if USING_CORS_FEATURE\n  ESP32_W6100_manager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  bool configDataLoaded = loadConfigData();\n\n  //////////////////////////////////\n\n  // Connect ETH now if using STA\n  initEthernet();\n\n  //////////////////////////////////\n\n  if (configDataLoaded)\n  {\n    //If no access point name has been previously entered disable timeout.\n    ESP32_W6100_manager.setConfigPortalTimeout(120);\n\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\"));\n\n#if USE_ESP_ETH_MANAGER_NTP\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESP32_W6100_manager.setConfigPortalTimeout(0);\n\n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    Serial.println(ETH.localIP());\n\n    //sets timeout in seconds until configuration portal gets turned off.\n    //If not specified device will remain in configuration mode until\n    //switched off via webserver or device is restarted.\n    //ESP32_W6100_manager.setConfigPortalTimeout(600);\n\n    // Starts an access point\n    if (!ESP32_W6100_manager.startConfigPortal())\n      Serial.println(F(\"Not connected to ETH network but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"ETH network connected...yeey :)\"));\n    }\n\n#if USE_ESP_ETH_MANAGER_NTP\n    String tempTZ   = ESP32_W6100_manager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(Ethconfig.TZ_Name) - 1)\n      strcpy(Ethconfig.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(Ethconfig.TZ_Name, tempTZ.c_str(), sizeof(Ethconfig.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP32_W6100_manager.getTZ(Ethconfig.TZ_Name);\n\n    if (strlen(TZ_Result) < sizeof(Ethconfig.TZ) - 1)\n      strcpy(Ethconfig.TZ, TZ_Result);\n    else\n      strncpy(Ethconfig.TZ, TZ_Result, sizeof(Ethconfig.TZ_Name) - 1);\n\n    if ( strlen(Ethconfig.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), Ethconfig.TZ_Name, F(\", TZ = \"), Ethconfig.TZ);\n\n      //configTzTime(Ethconfig.TZ, \"pool.ntp.org\" );\n      configTzTime(Ethconfig.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n\n#endif\n\n    ESP32_W6100_manager.getSTAStaticIPConfig(EthSTA_IPconfig);\n\n    saveConfigData();\n  }\n\n  startedAt = millis();\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (ESP32_W6100_isConnected())\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(ETH.localIP());\n  }\n\n  //SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n\n  //load editor\n  server.on(\"/edit\", HTTP_GET, []()\n  {\n    if (!handleFileRead(\"/edit.htm\"))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //create file\n  server.on(\"/edit\", HTTP_PUT, handleFileCreate);\n\n  //delete file\n  server.on(\"/edit\", HTTP_DELETE, handleFileDelete);\n\n  //first callback is called after the request has ended with all parsed arguments\n  //second callback handles file uploads at that location\n  server.on(\"/edit\", HTTP_POST, []()\n  {\n    server.send(200, \"text/plain\", \"\");\n  }, handleFileUpload);\n\n  //called when the url is not defined here\n  //use it to load content from SPIFFS\n  server.onNotFound([]()\n  {\n    if (!handleFileRead(server.uri()))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //get heap status, analog input value and all GPIO statuses in one json call\n  server.on(\"/all\", HTTP_GET, []()\n  {\n    String json = \"{\";\n    json += \"\\\"heap\\\":\" + String(ESP.getFreeHeap());\n    json += \", \\\"analog\\\":\" + String(analogRead(A0));\n    json += \", \\\"gpio\\\":\" + String((uint32_t)(0));\n    json += \"}\";\n    server.send(200, \"text/json\", json);\n    json = String();\n  });\n\n  server.begin();\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());\n\n  MDNS.begin(host);\n  // Add service to MDNS-SD\n  MDNS.addService(\"http\", \"tcp\", HTTP_PORT);\n\n  //////////////////////////////////////////////////////////////\n\n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(ETH.localIP());\n\n  Serial.println(separatorLine);\n  Serial.print(\"Open http://\");\n  Serial.print(ETH.localIP());\n  Serial.println(\"/edit to see the file browser\");\n  Serial.println(\"Using username = \" + http_username + \" and password = \" + http_password);\n  Serial.println(separatorLine);\n\n  digitalWrite(LED_BUILTIN, LED_OFF);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // this is just for checking if we are alive and connected to WiFi\n  check_status();\n\n  server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "stream",
        "json",
        "callback",
        "current",
        "power",
        "spi",
        "dns",
        "millis",
        "delay",
        "analogread",
        "littlefs",
        "spiffs",
        "html",
        "css",
        "javascript"
      ],
      "libraries": [
        "FS.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "WebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));        // H means alive\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong current_millis;\n\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024)\n  {\n    return String(bytes) + \"B\";\n  }\n  else if (bytes < (1024 * 1024))\n  {\n    return String(bytes / 1024.0) + \"KB\";\n  }\n  else if (bytes < (1024 * 1024 * 1024))\n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  }\n  else\n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "getContentType",
          "parameters": "String filename",
          "body": "if (server.hasArg(\"download\"))\n  {\n    return \"application/octet-stream\";\n  }\n  else if (filename.endsWith(\".htm\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".html\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".css\"))\n  {\n    return \"text/css\";\n  }\n  else if (filename.endsWith(\".js\"))\n  {\n    return \"application/javascript\";\n  }\n  else if (filename.endsWith(\".png\"))\n  {\n    return \"image/png\";\n  }\n  else if (filename.endsWith(\".gif\"))\n  {\n    return \"image/gif\";\n  }\n  else if (filename.endsWith(\".jpg\"))\n  {\n    return \"image/jpeg\";\n  }\n  else if (filename.endsWith(\".ico\"))\n  {\n    return \"image/x-icon\";\n  }\n  else if (filename.endsWith(\".xml\"))\n  {\n    return \"text/xml\";\n  }\n  else if (filename.endsWith(\".pdf\"))\n  {\n    return \"application/x-pdf\";\n  }\n  else if (filename.endsWith(\".zip\"))\n  {\n    return \"application/x-zip\";\n  }\n  else if (filename.endsWith(\".gz\"))\n  {\n    return \"application/x-gzip\";\n  }\n  return \"text/plain\";"
        },
        {
          "name": "handleFileRead",
          "parameters": "String path",
          "body": "Serial.println(\"handleFileRead: \" + path);\n  if (path.endsWith(\"/\"))\n  {\n    path += \"index.htm\";\n  }\n\n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n\n  if (filesystem->exists(pathWithGz) || filesystem->exists(path))\n  {\n    if (filesystem->exists(pathWithGz))\n    {\n      path += \".gz\";\n    }\n\n    File file = filesystem->open(path, \"r\");\n    server.streamFile(file, contentType);\n    file.close();\n    return true;\n  }\n  return false;"
        },
        {
          "name": "handleFileDelete",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileDelete: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (!filesystem->exists(path))\n  {\n    return server.send(404, \"text/plain\", \"FileNotFound\");\n  }\n\n  filesystem->remove(path);\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileCreate",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileCreate: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (filesystem->exists(path))\n  {\n    return server.send(500, \"text/plain\", \"FILE EXISTS\");\n  }\n\n  File file = filesystem->open(path, \"w\");\n\n  if (file)\n  {\n    file.close();\n  }\n  else\n  {\n    return server.send(500, \"text/plain\", \"CREATE FAILED\");\n  }\n\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileUpload",
          "parameters": "",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;\n  }\n\n  HTTPUpload& upload = server.upload();\n\n  if (upload.status == UPLOAD_FILE_START)\n  {\n    String filename = upload.filename;\n\n    if (!filename.startsWith(\"/\"))\n    {\n      filename = \"/\" + filename;\n    }\n\n    Serial.print(F(\"handleFileUpload Name: \")); Serial.println(filename);\n    fsUploadFile = filesystem->open(filename, \"w\");\n    filename.clear();\n  }\n  else if (upload.status == UPLOAD_FILE_WRITE)\n  {\n    //Serial.print(F(\"handleFileUpload Data: \")); Serial.println(upload.currentSize);\n\n    if (fsUploadFile)\n    {\n      fsUploadFile.write(upload.buf, upload.currentSize);\n    }\n  }\n  else if (upload.status == UPLOAD_FILE_END)\n  {\n    if (fsUploadFile)\n    {\n      fsUploadFile.close();\n    }\n\n    Serial.print(F(\"handleFileUpload Size: \")); Serial.println(upload.totalSize);\n  }"
        },
        {
          "name": "handleFileList",
          "parameters": "",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;\n  }\n\n  String path = server.arg(\"dir\");\n  Serial.println(\"handleFileList: \" + path);\n\n  File root = FileFS.open(path);\n  path = String();\n\n  String output = \"[\";\n\n  if (root.isDirectory())\n  {\n    File file = root.openNextFile();\n\n    while (file)\n    {\n      if (output != \"[\")\n      {\n        output += ',';\n      }\n\n      output += \"{\\\"type\\\":\\\"\";\n      output += (file.isDirectory()) ? \"dir\" : \"file\";\n      output += \"\\\",\\\"name\\\":\\\"\";\n      output += String(file.name()).substring(1);\n      output += \"\\\"}\";\n      file = root.openNextFile();\n    }\n  }\n\n  output += \"]\";\n\n  Serial.println(\"handleFileList: \" + output);\n\n  server.send(200, \"text/json\", output);"
        },
        {
          "name": "initFS",
          "parameters": "",
          "body": "// Initialize LittleFS/SPIFFS file-system\n  // Format SPIFFS if not yet\n  if (!FileFS.begin(true))\n  {\n    Serial.println(F(\"SPIFFS/LittleFS failed! Formatting.\"));\n\n    if (!FileFS.begin())\n    {\n      while (true)\n      {\n#if USE_LITTLEFS\n        Serial.println(F(\"LittleFS failed!. Please use SPIFFS.\"));\n#else\n        Serial.println(F(\"SPIFFS failed!. Please use LittleFS.\"));\n#endif\n        // Stay forever here as useless to go further\n        delay(5000);\n      }\n    }\n  }"
        },
        {
          "name": "listDir",
          "parameters": "",
          "body": "File root = FileFS.open(\"/\");\n  File file = root.openNextFile();\n  while (file)\n  {\n    String fileName = file.name();\n    size_t fileSize = file.size();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n    file = root.openNextFile();\n  }\n\n  Serial.println();"
        },
        {
          "name": "initWebserver",
          "parameters": "",
          "body": "//SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n\n  //load editor\n  server.on(\"/edit\", HTTP_GET, []()\n  {\n    if (!handleFileRead(\"/edit.htm\"))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //create file\n  server.on(\"/edit\", HTTP_PUT, handleFileCreate);\n\n  //delete file\n  server.on(\"/edit\", HTTP_DELETE, handleFileDelete);\n\n  //first callback is called after the request has ended with all parsed arguments\n  //second callback handles file uploads at that location\n  server.on(\"/edit\", HTTP_POST, []()\n  {\n    server.send(200, \"text/plain\", \"\");\n  }, handleFileUpload);\n\n  //called when the url is not defined here\n  //use it to load content from SPIFFS\n  server.onNotFound([]()\n  {\n    if (!handleFileRead(server.uri()))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //get heap status, analog input value and all GPIO statuses in one json call\n  server.on(\"/all\", HTTP_GET, []()\n  {\n    String json = \"{\";\n    json += \"\\\"heap\\\":\" + String(ESP.getFreeHeap());\n    json += \", \\\"analog\\\":\" + String(analogRead(A0));\n    json += \", \\\"gpio\\\":\" + String((uint32_t)(0));\n    json += \"}\";\n    server.send(200, \"text/json\", json);\n    json = String();\n  });\n\n  // Web Page handlers\n  server.serveStatic(\"/\", FileFS, \"/page1.html\");\n  server.serveStatic(\"/page2\", FileFS, \"/page2.html\");\n  server.serveStatic(\"/page3\", FileFS, \"/page3.html\");\n\n  //server.serveStatic(\"/\", SPIFFS, \"/page1.html\");\n  //server.serveStatic(\"/page2\", SPIFFS, \"/page2.html\");\n  //server.serveStatic(\"/page3\", SPIFFS, \"/page3.html\");\n\n  // Other usage with various web site assets:\n  // server.serveStatic(\"/assets/css/test.css\", SPIFFS, \"/assets/css/test.css\"); // Style sheet\n  // server.serveStatic(\"/assets/js/test_script.js\", SPIFFS,\"/assets/js/test_script.js\"); // Javascript\n  // server.serveStatic(\"/assets/font/fonticons.ttf\", SPIFFS,\"/assets/font/fonticons.ttf\"); // font\n  // server.serveStatic(\"/assets/picture.png\", SPIFFS,\"/assets/picture.png\"); // Picture\n\n  server.begin();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting ESP32_FS_EthernetWebServer on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  initFS();\n  listDir();\n  initWebserver();\n\n  Serial.print(\"HTTP server started @\");\n  Serial.println(ETH.localIP());\n\n  Serial.print(F(\"Open http://\"));\n  Serial.print(ETH.localIP());\n  Serial.println(F(\"/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "power",
        "gsm",
        "gprs",
        "wifi",
        "dns",
        "millis",
        "delay",
        "digitalwrite",
        ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp32_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp32_config);\n\n  serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (Blynk_GSM.connected())\n  {\n    Serial.print(F(\"G\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n  \n  SerialMon.print(F(\"\\nStart ESP32_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n\n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  //SerialAT.begin(115200);\n  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP32-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP32_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP32_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP32_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP32_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;\n  }\n  else\n  {\n    valid_apn = true;\n\n    for (uint16_t index = 0; index < NUM_BLYNK_CREDENTIALS; index++)\n    {\n      Blynk_GSM.config(modem, localBlynkGSM_ESP32_config.Blynk_Creds[index].gsm_blynk_token,\n                       localBlynkGSM_ESP32_config.Blynk_Creds[index].blynk_server, localBlynkGSM_ESP32_config.blynk_port);\n\n      GSM_CONNECT_OK = Blynk_GSM.connectNetwork(localBlynkGSM_ESP32_config.apn, localBlynkGSM_ESP32_config.gprsUser,\n                       localBlynkGSM_ESP32_config.gprsPass);\n\n      if (GSM_CONNECT_OK)\n      {\n        if ( Blynk_GSM.connect() == true )\n          break;\n      }\n    }\n  }\n#endif"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();\n  }\n\n  check_status();\n  \n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "temperature",
        "humidity",
        "power",
        "gsm",
        "gprs",
        "wifi",
        "dns",
        "millis",
        "delay",
        "digitalwrite",
        "sensorupdate",
        "sensor_check_interval",
        ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp32_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp32_config);\n\n  serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "SHT3x.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "SensorUpdate",
          "parameters": "",
          "body": "static float temperature;\n  static float rHumidity;\n\n  Sensor.UpdateData();\n\n  temperature = Sensor.GetTemperature();\n  rHumidity   = Sensor.GetRelHumidity();\n\n  if (!isnan(temperature) && !isnan(rHumidity))\n  {\n    if (Blynk_GSM.connected())\n    {\n      Blynk_GSM.virtualWrite(V1, String(temperature, 1));\n      Blynk_GSM.virtualWrite(V2, String(rHumidity, 1));\n    }\n    \n    if (Blynk_WF.connected())\n    {\n      Blynk_WF.virtualWrite(V1, String(temperature, 1));\n      Blynk_WF.virtualWrite(V2, String(rHumidity, 1));\n    }\n    \n    Serial.println(\"\\nTemperature   = \" + String(temperature, 1));\n    Serial.println(\"\\nRel. Humidity = \" + String(rHumidity, 1));\n  }\n  else\n  {\n    if (Blynk_GSM.connected())\n    {\n      Blynk_GSM.virtualWrite(V1, \"NAN\");\n      Blynk_GSM.virtualWrite(V2, \"NAN\");\n    }\n\n    if (Blynk_WF.connected())\n    {\n      Blynk_WF.virtualWrite(V1, \"NAN\");\n      Blynk_WF.virtualWrite(V2, \"NAN\");\n    }\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (Blynk_GSM.connected())\n  {\n    Serial.print(F(\"G\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n  static unsigned long checksensor_timeout = 0;\n\n#define SENSOR_CHECK_INTERVAL     10000L\n#define STATUS_CHECK_INTERVAL     60000L\n  // Read and send Sensor data every SENSOR_CHECK_INTERVAL (10) seconds\n  if ((millis() > checksensor_timeout) || (checksensor_timeout == 0))\n  {\n    // Read and send Sensor to Blynk\n    SensorUpdate();\n\n    checksensor_timeout = millis() + SENSOR_CHECK_INTERVAL;\n\n    // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n    if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n    {\n      // report status to Blynk\n      heartBeatPrint();\n  \n      checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n  \n  SerialMon.print(F(\"\\nStart ESP32_GSM_SHT3x (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  Sensor.Begin();\n\n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  //SerialAT.begin(115200);\n  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP32-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP32_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP32_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP32_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP32_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;\n  }\n  else\n  {\n    valid_apn = true;\n\n    for (uint16_t index = 0; index < NUM_BLYNK_CREDENTIALS; index++)\n    {\n      Blynk_GSM.config(modem, localBlynkGSM_ESP32_config.Blynk_Creds[index].gsm_blynk_token,\n                       localBlynkGSM_ESP32_config.Blynk_Creds[index].blynk_server, localBlynkGSM_ESP32_config.blynk_port);\n\n      GSM_CONNECT_OK = Blynk_GSM.connectNetwork(localBlynkGSM_ESP32_config.apn, localBlynkGSM_ESP32_config.gprsUser,\n                       localBlynkGSM_ESP32_config.gprsPass);\n\n      if (GSM_CONNECT_OK)\n      {\n        if ( Blynk_GSM.connect() == true )\n          break;\n      }\n    }\n  }\n#endif"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();\n  }\n\n  check_status();\n  \n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "password",
        "ssl",
        "token",
        "buffer",
        "parse",
        "json",
        "power",
        "voltage",
        "temperature",
        "lte",
        "nb-iot",
        "gprs",
        "ntp",
        "4g",
        "digitalwrite",
        "delay",
        "tone",
        "analogread",
        "led",
        "pwm",
        "devices"
      ],
      "libraries": [
        "BotleticsSIM7000.h",
        "Botletics_modem.h",
        "HardwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//  while (!Serial);\n\n  pinMode(RST, OUTPUT);\n  digitalWrite(RST, HIGH); // Default state\n\n  // Turn on the module by pulsing PWRKEY low for a little bit\n  // This amount of time depends on the specific module that's used\n  modem.powerOn(BOTLETICS_PWRKEY); // Power on the module\n\n  Serial.begin(9600);\n  Serial.println(F(\"ESP32 SIMCom Basic Test\"));\n  Serial.println(F(\"Initializing....(May take several seconds)\"));\n\n  // SIM7000 takes about 3s to turn on and SIM7500 takes about 15s\n  // Press reset button if the module is still turning on and the board doesn't find it.\n  // When the module is on it should communicate right after pressing reset\n  \n  // Start at default SIM7000 shield baud rate\n  modemSS.begin(115200, SERIAL_8N1, TX, RX); // baud rate, protocol, ESP32 RX pin, ESP32 TX pin\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modemSS.println(\"AT+IPR=9600\"); // Set baud rate\n  delay(100); // Short pause to let the command run\n  modemSS.begin(9600, SERIAL_8N1, TX, RX); // Switch to 9600\n  if (! modem.begin(modemSS)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while (1); // Don't proceed if it couldn't find the device\n  }\n\n  type = modem.type();\n  Serial.println(F(\"Modem is OK\"));\n  Serial.print(F(\"Found \"));\n  switch (type) {\n    case SIM800L:\n      Serial.println(F(\"SIM800L\")); break;\n    case SIM800H:\n      Serial.println(F(\"SIM800H\")); break;\n    case SIM808_V1:\n      Serial.println(F(\"SIM808 (v1)\")); break;\n    case SIM808_V2:\n      Serial.println(F(\"SIM808 (v2)\")); break;\n    case SIM5320A:\n      Serial.println(F(\"SIM5320A (American)\")); break;\n    case SIM5320E:\n      Serial.println(F(\"SIM5320E (European)\")); break;\n    case SIM7000:\n      Serial.println(F(\"SIM7000\")); break;\n    case SIM7070:\n      Serial.println(F(\"SIM7070\")); break;\n    case SIM7500:\n      Serial.println(F(\"SIM7500\")); break;\n    case SIM7600:\n      Serial.println(F(\"SIM7600\")); break;\n    default:\n      Serial.println(F(\"???\")); break;\n  }\n\n  // Print module IMEI number.\n  uint8_t imeiLen = modem.getIMEI(imei);\n  if (imeiLen > 0) {\n    Serial.print(\"Module IMEI: \"); Serial.println(imei);\n  }\n\n  // Set modem to full functionality\n  modem.setFunctionality(1); // AT+CFUN=1\n\n  // Configure a GPRS APN, username, and password.\n  // You might need to do this to access your network's GPRS/data\n  // network.  Contact your provider for the exact APN, username,\n  // and password values.  Username and password are optional and\n  // can be removed, but APN is required.\n  //modem.setNetworkSettings(F(\"your APN\"), F(\"your username\"), F(\"your password\"));\n  //modem.setNetworkSettings(F(\"m2m.com.attz\")); // For AT&T IoT SIM card\n  //modem.setNetworkSettings(F(\"telstra.internet\")); // For Telstra (Australia) SIM card - CAT-M1 (Band 28)\n  modem.setNetworkSettings(F(\"hologram\")); // For Hologram SIM card\n\n  // Optionally configure HTTP gets to follow redirects over SSL.\n  // Default is not to follow SSL redirects, however if you uncomment\n  // the following line then redirects over SSL will be followed.\n  //modem.setHTTPSRedirect(true);\n\n  /*\n  // Other examples of some things you can set:\n  modem.setPreferredMode(38); // Use LTE only, not 2G\n  modem.setPreferredLTEMode(1); // Use LTE CAT-M only, not NB-IoT\n  modem.setOperatingBand(\"CAT-M\", 12); // AT&T uses band 12\n//  modem.setOperatingBand(\"CAT-M\", 13); // Verizon uses band 13\n  modem.enableRTC(true);\n  \n  modem.enableSleepMode(true);\n  modem.set_eDRX(1, 4, \"0010\");\n  modem.enablePSM(true);\n\n  // Set the network status LED blinking pattern while connected to a network (see AT+SLEDS command)\n  modem.setNetLED(true, 2, 64, 3000); // on/off, mode, timer_on, timer_off\n  modem.setNetLED(false); // Disable network status LED\n  */\n\n  printMenu();"
        },
        {
          "name": "printMenu",
          "parameters": "void",
          "body": "Serial.println(F(\"-------------------------------------\"));\n  // General\n  Serial.println(F(\"[?] Print this menu\"));\n  Serial.println(F(\"[a] Read the ADC; 2.8V max for SIM800/808, 0V-VBAT for SIM7000 shield\"));\n  Serial.println(F(\"[b] Read supply voltage\")); // Will also give battery % charged for most modules\n  Serial.println(F(\"[C] Read the SIM CCID\"));\n  Serial.println(F(\"[U] Unlock SIM with PIN code\"));\n  Serial.println(F(\"[i] Read signal strength (RSSI)\"));\n  Serial.println(F(\"[n] Get network status\"));\n  Serial.println(F(\"[1] Get network connection info\")); // See what connection type and band you're on!\n\n#if !defined(SIMCOM_7000) && !defined(SIMCOM_7070)\n  // Audio\n  Serial.println(F(\"[v] Set audio Volume\"));\n  Serial.println(F(\"[V] Get volume\"));\n  Serial.println(F(\"[H] Set headphone audio (SIM800/808)\"));\n  Serial.println(F(\"[e] Set external audio (SIM800/808)\"));\n  Serial.println(F(\"[T] Play audio Tone\"));\n  Serial.println(F(\"[P] PWM/buzzer out (SIM800/808)\"));\n#endif\n\n  // Calling\n  Serial.println(F(\"[c] Make phone Call\"));\n  Serial.println(F(\"[A] Get call status\"));\n  Serial.println(F(\"[h] Hang up phone\"));\n  Serial.println(F(\"[p] Pick up phone\"));\n\n#ifdef SIMCOM_2G\n  // FM (SIM800 only!)\n  Serial.println(F(\"[f] Tune FM radio (SIM800)\"));\n  Serial.println(F(\"[F] Turn off FM (SIM800)\"));\n  Serial.println(F(\"[m] Set FM volume (SIM800)\"));\n  Serial.println(F(\"[M] Get FM volume (SIM800)\"));\n  Serial.println(F(\"[q] Get FM station signal level (SIM800)\"));\n#endif\n\n  // SMS\n  Serial.println(F(\"[N] Number of SMS's\"));\n  Serial.println(F(\"[r] Read SMS #\"));\n  Serial.println(F(\"[R] Read all SMS\"));\n  Serial.println(F(\"[d] Delete SMS #\"));\n  Serial.println(F(\"[D] Delete all SMS\"));\n  Serial.println(F(\"[s] Send SMS\"));\n  Serial.println(F(\"[u] Send USSD\"));\n  \n  // Time\n  Serial.println(F(\"[y] Enable local time stamp (SIM800/808/70X0)\"));\n  Serial.println(F(\"[Y] Enable NTP time sync (SIM800/808/70X0)\")); // Need to use \"G\" command first!\n  Serial.println(F(\"[t] Get network time\")); // Works just by being connected to network\n\n  // Data Connection\n  Serial.println(F(\"[G] Enable cellular data\"));\n  Serial.println(F(\"[g] Disable cellular data\"));\n  Serial.println(F(\"[l] Query GSMLOC (2G)\"));\n#if !defined(SIMCOM_3G) && !defined(SIMCOM_7500) && !defined(SIMCOM_7600)\n  Serial.println(F(\"[w] Read webpage\"));\n  Serial.println(F(\"[W] Post to website\"));\n#endif\n  // The following option below posts dummy data to dweet.io for demonstration purposes. See the\n  // IoT_example sketch for an actual application of this function!\n  Serial.println(F(\"[2] Post to dweet.io - 2G / LTE CAT-M / NB-IoT\")); // SIM800/808/900/7000/7070\n  Serial.println(F(\"[3] Post to dweet.io - 3G / 4G LTE\")); // SIM5320/7500/7600\n\n  // GPS\n  if (type >= SIM808_V1) {\n    Serial.println(F(\"[O] Turn GPS on (SIM808/5320/7XX0)\"));\n    Serial.println(F(\"[o] Turn GPS off (SIM808/5320/7XX0)\"));\n    Serial.println(F(\"[L] Query GPS location (SIM808/5320/7XX0)\"));\n    if (type == SIM808_V1) {\n      Serial.println(F(\"[x] GPS fix status (SIM808 v1 only)\"));\n    }\n    Serial.println(F(\"[E] Raw NMEA out (SIM808)\"));\n  }\n  \n  Serial.println(F(\"[S] Create serial passthru tunnel\"));\n  Serial.println(F(\"-------------------------------------\"));\n  Serial.println(F(\"\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"modem> \"));\n  while (! Serial.available() ) {\n    if (modem.available()) {\n      Serial.write(modem.read());\n    }\n  }\n\n  char command = Serial.read();\n  Serial.println(command);\n\n\n  switch (command) {\n    case '?': {\n        printMenu();\n        break;\n      }\n\n    case 'a': {\n        // read the ADC\n        uint16_t adc;\n        if (! modem.getADCVoltage(&adc)) {\n          Serial.println(F(\"Failed to read ADC\"));\n        } else {\n          Serial.print(F(\"ADC = \")); Serial.print(adc); Serial.println(F(\" mV\"));\n        }\n        break;\n      }\n\n    case 'b': {\n        // read the battery voltage and percentage\n        uint16_t vbat;\n        if (! modem.getBattVoltage(&vbat)) {\n          Serial.println(F(\"Failed to read Batt\"));\n        } else {\n          Serial.print(F(\"VBat = \")); Serial.print(vbat); Serial.println(F(\" mV\"));\n        }\n\n        if (type != SIM7500 && type != SIM7600) {\n          if (! modem.getBattPercent(&vbat)) {\n            Serial.println(F(\"Failed to read Batt\"));\n          } else {\n            Serial.print(F(\"VPct = \")); Serial.print(vbat); Serial.println(F(\"%\"));\n          }\n        }\n\n        break;\n      }\n\n    case 'U': {\n        // Unlock the SIM with a PIN code\n        char PIN[5];\n        flushSerial();\n        Serial.println(F(\"Enter 4-digit PIN\"));\n        readline(PIN, 3);\n        Serial.println(PIN);\n        Serial.print(F(\"Unlocking SIM card: \"));\n        if (! modem.unlockSIM(PIN)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n\n    case 'C': {\n        // read the CCID\n        modem.getSIMCCID(replybuffer);  // make sure replybuffer is at least 21 bytes!\n        Serial.print(F(\"SIM CCID = \")); Serial.println(replybuffer);\n        break;\n      }\n\n    case 'i': {\n        // read the RSSI\n        uint8_t n = modem.getRSSI();\n        int8_t r;\n\n        Serial.print(F(\"RSSI = \")); Serial.print(n); Serial.print(\": \");\n        if (n == 0) r = -115;\n        if (n == 1) r = -111;\n        if (n == 31) r = -52;\n        if ((n >= 2) && (n <= 30)) {\n          r = map(n, 2, 30, -110, -54);\n        }\n        Serial.print(r); Serial.println(F(\" dBm\"));\n\n        break;\n      }\n\n    case 'n': {\n        // read the network/cellular status\n        uint8_t n = modem.getNetworkStatus();\n        Serial.print(F(\"Network status \"));\n        Serial.print(n);\n        Serial.print(F(\": \"));\n        if (n == 0) Serial.println(F(\"Not registered\"));\n        if (n == 1) Serial.println(F(\"Registered (home)\"));\n        if (n == 2) Serial.println(F(\"Not registered (searching)\"));\n        if (n == 3) Serial.println(F(\"Denied\"));\n        if (n == 4) Serial.println(F(\"Unknown\"));\n        if (n == 5) Serial.println(F(\"Registered roaming\"));\n        break;\n      }\n    case '1': {\n        // Get connection type, cellular band, carrier name, etc.\n        modem.getNetworkInfo();        \n        break;\n      }\n    \n    /*** Calling ***/\n    case 'c': {\n        // call a phone!\n        char number[30];\n        flushSerial();\n        Serial.print(F(\"Call #\"));\n        readline(number, 30);\n        Serial.println();\n        Serial.print(F(\"Calling \")); Serial.println(number);\n        if (!modem.callPhone(number)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"Sent!\"));\n        }\n\n        break;\n      }\n    case 'A': {\n        // get call status\n        int8_t callstat = modem.getCallStatus();\n        switch (callstat) {\n          case 0: Serial.println(F(\"Ready\")); break;\n          case 1: Serial.println(F(\"Could not get status\")); break;\n          case 3: Serial.println(F(\"Ringing (incoming)\")); break;\n          case 4: Serial.println(F(\"Ringing/in progress (outgoing)\")); break;\n          default: Serial.println(F(\"Unknown\")); break;\n        }\n        break;\n      }\n      \n    case 'h': {\n        // hang up!\n        if (! modem.hangUp()) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n\n    case 'p': {\n        // pick up!\n        if (! modem.pickUp()) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n\n#if !defined(SIMCOM_7000) && !defined(SIMCOM_7070)\n    /*** Audio ***/\n    case 'v': {\n        // set volume\n        flushSerial();\n        if ( (type == SIM5320A) || (type == SIM5320E) ) {\n          Serial.print(F(\"Set Vol [0-8] \"));\n        } else if (type == SIM7500 || type == SIM7600) {\n          Serial.print(F(\"Set Vol [0-5] \"));\n        } else {\n          Serial.print(F(\"Set Vol % [0-100] \"));\n        }\n        uint8_t vol = readnumber();\n        Serial.println();\n        if (! modem.setVolume(vol)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n\n    case 'V': {\n        uint8_t v = modem.getVolume();\n        Serial.print(v);\n        if ( (type == SIM5320A) || (type == SIM5320E) ) {\n          Serial.println(\" / 8\");\n        } else if (type == SIM7500 || type == SIM7600) { // Don't write anything for SIM7500\n          Serial.println();\n        } else {\n          Serial.println(\"%\");\n        }\n        break;\n      }\n\n    case 'H': {\n        // Set Headphone output\n        if (! modem.setAudio(HEADSETAUDIO)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        modem.setMicVolume(HEADSETAUDIO, 15);\n        break;\n      }\n    case 'e': {\n        // Set External output\n        if (! modem.setAudio(EXTAUDIO)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n\n        modem.setMicVolume(EXTAUDIO, 10);\n        break;\n      }\n\n    case 'T': {\n        // play tone\n        flushSerial();\n        Serial.print(F(\"Play tone #\"));\n        uint8_t kittone = readnumber();\n        Serial.println();\n        // play for 1 second (1000 ms)\n        if (! modem.playToolkitTone(kittone, 1000)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n\n    /*** PWM ***/\n\n    case 'P': {\n        // PWM Buzzer output @ 2KHz max\n        flushSerial();\n        Serial.print(F(\"PWM Freq, 0 = Off, (1-2000): \"));\n        uint16_t freq = readnumber();\n        Serial.println();\n        if (! modem.setPWM(freq)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n#endif\n\n#ifdef SIMCOM_2G\n    /*** FM Radio ***/\n\n    case 'f': {\n        // get freq\n        flushSerial();\n        Serial.print(F(\"FM Freq (eg 1011 == 101.1 MHz): \"));\n        uint16_t station = readnumber();\n        Serial.println();\n        // FM radio ON using headset\n        if (modem.FMradio(true, HEADSETAUDIO)) {\n          Serial.println(F(\"Opened\"));\n        }\n        if (! modem.tuneFMradio(station)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"Tuned\"));\n        }\n        break;\n      }\n    case 'F': {\n        // FM radio off\n        if (! modem.FMradio(false)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n    case 'm': {\n        // Set FM volume.\n        flushSerial();\n        Serial.print(F(\"Set FM Vol [0-6]:\"));\n        uint8_t vol = readnumber();\n        Serial.println();\n        if (!modem.setFMVolume(vol)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"OK!\"));\n        }\n        break;\n      }\n    case 'M': {\n        // Get FM volume.\n        uint8_t fmvol = modem.getFMVolume();\n        if (fmvol < 0) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.print(F(\"FM volume: \"));\n          Serial.println(fmvol, DEC);\n        }\n        break;\n      }\n    case 'q': {\n        // Get FM station signal level (in decibels).\n        flushSerial();\n        Serial.print(F(\"FM Freq (eg 1011 == 101.1 MHz): \"));\n        uint16_t station = readnumber();\n        Serial.println();\n        int8_t level = modem.getFMSignalLevel(station);\n        if (level < 0) {\n          Serial.println(F(\"Failed! Make sure FM radio is on (tuned to station).\"));\n        } else {\n          Serial.print(F(\"Signal level (dB): \"));\n          Serial.println(level, DEC);\n        }\n        break;\n      }\n#endif\n\n    /*** SMS ***/\n\n    case 'N': {\n        // read the number of SMS's!\n        int8_t smsnum = modem.getNumSMS();\n        if (smsnum < 0) {\n          Serial.println(F(\"Could not read # SMS\"));\n        } else {\n          Serial.print(smsnum);\n          Serial.println(F(\" SMS's on SIM card!\"));\n        }\n        break;\n      }\n    case 'r': {\n        // read an SMS\n        flushSerial();\n        Serial.print(F(\"Read #\"));\n        uint8_t smsn = readnumber();\n        Serial.print(F(\"\\n\\rReading SMS #\")); Serial.println(smsn);\n\n        // Retrieve SMS sender address/phone number.\n        if (! modem.getSMSSender(smsn, replybuffer, 250)) {\n          Serial.println(\"Failed!\");\n          break;\n        }\n        Serial.print(F(\"FROM: \")); Serial.println(replybuffer);\n\n        // Retrieve SMS value.\n        uint16_t smslen;\n        if (! modem.readSMS(smsn, replybuffer, 250, &smslen)) { // pass in buffer and max len!\n          Serial.println(\"Failed!\");\n          break;\n        }\n        Serial.print(F(\"***** SMS #\")); Serial.print(smsn);\n        Serial.print(\" (\"); Serial.print(smslen); Serial.println(F(\") bytes *****\"));\n        Serial.println(replybuffer);\n        Serial.println(F(\"*****\"));\n\n        break;\n      }\n    case 'R': {\n        // read all SMS\n        int8_t smsnum = modem.getNumSMS();\n        uint16_t smslen;\n        int8_t smsn;\n\n        if ( (type == SIM5320A) || (type == SIM5320E) ) {\n          smsn = 0; // zero indexed\n          smsnum--;\n        } else {\n          smsn = 1;  // 1 indexed\n        }\n\n        for ( ; smsn <= smsnum; smsn++) {\n          Serial.print(F(\"\\n\\rReading SMS #\")); Serial.println(smsn);\n          if (!modem.readSMS(smsn, replybuffer, 250, &smslen)) {  // pass in buffer and max len!\n            Serial.println(F(\"Failed!\"));\n            break;\n          }\n          // if the length is zero, its a special case where the index number is higher\n          // so increase the max we'll look at!\n          if (smslen == 0) {\n            Serial.println(F(\"[empty slot]\"));\n            smsnum++;\n            continue;\n          }\n\n          Serial.print(F(\"***** SMS #\")); Serial.print(smsn);\n          Serial.print(\" (\"); Serial.print(smslen); Serial.println(F(\") bytes *****\"));\n          Serial.println(replybuffer);\n          Serial.println(F(\"*****\"));\n        }\n        break;\n      }\n\n    case 'd': {\n        // delete an SMS\n        flushSerial();\n        Serial.print(F(\"Delete #\"));\n        uint8_t smsn = readnumber();\n\n        Serial.print(F(\"\\n\\rDeleting SMS #\")); Serial.println(smsn);\n        if (modem.deleteSMS(smsn)) {\n          Serial.println(F(\"OK!\"));\n        } else {\n          Serial.println(F(\"Couldn't delete\"));\n        }\n        break;\n      }\n\n    case 'D': {\n        // Delete all SMS\n        flushSerial();\n        Serial.println(F(\"\\n\\rDeleting all SMS\"));\n        if (modem.deleteAllSMS()) {\n          Serial.println(F(\"OK!\"));\n        } else {\n          Serial.println(F(\"Couldn't delete\"));\n        }\n        break;\n      }\n\n    case 's': {\n        // send an SMS!\n        char sendto[21], message[141];\n        flushSerial();\n        Serial.print(F(\"Send to #\"));\n        readline(sendto, 20);\n        Serial.println(sendto);\n        Serial.print(F(\"Type out one-line message (140 char): \"));\n        readline(message, 140);\n        Serial.println(message);\n        if (!modem.sendSMS(sendto, message)) {\n          Serial.println(F(\"Failed\"));\n        } else {\n          Serial.println(F(\"Sent!\"));\n        }\n\n        break;\n      }\n\n    case 'u': {\n      // send a USSD!\n      char message[141];\n      flushSerial();\n      Serial.print(F(\"Type out one-line message (140 char): \"));\n      readline(message, 140);\n      Serial.println(message);\n\n      uint16_t ussdlen;\n      if (!modem.sendUSSD(message, replybuffer, 250, &ussdlen)) { // pass in buffer and max len!\n        Serial.println(F(\"Failed\"));\n      } else {\n        Serial.println(F(\"Sent!\"));\n        Serial.print(F(\"***** USSD Reply\"));\n        Serial.print(\" (\"); Serial.print(ussdlen); Serial.println(F(\") bytes *****\"));\n        Serial.println(replybuffer);\n        Serial.println(F(\"*****\"));\n      }\n    }\n\n    /*** Time ***/\n\n    case 'y': {\n        // enable network time sync\n        if (!modem.enableRTC(true))\n          Serial.println(F(\"Failed to enable\"));\n        break;\n      }\n\n    case 'Y': {\n        // enable NTP time sync\n        if (!modem.enableNTPTimeSync(true, F(\"pool.ntp.org\")))\n          Serial.println(F(\"Failed to enable\"));\n        break;\n      }\n\n    case 't': {\n        // read the time\n        char buffer[23];\n\n        modem.getTime(buffer, 23);  // make sure replybuffer is at least 23 bytes!\n        Serial.print(F(\"Time = \")); Serial.println(buffer);\n        break;\n      }\n\n\n    /*********************************** GPS */\n\n    case 'o': {\n        // turn GPS off\n        if (!modem.enableGPS(false))\n          Serial.println(F(\"Failed to turn off\"));\n        break;\n      }\n    case 'O': {\n        // turn GPS on\n        if (!modem.enableGPS(true))\n          Serial.println(F(\"Failed to turn on\"));\n        break;\n      }\n    case 'x': {\n        int8_t stat;\n        // check GPS fix\n        stat = modem.GPSstatus();\n        if (stat < 0)\n          Serial.println(F(\"Failed to query\"));\n        if (stat == 0) Serial.println(F(\"GPS off\"));\n        if (stat == 1) Serial.println(F(\"No fix\"));\n        if (stat == 2) Serial.println(F(\"2D fix\"));\n        if (stat == 3) Serial.println(F(\"3D fix\"));\n        break;\n      }\n\n    case 'L': {\n        /*\n        // Uncomment this block if all you want to see is the AT command response\n        // check for GPS location\n        char gpsdata[120];\n        modem.getGPS(0, gpsdata, 120);\n        if (type == SIM808_V1)\n          Serial.println(F(\"Reply in format: mode,longitude,latitude,altitude,utctime(yyyymmddHHMMSS),ttff,satellites,speed,course\"));\n        else if ( (type == SIM5320A) || (type == SIM5320E) || (type == SIM7500) || (type == SIM7600) )\n          Serial.println(F(\"Reply in format: [<lat>],[<N/S>],[<lon>],[<E/W>],[<date>],[<UTC time>(yyyymmddHHMMSS)],[<alt>],[<speed>],[<course>]\"));\n        else\n          Serial.println(F(\"Reply in format: mode,fixstatus,utctime(yyyymmddHHMMSS),latitude,longitude,altitude,speed,course,fixmode,reserved1,HDOP,PDOP,VDOP,reserved2,view_satellites,used_satellites,reserved3,C/N0max,HPA,VPA\"));\n        \n        Serial.println(gpsdata);\n\n        break;\n        */\n\n        float latitude, longitude, speed_kph, heading, altitude; \n        // Comment out the stuff below if you don't care about UTC time\n        /*        float second;\n        uint16_t year;\n        uint8_t month, day, hour, minute;\n        */\n        // Use the top line if you want to parse UTC time data as well, the line below it if you don't care\n//        if (modem.getGPS(&latitude, &longitude, &speed_kph, &heading, &altitude, &year, &month, &day, &hour, &minute, &second)) {\n        if (modem.getGPS(&latitude, &longitude, &speed_kph, &heading, &altitude)) { // Use this line instead if you don't want UTC time\n          Serial.println(F(\"---------------------\"));\n          Serial.print(F(\"Latitude: \")); Serial.println(latitude, 6);\n          Serial.print(F(\"Longitude: \")); Serial.println(longitude, 6);\n          Serial.print(F(\"Speed: \")); Serial.println(speed_kph);\n          Serial.print(F(\"Heading: \")); Serial.println(heading);\n          Serial.print(F(\"Altitude: \")); Serial.println(altitude);\n          // Comment out the stuff below if you don't care about UTC time\n          /*\n          Serial.print(F(\"Year: \")); Serial.println(year);\n          Serial.print(F(\"Month: \")); Serial.println(month);\n          Serial.print(F(\"Day: \")); Serial.println(day);\n          Serial.print(F(\"Hour: \")); Serial.println(hour);\n          Serial.print(F(\"Minute: \")); Serial.println(minute);\n          Serial.print(F(\"Second: \")); Serial.println(second);\n          Serial.println(F(\"---------------------\"));\n          */\n        }\n\n        break;\n      }\n\n    case 'E': {\n        flushSerial();\n        if (type == SIM808_V1) {\n          Serial.print(F(\"GPS NMEA output sentences (0 = off, 34 = RMC+GGA, 255 = all)\"));\n        } else {\n          Serial.print(F(\"On (1) or Off (0)? \"));\n        }\n        uint8_t nmeaout = readnumber();\n\n        // turn on NMEA output\n        modem.enableGPSNMEA(nmeaout);\n\n        break;\n      }\n\n    /*********************************** GPRS */\n\n    case 'g': {\n        // turn GPRS off\n        if (!modem.enableGPRS(false))\n          Serial.println(F(\"Failed to turn off\"));\n        break;\n      }\n    case 'G': {\n        // turn GPRS off first for SIM7500\n        #if defined(SIMCOM_7500) || defined (SIMCOM_7600)\n          modem.enableGPRS(false);\n        #endif\n        \n        // turn GPRS on\n        if (!modem.enableGPRS(true))\n          Serial.println(F(\"Failed to turn on\"));\n        break;\n      }\n    case 'l': {\n        // check for GSMLOC (requires GPRS)\n        uint16_t returncode;\n\n        if (!modem.getGSMLoc(&returncode, replybuffer, 250))\n          Serial.println(F(\"Failed!\"));\n        if (returncode == 0) {\n          Serial.println(replybuffer);\n        } else {\n          Serial.print(F(\"Fail code #\")); Serial.println(returncode);\n        }\n\n        break;\n      }\n\n#if !defined(SIMCOM_3G) && !defined(SIMCOM_7500) && !defined(SIMCOM_7600)\n    // The code below was written by Adafruit and only works on some modules\n    case 'w': {\n        // read website URL\n        uint16_t statuscode;\n        int16_t length;\n        char url[80];\n\n        flushSerial();\n        Serial.println(F(\"URL to read (e.g. dweet.io/get/latest/dweet/for/sim7500test123):\"));\n        Serial.print(F(\"http://\")); readline(url, 79);\n        Serial.println(url);\n\n        Serial.println(F(\"****\"));\n        if (!modem.HTTP_GET_start(url, &statuscode, (uint16_t *)&length)) {\n          Serial.println(\"Failed!\");\n          break;\n        }\n        while (length > 0) {\n          while (modem.available()) {\n            char c = modem.read();\n\n            // Serial.write is too slow, we'll write directly to Serial register!\n#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)\n            loop_until_bit_is_set(UCSR0A, UDRE0); /* Wait until data register empty. */\n            UDR0 = c;\n#else\n            Serial.write(c);\n#endif\n            length--;\n            if (! length) break;\n          }\n        }\n        Serial.println(F(\"\\n****\"));\n        modem.HTTP_GET_end();\n        break;\n      }\n\n    case 'W': {\n        // Post data to website\n        uint16_t statuscode;\n        int16_t length;\n        char url[80];\n        char data[80];\n\n        flushSerial();\n        Serial.println(F(\"NOTE: in beta! Use simple websites to post!\"));\n        Serial.println(F(\"URL to post (e.g. httpbin.org/post):\"));\n        Serial.print(F(\"http://\")); readline(url, 79);\n        Serial.println(url);\n        Serial.println(F(\"Data to post (e.g. \\\"foo\\\" or \\\"{\\\"simple\\\":\\\"json\\\"}\\\"):\"));\n        readline(data, 79);\n        Serial.println(data);\n\n        Serial.println(F(\"****\"));\n        if (!modem.HTTP_POST_start(url, F(\"text/plain\"), (uint8_t *) data, strlen(data), &statuscode, (uint16_t *)&length)) {\n          Serial.println(\"Failed!\");\n          break;\n        }\n        while (length > 0) {\n          while (modem.available()) {\n            char c = modem.read();\n\n#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)\n            loop_until_bit_is_set(UCSR0A, UDRE0); /* Wait until data register empty. */\n            UDR0 = c;\n#else\n            Serial.write(c);\n#endif\n\n            length--;\n            if (! length) break;\n          }\n        }\n        Serial.println(F(\"\\n****\"));\n        modem.HTTP_POST_end();\n        break;\n      }\n#endif\n\n#if defined(SIMCOM_2G) || defined(SIMCOM_7000)\n    case '2': {\n        // Post data to website via 2G or LTE CAT-M/NB-IoT\n        float temperature = analogRead(A0)*1.23; // Change this to suit your needs\n        \n        uint16_t battLevel = 3600; // Dummy voltage in mV for testing\n\n        // Create char buffers for the floating point numbers for sprintf\n        // Make sure these buffers are long enough for your request URL\n        char URL[150];\n        /* Uncomment below if you are going to use the http post method below */\n        /*\n        char body[100];\n        */\n        char tempBuff[16];\n        char battLevelBuff[16];\n      \n        // Format the floating point numbers as needed\n        dtostrf(temperature, 1, 2, tempBuff); // float_val, min_width, digits_after_decimal, char_buffer\n        dtostrf(battLevel, 1, 0, battLevelBuff);\n\n        // Construct the appropriate URL's and body, depending on request type\n        // Use IMEI as device ID for this example\n        \n        // GET request\n        sprintf(URL, \"dweet.io/dweet/for/%s?temp=%s&batt=%s\", imei, tempBuff, battLevelBuff); // No need to specify http:// or https://\n//        sprintf(URL, \"http://dweet.io/dweet/for/%s?temp=%s&batt=%s\", imei, tempBuff, battLevelBuff); // But this works too\n\n        if (!modem.postData(\"GET\", URL))\n          Serial.println(F(\"Failed to complete HTTP GET...\"));\n        \n        // POST request\n        /*\n        sprintf(URL, \"http://dweet.io/dweet/for/%s\", imei);\n        sprintf(body, \"{\\\"temp\\\":%s,\\\"batt\\\":%s}\", tempBuff, battLevelBuff);\n        \n        if (!modem.postData(\"POST\", URL, body)) // Can also add authorization token parameter!\n          Serial.println(F(\"Failed to complete HTTP POST...\"));\n        */\n      \n        break;\n      }\n#endif\n\n#if defined(SIMCOM_3G) || defined(SIMCOM_7500) || defined(SIMCOM_7600)\n    case '3': {\n        // Post data to website via 3G or 4G LTE\n        float temperature = analogRead(A0)*1.23; // Change this to suit your needs\n        \n        // Voltage in mV, just for testing. Use the read battery function instead for real applications.\n        uint16_t battLevel = 3700;\n\n        // Create char buffers for the floating point numbers for sprintf\n        // Make sure these buffers are long enough for your request URL\n        char URL[150];\n        char tempBuff[16];\n        char battLevelBuff[16];\n      \n        // Format the floating point numbers as needed\n        dtostrf(temperature, 1, 2, tempBuff); // float_val, min_width, digits_after_decimal, char_buffer\n        dtostrf(battLevel, 1, 0, battLevelBuff);\n\n        // Construct the appropriate URL's and body, depending on request type\n        // Use IMEI as device ID for this example\n        \n        // GET request\n        sprintf(URL, \"GET /dweet/for/%s?temp=%s&batt=%s HTTP/1.1\\r\\nHost: dweet.io\\r\\n\\r\\n\", imei, tempBuff, battLevelBuff);\n        \n        if (!modem.postData(\"www.dweet.io\", 443, \"HTTPS\", URL)) // Server, port, connection type, URL\n          Serial.println(F(\"Failed to complete HTTP/HTTPS request...\"));\n      \n        break;\n      }\n#endif\n    /*****************************************/\n\n    case 'S': {\n        Serial.println(F(\"Creating SERIAL TUBE\"));\n        while (1) {\n          while (Serial.available()) {\n            delay(1);\n            modem.write(Serial.read());\n          }\n          if (modem.available()) {\n            Serial.write(modem.read());\n          }\n        }\n        break;\n      }\n\n    default: {\n        Serial.println(F(\"Unknown command\"));\n        printMenu();\n        break;\n      }\n  }\n  // flush input\n  flushSerial();\n  while (modem.available()) {\n    Serial.write(modem.read());\n  }"
        },
        {
          "name": "flushSerial",
          "parameters": "",
          "body": "while (Serial.available())\n    Serial.read();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "delay",
        "digitalwrite",
        "led",
        "html"
      ],
      "libraries": [
        "loopTimer.h",
        "millisDelay.h",
        "BufferedOutput.h"
      ],
      "functions": [
        {
          "name": "blinkTask",
          "parameters": "void* parameter",
          "body": "ledOn = false;\n  // start delay\n  ledDelay.start(1000);\n\n  for (;;) {   // loop forever\n    blinkTaskTimer.check();\n    vTaskDelay(1); // need this to prevent wdt panic\n\n    if (ledDelay.justFinished()) {\n      ledDelay.repeat(); // start delay again without drift\n      // toggle the led\n      ledOn = !ledOn;\n      if (ledOn) {\n        digitalWrite(led, HIGH); // turn led on\n      } else {\n        digitalWrite(led, LOW); // turn led off\n      }\n    }\n  }\n  /* delete a task when finish,\n    this will never happen because this is infinity loop */\n  vTaskDelete( NULL );"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  for (int i = 10; i > 0; i--) {\n    Serial.println(i);\n    delay(500);\n  }\n  // initialize digital pin led as an output.\n  pinMode(led, OUTPUT);\n\n  xTaskCreatePinnedToCore(\n    blinkTask,           /* Task function. */\n    \"blinkTask\",        /* name of task. */\n    1000,                    /* Stack size of task */\n    NULL,                     /* parameter of the task */\n    1,                        /* priority of the task */  // loop() has priority == 1\n    NULL,                    /* Task handle to keep track of created task */\n    CONFIG_ARDUINO_RUNNING_CORE); //pin to core 1, WiFi is pinned to 0\n\n  printTimers.start(PRINT_TIMERS_DELAY);\n  bufferedOut.connect(Serial);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "loopTimer.check();\n  bufferedOut.nextByteOut(); // check if any output to print\n\n  if (printTimers.justFinished()) {\n    printTimers.restart(); // this may drift\n    loopTimer.print(bufferedOut);\n    blinkTaskTimer.print(bufferedOut);\n  }\n  vTaskDelay(1); // need this to prevent wdt panic"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "power",
        "gsm",
        "gprs",
        "wifi",
        "dns",
        "millis",
        "delay",
        "digitalwrite",
        ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp32_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp32_config);\n\n  serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (Blynk_GSM.connected())\n  {\n    Serial.print(F(\"G\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n  \n  SerialMon.print(F(\"\\nStart ESP32_MRD_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  #if USING_MRD\n    Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  #else\n    Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n  #endif\n#endif\n\n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  //SerialAT.begin(115200);\n  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP32\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP32-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP32_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP32_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP32_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP32_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;\n  }\n  else\n  {\n    valid_apn = true;\n\n    for (uint16_t index = 0; index < NUM_BLYNK_CREDENTIALS; index++)\n    {\n      Blynk_GSM.config(modem, localBlynkGSM_ESP32_config.Blynk_Creds[index].gsm_blynk_token,\n                       localBlynkGSM_ESP32_config.Blynk_Creds[index].blynk_server, localBlynkGSM_ESP32_config.blynk_port);\n\n      GSM_CONNECT_OK = Blynk_GSM.connectNetwork(localBlynkGSM_ESP32_config.apn, localBlynkGSM_ESP32_config.gprsUser,\n                       localBlynkGSM_ESP32_config.gprsPass);\n\n      if (GSM_CONNECT_OK)\n      {\n        if ( Blynk_GSM.connect() == true )\n          break;\n      }\n    }\n  }\n#endif"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();\n  }\n\n  check_status();\n  \n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "key",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "WiFiUdp.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    DBG(\"Establishing connection to WiFi..\");\n  }\n  DBG(\"Connected to network\");\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), WiFi.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n  DBG(F(\"Listen to incoming MIDI commands\"));\n\n  MIDI.begin();\n\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n  \n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });\n\n  DBG(F(\"Sending NoteOn/Off of note 45, every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t0) > 1000)\n  {\n    t0 = millis();\n\n    byte note = 45;\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "callback",
        "millis",
        "delay"
      ],
      "libraries": [
        "ETH_Helper.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Das Booting\");\n\n  ETH_startup();\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), Ethernet.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n\n  MIDI.begin(MIDI_CHANNEL_OMNI);\n\n  // Normal callbacks - always available\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n\n  // Extended callback, only available when defining USE_EXT_CALLBACKS\n  AppleMIDI.setHandleSentRtp([](const APPLEMIDI_NAMESPACE::Rtp_t & rtp) {\n    //  DBG(F(\"an rtpMessage has been sent with sequenceNr\"), rtp.sequenceNr);\n  });\n  AppleMIDI.setHandleSentRtpMidi([](const APPLEMIDI_NAMESPACE::RtpMIDI_t& rtpMidi) {\n    DBG(F(\"an rtpMidiMessage has been sent\"), rtpMidi.flags);\n  });\n  AppleMIDI.setHandleReceivedRtp([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const APPLEMIDI_NAMESPACE::Rtp_t & rtp, const int32_t& latency) {\n    //  DBG(F(\"setHandleReceivedRtp\"), ssrc, rtp.sequenceNr , \"with\", latency, \"ms latency\");\n  });\n  AppleMIDI.setHandleStartReceivedMidi([](const APPLEMIDI_NAMESPACE::ssrc_t& ssrc) {\n    //  DBG(F(\"setHandleStartReceivedMidi from SSRC\"), ssrc);\n  });\n  AppleMIDI.setHandleReceivedMidi([](const APPLEMIDI_NAMESPACE::ssrc_t& ssrc, byte value) {\n    //    DBG(F(\"setHandleReceivedMidi from SSRC\"), ssrc, \", value:\", value);\n  });\n  AppleMIDI.setHandleEndReceivedMidi([](const APPLEMIDI_NAMESPACE::ssrc_t& ssrc) {\n    //  DBG(F(\"setHandleEndReceivedMidi from SSRC\"), ssrc);\n  });\n  AppleMIDI.setHandleException(OnAppleMidiException);\n\n  MIDI.setHandleControlChange([](Channel channel, byte v1, byte v2) {\n    DBG(F(\"ControlChange\"), channel, v1, v2);\n  });\n  MIDI.setHandleProgramChange([](Channel channel, byte v1) {\n    DBG(F(\"ProgramChange\"), channel, v1);\n  });\n  MIDI.setHandlePitchBend([](Channel channel, int v1) {\n    DBG(F(\"PitchBend\"), channel, v1);\n  });\n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), channel, note, velocity);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), channel, note, velocity);\n  });\n\n  DBG(F(\"Sending MIDI messages every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 100)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    //   DBG(F(\"\\nsendNoteOn\"), note, velocity, channel);\n    MIDI.sendNoteOn(note, velocity, channel);\n    //MIDI.sendNoteOff(note, velocity, channel);\n  }\n\n#ifndef ETHERNET3\n  EthernetBonjour.run();\n#endif"
        },
        {
          "name": "OnAppleMidiException",
          "parameters": "const APPLEMIDI_NAMESPACE::ssrc_t& ssrc, const APPLEMIDI_NAMESPACE::Exception& e, const int32_t value",
          "body": "switch (e)\n  {\n    case APPLEMIDI_NAMESPACE::Exception::BufferFullException:\n      DBG(F(\"*** BufferFullException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParseException:\n      DBG(F(\"*** ParseException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::TooManyParticipantsException:\n      DBG(F(\"*** TooManyParticipantsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UnexpectedInviteException:\n      DBG(F(\"*** UnexpectedInviteException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParticipantNotFoundException:\n      DBG(F(\"*** ParticipantNotFoundException\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ComputerNotInDirectory:\n      DBG(F(\"*** ComputerNotInDirectory\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NotAcceptingAnyone:\n      DBG(F(\"*** NotAcceptingAnyone\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ListenerTimeOutException:\n      DBG(F(\"*** ListenerTimeOutException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::MaxAttemptsException:\n      DBG(F(\"*** MaxAttemptsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NoResponseFromConnectionRequestException:\n      DBG(F(\"***:yyy did't respond to the connection request. Check the address and port, and any firewall or router settings. (time)\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::SendPacketsDropped:\n      DBG(F(\"*** SendPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ReceivedPacketsDropped:\n      DBG(F(\"******************************************** ReceivedPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UdpBeginPacketFailed:\n      DBG(F(\"*** UdpBeginPacketFailed\"), value);\n      break;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "http",
        "https",
        "password",
        "payload",
        "wifi",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "hexdump",
          "parameters": "const void *mem, const uint32_t& len, const uint8_t& cols = 16",
          "body": "const uint8_t* src = (const uint8_t*) mem;\n\n  Serial.printf(\"\\n[HEXDUMP] Address: 0x%08X len: 0x%X (%d)\", (ptrdiff_t)src, len, len);\n\n  for (uint32_t i = 0; i < len; i++)\n  {\n    if (i % cols == 0)\n    {\n      Serial.printf(\"\\n[0x%08X] 0x%08X: \", (ptrdiff_t)src, i);\n    }\n\n    Serial.printf(\"%02X \", *src);\n    src++;\n  }\n\n  Serial.printf(\"\\n\");"
        },
        {
          "name": "webSocketEvent",
          "parameters": "const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;\n      }\n\n      break;\n\n    case WStype_CONNECTED:\n    {\n      alreadyConnected = true;\n\n      Serial.print(\"[WSc] Connected to url: \");\n      Serial.println((char *) payload);\n\n      // send message to server when Connected\n      webSocket.sendTXT(\"Connected\");\n    }\n\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      //webSocket.sendTXT(\"Message from ESP32\");\n      webSocket.sendTXT(messageToServer);\n\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      webSocket.sendBIN(payload, length);\n\n      break;\n\n    case WStype_PING:\n      // pong will be send automatically\n      Serial.printf(\"[WSc] get ping\\n\");\n\n      break;\n\n    case WStype_PONG:\n      // answer to a ping we send\n      Serial.printf(\"[WSc] get pong\\n\");\n\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ESP32_WebSocketClient on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ \");\n  Serial.println(WS_SERVER);\n\n  // server address, port and URL\n#if USE_SSL\n  webSocket.beginSSL(WS_SERVER, WS_PORT);\n#else\n  webSocket.begin(WS_SERVER, WS_PORT, \"/\");\n#endif\n\n  // event handler\n  webSocket.onEvent(webSocketEvent);\n\n  // use HTTP Basic Authorization this is optional remove if not needed\n  //webSocket.setAuthorization(\"user\", \"Password\");\n\n  // try ever 5000 again if connection has failed\n  webSocket.setReconnectInterval(5000);\n\n  // start heartbeat (optional)\n  // ping server every 15000 ms\n  // expect pong from server within 3000 ms\n  // consider connection disconnected if pong is not received 2 times\n  webSocket.enableHeartbeat(15000, 3000, 2);\n\n  // server address, port and URL\n  Serial.print(\"Connected to WebSockets Server @ IP address: \");\n  Serial.println(WS_SERVER);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "payload",
        "wifi",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "hexdump",
          "parameters": "const void *mem, const uint32_t& len, const uint8_t& cols = 16",
          "body": "const uint8_t* src = (const uint8_t*) mem;\n\n  Serial.printf(\"\\n[HEXDUMP] Address: 0x%08X len: 0x%X (%d)\", (ptrdiff_t)src, len, len);\n\n  for (uint32_t i = 0; i < len; i++)\n  {\n    if (i % cols == 0)\n    {\n      Serial.printf(\"\\n[0x%08X] 0x%08X: \", (ptrdiff_t)src, i);\n    }\n\n    Serial.printf(\"%02X \", *src);\n    src++;\n  }\n\n  Serial.printf(\"\\n\");"
        },
        {
          "name": "webSocketEvent",
          "parameters": "const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n\n      break;\n\n    case WStype_CONNECTED:\n      Serial.printf(\"[WSc] Connected to url: %s\\n\", payload);\n\n      // send message to server when Connected\n      webSocket.sendTXT(\"Connected\");\n\n      break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      webSocket.sendTXT(\"message here\");\n\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      webSocket.sendBIN(payload, length);\n\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ESP32_WebSocketClientSSL on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ \");\n  Serial.println(WS_SERVER);\n\n  webSocket.beginSSL(WS_SERVER, SSL_PORT);\n  webSocket.onEvent(webSocketEvent);\n\n  // server address, port and URL\n  Serial.print(\"Connected to WebSockets Server @ \");\n  Serial.println(WS_SERVER);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "key",
        "payload",
        "json",
        "wifi",
        "delay",
        "millis",
        "clientip"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "parameters": "const socketIOmessageType_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n      Serial.print(\"[IOc] Get event: \");\n      Serial.println((char*) payload);\n\n      break;\n\n    case sIOtype_ACK:\n      Serial.print(\"[IOc] Get ack: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_ERROR:\n      Serial.print(\"[IOc] Get error: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_BINARY_EVENT:\n      Serial.print(\"[IOc] Get binary: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_BINARY_ACK:\n      Serial.print(\"[IOc] Get binary ack: \");\n      Serial.println(length);\n\n      //hexdump(payload, length);\n\n      break;\n\n    case sIOtype_PING:\n      Serial.println(\"[IOc] Get PING\");\n\n      break;\n\n    case sIOtype_PONG:\n      Serial.println(\"[IOc] Get PONG\");\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "printWifiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"WebSockets Client IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP32_WebSocketClientSocketIO on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  WiFiMulti.addAP(ssid, pass);\n\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ IP address: \");\n  Serial.print(serverIP);\n  Serial.print(\", port: \");\n  Serial.println(serverPort);\n\n  // setReconnectInterval to 10s, new from v2.5.1 to avoid flooding server. Default is 0.5s\n  socketIO.setReconnectInterval(10000);\n\n  socketIO.setExtraHeaders(\"Authorization: 1234567890\");\n\n  // server address, port and URL\n  // void begin(IPAddress host, uint16_t port, String url = \"/socket.io/?EIO=4\", String protocol = \"arduino\");\n  // To use default EIO=4 from v2.5.1\n  socketIO.begin(serverIP, serverPort);\n\n  // event handler\n  socketIO.onEvent(socketIOEvent);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "payload",
        "wifi",
        "delay",
        "clients"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiMulti.h",
        "WiFiClientSecure.h",
        "WebSocketsServer_Generic.h"
      ],
      "functions": [
        {
          "name": "hexdump",
          "parameters": "const void *mem, const uint32_t& len, const uint8_t& cols = 16",
          "body": "const uint8_t* src = (const uint8_t*) mem;\n\n  Serial.printf(\"\\n[HEXDUMP] Address: 0x%08X len: 0x%X (%d)\", (ptrdiff_t)src, len, len);\n\n  for (uint32_t i = 0; i < len; i++)\n  {\n    if (i % cols == 0)\n    {\n      Serial.printf(\"\\n[0x%08X] 0x%08X: \", (ptrdiff_t)src, i);\n    }\n\n    Serial.printf(\"%02X \", *src);\n    src++;\n  }\n\n  Serial.printf(\"\\n\");"
        },
        {
          "name": "webSocketEvent",
          "parameters": "const uint8_t& num, const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");\n    }\n\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[%u] get Text: %s\\n\", num, payload);\n\n      // send message to client\n      webSocket.sendTXT(num, messageFromServer);\n\n      // send data to all connected clients\n      // webSocket.broadcastTXT(num, messageFromServer);\n\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[%u] get binary length: %u\\n\", num, length);\n      hexdump(payload, length);\n\n      // send message to client\n      webSocket.sendBIN(num, payload, length);\n\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting ESP32_WebSocketServer on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  webSocket.begin();\n  webSocket.onEvent(webSocketEvent);\n\n  // server address, port and URL\n  Serial.print(\"WebSockets Server started @ IP address: \");\n  Serial.print(WiFi.localIP());\n  Serial.print(\", port: \");\n  Serial.println(WS_PORT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "wificlient",
        "https",
        "auth",
        "token",
        "password",
        "wifi"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "BlynkSimpleEsp32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "password",
        "wifi"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClientSecure.h",
        "BlynkSimpleEsp32_SSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "mosquitto",
        "mqtt",
        "wificlient",
        "pubsubclient",
        "publish",
        "callback",
        "subscribe",
        "wifi",
        "millis",
        "esp.restart",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "PubSubClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"\");\n  Serial.print(\"Arduino MQTT OTA Test \");\n  Serial.println(__TIMESTAMP__);\n\n  Serial.printf(\"Sketch size: %u\\n\", ESP.getSketchSize());\n  Serial.printf(\"Free size: %u\\n\", ESP.getFreeSketchSpace());"
        },
        {
          "name": "receive_ota",
          "parameters": "const MQTT::Publish& pub",
          "body": "uint32_t startTime = millis();\n  uint32_t size = pub.payload_len();\n  if (size == 0)\n    return;\n\n  Serial.print(\"Receiving OTA of \");\n  Serial.print(size);\n  Serial.println(\" bytes...\");\n\n  Serial.setDebugOutput(true);\n  if (ESP.updateSketch(*pub.payload_stream(), size, true, false)) {\n    Serial.println(\"Clearing retained message.\");\n    client.publish(MQTT::Publish(pub.topic(), \"\")\n                   .set_retain());\n    client.disconnect();\n\n    Serial.printf(\"Update Success: %lu\\nRebooting...\\n\", millis() - startTime);\n    ESP.restart();\n    delay(10000);\n  }\n\n  Update.printError(Serial);\n  Serial.setDebugOutput(false);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\"Connecting to \");\n    Serial.print(ssid);\n    Serial.println(\"...\");\n    WiFi.begin(ssid, pass);\n    if (WiFi.waitForConnectResult() != WL_CONNECTED)\n      return;\n\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());\n  }\n\n  if (WiFi.status() == WL_CONNECTED) {\n    if (!client.connected()) {\n      // Give ourselves a unique client name\n      if (client.connect(WiFi.macAddress())) {\n\tclient.set_callback(receive_ota);   // Register our callback for receiving OTA's\n\tIPAddress local = WiFi.localIP();\n\tString ipaddr = String(local[0]) + \".\" + String(local[1]) + \".\" + String(local[2]) + \".\" + String(local[3]);\n\tString topic = \"ota/\" + ipaddr;\n\tSerial.print(\"Subscribing to topic \");\n\tSerial.println(topic);\n\tclient.subscribe(topic);\n      }\n    }\n\n    if (client.connected())\n      client.loop();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "wificlient",
        "api",
        "auth",
        "token",
        "json",
        "wifi",
        "delay",
        "millis",
        "display"
      ],
      "libraries": [
        "ESP8266WiFi.h"
      ],
      "functions": [
        {
          "name": "connectNetwork",
          "parameters": "",
          "body": "Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println();\n  Serial.println(\"WiFi connected\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  delay(10);\n  Serial.println();\n  Serial.println();\n\n  connectNetwork();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "String response;\n\n  unsigned long value = millis();\n\n  // Send value to the cloud\n  // similar to Blynk.virtualWrite()\n\n  Serial.print(\"Sending value: \");\n  Serial.println(value);\n\n  String putData = String(\"[\\\"\") + value + \"\\\"]\";\n  if (httpRequest(String(\"PUT /\") + auth + \"/update/V2\", putData, response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);\n    }\n  }\n\n  // Read the value back\n  // similar to Blynk.syncVirtual()\n\n  Serial.println(\"Reading value\");\n\n  if (httpRequest(String(\"GET /\") + auth + \"/get/V2\", \"\", response)) {\n    Serial.print(\"Value from server: \");\n    Serial.println(response);\n  }\n\n  // Set Property\n  Serial.println(\"Setting property\");\n\n  if (httpRequest(String(\"GET /\") + auth + \"/update/V2?label=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);\n    }\n  }\n\n  // For more HTTP API, see http://docs.blynkapi.apiary.io\n\n  // Wait\n  delay(30000L);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "rest",
        "webserver",
        "power",
        "wifi",
        "delay",
        "led",
        "eeprom"
      ],
      "libraries": [
        "ESPAutoWiFiConfig.h",
        "ESP8266WiFi.h",
        "ESP8266WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// setup code that must be run every time\n#ifdef DEBUG\n  Serial.begin(115200);\n  Serial.println();\n  for (int i = 10; i > 0; i--) {\n    Serial.print(i); Serial.print(' ');\n    delay(500);\n  }\n  Serial.println();\n#endif\n\n#ifdef DEBUG\n  setESPAutoWiFiConfigDebugOut(Serial); // turns on debug output for the ESPAutoWiFiConfig code\n#endif\n\n  if (ESPAutoWiFiConfigSetup(ledPin, highForLedOn, eepromOffset)) { // check if we should start access point to configure WiFi settings\n    return; // in config mode so skip rest of setup\n  }\n  \n  // when we get here the WiFi has connected !!\n  \n  // normal setup code that is run when not configuring the WiFi settings\n  startWebServer();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//  .. other code that MUST run all the time\n  if (ESPAutoWiFiConfigLoop()) {  // handle WiFi config webpages\n    return;  // skip the rest of the loop until config finished\n  }\n  \n  // .. normal loop code here that is run when not configuring the WiFi settings\n  server.handleClient();"
        },
        {
          "name": "notFound",
          "parameters": "",
          "body": "server.send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "server.send(200, \"text/plain\", \"hello from esp8266!\\r\\n\");"
        },
        {
          "name": "startWebServer",
          "parameters": "",
          "body": "server.on(\"/\", handleRoot);\n  server.onNotFound(notFound);\n  server.begin();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "millis",
        "digitalwrite",
        "delay",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, \"NAN\");\n      Blynk.virtualWrite(V18, \"NAN\");\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_Config using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8288 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8288 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "delay",
        "esp.restart",
        "millis",
        "digitalwrite",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, \"NAN\");\n      Blynk.virtualWrite(V18, \"NAN\");\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "void",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_ForcedConfig using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION); \n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8288 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8288 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "millis",
        "digitalwrite",
        "delay",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, \"NAN\");\n      Blynk.virtualWrite(V18, \"NAN\");\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_Config using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_Config using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  \n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8288 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8288 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "ssl",
        "password",
        "temperature",
        "humidity",
        "wifi",
        "dns",
        "delay",
        "esp.restart",
        "millis",
        "digitalwrite",
        "eeprom",
        "timer",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Ticker.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, \"NAN\");\n      Blynk.virtualWrite(V18, \"NAN\");\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "set_led",
          "parameters": "byte status",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(PIN_LED, OUTPUT);\n  \n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_ForcedConfig using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(F(\"\\nStarting ESP8266WM_MRD_ForcedConfig using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);;\n  \n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif  \n      \n  dht.begin();\n\n  // From v1.0.5\n  // Set config portal SSID and Password\n  Blynk.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n  // Set config portal IP address\n  //Blynk.setConfigPortalIP(IPAddress(192, 168, 200, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  Blynk.setConfigPortalChannel(0);\n\n  // From v1.0.5, select either one of these to set static IP + DNS\n  Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk.setSTAStaticIPConfig(IPAddress(192, 168, 2, 220), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n\n//////////////////////////////////////////////\n  \n#if USING_CUSTOMS_STYLE\n  Blynk.setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  Blynk.setCustomsHeadElement(\"<style>html{filter: invert(10%);}</style>\");\n#endif\n\n#if USING_CORS_FEATURE  \n  Blynk.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  //////////////////////////////////////////////\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk.begin(HOST_NAME);\n\n  timer.setInterval(60 * 1000, readAndSendData);\n\n  if (Blynk.connected())\n  {\n#if ( USE_LITTLEFS || USE_SPIFFS)\n    Serial.print(F(\"\\nBlynk ESP8266 using \"));\n    Serial.print(CurrentFileFS);\n    Serial.println(F(\" connected.\"));\n#else\n    {\n      Serial.println(F(\"\\nBlynk ESP8266 using EEPROM connected.\"));\n      Serial.printf(\"EEPROM size = %d bytes, EEPROM start address = %d / 0x%X\\n\", EEPROM_SIZE, EEPROM_START, EEPROM_START);\n    }\n#endif\n\n    Serial.print(F(\"Board Name : \")); Serial.println(Blynk.getBoardName());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (int i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "http",
        "https",
        "password",
        "json",
        "payload",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "sendTXTMessage",
          "parameters": "",
          "body": "static uint64_t sendTXTMessage_timeout = 0;\n\n  uint64_t now = millis();\n\n  //KH\n#define SEND_INTERVAL         30000L\n\n  // sendTXTMessage every SEND_INTERVAL (30) seconds.\n  if (now > sendTXTMessage_timeout)\n  {\n    //webSocket.sendTXT(\"message here\");\n    // creat JSON message\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    array.add(messageToSend);\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    webSocket.sendTXT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n\n    sendTXTMessage_timeout = millis() + SEND_INTERVAL;\n  }"
        },
        {
          "name": "webSocketEvent",
          "parameters": "const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;\n      }\n\n      break;\n\n    case WStype_CONNECTED:\n    {\n      alreadyConnected = true;\n\n      Serial.print(\"[WSc] Connected to url: \");\n      Serial.println((char *) payload);\n\n      // send message to server when Connected\n      webSocket.sendTXT(\"Connected\");\n    }\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      //sendTXTMessage();\n\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      webSocket.sendBIN(payload, length);\n      break;\n\n    case WStype_PING:\n      // pong will be send automatically\n      Serial.printf(\"[WSc] get ping\\n\");\n      break;\n\n    case WStype_PONG:\n      // answer to a ping we send\n      Serial.printf(\"[WSc] get pong\\n\");\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP8266_AsyncWSClient on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ \");\n  Serial.println(WS_SERVER);\n\n  // server address, port and URL\n#if USE_SSL\n  webSocket.beginSSL(WS_SERVER, WS_PORT);\n#else\n  webSocket.begin(WS_SERVER, WS_PORT, \"/\");\n#endif\n\n\n  // event handler\n  webSocket.onEvent(webSocketEvent);\n\n  // use HTTP Basic Authorization this is optional remove if not needed\n  //webSocket.setAuthorization(\"user\", \"Password\");\n\n  // try ever 5000 again if connection has failed\n  webSocket.setReconnectInterval(5000);\n\n  // start heartbeat (optional)\n  // ping server every 15000 ms\n  // expect pong from server within 3000 ms\n  // consider connection disconnected if pong is not received 2 times\n  webSocket.enableHeartbeat(15000, 3000, 2);\n\n  // server address, port and URL\n  Serial.print(\"Connected to WebSockets Server @ IP address: \");\n  Serial.println(WS_SERVER);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// No more webSocket.loop() in Async\n\n  sendTXTMessage();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "wificlient",
        "http",
        "api",
        "https",
        "token",
        "json",
        "wifi",
        "delay",
        "millis",
        "display"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "connectNetwork",
          "parameters": "",
          "body": "Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println();\n  Serial.println(\"WiFi connected\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  delay(10);\n  Serial.println();\n  Serial.println();\n\n  connectNetwork();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "String response;\n\n  unsigned long value = millis();\n\n  // Send value to the cloud\n  // similar to Blynk.virtualWrite()\n\n  Serial.print(\"Sending value: \");\n  Serial.println(value);\n\n  if (httpRequest(\"GET\", String(\"/external/api/update?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2&value=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);\n    }\n  }\n\n  // Read the value back\n  // similar to Blynk.syncVirtual()\n\n  Serial.println(\"Reading value\");\n\n  if (httpRequest(\"GET\", String(\"/external/api/get?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2\", \"\", response)) {\n    Serial.print(\"Value from server: \");\n    Serial.println(response);\n  }\n\n  // Set Property\n  Serial.println(\"Setting property\");\n\n  if (httpRequest(\"GET\", String(\"/external/api/update/property?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2&label=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);\n    }\n  }\n\n  // For more HTTP API, see https://docs.blynk.io/en/blynk.cloud/https-api-overview\n\n  // Wait\n  delay(30000L);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "power",
        "gsm",
        "gprs",
        "wifi",
        "dns",
        "millis",
        "delay",
        "digitalwrite",
        ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp8266_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp8266_config);\n\n  serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (Blynk_GSM.connected())\n  {\n    Serial.print(F(\"G\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n\n  SerialMon.print(F(\"\\nStart ESP8266_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n  \n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP8266-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP8266_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP8266_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP8266_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP8266_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;\n  }\n  else\n  {\n    valid_apn = true;\n\n    for (uint16_t index = 0; index < NUM_BLYNK_CREDENTIALS; index++)\n    {\n      Blynk_GSM.config(modem, localBlynkGSM_ESP8266_config.Blynk_Creds[index].gsm_blynk_token,\n                       localBlynkGSM_ESP8266_config.Blynk_Creds[index].blynk_server, localBlynkGSM_ESP8266_config.blynk_port);\n\n      GSM_CONNECT_OK = Blynk_GSM.connectNetwork(localBlynkGSM_ESP8266_config.apn, localBlynkGSM_ESP8266_config.gprsUser,\n                       localBlynkGSM_ESP8266_config.gprsPass);\n\n      if (GSM_CONNECT_OK)\n      {\n        if ( Blynk_GSM.connect() == true )\n          break;\n      }\n    }\n  }\n#endif"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();\n  }\n\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "temperature",
        "humidity",
        "power",
        "gsm",
        "gprs",
        "wifi",
        "dns",
        "millis",
        "delay",
        "digitalwrite",
        "sensorupdate",
        "sensor_check_interval",
        ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp8266_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp8266_config);\n\n  serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "SHT3x.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "SensorUpdate",
          "parameters": "",
          "body": "static float temperature;\n  static float rHumidity;\n\n  Sensor.UpdateData();\n\n  temperature = Sensor.GetTemperature();\n  rHumidity   = Sensor.GetRelHumidity();\n\n  if (!isnan(temperature) && !isnan(rHumidity))\n  {\n    if (Blynk_GSM.connected())\n    {\n      Blynk_GSM.virtualWrite(V1, String(temperature, 1));\n      Blynk_GSM.virtualWrite(V2, String(rHumidity, 1));\n    }\n    \n    if (Blynk_WF.connected())\n    {\n      Blynk_WF.virtualWrite(V1, String(temperature, 1));\n      Blynk_WF.virtualWrite(V2, String(rHumidity, 1));\n    }\n    \n    Serial.println(\"\\nTemperature   = \" + String(temperature, 1));\n    Serial.println(\"\\nRel. Humidity = \" + String(rHumidity, 1));\n  }\n  else\n  {\n    if (Blynk_GSM.connected())\n    {\n      Blynk_GSM.virtualWrite(V1, \"NAN\");\n      Blynk_GSM.virtualWrite(V2, \"NAN\");\n    }\n\n    if (Blynk_WF.connected())\n    {\n      Blynk_WF.virtualWrite(V1, \"NAN\");\n      Blynk_WF.virtualWrite(V2, \"NAN\");\n    }\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (Blynk_GSM.connected())\n  {\n    Serial.print(F(\"G\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n  static unsigned long checksensor_timeout = 0;\n\n#define SENSOR_CHECK_INTERVAL     10000L\n#define STATUS_CHECK_INTERVAL     60000L\n  // Read and send Sensor data every SENSOR_CHECK_INTERVAL (10) seconds\n  if ((millis() > checksensor_timeout) || (checksensor_timeout == 0))\n  {\n    // Read and send Sensor to Blynk\n    SensorUpdate();\n\n    checksensor_timeout = millis() + SENSOR_CHECK_INTERVAL;\n\n    // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n    if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n    {\n      // report status to Blynk\n      heartBeatPrint();\n  \n      checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n\n  SerialMon.print(F(\"\\nStart ESP8266_GSM_SHT3x (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  SerialMon.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  Sensor.Begin();\n  \n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP8266-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP8266_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP8266_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP8266_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP8266_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;\n  }\n  else\n  {\n    valid_apn = true;\n\n    for (uint16_t index = 0; index < NUM_BLYNK_CREDENTIALS; index++)\n    {\n      Blynk_GSM.config(modem, localBlynkGSM_ESP8266_config.Blynk_Creds[index].gsm_blynk_token,\n                       localBlynkGSM_ESP8266_config.Blynk_Creds[index].blynk_server, localBlynkGSM_ESP8266_config.blynk_port);\n\n      GSM_CONNECT_OK = Blynk_GSM.connectNetwork(localBlynkGSM_ESP8266_config.apn, localBlynkGSM_ESP8266_config.gprsUser,\n                       localBlynkGSM_ESP8266_config.gprsPass);\n\n      if (GSM_CONNECT_OK)\n      {\n        if ( Blynk_GSM.connect() == true )\n          break;\n      }\n    }\n  }\n#endif"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();\n  }\n\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "power",
        "gsm",
        "gprs",
        "wifi",
        "dns",
        "millis",
        "delay",
        "digitalwrite",
        ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp8266_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp8266_config);\n\n  serial.print(f("
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk_WF.connected())\n  {\n    Serial.print(F(\"B\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (Blynk_GSM.connected())\n  {\n    Serial.print(F(\"G\"));\n  }\n  else\n  {\n    Serial.print(F(\"F\"));\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  while (!SerialMon);\n\n  delay(200);\n\n  SerialMon.print(F(\"\\nStart ESP8266_MRD_GSM (Simultaneous WiFi+GSM) using \"));\n  SerialMon.print(CurrentFileFS);\n  SerialMon.print(F(\" on \")); SerialMon.println(ARDUINO_BOARD);\n  SerialMon.println(BLYNK_GSM_MANAGER_VERSION);\n\n#if USE_BLYNK_WM\n  #if USING_MRD\n    Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n  #else\n    Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n  #endif\n#endif\n  \n  // Set-up modem reset, enable, power pins\n  pinMode(MODEM_PWKEY, OUTPUT);\n  pinMode(MODEM_RST, OUTPUT);\n  pinMode(MODEM_POWER_ON, OUTPUT);\n\n  digitalWrite(MODEM_PWKEY, LOW);\n  digitalWrite(MODEM_RST, HIGH);\n  digitalWrite(MODEM_POWER_ON, HIGH);\n\n  SerialMon.println(F(\"Set GSM module baud rate\"));\n\n  // Set GSM module baud rate\n  SerialAT.begin(115200);\n\n  delay(3000);\n\n  Serial.println(F(\"Use WiFi to connect Blynk\"));\n\n#if USE_BLYNK_WM\n\n  // Set config portal SSID and Password\n  Blynk_WF.setConfigPortal(\"TestPortal-ESP8266\", \"TestPortalPass\");\n    \n  // Use configurable AP IP, instead of default IP 192.168.4.1\n  Blynk_WF.setConfigPortalIP(IPAddress(192, 168, 232, 1));\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-12 to avoid conflict\n  Blynk_WF.setConfigPortalChannel(0);\n\n  // Select either one of these to set static IP + DNS\n  Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(192, 168, 2, 1), IPAddress(8, 8, 8, 8));\n  //Blynk_WF.setSTAStaticIPConfig(IPAddress(192, 168, 2, 232), IPAddress(192, 168, 2, 1), IPAddress(255, 255, 255, 0),\n  //                           IPAddress(4, 4, 4, 4), IPAddress(8, 8, 8, 8));\n  \n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //Blynk_WF.begin();\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  // 24 chars max,- only a..z A..Z 0..9 '-' and no '-' as last char\n  Blynk_WF.begin(\"ESP8266-WiFi-GSM\");\n  \n#else\n  Blynk_WF.begin(wifi_blynk_tok, ssid, pass, blynk_server, BLYNK_HARDWARE_PORT);\n\n  Blynk_GSM.config(modem, gsm_blynk_tok, blynk_server, BLYNK_HARDWARE_PORT);\n  GSM_CONNECT_OK = Blynk_GSM.connectNetwork(apn, gprsUser, gprsPass);\n\n  if (GSM_CONNECT_OK)\n    Blynk_GSM.connect();\n#endif\n\n#if USE_BLYNK_WM\n  Blynk_WF_Configuration localBlynkGSM_ESP8266_config;\n\n  Blynk_WF.getFullConfigData(&localBlynkGSM_ESP8266_config);\n\n  Serial.print(F(\"gprs apn = \"));\n  Serial.println(localBlynkGSM_ESP8266_config.apn);\n\n  if ( Blynk.inConfigPortal() || (String(localBlynkGSM_ESP8266_config.apn) == NO_CONFIG) )\n  {\n    Serial.println(F(\"DRD/MRD, Forced Config Portal or No valid stored apn. Must run only WiFi to Open config portal\"));\n    valid_apn = false;\n  }\n  else\n  {\n    valid_apn = true;\n\n    for (uint16_t index = 0; index < NUM_BLYNK_CREDENTIALS; index++)\n    {\n      Blynk_GSM.config(modem, localBlynkGSM_ESP8266_config.Blynk_Creds[index].gsm_blynk_token,\n                       localBlynkGSM_ESP8266_config.Blynk_Creds[index].blynk_server, localBlynkGSM_ESP8266_config.blynk_port);\n\n      GSM_CONNECT_OK = Blynk_GSM.connectNetwork(localBlynkGSM_ESP8266_config.apn, localBlynkGSM_ESP8266_config.gprsUser,\n                       localBlynkGSM_ESP8266_config.gprsPass);\n\n      if (GSM_CONNECT_OK)\n      {\n        if ( Blynk_GSM.connect() == true )\n          break;\n      }\n    }\n  }\n#endif"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk_WF.run();\n\n#if USE_BLYNK_WM\n  if (valid_apn)\n#endif\n  {\n    if (GSM_CONNECT_OK)\n      Blynk_GSM.run();\n  }\n\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "key",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "WiFiUdp.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  WiFi.begin(ssid, pass);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    DBG(\"Establishing connection to WiFi..\");\n  }\n  DBG(\"Connected to network\");\n\n  DBG(F(\"OK, now make sure you an rtpMIDI session that is Enabled\"));\n  DBG(F(\"Add device named Arduino with Host\"), WiFi.localIP(), \"Port\", AppleMIDI.getPort(), \"(Name\", AppleMIDI.getName(), \")\");\n  DBG(F(\"Select and then press the Connect button\"));\n  DBG(F(\"Then open a MIDI listener and monitor incoming notes\"));\n  DBG(F(\"Listen to incoming MIDI commands\"));\n\n  MIDI.begin();\n\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n  \n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });\n\n  DBG(F(\"Sending NoteOn/Off of note 45, every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t0) > 1000)\n  {\n    t0 = millis();\n\n    byte note = 45;\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "password",
        "key",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266mDNS.h",
        "WiFiClient.h",
        "WiFiUdp.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  WiFi.softAP(ssid, pass);\n\n  DBG(F(\"Started soft access point:\"), WiFi.softAPIP(), \"Port\", AppleMIDI.getPort());\n  DBG(F(\"AppleMIDI device name:\"), AppleMIDI.getName());\n  // Set up mDNS responder:\n  if (!MDNS.begin(AppleMIDI.getName()))\n    DBG(F(\"Error setting up MDNS responder!\"));\n  char str[128] = \"\";\n  strcat(str, AppleMIDI.getName());\n  strcat(str,\".local\");\n  DBG(F(\"mDNS responder started at:\"), str);\n  MDNS.addService(\"apple-midi\", \"udp\", AppleMIDI.getPort());\n  DBG(F(\"Open Wifi settings and connect to soft acess point using 'ssid'\"));\n  DBG(F(\"Start MIDI Network app on iPhone/iPad or rtpMIDI on Windows\"));\n  DBG(F(\"AppleMIDI-ESP8266 will show in the 'Directory' list (rtpMIDI) or\"));\n  DBG(F(\"under 'Found on the network' list (iOS). Select and click 'Connect'\"));\n  \n  MIDI.begin();\n\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char* name) {\n    isConnected++;\n    DBG(F(\"Connected to session\"), ssrc, name);\n  });\n  AppleMIDI.setHandleDisconnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc) {\n    isConnected--;\n    DBG(F(\"Disconnected\"), ssrc);\n  });\n  \n  MIDI.setHandleNoteOn([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOn\"), note);\n  });\n  MIDI.setHandleNoteOff([](byte channel, byte note, byte velocity) {\n    DBG(F(\"NoteOff\"), note);\n  });\n\n  DBG(F(\"Sending NoteOn/Off of note 45, every second\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "MDNS.update();\n  \n  // Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t0) > 1000)\n  {\n    t0 = millis();\n\n    byte note = 45;\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "password",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266_Lib.h",
        "BlynkSimpleShieldEsp8266.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  delay(10);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, wifi, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "password",
        "wifi"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "password",
        "wifi",
        "device_ip",
        "gateway_ip"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Setup WiFi network\n  WiFi.config(device_ip, gateway_ip, subnet_mask);\n  WiFi.begin(ssid, pass);\n\n  // Setup Blynk\n  Blynk.config(BLYNK_AUTH_TOKEN);\n  while (Blynk.connect() == false) {\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "password",
        "wifi"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266_SSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  WiFi.mode(WIFI_STA);\n\n  int cnt = 0;\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n    if (cnt++ >= 10) {\n      WiFi.beginSmartConfig();\n      while (1) {\n        delay(1000);\n        if (WiFi.smartConfigDone()) {\n          Serial.println();\n          Serial.println(\"SmartConfig: Success\");\n          break;\n        }\n        Serial.print(\"|\");\n      }\n    }\n  }\n\n  WiFi.printDiag(Serial);\n\n  Blynk.config(auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "http",
        "https",
        "password",
        "json",
        "payload",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "sendTXTMessage",
          "parameters": "",
          "body": "static uint64_t sendTXTMessage_timeout = 0;\n\n  uint64_t now = millis();\n\n  //KH\n#define SEND_INTERVAL         30000L\n\n  // sendTXTMessage every SEND_INTERVAL (30) seconds.\n  if (now > sendTXTMessage_timeout)\n  {\n    //webSocket.sendTXT(\"message here\");\n    // creat JSON message\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    array.add(messageToSend);\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    webSocket.sendTXT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n\n    sendTXTMessage_timeout = millis() + SEND_INTERVAL;\n  }"
        },
        {
          "name": "webSocketEvent",
          "parameters": "const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;\n      }\n\n      break;\n\n    case WStype_CONNECTED:\n    {\n      alreadyConnected = true;\n\n      Serial.print(\"[WSc] Connected to url: \");\n      Serial.println((char *) payload);\n\n      // send message to server when Connected\n      webSocket.sendTXT(\"Connected\");\n    }\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      //sendTXTMessage();\n\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      webSocket.sendBIN(payload, length);\n      break;\n\n    case WStype_PING:\n      // pong will be send automatically\n      Serial.printf(\"[WSc] get ping\\n\");\n      break;\n\n    case WStype_PONG:\n      // answer to a ping we send\n      Serial.printf(\"[WSc] get pong\\n\");\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClient on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ \");\n  Serial.println(WS_SERVER);\n\n  // server address, port and URL\n#if USE_SSL\n  webSocket.beginSSL(WS_SERVER, WS_PORT);\n#else\n  webSocket.begin(WS_SERVER, WS_PORT, \"/\");\n#endif\n\n\n  // event handler\n  webSocket.onEvent(webSocketEvent);\n\n  // use HTTP Basic Authorization this is optional remove if not needed\n  //webSocket.setAuthorization(\"user\", \"Password\");\n\n  // try ever 5000 again if connection has failed\n  webSocket.setReconnectInterval(5000);\n\n  // start heartbeat (optional)\n  // ping server every 15000 ms\n  // expect pong from server within 3000 ms\n  // consider connection disconnected if pong is not received 2 times\n  webSocket.enableHeartbeat(15000, 3000, 2);\n\n  // server address, port and URL\n  Serial.print(\"Connected to WebSockets Server @ IP address: \");\n  Serial.println(WS_SERVER);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();\n\n  sendTXTMessage();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "http",
        "https",
        "payload",
        "parse",
        "json",
        "current",
        "wifi",
        "esp.restart",
        "yield",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "ArduinoJson.h",
        "ESP8266WiFi.h",
        "ESP8266mDNS.h",
        "Updater.h",
        "WiFiUdp.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "IpAddress2String",
          "parameters": "const IPAddress& ipAddress",
          "body": "return String(ipAddress[0]) + String(\".\") +\n         String(ipAddress[1]) + String(\".\") +\n         String(ipAddress[2]) + String(\".\") +\n         String(ipAddress[3]);"
        },
        {
          "name": "greetings_",
          "parameters": "",
          "body": "StaticJsonDocument<200> doc;\n  doc[\"type\"] = \"greetings\";\n  doc[\"mac\"] = WiFi.macAddress();\n  doc[\"ip\"] = IpAddress2String(WiFi.localIP());\n  doc[\"version\"] = version;\n  doc[\"name\"] = name;\n  doc[\"chip\"] = chip;\n\n  char data[200];\n  serializeJson(doc, data);\n  webSocket.sendTXT(data);"
        },
        {
          "name": "register_",
          "parameters": "",
          "body": "StaticJsonDocument<200> doc;\n  doc[\"type\"] = \"register\";\n  doc[\"mac\"] = WiFi.macAddress();\n\n  char data[200];\n  serializeJson(doc, data);\n  webSocket.sendTXT(data);\n  ws_conn = true;"
        },
        {
          "name": "OTA",
          "parameters": "JsonDocument &msg",
          "body": "Serial.print(F(\"[WSc] OTA mode: \"));\n  const char* go = \"go\";\n  const char* ok = \"ok\";\n\n  if (strncmp( msg[\"value\"], go, strlen(go)) == 0 )\n  {\n    Serial.print(F(\"go\\n\"));\n    SketchSize = int(msg[\"size\"]);\n    maxSketchSpace = (ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000;\n    Serial.printf(\"[WSc] Max sketch size: %u\\n\", maxSketchSpace);\n    Serial.printf(\"[WSc] Sketch size: %d\\n\", SketchSize);\n    Serial.setDebugOutput(true);\n\n    if (!Update.begin(maxSketchSpace))\n    {\n      //start with max available size\n      Update.printError(Serial);\n      ESP.restart();\n    }\n  }\n  else if (strncmp( msg[\"value\"], ok, strlen(ok)) == 0)\n  {\n    Serial.print(F(\"OK\\n\"));\n    register_();\n  }\n  else\n  {\n    Serial.print(F(\"unknown value : \"));\n    Serial.print(msg[\"value\"].as<char>());\n    Serial.print(F(\"\\n\"));\n  }"
        },
        {
          "name": "STATE",
          "parameters": "JsonDocument &msg",
          "body": "// Do something with message\n  (void) msg;"
        },
        {
          "name": "text",
          "parameters": "uint8_t * payload, size_t length",
          "body": "// Convert mesage to something usable\n  char msgch[length];\n\n  for (unsigned int i = 0; i < length; i++)\n  {\n    Serial.print((char)payload[i]);\n    msgch[i] = ((char)payload[i]);\n  }\n\n  msgch[length] = '\\0';\n\n  // Parse Json\n  StaticJsonDocument<200> doc_in;\n  DeserializationError error = deserializeJson(doc_in, msgch);\n\n  if (error)\n  {\n    Serial.print(F(\"deserializeJson() failed: \"));\n    Serial.println(error.c_str());\n    return;\n  }\n\n  // Handle each TYPE of message\n  int b = 0;\n\n  for ( b = 0 ; strlen(responses[b].type) ; b++ )\n  {\n    if ( strncmp(doc_in[\"type\"], responses[b].type, strlen(responses[b].type)) == 0 )\n    {\n      responses[b].func(doc_in);\n    }\n  }"
        },
        {
          "name": "webSocketEvent",
          "parameters": "WStype_t type, uint8_t * payload, size_t length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      if (alreadyConnected)\n      {\n        Serial.println(\"[WSc] Disconnected!\");\n        alreadyConnected = false;\n      }\n\n      break;\n\n    case WStype_CONNECTED:\n    {\n      alreadyConnected = true;\n\n      Serial.print(\"[WSc] Connected to url: \");\n      Serial.println((char *) payload);\n\n      // send message to server when Connected\n      // webSocket.sendTXT(\"Connected\");\n      greetings_();\n    }\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      // webSocket.sendTXT(\"message here\");\n      text(payload, length);\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n\n      // hexdump(payload, length);\n\n      if (Update.write(payload, length) != length)\n      {\n        Update.printError(Serial);\n        ESP.restart();\n      }\n\n      yield();\n      SketchSize -= length;\n      Serial.printf(\"[WSc] Sketch size left: %u\\n\", SketchSize);\n\n      if (SketchSize < 1)\n      {\n        if (Update.end(true))\n        {\n          //true to set the size to the current progress\n          Serial.printf(\"Update Success: \\nRebooting...\\n\");\n          delay(5);\n          yield();\n          ESP.restart();\n        }\n        else\n        {\n          Update.printError(Serial);\n          ESP.restart();\n        }\n\n        Serial.setDebugOutput(false);\n      }\n\n      // send data to server\n      // webSocket.sendBIN(payload, length);\n      break;\n\n    case WStype_PING:\n      // pong will be send automatically\n      Serial.printf(\"[WSc] get ping\\n\");\n      break;\n\n    case WStype_PONG:\n      // answer to a ping we send\n      Serial.printf(\"[WSc] get pong\\n\");\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientOTA on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  webSocket.begin(WS_SERVER, WS_PORT, \"/\");\n\n  // event handler\n  webSocket.onEvent(webSocketEvent);\n\n  // use HTTP Basic Authorization this is optional remove if not needed\n  // webSocket.setAuthorization(\"USER\", \"PASS\");\n\n  // try ever 5000 again if connection has failed\n  webSocket.setReconnectInterval(5000);\n\n  // start heartbeat (optional)\n  // ping server every 15000 ms\n  // expect pong from server within 3000 ms\n  // consider connection disconnected if pong is not received 2 times\n  webSocket.enableHeartbeat(15000, 3000, 2);\n\n  // server address, port and URL\n  Serial.print(\"Connected to WebSockets OTA Server @ IP address: \");\n  Serial.println(WS_SERVER);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "payload",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsClient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "parameters": "const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n      break;\n\n    case WStype_CONNECTED:\n      Serial.printf(\"[WSc] Connected to url: %s\\n\", payload);\n\n      // send message to server when Connected\n      webSocket.sendTXT(\"Connected\");\n      break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      // send message to server\n      webSocket.sendTXT(\"message here\");\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      webSocket.sendBIN(payload, length);\n      break;\n\n    case WStype_ERROR:\n    case WStype_FRAGMENT_TEXT_START:\n    case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT:\n    case WStype_FRAGMENT_FIN:\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientSSL on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  webSocket.beginSSL(WS_SERVER, SSL_PORT);\n  webSocket.onEvent(webSocketEvent);\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ IP address: \");\n  Serial.println(WS_SERVER);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "payload",
        "json",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "parameters": "const socketIOmessageType_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n      Serial.print(\"[IOc] Get event: \");\n      Serial.println((char*) payload);\n\n      break;\n\n    case sIOtype_ACK:\n      Serial.print(\"[IOc] Get ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_ERROR:\n      Serial.print(\"[IOc] Get error: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_EVENT:\n      Serial.print(\"[IOc] Get binary: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_ACK:\n      Serial.print(\"[IOc] Get binary ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_PING:\n      Serial.println(\"[IOc] Get PING\");\n\n      break;\n\n    case sIOtype_PONG:\n      Serial.println(\"[IOc] Get PONG\");\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientSocketIO on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  // disable AP\n  if (WiFi.getMode() & WIFI_AP)\n  {\n    WiFi.softAPdisconnect(true);\n  }\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ IP address: \");\n  Serial.print(serverIP);\n  Serial.print(\", port: \");\n  Serial.println(serverPort);\n\n  // setReconnectInterval to 10s, new from v2.5.1 to avoid flooding server. Default is 0.5s\n  socketIO.setReconnectInterval(10000);\n\n  socketIO.setExtraHeaders(\"Authorization: 1234567890\");\n\n  // server address, port and URL\n  // void begin(IPAddress host, uint16_t port, String url = \"/socket.io/?EIO=4\", String protocol = \"arduino\");\n  // To use default EIO=4 fron v2.5.1\n  socketIO.begin(serverIP, serverPort);\n\n  // event handler\n  socketIO.onEvent(socketIOEvent);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "payload",
        "callback",
        "json",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "parameters": "const socketIOmessageType_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n    {\n      char * sptr = NULL;\n      int id = strtol((char *)payload, &sptr, 10);\n\n      Serial.print(\"[IOc] Get event: \");\n      Serial.print((char*) payload);\n      Serial.print(\", id: \");\n      Serial.println(id);\n\n      if (id)\n      {\n        payload = (uint8_t *)sptr;\n      }\n\n      DynamicJsonDocument doc(1024);\n      DeserializationError error = deserializeJson(doc, payload, length);\n\n      if (error)\n      {\n        Serial.print(F(\"DeserializeJson() failed: \"));\n        Serial.println(error.c_str());\n        return;\n      }\n\n      String eventName = doc[0];\n\n      Serial.print(\"[IOc] Event name: \");\n      Serial.println(eventName);\n\n      // Message Includes a ID for a ACK (callback)\n      if (id)\n      {\n        // creat JSON message for Socket.IO (ack)\n        DynamicJsonDocument docOut(1024);\n        JsonArray array = docOut.to<JsonArray>();\n\n        // add payload (parameters) for the ack (callback function)\n        JsonObject param1 = array.createNestedObject();\n        param1[\"now\"] = millis();\n\n        // JSON to String (serializion)\n        String output;\n        output += id;\n        serializeJson(docOut, output);\n\n        // Send event\n        socketIO.send(sIOtype_ACK, output);\n      }\n    }\n\n    break;\n\n    case sIOtype_ACK:\n      Serial.print(\"[IOc] Get ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_ERROR:\n      Serial.print(\"[IOc] Get error: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_EVENT:\n      Serial.print(\"[IOc] Get binary: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_ACK:\n      Serial.print(\"[IOc] Get binary ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_PING:\n      Serial.println(\"[IOc] Get PING\");\n\n      break;\n\n    case sIOtype_PONG:\n      Serial.println(\"[IOc] Get PONG\");\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientSocketIOack on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  // disable AP\n  if (WiFi.getMode() & WIFI_AP)\n  {\n    WiFi.softAPdisconnect(true);\n  }\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ IP address: \");\n  Serial.print(serverIP);\n  Serial.print(\", port: \");\n  Serial.println(serverPort);\n\n  // setReconnectInterval to 10s, new from v2.5.1 to avoid flooding server. Default is 0.5s\n  socketIO.setReconnectInterval(10000);\n\n  socketIO.setExtraHeaders(\"Authorization: 1234567890\");\n\n  // server address, port and URL\n  // void begin(IPAddress host, uint16_t port, String url = \"/socket.io/?EIO=4\", String protocol = \"arduino\");\n  // To use default EIO=4 from v2.5.1\n  socketIO.begin(serverIP, serverPort);\n\n  // event handler\n  socketIO.onEvent(socketIOEvent);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "payload",
        "subscribe",
        "current",
        "wifi",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "Hash.h",
        "ESP8266WiFi.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "sendMessage",
          "parameters": "const String & msg",
          "body": "webSocket.sendTXT(msg.c_str(), msg.length() + 1);"
        },
        {
          "name": "webSocketEvent",
          "parameters": "const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n      break;\n\n    case WStype_CONNECTED:\n    {\n      Serial.printf(\"[WSc] Connected to url: %s\\n\",  payload);\n\n      String msg = \"CONNECT\\r\\naccept-version:1.1,1.0\\r\\nheart-beat:10000,10000\\r\\n\\r\\n\";\n      sendMessage(msg);\n    }\n    break;\n\n    case WStype_TEXT:\n    {\n      // #####################\n      // handle STOMP protocol\n      // #####################\n\n      String text = (char*) payload;\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      if (text.startsWith(\"CONNECTED\"))\n      {\n        // subscribe to some channels\n        String msg = \"SUBSCRIBE\\nid:sub-0\\ndestination:/user/queue/messages\\n\\n\";\n        sendMessage(msg);\n        delay(1000);\n\n        // and send a message\n        msg = \"SEND\\ndestination:/app/message\\n\\n{\\\"user\\\":\\\"esp\\\",\\\"message\\\":\\\"Hello!\\\"}\";\n        sendMessage(msg);\n        delay(1000);\n      }\n      else\n      {\n        // do something with messages\n      }\n\n      break;\n    }\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      // webSocket.sendBIN(payload, length);\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientStomp on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  // connect to WiFi\n  Serial.print(\"Logging into WLAN: \");\n  Serial.print(wlan_ssid);\n  Serial.print(\" ...\");\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(wlan_ssid, wlan_password);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\" success.\");\n  Serial.print(\"WebSockets Client IP: \");\n  Serial.println(WiFi.localIP());\n\n  // connect to websocket\n  webSocket.begin(ws_host, ws_port, stompUrl);\n  webSocket.setExtraHeaders(); // remove \"Origin: file://\" header because it breaks the connection with Spring's default websocket config\n  //webSocket.setExtraHeaders(\"foo: I am so funny\\r\\nbar: not\"); // some headers, in case you feel funny\n  webSocket.onEvent(webSocketEvent);\n\n  // server address, port and URL\n  Serial.println(\"Connecting to WebSockets Server @ : \" + String(ws_host) + \":\" + ws_port + stompUrl );"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "http",
        "https",
        "payload",
        "subscribe",
        "current",
        "wifi",
        "delay",
        "html"
      ],
      "libraries": [
        "Arduino.h",
        "Hash.h",
        "ESP8266WiFi.h",
        "WebSocketsClient_Generic.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "parameters": "const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[WSc] Disconnected!\\n\");\n      break;\n\n    case WStype_CONNECTED:\n    {\n      Serial.printf(\"[WSc] Connected to url: %s\\n\",  payload);\n    }\n    break;\n\n    case WStype_TEXT:\n    {\n      // #####################\n      // handle SockJs+STOMP protocol\n      // #####################\n\n      String text = (char*) payload;\n\n      Serial.printf(\"[WSc] get text: %s\\n\", payload);\n\n      if (payload[0] == 'h')\n      {\n        Serial.println(\"Heartbeat!\");\n      }\n      else if (payload[0] == 'o')\n      {\n        // on open connection\n        const char *msg = \"[\\\"CONNECT\\\\naccept-version:1.1,1.0\\\\nheart-beat:10000,10000\\\\n\\\\n\\\\u0000\\\"]\";\n        webSocket.sendTXT(msg);\n\n      }\n      else if (text.startsWith(\"a[\\\"CONNECTED\"))\n      {\n        // subscribe to some channels\n\n        const char *msg = \"[\\\"SUBSCRIBE\\\\nid:sub-0\\\\ndestination:/user/queue/messages\\\\n\\\\n\\\\u0000\\\"]\";\n        webSocket.sendTXT(msg);\n        delay(1000);\n\n        // and send a message\n        msg = \"[\\\"SEND\\\\ndestination:/app/message\\\\n\\\\n{\\\\\\\"user\\\\\\\":\\\\\\\"esp\\\\\\\",\\\\\\\"message\\\\\\\":\\\\\\\"Hello!\\\\\\\"}\\\\u0000\\\"]\";\n        webSocket.sendTXT(msg);\n        delay(1000);\n      }\n\n      break;\n    }\n\n    case WStype_BIN:\n      Serial.printf(\"[WSc] get binary length: %u\\n\", length);\n      hexdump(payload, length);\n\n      // send data to server\n      // webSocket.sendBIN(payload, length);\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClientStompOverSockJs on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  // connect to WiFi\n  Serial.print(\"Logging into WLAN: \");\n  Serial.print(wlan_ssid);\n  Serial.print(\" ...\");\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(wlan_ssid, wlan_password);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\" success.\");\n  Serial.print(\"WebSockets Client @ IP: \");\n  Serial.println(WiFi.localIP());\n\n  // #####################\n  // create socket url according to SockJS protocol (cf. http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-36)\n  // #####################\n  String socketUrl = ws_baseurl;\n  socketUrl += random(0, 999);\n  socketUrl += \"/\";\n  socketUrl += random(0, 999999); // should be a random string, but this works (see )\n  socketUrl += \"/websocket\";\n\n  // connect to websocket\n  webSocket.begin(ws_host, ws_port, socketUrl);\n  webSocket.setExtraHeaders(); // remove \"Origin: file://\" header because it breaks the connection with Spring's default websocket config\n  //    webSocket.setExtraHeaders(\"foo: I am so funny\\r\\nbar: not\"); // some headers, in case you feel funny\n  webSocket.onEvent(webSocketEvent);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "payload",
        "json",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "ArduinoJson.h",
        "WebSocketsClient_Generic.h",
        "SocketIOclient_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "socketIOEvent",
          "parameters": "const socketIOmessageType_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case sIOtype_DISCONNECT:\n      Serial.println(\"[IOc] Disconnected\");\n      break;\n\n    case sIOtype_CONNECT:\n      Serial.print(\"[IOc] Connected to url: \");\n      Serial.println((char*) payload);\n\n      // join default namespace (no auto join in Socket.IO V3)\n      socketIO.send(sIOtype_CONNECT, \"/\");\n\n      break;\n\n    case sIOtype_EVENT:\n      Serial.print(\"[IOc] Get event: \");\n      Serial.println((char*) payload);\n\n      break;\n\n    case sIOtype_ACK:\n      Serial.print(\"[IOc] Get ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_ERROR:\n      Serial.print(\"[IOc] Get error: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_EVENT:\n      Serial.print(\"[IOc] Get binary: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_BINARY_ACK:\n      Serial.print(\"[IOc] Get binary ack: \");\n      Serial.println(length);\n\n      hexdump(payload, length);\n      break;\n\n    case sIOtype_PING:\n      Serial.println(\"[IOc] Get PING\");\n\n      break;\n\n    case sIOtype_PONG:\n      Serial.println(\"[IOc] Get PONG\");\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  while (!Serial);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketClient_Sticky_SocketIO on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  // disable AP\n  if (WiFi.getMode() & WIFI_AP)\n  {\n    WiFi.softAPdisconnect(true);\n  }\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // Client address\n  Serial.print(\"WebSockets Client started @ IP address: \");\n  Serial.println(WiFi.localIP());\n\n  // server address, port and URL\n  Serial.print(\"Connecting to WebSockets Server @ IP address: \");\n  Serial.print(serverIP);\n  Serial.print(\", port: \");\n  Serial.println(serverPort);\n\n  // setReconnectInterval to 10s, new from v2.5.1 to avoid flooding server. Default is 0.5s\n  socketIO.setReconnectInterval(10000);\n\n  socketIO.setExtraHeaders(\"Authorization: 1234567890\");\n\n  // server address, port and URL\n  // void begin(IPAddress host, uint16_t port, String url = \"/socket.io/?EIO=4\", String protocol = \"arduino\");\n  // To use default EIO=4 fron v2.5.1\n  socketIO.begin(serverIP, serverPort);\n\n  // event handler\n  socketIO.onEvent(socketIOEvent);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "socketIO.loop();\n\n  uint64_t now = millis();\n\n  if (now - messageTimestamp > 30000)\n  {\n    messageTimestamp = now;\n\n    // creat JSON message for Socket.IO (event)\n    DynamicJsonDocument doc(1024);\n    JsonArray array = doc.to<JsonArray>();\n\n    // add evnet name\n    // Hint: socket.on('event_name', ....\n    array.add(\"event_name\");\n\n    // add payload (parameters) for the event\n    JsonObject param1 = array.createNestedObject();\n    param1[\"now\"]     = (uint32_t) now;\n\n    // JSON to String (serializion)\n    String output;\n    serializeJson(doc, output);\n\n    // Send event\n    socketIO.sendEVENT(output);\n\n    // Print JSON for debugging\n    Serial.println(output);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "payload",
        "wifi",
        "delay",
        "clients"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "parameters": "const uint8_t& num, const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "(void) length;\n\n  switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");\n    }\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[%u] get Text: %s\\n\", num, payload);\n\n      // send message to client\n      // webSocket.sendTXT(num, \"message here\");\n\n      // send data to all connected clients\n      // webSocket.broadcastTXT(\"message here\");\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[%u] get binary length: %u\\n\", num, length);\n      hexdump(payload, length);\n\n      // send message to client\n      // webSocket.sendBIN(num, payload, length);\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServer on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(\"Version \" + String(WEBSOCKETS_GENERIC_VERSION));\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // print your board's IP address:\n  Serial.print(\"WebSockets Server started @ IP Address: \");\n  Serial.println(WiFi.localIP());\n\n  webSocket.begin();\n  webSocket.onEvent(webSocketEvent);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "websocket",
        "http",
        "https",
        "payload",
        "wifi",
        "analogwrite",
        "digitalwrite",
        "delay",
        "millis",
        "rgb",
        "led",
        "html",
        "clients"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "parameters": "const uint8_t& num, const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "(void) length;\n\n  switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");\n    }\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[%u] get Text: %s\\n\", num, payload);\n\n      if (payload[0] == '#')\n      {\n        // we get RGB data\n\n        // decode rgb data\n        uint32_t rgb = (uint32_t) strtol((const char *) &payload[1], NULL, 16);\n\n        analogWrite(LED_RED, ((rgb >> 16) & 0xFF));\n        analogWrite(LED_GREEN, ((rgb >> 8) & 0xFF));\n        analogWrite(LED_BLUE, ((rgb >> 0) & 0xFF));\n      }\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(LED_BLUE, OUTPUT);\n\n  digitalWrite(LED_RED, 1);\n  digitalWrite(LED_GREEN, 1);\n  digitalWrite(LED_BLUE, 1);\n\n  //Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServerAllFunctionsDemo on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // start webSocket server\n  webSocket.begin();\n  webSocket.onEvent(webSocketEvent);\n\n  if (MDNS.begin(\"esp8266\"))\n  {\n    Serial.println(\"MDNS responder started\");\n  }\n\n  // handle index\n  server.on(\"/\", []()\n  {\n    // send index.html\n    server.send(200, \"text/html\",\n                \"<html><head><script>var connection = new WebSocket('ws://'+location.hostname+':81/', ['arduino']);connection.onopen = function () {  connection.send('Connect ' + new Date()); }; connection.onerror = function (error) {    console.log('WebSocket Error ', error);};connection.onmessage = function (e) {  console.log('Server: ', e.data);};function sendRGB() {  var r = parseInt(document.getElementById('r').value).toString(16);  var g = parseInt(document.getElementById('g').value).toString(16);  var b = parseInt(document.getElementById('b').value).toString(16);  if(r.length < 2) { r = '0' + r; }   if(g.length < 2) { g = '0' + g; }   if(b.length < 2) { b = '0' + b; }   var rgb = '#'+r+g+b;    console.log('RGB: ' + rgb); connection.send(rgb); }</script></head><body>LED Control:<br/><br/>R: <input id=\\\"r\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"255\\\" step=\\\"1\\\" oninput=\\\"sendRGB();\\\" /><br/>G: <input id=\\\"g\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"255\\\" step=\\\"1\\\" oninput=\\\"sendRGB();\\\" /><br/>B: <input id=\\\"b\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"255\\\" step=\\\"1\\\" oninput=\\\"sendRGB();\\\" /><br/></body></html>\");\n  });\n\n  server.begin();\n\n  // Add service to MDNS\n  MDNS.addService(\"http\", \"tcp\", 80);\n  MDNS.addService(\"ws\", \"tcp\", 81);\n\n  digitalWrite(LED_RED, 0);\n  digitalWrite(LED_GREEN, 0);\n  digitalWrite(LED_BLUE, 0);\n\n  // server address, port and URL\n  Serial.print(\"WebSockets Server started @ IP address: \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "unsigned long t = millis();\n  webSocket.loop();\n  server.handleClient();\n\n  if ((t - last_10sec) > 10 * 1000)\n  {\n    counter++;\n    bool ping = (counter % 2);\n    int i = webSocket.connectedClients(ping);\n    Serial.printf(\"%d Connected websocket clients ping: %d\\n\", i, ping);\n    last_10sec = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "payload",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "parameters": "const uint8_t& num, const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");\n    }\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[%u] get Text: %s\\n\", num, payload);\n      break;\n\n    case WStype_BIN:\n      Serial.printf(\"[%u] get binary length: %u\\n\", num, length);\n      hexdump(payload, length);\n      break;\n\n    // Fragmentation / continuation opcode handling\n    // case WStype_FRAGMENT_BIN_START:\n    case WStype_FRAGMENT_TEXT_START:\n      fragmentBuffer = (char*)payload;\n      Serial.printf(\"[%u] get start start of Textfragment: %s\\n\", num, payload);\n      break;\n\n    case WStype_FRAGMENT:\n      fragmentBuffer += (char*)payload;\n      Serial.printf(\"[%u] get Textfragment : %s\\n\", num, payload);\n      break;\n\n    case WStype_FRAGMENT_FIN:\n      fragmentBuffer += (char*)payload;\n      Serial.printf(\"[%u] get end of Textfragment: %s\\n\", num, payload);\n      Serial.printf(\"[%u] full frame: %s\\n\", num, fragmentBuffer.c_str());\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServerFragmentation on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  webSocket.begin();\n  webSocket.onEvent(webSocketEvent);\n\n  // server address, port and URL\n  Serial.print(\"WebSockets Server started @ IP address: \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "wifi",
        "delay",
        "clients"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "isCookieValid",
          "parameters": "const String& rawCookieHeaderValue",
          "body": "if (rawCookieHeaderValue.indexOf(\"sessionId\") != -1)\n  {\n    String sessionIdStr = rawCookieHeaderValue.substring(rawCookieHeaderValue.indexOf(\"sessionId=\") + 10,\n                                                         rawCookieHeaderValue.indexOf(\"|\"));\n    unsigned long int sessionId = strtoul(sessionIdStr.c_str(), NULL, 10);\n    return sessionId == validSessionId;\n  }\n\n  return false;"
        },
        {
          "name": "validateHttpHeader",
          "parameters": "const String& headerName, const String& headerValue",
          "body": "//assume a true response for any headers not handled by this validator\n  bool valid = true;\n\n  if (headerName.equalsIgnoreCase(\"Cookie\"))\n  {\n    //if the header passed is the Cookie header, validate it according to the rules in 'isCookieValid' function\n    valid = isCookieValid(headerValue);\n  }\n\n  return valid;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServerHttpHeaderValidation on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  //connecting clients must supply a valid session cookie at websocket upgrade handshake negotiation time\n  const char * headerkeys[] = { \"Cookie\" };\n  size_t headerKeyCount = sizeof(headerkeys) / sizeof(char*);\n  webSocket.onValidateHttpHeader(validateHttpHeader, headerkeys, headerKeyCount);\n  webSocket.begin();\n\n  // server address, port and URL\n  Serial.print(\"WebSockets Server started @ IP address: \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "webSocket.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "websocket",
        "http",
        "https",
        "payload",
        "wifi",
        "analogwrite",
        "digitalwrite",
        "delay",
        "millis",
        "rgb",
        "led",
        "html"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "ESP8266WiFiMulti.h",
        "WebSocketsServer_Generic.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "Hash.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "parameters": "const uint8_t& num, const WStype_t& type, uint8_t * payload, const size_t& length",
          "body": "(void) length;\n\n  switch (type)\n  {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n\n    case WStype_CONNECTED:\n    {\n      IPAddress ip = webSocket.remoteIP(num);\n      Serial.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n\n      // send message to client\n      webSocket.sendTXT(num, \"Connected\");\n    }\n    break;\n\n    case WStype_TEXT:\n      Serial.printf(\"[%u] get Text: %s\\n\", num, payload);\n\n      if (payload[0] == '#')\n      {\n        // we get RGB data\n\n        // decode rgb data\n        uint32_t rgb = (uint32_t) strtol((const char *) &payload[1], NULL, 16);\n\n        analogWrite(LED_RED,    ((rgb >> 16) & 0xFF));\n        analogWrite(LED_GREEN,  ((rgb >> 8) & 0xFF));\n        analogWrite(LED_BLUE,   ((rgb >> 0) & 0xFF));\n      }\n\n      break;\n\n    default:\n      break;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(LED_BLUE, OUTPUT);\n\n  digitalWrite(LED_RED, 1);\n  digitalWrite(LED_GREEN, 1);\n  digitalWrite(LED_BLUE, 1);\n\n  // Serial.begin(921600);\n  Serial.begin(115200);\n\n  Serial.print(\"\\nStart ESP8266_WebSocketServer_LEDcontrol on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(WEBSOCKETS_GENERIC_VERSION);\n\n  //Serial.setDebugOutput(true);\n\n  //WiFi.config(static_ip, static_gw, static_sn);\n\n  WiFiMulti.addAP(\"SSID\", \"passpasspass\");\n\n  //WiFi.disconnect();\n  while (WiFiMulti.run() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n\n  // start webSocket server\n  webSocket.begin();\n  webSocket.onEvent(webSocketEvent);\n\n  if (MDNS.begin(\"esp8266\"))\n  {\n    Serial.println(\"MDNS responder started\");\n  }\n\n  // handle index\n  server.on(\"/\", []()\n  {\n    // send index.html\n    server.send(200, \"text/html\",\n                \"<html><head><script>var connection = new WebSocket('ws://'+location.hostname+':81/', ['arduino']); connection.onopen = function () {  connection.send('Connect ' + new Date()); }; connection.onerror = function (error) {    console.log('WebSocket Error ', error);};connection.onmessage = function (e) {  console.log('Server: ', e.data);};function sendRGB() {  var r = parseInt(document.getElementById('r').value).toString(16);  var g = parseInt(document.getElementById('g').value).toString(16);  var b = parseInt(document.getElementById('b').value).toString(16);  if(r.length < 2) { r = '0' + r; }   if(g.length < 2) { g = '0' + g; }   if(b.length < 2) { b = '0' + b; }   var rgb = '#'+r+g+b;    console.log('RGB: ' + rgb); connection.send(rgb); }</script></head><body>LED Control:<br/><br/>R: <input id=\\\"r\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"255\\\" step=\\\"1\\\" oninput=\\\"sendRGB();\\\" /><br/>G: <input id=\\\"g\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"255\\\" step=\\\"1\\\" oninput=\\\"sendRGB();\\\" /><br/>B: <input id=\\\"b\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"255\\\" step=\\\"1\\\" oninput=\\\"sendRGB();\\\" /><br/></body></html>\");\n  });\n\n  server.begin();\n\n  // Add service to MDNS\n  MDNS.addService(\"http\", \"tcp\", 80);\n  MDNS.addService(\"ws\", \"tcp\", 81);\n\n  digitalWrite(LED_RED, 0);\n  digitalWrite(LED_GREEN, 0);\n  digitalWrite(LED_BLUE, 0);\n\n  // server address, port and URL\n  Serial.print(\"WebSockets Server started @ IP address: \");\n  Serial.println(WiFi.localIP());"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n    Serial.print(\"F\");        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n  //KH\n#define HEARTBEAT_INTERVAL    20000L\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (20) seconds.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "check_status();\n  webSocket.loop();\n  server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "password",
        "current",
        "temperature",
        "wifi",
        "delay",
        "html",
        "sensor1_reading",
        "sensor2_reading"
      ],
      "libraries": [
        "Arduino.h",
        "ESPAsyncWebServer.h",
        "WiFi.h",
        "TemplateTango.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    // Connect to Wi-Fi\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(1000);\n        Serial.println(\"Connecting to WiFi...\");\n    }\n    Serial.println(\"Connected to WiFi\");\n\n    // Define the template string\n    string templateStr = R\"(\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>ESPAsyncWebServer Example</title>\n        </head>\n        <body>\n            <h1>Sensor Data</h1>\n            <p>Current Temperature: {{temperature}} °C</p>\n            <p>Temperature in Fahrenheit: {{(temperature * 9 / 5) + 32}} °F</p>\n            <p>Sensor 1 Reading: {{sensor1_reading}}</p>\n            <p>Sensor 2 Reading: {{sensor2_reading}}</p>\n        </body>\n        </html>\n    )\";\n\n    // Define the route to handle the main page\n    server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request) {\n        // Collect the variable values\n        std::map<string, string> variables = {\n            {\"temperature\", readTemperature()},\n            {\"sensor1_reading\", readSensor1()},\n            {\"sensor2_reading\", readSensor2()}\n        };\n\n        // Render the template with the collected variables\n        string processedTemplate = TemplateTango::render(templateStr, variables);\n        request->send(200, \"text/html\", processedTemplate.c_str());\n    });\n\n    // Start server\n    server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Main loop"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "wifi",
        "millis",
        "delay",
        "eeprom",
        "spiffs",
        "littlefs",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n  {\n    if (ESPAsync_WiFiManager->isConfigMode())\n      Serial.print(\"C\");        // C means in Config Mode\n    else\n      Serial.print(\"F\");        // F means not connected to WiFi\n  }\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n  //KH\n#define HEARTBEAT_INTERVAL    20000L\n  // Print hearbeat every HEARTBEAT_INTERVAL (20) seconds.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESPAsync_WiFi using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFI_MANAGER_LITE_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  ESPAsync_WiFiManager = new ESPAsync_WiFiManager_Lite();\n  String AP_SSID = \"your_customized_ssid\";\n  String AP_PWD  = \"your_customized_pwd\";\n  \n  // Set customized AP SSID and PWD\n  ESPAsync_WiFiManager->setConfigPortal(AP_SSID, AP_PWD);\n\n  // Optional to change default AP IP(192.168.4.1) and channel(10)\n  //ESPAsync_WiFiManager->setConfigPortalIP(IPAddress(192, 168, 120, 1));\n  ESPAsync_WiFiManager->setConfigPortalChannel(0);\n\n#if USING_CUSTOMS_STYLE\n  ESPAsync_WiFiManager->setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  ESPAsync_WiFiManager->setCustomsHeadElement(PSTR(\"<style>html{filter: invert(10%);}</style>\"));\n#endif\n\n#if USING_CORS_FEATURE\n  ESPAsync_WiFiManager->setCORSHeader(PSTR(\"Your Access-Control-Allow-Origin\"));\n#endif\n\n  // Set customized DHCP HostName\n  ESPAsync_WiFiManager->begin(HOST_NAME);\n  //Or use default Hostname \"ESP_XXXXXX\"\n  //ESPAsync_WiFiManager->begin();"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ESPAsync_WiFiManager->run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "mqtt",
        "https",
        "publish",
        "subscribe",
        "temperature",
        "wifi",
        "digitalwrite",
        "millis",
        "delay",
        "eeprom",
        "spiffs",
        "littlefs",
        "html"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "Adafruit_MQTT.h",
        "Adafruit_MQTT_Client.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(\"H\");        // H means connected to WiFi\n  else\n  {\n    if (ESPAsync_WiFiManager->isConfigMode())\n      Serial.print(\"C\");        // C means in Config Mode\n    else\n      Serial.print(\"F\");        // F means not connected to WiFi\n  }\n\n  if (num == 40)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 5 == 0)\n  {\n    Serial.print(\" \");\n  }"
        },
        {
          "name": "publishMQTT",
          "parameters": "",
          "body": "MQTT_connect();\n\n  if (Temperature->publish(measuredTemp))\n  {\n    //Serial.println(F(\"Failed to send value to Temperature feed!\"));\n    Serial.print(F(\"T\"));        // T means publishing OK\n  }\n  else\n  {\n    //Serial.println(F(\"Value to Temperature feed sucessfully sent!\"));\n    Serial.print(F(\"F\"));        // F means publishing failure\n  }"
        },
        {
          "name": "subscribeMQTT",
          "parameters": "",
          "body": "Adafruit_MQTT_Subscribe *subscription;\n\n  MQTT_connect();\n\n  while ((subscription = mqtt->readSubscription(5000)))\n  {\n    if (subscription == LED_Control)\n    {\n      Serial.print(F(\"\\nGot: \"));\n      Serial.println((char *)LED_Control->lastread);\n\n      if (!strcmp((char*) LED_Control->lastread, \"ON\"))\n      {\n        digitalWrite(LED_PIN, HIGH);\n      }\n      else\n      {\n        digitalWrite(LED_PIN, LOW);\n      }\n    }\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n  //KH\n#define HEARTBEAT_INTERVAL    5000L\n  // Print WiFi hearbeat, Publish MQTT Topic every HEARTBEAT_INTERVAL (5) seconds.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    if (WiFi.status() == WL_CONNECTED)\n    {\n      // MQTT related jobs\n      publishMQTT();\n      subscribeMQTT();\n    }\n\n    heartBeatPrint();\n    checkstatus_timeout = millis() + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "deleteOldInstances",
          "parameters": "",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    Serial.println(F(\"Deleting old MQTT object\"));\n  }\n\n  if (Temperature)\n  {\n    delete Temperature;\n    Temperature = NULL;\n    Serial.println(F(\"Deleting old Temperature object\"));\n  }"
        },
        {
          "name": "createNewInstances",
          "parameters": "",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n\n    if (client)\n    {\n      Serial.println(F(\"\\nCreating new WiFi client object OK\"));\n    }\n    else\n      Serial.println(F(\"\\nCreating new WiFi client object failed\"));\n  }\n\n  // Create new instances from new data\n  if (!mqtt)\n  {\n    // Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.\n    mqtt = new Adafruit_MQTT_Client(client, AIO_SERVER, atoi(AIO_SERVERPORT), AIO_USERNAME, AIO_KEY);\n\n    if (mqtt)\n    {\n      Serial.println(F(\"Creating new MQTT object OK\"));\n      Serial.print(F(\"AIO_SERVER = \"));\n      Serial.print(AIO_SERVER);\n      Serial.print(F(\", AIO_SERVERPORT = \"));\n      Serial.println(AIO_SERVERPORT);\n      Serial.print(F(\"AIO_USERNAME = \"));\n      Serial.print(AIO_USERNAME);\n      Serial.print(F(\", AIO_KEY = \"));\n      Serial.println(AIO_KEY);\n    }\n    else\n      Serial.println(F(\"Creating new MQTT object failed\"));\n  }\n\n  if (!Temperature)\n  {\n#if USE_GLOBAL_TOPIC\n    completePubTopic = String(AIO_USERNAME) + String(AIO_PUB_TOPIC);\n#else\n    // Must be static or global\n    static String completePubTopic = String(AIO_USERNAME) + String(AIO_PUB_TOPIC);\n#endif\n\n    Temperature = new Adafruit_MQTT_Publish(mqtt, completePubTopic.c_str());\n    Serial.print(F(\"Creating new MQTT_Pub_Topic, Temperature = \"));\n    Serial.println(completePubTopic);\n\n    if (Temperature)\n    {\n      Serial.println(F(\"Creating new Temperature object OK\"));\n      Serial.print(F(\"Temperature MQTT_Pub_Topic = \"));\n      Serial.println(completePubTopic);\n    }\n    else\n      Serial.println(F(\"Creating new Temperature object failed\"));\n  }\n\n  if (!LED_Control)\n  {\n#if USE_GLOBAL_TOPIC\n    completeSubTopic = String(AIO_USERNAME) + String(AIO_SUB_TOPIC);\n#else\n    // Must be static or global\n    static String completeSubTopic = String(AIO_USERNAME) + String(AIO_SUB_TOPIC);\n#endif\n\n    LED_Control = new Adafruit_MQTT_Subscribe(mqtt, completeSubTopic.c_str());\n\n    Serial.print(F(\"Creating new AIO_SUB_TOPIC, LED_Control = \"));\n    Serial.println(completeSubTopic);\n\n    if (LED_Control)\n    {\n      Serial.println(F(\"Creating new LED_Control object OK\"));\n      Serial.print(F(\"LED_Control AIO_SUB_TOPIC = \"));\n      Serial.println(completeSubTopic);\n\n      mqtt->subscribe(LED_Control);\n    }\n    else\n      Serial.println(F(\"Creating new LED_Control object failed\"));\n  }"
        },
        {
          "name": "MQTT_connect",
          "parameters": "",
          "body": "int8_t ret;\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected())\n  {\n    return;\n  }\n\n#if LOCAL_DEBUG\n  Serial.println(F(\"\\nConnecting to WiFi MQTT (3 attempts)...\"));\n#endif\n\n  uint8_t attempt = 3;\n\n  while ( (ret = mqtt->connect()) )\n  {\n    // connect will return 0 for connected\n    Serial.println(mqtt->connectErrorString(ret));\n\n#if LOCAL_DEBUG\n    Serial.println(F(\"Another attemtpt to connect to MQTT in 5 seconds...\"));\n#endif\n\n    mqtt->disconnect();\n    delay(5000);  // wait 5 seconds\n    attempt--;\n\n    if (attempt == 0)\n    {\n      Serial.println(F(\"WiFi MQTT connection failed. Continuing with program...\"));\n      return;\n    }\n  }\n\n#if LOCAL_DEBUG\n  Serial.println(F(\"WiFi MQTT connection successful!\"));\n#endif"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  pinMode(LED_PIN, OUTPUT);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESPAsync_WiFi_MQTT using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFI_MANAGER_LITE_VERSION);\n\n#if USING_MRD\n  Serial.println(ESP_MULTI_RESET_DETECTOR_VERSION);\n#else\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  ESPAsync_WiFiManager = new ESPAsync_WiFiManager_Lite();\n\n  String AP_SSID = \"your_customized_ssid\";\n  String AP_PWD  = \"your_customized_pwd\";\n  \n  // Set customized AP SSID and PWD\n  ESPAsync_WiFiManager->setConfigPortal(AP_SSID, AP_PWD);\n\n  // Optional to change default AP IP(192.168.4.1) and channel(10)\n  //ESPAsync_WiFiManager->setConfigPortalIP(IPAddress(192, 168, 120, 1));\n  ESPAsync_WiFiManager->setConfigPortalChannel(0);\n\n#if USING_CUSTOMS_STYLE\n  ESPAsync_WiFiManager->setCustomsStyle(NewCustomsStyle);\n#endif\n\n#if USING_CUSTOMS_HEAD_ELEMENT\n  ESPAsync_WiFiManager->setCustomsHeadElement(PSTR(\"<style>html{filter: invert(10%);}</style>\"));\n#endif\n\n#if USING_CORS_FEATURE\n  ESPAsync_WiFiManager->setCORSHeader(PSTR(\"Your Access-Control-Allow-Origin\"));\n#endif\n\n  // Set customized DHCP HostName\n  ESPAsync_WiFiManager->begin(HOST_NAME);\n  //Or use default Hostname \"ESP_XXXXXX\"\n  //ESPAsync_WiFiManager->begin();"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (int i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ESPAsync_WiFiManager->run();\n  check_status();\n\n#if USE_DYNAMIC_PARAMETERS\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "asyncwebserver",
        "http",
        "password",
        "auth",
        "wifi",
        "delay",
        "millis",
        "spiffs"
      ],
      "libraries": [
        "ArduinoOTA.h",
        "FS.h",
        "SPIFFS.h",
        "ESPmDNS.h",
        "WiFi.h",
        "AsyncTCP.h",
        "ESP8266WiFi.h",
        "ESPAsyncTCP.h",
        "ESP8266mDNS.h",
        "ESPAsyncWebSrv.h",
        "SPIFFSEditor.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if(type == WS_EVT_CONNECT){\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n    client->printf(\"Hello Client %u :)\", client->id());\n    client->ping();\n  } else if(type == WS_EVT_DISCONNECT){\n    Serial.printf(\"ws[%s][%u] disconnect\\n\", server->url(), client->id());\n  } else if(type == WS_EVT_ERROR){\n    Serial.printf(\"ws[%s][%u] error(%u): %s\\n\", server->url(), client->id(), *((uint16_t*)arg), (char*)data);\n  } else if(type == WS_EVT_PONG){\n    Serial.printf(\"ws[%s][%u] pong[%u]: %s\\n\", server->url(), client->id(), len, (len)?(char*)data:\"\");\n  } else if(type == WS_EVT_DATA){\n    AwsFrameInfo * info = (AwsFrameInfo*)arg;\n    String msg = \"\";\n    if(info->final && info->index == 0 && info->len == len){\n      //the whole message is in a single frame and we got all of it's data\n      Serial.printf(\"ws[%s][%u] %s-message[%llu]: \", server->url(), client->id(), (info->opcode == WS_TEXT)?\"text\":\"binary\", info->len);\n\n      if(info->opcode == WS_TEXT){\n        for(size_t i=0; i < info->len; i++) {\n          msg += (char) data[i];\n        }\n      } else {\n        char buff[3];\n        for(size_t i=0; i < info->len; i++) {\n          sprintf(buff, \"%02x \", (uint8_t) data[i]);\n          msg += buff ;\n        }\n      }\n      Serial.printf(\"%s\\n\",msg.c_str());\n\n      if(info->opcode == WS_TEXT)\n        client->text(\"I got your text message\");\n      else\n        client->binary(\"I got your binary message\");\n    } else {\n      //message is comprised of multiple frames or the frame is split into multiple packets\n      if(info->index == 0){\n        if(info->num == 0)\n          Serial.printf(\"ws[%s][%u] %s-message start\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT)?\"text\":\"binary\");\n        Serial.printf(\"ws[%s][%u] frame[%u] start[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n      }\n\n      Serial.printf(\"ws[%s][%u] frame[%u] %s[%llu - %llu]: \", server->url(), client->id(), info->num, (info->message_opcode == WS_TEXT)?\"text\":\"binary\", info->index, info->index + len);\n\n      if(info->opcode == WS_TEXT){\n        for(size_t i=0; i < len; i++) {\n          msg += (char) data[i];\n        }\n      } else {\n        char buff[3];\n        for(size_t i=0; i < len; i++) {\n          sprintf(buff, \"%02x \", (uint8_t) data[i]);\n          msg += buff ;\n        }\n      }\n      Serial.printf(\"%s\\n\",msg.c_str());\n\n      if((info->index + len) == info->len){\n        Serial.printf(\"ws[%s][%u] frame[%u] end[%llu]\\n\", server->url(), client->id(), info->num, info->len);\n        if(info->final){\n          Serial.printf(\"ws[%s][%u] %s-message end\\n\", server->url(), client->id(), (info->message_opcode == WS_TEXT)?\"text\":\"binary\");\n          if(info->message_opcode == WS_TEXT)\n            client->text(\"I got your text message\");\n          else\n            client->binary(\"I got your binary message\");\n        }\n      }\n    }\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.setDebugOutput(true);\n  WiFi.mode(WIFI_AP_STA);\n  WiFi.softAP(hostName);\n  WiFi.begin(ssid, password);\n  if (WiFi.waitForConnectResult() != WL_CONNECTED) {\n    Serial.printf(\"STA: Failed!\\n\");\n    WiFi.disconnect(false);\n    delay(1000);\n    WiFi.begin(ssid, password);\n  }\n\n  //Send OTA events to the browser\n  ArduinoOTA.onStart([]() { events.send(\"Update Start\", \"ota\"); });\n  ArduinoOTA.onEnd([]() { events.send(\"Update End\", \"ota\"); });\n  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {\n    char p[32];\n    sprintf(p, \"Progress: %u%%\\n\", (progress/(total/100)));\n    events.send(p, \"ota\");\n  });\n  ArduinoOTA.onError([](ota_error_t error) {\n    if(error == OTA_AUTH_ERROR) events.send(\"Auth Failed\", \"ota\");\n    else if(error == OTA_BEGIN_ERROR) events.send(\"Begin Failed\", \"ota\");\n    else if(error == OTA_CONNECT_ERROR) events.send(\"Connect Failed\", \"ota\");\n    else if(error == OTA_RECEIVE_ERROR) events.send(\"Recieve Failed\", \"ota\");\n    else if(error == OTA_END_ERROR) events.send(\"End Failed\", \"ota\");\n  });\n  ArduinoOTA.setHostname(hostName);\n  ArduinoOTA.begin();\n\n  MDNS.addService(\"http\",\"tcp\",80);\n\n  SPIFFS.begin();\n\n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  events.onConnect([](AsyncEventSourceClient *client){\n    client->send(\"hello!\",NULL,millis(),1000);\n  });\n  server.addHandler(&events);\n\n#ifdef ESP32\n  server.addHandler(new SPIFFSEditor(SPIFFS, http_username,http_password));\n#elif defined(ESP8266)\n  server.addHandler(new SPIFFSEditor(http_username,http_password));\n#endif\n  \n  server.on(\"/heap\", HTTP_GET, [](AsyncWebServerRequest *request){\n    request->send(200, \"text/plain\", String(ESP.getFreeHeap()));\n  });\n\n  server.serveStatic(\"/\", SPIFFS, \"/\").setDefaultFile(\"index.htm\");\n\n  server.onNotFound([](AsyncWebServerRequest *request){\n    Serial.printf(\"NOT_FOUND: \");\n    if(request->method() == HTTP_GET)\n      Serial.printf(\"GET\");\n    else if(request->method() == HTTP_POST)\n      Serial.printf(\"POST\");\n    else if(request->method() == HTTP_DELETE)\n      Serial.printf(\"DELETE\");\n    else if(request->method() == HTTP_PUT)\n      Serial.printf(\"PUT\");\n    else if(request->method() == HTTP_PATCH)\n      Serial.printf(\"PATCH\");\n    else if(request->method() == HTTP_HEAD)\n      Serial.printf(\"HEAD\");\n    else if(request->method() == HTTP_OPTIONS)\n      Serial.printf(\"OPTIONS\");\n    else\n      Serial.printf(\"UNKNOWN\");\n    Serial.printf(\" http://%s%s\\n\", request->host().c_str(), request->url().c_str());\n\n    if(request->contentLength()){\n      Serial.printf(\"_CONTENT_TYPE: %s\\n\", request->contentType().c_str());\n      Serial.printf(\"_CONTENT_LENGTH: %u\\n\", request->contentLength());\n    }\n\n    int headers = request->headers();\n    int i;\n    for(i=0;i<headers;i++){\n      AsyncWebHeader* h = request->getHeader(i);\n      Serial.printf(\"_HEADER[%s]: %s\\n\", h->name().c_str(), h->value().c_str());\n    }\n\n    int params = request->params();\n    for(i=0;i<params;i++){\n      AsyncWebParameter* p = request->getParam(i);\n      if(p->isFile()){\n        Serial.printf(\"_FILE[%s]: %s, size: %u\\n\", p->name().c_str(), p->value().c_str(), p->size());\n      } else if(p->isPost()){\n        Serial.printf(\"_POST[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n      } else {\n        Serial.printf(\"_GET[%s]: %s\\n\", p->name().c_str(), p->value().c_str());\n      }\n    }\n\n    request->send(404);\n  });\n  server.onFileUpload([](AsyncWebServerRequest *request, const String& filename, size_t index, uint8_t *data, size_t len, bool final){\n    if(!index)\n      Serial.printf(\"UploadStart: %s\\n\", filename.c_str());\n    Serial.printf(\"%s\", (const char*)data);\n    if(final)\n      Serial.printf(\"UploadEnd: %s (%u)\\n\", filename.c_str(), index+len);\n  });\n  server.onRequestBody([](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){\n    if(!index)\n      Serial.printf(\"BodyStart: %u\\n\", total);\n    Serial.printf(\"%s\", (const char*)data);\n    if(index + len == total)\n      Serial.printf(\"BodyEnd: %u\\n\", total);\n  });\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "ArduinoOTA.handle();\n  ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "wificlient",
        "https",
        "password",
        "stream",
        "json",
        "callback",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "millis",
        "analogread",
        "display",
        "spiffs",
        "littlefs",
        "flash",
        "eeprom",
        "html",
        "css",
        "javascript",
        "gatewayip"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024) \n  {\n    return String(bytes) + \"B\";\n  } \n  else if (bytes < (1024 * 1024)) \n  {\n    return String(bytes / 1024.0) + \"KB\";\n  } \n  else if (bytes < (1024 * 1024 * 1024)) \n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  } \n  else \n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "getContentType",
          "parameters": "String filename",
          "body": "if (server.hasArg(\"download\")) \n  {\n    return \"application/octet-stream\";\n  } \n  else if (filename.endsWith(\".htm\")) \n  {\n    return \"text/html\";\n  } \n  else if (filename.endsWith(\".html\")) \n  {\n    return \"text/html\";\n  } \n  else if (filename.endsWith(\".css\")) \n  {\n    return \"text/css\";\n  } \n  else if (filename.endsWith(\".js\")) \n  {\n    return \"application/javascript\";\n  } \n  else if (filename.endsWith(\".png\")) \n  {\n    return \"image/png\";\n  } \n  else if (filename.endsWith(\".gif\")) \n  {\n    return \"image/gif\";\n  } \n  else if (filename.endsWith(\".jpg\")) \n  {\n    return \"image/jpeg\";\n  } \n  else if (filename.endsWith(\".ico\")) \n  {\n    return \"image/x-icon\";\n  } \n  else if (filename.endsWith(\".xml\")) \n  {\n    return \"text/xml\";\n  } \n  else if (filename.endsWith(\".pdf\")) \n  {\n    return \"application/x-pdf\";\n  } \n  else if (filename.endsWith(\".zip\")) \n  {\n    return \"application/x-zip\";\n  } \n  else if (filename.endsWith(\".gz\")) \n  {\n    return \"application/x-gzip\";\n  }\n  return \"text/plain\";"
        },
        {
          "name": "handleFileRead",
          "parameters": "String path",
          "body": "Serial.println(\"handleFileRead: \" + path);\n  if (path.endsWith(\"/\")) \n  {\n    path += \"index.htm\";\n  }\n  \n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n  \n  if (filesystem->exists(pathWithGz) || filesystem->exists(path)) \n  {\n    if (filesystem->exists(pathWithGz)) \n    {\n      path += \".gz\";\n    }\n    \n    File file = filesystem->open(path, \"r\");\n    server.streamFile(file, contentType);\n    file.close();\n    return true;\n  }\n  return false;"
        },
        {
          "name": "handleFileUpload",
          "parameters": "",
          "body": "if (server.uri() != \"/edit\") \n  {\n    return;\n  }\n  \n  HTTPUpload& upload = server.upload();\n  \n  if (upload.status == UPLOAD_FILE_START) \n  {\n    String filename = upload.filename;\n    \n    if (!filename.startsWith(\"/\")) \n    {\n      filename = \"/\" + filename;\n    }\n    \n    Serial.print(F(\"handleFileUpload Name: \")); Serial.println(filename);\n    fsUploadFile = filesystem->open(filename, \"w\");\n    filename.clear();\n  } \n  else if (upload.status == UPLOAD_FILE_WRITE) \n  {\n    //Serial.print(F(\"handleFileUpload Data: \")); Serial.println(upload.currentSize);\n    \n    if (fsUploadFile) \n    {\n      fsUploadFile.write(upload.buf, upload.currentSize);\n    }\n  } \n  else if (upload.status == UPLOAD_FILE_END) \n  {\n    if (fsUploadFile) \n    {\n      fsUploadFile.close();\n    }\n    \n    Serial.print(F(\"handleFileUpload Size: \")); Serial.println(upload.totalSize);\n  }"
        },
        {
          "name": "handleFileDelete",
          "parameters": "",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n  String path = server.arg(0);\n  Serial.println(\"handleFileDelete: \" + path);\n  \n  if (path == \"/\") \n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n  \n  if (!filesystem->exists(path)) \n  {\n    return server.send(404, \"text/plain\", \"FileNotFound\");\n  }\n  \n  filesystem->remove(path);\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileCreate",
          "parameters": "",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n  \n  String path = server.arg(0);\n  Serial.println(\"handleFileCreate: \" + path);\n  \n  if (path == \"/\") \n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n  \n  if (filesystem->exists(path)) \n  {\n    return server.send(500, \"text/plain\", \"FILE EXISTS\");\n  }\n  \n  File file = filesystem->open(path, \"w\");\n  \n  if (file) \n  {\n    file.close();\n  } \n  else \n  {\n    return server.send(500, \"text/plain\", \"CREATE FAILED\");\n  }\n  \n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileList",
          "parameters": "",
          "body": "if (!server.hasArg(\"dir\")) \n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;\n  }\n\n  String path = server.arg(\"dir\");\n  Serial.println(\"handleFileList: \" + path);\n  Dir dir = filesystem->openDir(path);\n  path.clear();\n\n  String output = \"[\";\n  \n  while (dir.next()) \n  {\n    File entry = dir.openFile(\"r\");\n    \n    if (output != \"[\") \n    {\n      output += ',';\n    }\n    \n    bool isDir = false;\n    output += \"{\\\"type\\\":\\\"\";\n    output += (isDir) ? \"dir\" : \"file\";\n    output += \"\\\",\\\"name\\\":\\\"\";\n    \n    if (entry.name()[0] == '/') \n    {\n      output += &(entry.name()[1]);\n    } \n    else \n    {\n      output += entry.name();\n    }\n    \n    output += \"\\\"}\";\n    entry.close();\n  }\n\n  output += \"]\";\n  server.send(200, \"text/json\", output);"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n  \n  Serial.setDebugOutput(false);\n\n  // Format filesystem if not yet\n  if (!filesystem->begin())\n  {\n    filesystem->format();\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!filesystem->begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n  \n  // Uncomment to format FS. Remember to uncomment after done\n  //filesystem->format();\n  Dir dir = filesystem->openDir(\"/\");\n  Serial.println(F(\"Opening / directory\"));\n  \n  while (dir.next()) \n  {\n    String fileName = dir.fileName();\n    size_t fileSize = dir.fileSize();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n  }\n  \n  Serial.println();\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESP_WiFiManager ESP_wifiManager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP_WiFiManager ESP_wifiManager(\"ESP-FSWebServer\");\n\n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESP_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32 as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = loadConfigData();\n\n  if (configDataLoaded)\n  {\n    #if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif  \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID == \"\") || (Router_Pass == \"\") )\n    {\n      Serial.println(F(\"We haven't got any access point credentials, so get them now\"));\n  \n      initialConfig = true;\n\n      Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n      Serial.print(APStaticIP);\n#else\n      Serial.print(F(\"192.168.4.1\"));\n#endif\n\n#if defined(HTTP_PORT_TO_USE)\n    Serial.print(F(\":\")); Serial.print(HTTP_PORT_TO_USE);\n#endif\n\n      Serial.print(F(\", SSID = \"));\n      Serial.print(ssid);\n      Serial.print(F(\", PWD = \"));\n      Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESP_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                   WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n      // Starts an access point\n      if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n        Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n      else\n        Serial.println(F(\"WiFi connected...yeey :)\"));\n  \n      // Stored  for later usage, from v1.1.0, but clear first\n      memset(&WM_config, 0, sizeof(WM_config));\n      \n      for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n      {\n        String tempSSID = ESP_wifiManager.getSSID(i);\n        String tempPW   = ESP_wifiManager.getPW(i);\n    \n        if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n  \n        if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n          strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n        else\n          strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n  \n        // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n        if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n        {\n          LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n          wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n        }\n      }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESP_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n#if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n#else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n#endif\n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n      // New in v1.4.0\n      ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n      //////\n      \n      saveConfigData();\n    }\n    else\n    {\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    }\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000L);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESP_wifiManager.getStatus(WiFi.status()));\n\n  //SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n  \n  //load editor\n  server.on(\"/edit\", HTTP_GET, []() \n  {\n    if (!handleFileRead(\"/edit.htm\")) \n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n  \n  //create file\n  server.on(\"/edit\", HTTP_PUT, handleFileCreate);\n  \n  //delete file\n  server.on(\"/edit\", HTTP_DELETE, handleFileDelete);\n  \n  //first callback is called after the request has ended with all parsed arguments\n  //second callback handles file uploads at that location\n  server.on(\"/edit\", HTTP_POST, []() \n  {\n    server.send(200, \"text/plain\", \"\");\n  }, handleFileUpload);\n\n  //called when the url is not defined here\n  //use it to load content from SPIFFS\n  server.onNotFound([]() \n  {\n    if (!handleFileRead(server.uri())) \n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //get heap status, analog input value and all GPIO statuses in one json call\n  server.on(\"/all\", HTTP_GET, []() \n  {\n    String json('{');\n    json += \"\\\"heap\\\":\" + String(ESP.getFreeHeap());\n    json += \", \\\"analog\\\":\" + String(analogRead(A0));\n    json += \", \\\"gpio\\\":\" + String((uint32_t)(((GPI | GPO) & 0xFFFF) | ((GP16I & 0x01) << 16)));\n    json += \"}\";\n    server.send(200, \"text/json\", json);\n    json.clear();\n  });\n  \n  server.begin();\n  \n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());\n\n  MDNS.begin(host);\n  Serial.print(F(\"Open http://\"));\n  Serial.print(host);\n  Serial.println(F(\".local/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// this is just for checking if we are alive and connected to WiFi\n  check_status();\n  \n  server.handleClient();\n  MDNS.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "esp8266webserver",
        "http",
        "wificlient",
        "https",
        "password",
        "stream",
        "json",
        "callback",
        "current",
        "wifi",
        "ntp",
        "delay",
        "esp.restart",
        "millis",
        "analogread",
        "display",
        "spiffs",
        "eeprom",
        "littlefs",
        "flash",
        "rtc",
        "html",
        "css",
        "javascript",
        "gatewayip"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "ESP_DoubleResetDetector.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESP_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "parameters": "WiFi_AP_IPConfig &in_WM_AP_IPconfig",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig &in_WM_STA_IPconfig",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "parameters": "WiFi_STA_IPConfig in_WM_STA_IPconfig",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "parameters": "",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));\n  }\n#else\n  struct tm timeinfo;\n\n  getLocalTime( &timeinfo );\n\n  // Valid only if year > 2000. \n  // You can get from timeinfo : tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec\n  if (timeinfo.tm_year > 100 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print( asctime( &timeinfo ) );\n  }\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }\n#endif"
        },
        {
          "name": "check_WiFi",
          "parameters": "",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;\n  }\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024) \n  {\n    return String(bytes) + \"B\";\n  } \n  else if (bytes < (1024 * 1024)) \n  {\n    return String(bytes / 1024.0) + \"KB\";\n  } \n  else if (bytes < (1024 * 1024 * 1024)) \n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  } \n  else \n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "getContentType",
          "parameters": "String filename",
          "body": "if (server.hasArg(\"download\")) \n  {\n    return \"application/octet-stream\";\n  } \n  else if (filename.endsWith(\".htm\")) \n  {\n    return \"text/html\";\n  } \n  else if (filename.endsWith(\".html\")) \n  {\n    return \"text/html\";\n  } \n  else if (filename.endsWith(\".css\")) \n  {\n    return \"text/css\";\n  } \n  else if (filename.endsWith(\".js\")) \n  {\n    return \"application/javascript\";\n  } \n  else if (filename.endsWith(\".png\")) \n  {\n    return \"image/png\";\n  } \n  else if (filename.endsWith(\".gif\")) \n  {\n    return \"image/gif\";\n  } \n  else if (filename.endsWith(\".jpg\")) \n  {\n    return \"image/jpeg\";\n  } \n  else if (filename.endsWith(\".ico\")) \n  {\n    return \"image/x-icon\";\n  } \n  else if (filename.endsWith(\".xml\")) \n  {\n    return \"text/xml\";\n  } \n  else if (filename.endsWith(\".pdf\")) \n  {\n    return \"application/x-pdf\";\n  } \n  else if (filename.endsWith(\".zip\")) \n  {\n    return \"application/x-zip\";\n  } \n  else if (filename.endsWith(\".gz\")) \n  {\n    return \"application/x-gzip\";\n  }\n  return \"text/plain\";"
        },
        {
          "name": "handleFileRead",
          "parameters": "String path",
          "body": "Serial.println(\"handleFileRead: \" + path);\n  \n  if (path.endsWith(\"/\")) \n  {\n    path += \"index.htm\";\n  }\n  \n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n  \n  if (filesystem->exists(pathWithGz) || filesystem->exists(path)) \n  {\n    if (filesystem->exists(pathWithGz)) \n    {\n      path += \".gz\";\n    }\n    \n    File file = filesystem->open(path, \"r\");\n    server.streamFile(file, contentType);\n    file.close();\n    return true;\n  }\n  \n  return false;"
        },
        {
          "name": "handleFileUpload",
          "parameters": "",
          "body": "if (server.uri() != \"/edit\") \n  {\n    return;\n  }\n  \n  HTTPUpload& upload = server.upload();\n  \n  if (upload.status == UPLOAD_FILE_START) \n  {\n    String filename = upload.filename;\n    \n    if (!filename.startsWith(\"/\")) \n    {\n      filename = \"/\" + filename;\n    }\n    \n    Serial.print(F(\"handleFileUpload Name: \")); Serial.println(filename);\n    fsUploadFile = filesystem->open(filename, \"w\");\n    filename.clear();\n  } \n  else if (upload.status == UPLOAD_FILE_WRITE) \n  {\n    //Serial.print(F(\"handleFileUpload Data: \")); Serial.println(upload.currentSize);\n    \n    if (fsUploadFile) \n    {\n      fsUploadFile.write(upload.buf, upload.currentSize);\n    }\n  } \n  else if (upload.status == UPLOAD_FILE_END) \n  {\n    if (fsUploadFile) \n    {\n      fsUploadFile.close();\n    }\n    \n    Serial.print(F(\"handleFileUpload Size: \")); Serial.println(upload.totalSize);\n  }"
        },
        {
          "name": "handleFileDelete",
          "parameters": "",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n  String path = server.arg(0);\n  Serial.println(\"handleFileDelete: \" + path);\n  \n  if (path == \"/\") \n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n  \n  if (!filesystem->exists(path)) \n  {\n    return server.send(404, \"text/plain\", \"FileNotFound\");\n  }\n  \n  filesystem->remove(path);\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileCreate",
          "parameters": "",
          "body": "if (server.args() == 0) \n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n  \n  String path = server.arg(0);\n  Serial.println(\"handleFileCreate: \" + path);\n  \n  if (path == \"/\") \n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n  \n  if (filesystem->exists(path)) \n  {\n    return server.send(500, \"text/plain\", \"FILE EXISTS\");\n  }\n  \n  File file = filesystem->open(path, \"w\");\n  \n  if (file) \n  {\n    file.close();\n  } \n  else \n  {\n    return server.send(500, \"text/plain\", \"CREATE FAILED\");\n  }\n  \n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileList",
          "parameters": "",
          "body": "if (!server.hasArg(\"dir\")) \n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;\n  }\n\n  String path = server.arg(\"dir\");\n  Serial.println(\"handleFileList: \" + path);\n  Dir dir = filesystem->openDir(path);\n  path.clear();\n\n  String output = \"[\";\n  \n  while (dir.next()) \n  {\n    File entry = dir.openFile(\"r\");\n    \n    if (output != \"[\") \n    {\n      output += ',';\n    }\n    \n    bool isDir = false;\n    output += \"{\\\"type\\\":\\\"\";\n    output += (isDir) ? \"dir\" : \"file\";\n    output += \"\\\",\\\"name\\\":\\\"\";\n    \n    if (entry.name()[0] == '/') \n    {\n      output += &(entry.name()[1]);\n    } \n    else \n    {\n      output += entry.name();\n    }\n    \n    output += \"\\\"}\";\n    entry.close();\n  }\n\n  output += \"]\";\n  server.send(200, \"text/json\", output);"
        },
        {
          "name": "calcChecksum",
          "parameters": "uint8_t* address, uint16_t sizeToCalc",
          "body": "uint16_t checkSum = 0;\n  \n  for (uint16_t index = 0; index < sizeToCalc; index++)\n  {\n    checkSum += * ( ( (byte*) address ) + index);\n  }\n\n  return checkSum;"
        },
        {
          "name": "loadConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset((void *) &WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  memset((void *) &WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    if ( WM_config.checksum != calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) ) )\n    {\n      LOGERROR(F(\"WM_config checksum wrong\"));\n      \n      return false;\n    }\n    \n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////\n\n    return true;\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n\n    return false;\n  }"
        },
        {
          "name": "saveConfigData",
          "parameters": "",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n  }\n  else\n  {\n    LOGERROR(F(\"failed\"));\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!DBG_OUTPUT_PORT);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting ESP_FSWebServer_DRD with DoubleResetDetect using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_WIFIMANAGER_VERSION_MIN)\n  if (ESP_WIFIMANAGER_VERSION_INT < ESP_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_WIFIMANAGER_VERSION_MIN_TARGET);\n  }\n#endif\n   \n  Serial.setDebugOutput(false);\n\n  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);\n  \n  // Format filesystem if not yet\n  if (!filesystem->begin())\n  {\n    filesystem->format();\n\n    Serial.println(F(\"SPIFFS/LittleFS failed! Already tried formatting.\"));\n  \n    if (!filesystem->begin())\n    {     \n      // prevents debug info from the library to hide err message.\n      delay(100);\n      \n#if USE_LITTLEFS\n      Serial.println(F(\"LittleFS failed!. Please use SPIFFS or EEPROM. Stay forever\"));\n#else\n      Serial.println(F(\"SPIFFS failed!. Please use LittleFS or EEPROM. Stay forever\"));\n#endif\n\n      while (true)\n      {\n        delay(1);\n      }\n    }\n  }\n\n  // Uncomment to format FS. Remember to uncomment after done\n  //filesystem->format();\n  Dir dir = filesystem->openDir(\"/\");\n  Serial.println(F(\"Opening / directory\"));\n  \n  while (dir.next()) \n  {\n    String fileName = dir.fileName();\n    size_t fileSize = dir.fileSize();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n  }\n  \n  Serial.println();\n\n  unsigned long startedAt = millis();\n\n  // New in v1.4.0\n  initAPIPConfigStruct(WM_AP_IPconfig);\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESP_WiFiManager ESP_wifiManager;\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  ESP_WiFiManager ESP_wifiManager(\"ESP-FSWebServer_DRD\");\n\n#if USE_CUSTOM_AP_IP\n  //set custom ip for portal\n  // New in v1.4.0\n  ESP_wifiManager.setAPStaticIPConfig(WM_AP_IPconfig);\n  //////\n#endif\n\n  ESP_wifiManager.setMinimumSignalQuality(-1);\n\n  // From v1.0.10 only\n  // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n  ESP_wifiManager.setConfigPortalChannel(0);\n  //////\n  \n#if !USE_DHCP_IP    \n    // Set (static IP, Gateway, Subnetmask, DNS1 and DNS2) or (IP, Gateway, Subnetmask). New in v1.0.5\n    // New in v1.4.0\n    ESP_wifiManager.setSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n#endif\n\n// New from v1.1.0+\n#if USING_CORS_FEATURE\n  ESP_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n  // We can't use WiFi.SSID() in ESP32as it's only valid after connected.\n  // SSID and Password stored in ESP32 wifi_ap_record_t and wifi_config_t are also cleared in reboot\n  // Have to create a new function to store in EEPROM/SPIFFS for this purpose\n  Router_SSID = ESP_wifiManager.WiFi_SSID();\n  Router_Pass = ESP_wifiManager.WiFi_Pass();\n\n  //Remove this line if you do not want to see WiFi password printed\n  Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n\n  // SSID to uppercase\n  ssid.toUpperCase();\n  password = \"My\" + ssid;\n\n  bool configDataLoaded = false;\n\n  // From v1.1.0, Don't permit NULL password\n  if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n    wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n    \n    ESP_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));\n  }\n  \n  if (loadConfigData())\n  {\n    configDataLoaded = true;\n    \n    ESP_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n    Serial.println(F(\"Got stored Credentials. Timeout 120s for Config Portal\")); \n\n#if USE_ESP_WIFIMANAGER_NTP      \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n\n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif   \n    }\n    else\n    {\n      Serial.println(F(\"Current Timezone is not set. Enter Config Portal to set.\"));\n    } \n#endif\n  }\n  else\n  {\n    // Enter CP only if no stored SSID on flash and file\n    Serial.println(F(\"Open Config Portal without Timeout: No stored Credentials.\"));\n    initialConfig = true;\n  }\n\n  if (drd->detectDoubleReset())\n  {\n    // DRD, disable timeout.\n    ESP_wifiManager.setConfigPortalTimeout(0);\n    \n    Serial.println(F(\"Open Config Portal without Timeout: Double Reset Detected\"));\n    initialConfig = true;\n  }\n\n  if (initialConfig)\n  {\n    Serial.print(F(\"Starting configuration portal @ \"));\n    \n#if USE_CUSTOM_AP_IP    \n    Serial.print(APStaticIP);\n#else\n    Serial.print(F(\"192.168.4.1\"));\n#endif\n\n#if defined(HTTP_PORT_TO_USE)\n    Serial.print(F(\":\")); Serial.print(HTTP_PORT_TO_USE);\n#endif\n\n    Serial.print(F(\", SSID = \"));\n    Serial.print(ssid);\n    Serial.print(F(\", PWD = \"));\n    Serial.println(password);\n\n#if DISPLAY_STORED_CREDENTIALS_IN_CP\n    // New. Update Credentials, got from loadConfigData(), to display on CP\n    ESP_wifiManager.setCredentials(WM_config.WiFi_Creds[0].wifi_ssid, WM_config.WiFi_Creds[0].wifi_pw, \n                                   WM_config.WiFi_Creds[1].wifi_ssid, WM_config.WiFi_Creds[1].wifi_pw);\n#endif\n\n    // Starts an access point\n    if (!ESP_wifiManager.startConfigPortal((const char *) ssid.c_str(), password.c_str()))\n      Serial.println(F(\"Not connected to WiFi but continuing anyway.\"));\n    else\n    {\n      Serial.println(F(\"WiFi connected...yeey :)\"));\n    }\n\n    // Stored  for later usage, from v1.1.0, but clear first\n    memset(&WM_config, 0, sizeof(WM_config));\n    \n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      String tempSSID = ESP_wifiManager.getSSID(i);\n      String tempPW   = ESP_wifiManager.getPW(i);\n  \n      if (strlen(tempSSID.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_ssid, tempSSID.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_ssid) - 1);\n\n      if (strlen(tempPW.c_str()) < sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1)\n        strcpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str());\n      else\n        strncpy(WM_config.WiFi_Creds[i].wifi_pw, tempPW.c_str(), sizeof(WM_config.WiFi_Creds[i].wifi_pw) - 1);  \n\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n#if USE_ESP_WIFIMANAGER_NTP      \n    String tempTZ   = ESP_wifiManager.getTimezoneName();\n\n    if (strlen(tempTZ.c_str()) < sizeof(WM_config.TZ_Name) - 1)\n      strcpy(WM_config.TZ_Name, tempTZ.c_str());\n    else\n      strncpy(WM_config.TZ_Name, tempTZ.c_str(), sizeof(WM_config.TZ_Name) - 1);\n\n    const char * TZ_Result = ESP_wifiManager.getTZ(WM_config.TZ_Name);\n    \n    if (strlen(TZ_Result) < sizeof(WM_config.TZ) - 1)\n      strcpy(WM_config.TZ, TZ_Result);\n    else\n      strncpy(WM_config.TZ, TZ_Result, sizeof(WM_config.TZ_Name) - 1);\n         \n    if ( strlen(WM_config.TZ_Name) > 0 )\n    {\n      LOGERROR3(F(\"Saving current TZ_Name =\"), WM_config.TZ_Name, F(\", TZ = \"), WM_config.TZ);\n      \n  #if ESP8266\n      configTime(WM_config.TZ, \"pool.ntp.org\"); \n  #else\n      //configTzTime(WM_config.TZ, \"pool.ntp.org\" );\n      configTzTime(WM_config.TZ, \"time.nist.gov\", \"0.pool.ntp.org\", \"1.pool.ntp.org\");\n  #endif \n    }\n    else\n    {\n      LOGERROR(F(\"Current Timezone Name is not set. Enter Config Portal to set.\"));\n    }\n#endif\n\n    // New in v1.4.0\n    ESP_wifiManager.getSTAStaticIPConfig(WM_STA_IPconfig);\n    //////\n    \n    saveConfigData();\n  }\n\n  startedAt = millis();\n\n  if (!initialConfig)\n  {\n    // Load stored data, the addAP ready for MultiWiFi reconnection\n    if (!configDataLoaded)\n      loadConfigData();\n\n    for (uint8_t i = 0; i < NUM_WIFI_CREDENTIALS; i++)\n    {\n      // Don't permit NULL SSID and password len < MIN_AP_PASSWORD_SIZE (8)\n      if ( (String(WM_config.WiFi_Creds[i].wifi_ssid) != \"\") && (strlen(WM_config.WiFi_Creds[i].wifi_pw) >= MIN_AP_PASSWORD_SIZE) )\n      {\n        LOGERROR3(F(\"* Add SSID = \"), WM_config.WiFi_Creds[i].wifi_ssid, F(\", PW = \"), WM_config.WiFi_Creds[i].wifi_pw );\n        wifiMulti.addAP(WM_config.WiFi_Creds[i].wifi_ssid, WM_config.WiFi_Creds[i].wifi_pw);\n      }\n    }\n\n    if ( WiFi.status() != WL_CONNECTED ) \n    {\n      Serial.println(F(\"ConnectMultiWiFi in setup\"));\n     \n      connectMultiWiFi();\n    }\n  }\n\n  Serial.print(F(\"After waiting \"));\n  Serial.print((float) (millis() - startedAt) / 1000);\n  Serial.print(F(\" secs more in setup(), connection result is \"));\n\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(F(\"connected. Local IP: \"));\n    Serial.println(WiFi.localIP());\n  }\n  else\n    Serial.println(ESP_wifiManager.getStatus(WiFi.status()));\n\n  //SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n  \n  //load editor\n  server.on(\"/edit\", HTTP_GET, []() \n  {\n    if (!handleFileRead(\"/edit.htm\")) \n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n  \n  //create file\n  server.on(\"/edit\", HTTP_PUT, handleFileCreate);\n  \n  //delete file\n  server.on(\"/edit\", HTTP_DELETE, handleFileDelete);\n  \n  //first callback is called after the request has ended with all parsed arguments\n  //second callback handles file uploads at that location\n  server.on(\"/edit\", HTTP_POST, []() \n  {\n    server.send(200, \"text/plain\", \"\");\n  }, handleFileUpload);\n\n  //called when the url is not defined here\n  //use it to load content from SPIFFS\n  server.onNotFound([]() \n  {\n    if (!handleFileRead(server.uri())) \n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //get heap status, analog input value and all GPIO statuses in one json call\n  server.on(\"/all\", HTTP_GET, []() \n  {\n    String json('{');\n    json += \"\\\"heap\\\":\" + String(ESP.getFreeHeap());\n    json += \", \\\"analog\\\":\" + String(analogRead(A0));\n    json += \", \\\"gpio\\\":\" + String((uint32_t)(((GPI | GPO) & 0xFFFF) | ((GP16I & 0x01) << 16)));\n    json += \"}\";\n    server.send(200, \"text/json\", json);\n    json.clear();\n  });\n  \n  server.begin();\n  \n  Serial.print(F(\"HTTP server started @ \"));\n  Serial.println(WiFi.localIP());\n\n  MDNS.begin(host);\n  Serial.print(F(\"Open http://\"));\n  Serial.print(host);\n  Serial.println(F(\".local/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // this is just for checking if we are alive and connected to WiFi\n  check_status();\n  \n  server.handleClient();\n  MDNS.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "token",
        "key",
        "password",
        "auth",
        "ssl",
        "payload",
        "callback",
        "buffer",
        "database",
        "wifi",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Connected with IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n  /* Assign the api key (required) */\n  config.api_key = API_KEY;\n\n  /* Assign the user sign in credentials */\n  auth.user.email = USER_EMAIL;\n  auth.user.password = USER_PASSWORD;\n\n  /* Assign the RTDB URL (required) */\n  config.database_url = DATABASE_URL;\n\n  /* Assign the callback function for the long running token generation task */\n  config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n  // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n  Firebase.reconnectNetwork(true);\n\n  // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n  // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n  fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n  // Or use legacy authenticate method\n  // config.database_url = DATABASE_URL;\n  // config.signer.tokens.legacy_token = \"<database secret>\";\n\n  // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n  Firebase.begin(&config, &auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && !taskCompleted)\n  {\n    taskCompleted = true;\n\n    String ETag = \"\";\n    String wrong_ETag = \"ANY_WRONG_ETag\";\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int/data\", 100) ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK)\n    {\n      Serial.printf(\"ETag, %s\\n\\n\", fbdo.ETag().c_str());\n      ETag = fbdo.ETag();\n    }\n\n    Serial.printf(\"Set int with valid ETag... %s\\n\", Firebase.setInt(fbdo, \"/test/int/data\", 200, ETag.c_str()) ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK)\n      Serial.printf(\"ETag, %s\\n\\n\", fbdo.ETag().c_str());\n\n    Serial.printf(\"Set int with invalid ETag... %s\\n\", Firebase.setInt(fbdo, \"/test/int/data\", 200, wrong_ETag.c_str()) ? \"ok\" : fbdo.errorReason().c_str());\n\n    if (fbdo.httpCode() == FIREBASE_ERROR_HTTP_CODE_OK)\n      Serial.printf(\"ETag, %s\\n\\n\", fbdo.ETag().c_str());\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble",
        "delay"
      ],
      "libraries": [
        "HardwareBLESerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (!bleSerial.beginAndSetupBLE(\"Echo\")) {\n    Serial.begin(9600);\n    while (true) {\n      Serial.println(\"failed to initialize HardwareBLESerial!\");\n      delay(1000);\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// this must be called regularly to perform BLE updates\n  bleSerial.poll();\n\n  while (bleSerial.availableLines() > 0) {\n    bleSerial.print(\"You said: \");\n    char line[128]; bleSerial.readLine(line, 128);\n    bleSerial.println(line);\n  }\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "telegram",
        "api",
        "https",
        "password",
        "token",
        "json",
        "spi",
        "wifi",
        "delay",
        "millis",
        "devices"
      ],
      "libraries": [
        "SPI.h",
        "WiFiNINA.h",
        "UniversalTelegramBot.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "handleNewMessages",
          "parameters": "int numNewMessages",
          "body": "for (int i = 0; i < numNewMessages; i++)\n  {\n    bot.sendMessage(bot.messages[i].chat_id, bot.messages[i].text, \"\");\n  }"
        },
        {
          "name": "printWiFiStatus",
          "parameters": "",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE) {\n    Serial.println(\"Communication with WiFi module failed!\");\n    // don't continue\n    while (true);\n  }\n\n  String fv = WiFi.firmwareVersion();\n  if (fv < \"1.0.0\") {\n    Serial.println(\"Please upgrade the firmware\");\n  }\n\n  // attempt to connect to WiFi network:\n  while (status != WL_CONNECTED) {\n    Serial.print(\"Attempting to connect to SSID: \");\n    Serial.println(ssid);\n    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:\n    status = WiFi.begin(ssid, password);\n\n    // wait 10 seconds for connection:\n    delay(10000);\n  }\n  Serial.println(\"Connected to wifi\");\n  printWiFiStatus();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (millis() - bot_lasttime > BOT_MTBS)\n  {\n    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n\n    while (numNewMessages)\n    {\n      Serial.println(\"got response\");\n      handleNewMessages(numNewMessages);\n      numNewMessages = bot.getUpdates(bot.last_message_received + 1);\n    }\n\n    bot_lasttime = millis();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "wifi",
        "spi",
        "dns",
        "delay",
        "display",
        "flash",
        "interrupt",
        "html",
        "clients"
      ],
      "libraries": [
        "Adafruit_CC3000.h",
        "SPI.h",
        "utility/debug.h",
        "utility/socket.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "void",
          "body": "Serial.begin(115200);\n  Serial.println(F(\"Hello, CC3000!\\n\")); \n\n  Serial.print(\"Free RAM: \"); Serial.println(getFreeRam(), DEC);\n  \n  /* Initialise the module */\n  Serial.println(F(\"\\nInitializing...\"));\n  if (!cc3000.begin())\n  {\n    Serial.println(F(\"Couldn't begin()! Check your wiring?\"));\n    while(1);\n  }\n  \n  Serial.print(F(\"\\nAttempting to connect to \")); Serial.println(WLAN_SSID);\n  if (!cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY)) {\n    Serial.println(F(\"Failed!\"));\n    while(1);\n  }\n   \n  Serial.println(F(\"Connected!\"));\n  \n  Serial.println(F(\"Request DHCP\"));\n  while (!cc3000.checkDHCP())\n  {\n    delay(100); // ToDo: Insert a DHCP timeout!\n  }  \n\n  /* Display the IP address DNS, Gateway, etc. */  \n  while (! displayConnectionDetails()) {\n    delay(1000);\n  }\n\n  /*********************************************************/\n  /* You can safely remove this to save some flash memory! */\n  /*********************************************************/\n  Serial.println(F(\"\\r\\nNOTE: This sketch may cause problems with other sketches\"));\n  Serial.println(F(\"since the .disconnect() function is never called, so the\"));\n  Serial.println(F(\"AP may refuse connection requests from the CC3000 until a\"));\n  Serial.println(F(\"timeout period passes.  This is normal behaviour since\"));\n  Serial.println(F(\"there isn't an obvious moment to disconnect with a server.\\r\\n\"));\n  \n  // Start listening for connections\n  echoServer.begin();\n  \n  Serial.println(F(\"Listening for connections...\"));"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "// Try to get a client which is connected.\n  Adafruit_CC3000_ClientRef client = echoServer.available();\n  if (client) {\n     // Check if there is data available to read.\n     if (client.available() > 0) {\n       // Read a byte and write it to all clients.\n       uint8_t ch = client.read();\n       client.write(ch);\n     }\n  }"
        },
        {
          "name": "displayConnectionDetails",
          "parameters": "void",
          "body": "uint32_t ipAddress, netmask, gateway, dhcpserv, dnsserv;\n  \n  if(!cc3000.getIPAddress(&ipAddress, &netmask, &gateway, &dhcpserv, &dnsserv))\n  {\n    Serial.println(F(\"Unable to retrieve the IP Address!\\r\\n\"));\n    return false;\n  }\n  else\n  {\n    Serial.print(F(\"\\nIP Addr: \")); cc3000.printIPdotsRev(ipAddress);\n    Serial.print(F(\"\\nNetmask: \")); cc3000.printIPdotsRev(netmask);\n    Serial.print(F(\"\\nGateway: \")); cc3000.printIPdotsRev(gateway);\n    Serial.print(F(\"\\nDHCPsrv: \")); cc3000.printIPdotsRev(dhcpserv);\n    Serial.print(F(\"\\nDNSserv: \")); cc3000.printIPdotsRev(dnsserv);\n    Serial.println();\n    return true;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https"
      ],
      "libraries": [
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "stringCallback",
          "parameters": "char *myString",
          "body": "Firmata.sendString(myString);"
        },
        {
          "name": "sysexCallback",
          "parameters": "byte command, byte argc, byte *argv",
          "body": "Firmata.sendSysex(command, argc, argv);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n  Firmata.attach(STRING_DATA, stringCallback);\n  Firmata.attach(START_SYSEX, sysexCallback);\n  Firmata.begin(57600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "while (Firmata.available()) {\n    Firmata.processInput();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "i2c",
        "millis",
        "digitalwrite",
        "delay"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // Set the timeout\n  auto startNow = millis() + 2500;\n  while (!Serial && millis() < startNow);\n  Serial.println(\"Hello, Edge Control Sketch!\");\n\n  // Enable power lines \n  Power.enable3V3();\n  Power.enable5V();\n\n  // Start the I2C connection \n  Wire.begin();\n\n  // Initialize the expander pins \n  Expander.begin();\n  Expander.pinMode(EXP_LED1, OUTPUT);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n    Serial.println(\"Blink\");\n    Expander.digitalWrite(EXP_LED1, LOW);\n    delay(500);\n    Expander.digitalWrite(EXP_LED1, HIGH);\n    delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "delay",
        "millis"
      ],
      "libraries": [
        "your-fomo-project_inferencing.h",
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/edgeimpulse/fomo.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"__EDGE IMPULSE FOMO (NO-PSRAM)__\");\n\n    // camera settings\n    // replace with your own model!\n    camera.pinout.aithinker();\n    camera.brownout.disable();\n    // NON-PSRAM FOMO only works on 96x96 (yolo) RGB565 images\n    camera.resolution.yolo();\n    camera.pixformat.rgb565();\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Put object in front of camera\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;\n    }\n\n    // run FOMO\n    if (!fomo.run().isOk()) {\n      Serial.println(fomo.exception.toString());\n      return;\n    }\n\n    // how many objects were found?\n    Serial.printf(\n      \"Found %d object(s) in %dms\\n\", \n      fomo.count(),\n      fomo.benchmark.millis()\n    );\n\n    // if no object is detected, return\n    if (!fomo.foundAnyObject())\n      return;\n\n    // if you expect to find a single object, use fomo.first\n    Serial.printf(\n      \"Found %s at (x = %d, y = %d) (size %d x %d). \"\n      \"Proba is %.2f\\n\",\n      fomo.first.label,\n      fomo.first.x,\n      fomo.first.y,\n      fomo.first.width,\n      fomo.first.height,\n      fomo.first.proba\n    );\n\n    // if you expect to find many objects, use fomo.forEach\n    if (fomo.count() > 1) {\n      fomo.forEach([](int i, bbox_t bbox) {\n        Serial.printf(\n          \"#%d) Found %s at (x = %d, y = %d) (size %d x %d). \"\n          \"Proba is %.2f\\n\",\n          i + 1,\n          bbox.label,\n          bbox.x,\n          bbox.y,\n          bbox.width,\n          bbox.height,\n          bbox.proba\n        );\n      });\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "wifi",
        "delay",
        "led"
      ],
      "libraries": [
        "BlynkEdgent.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(100);\n\n  BlynkEdgent.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "BlynkEdgent.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "wifi",
        "delay",
        "led"
      ],
      "libraries": [
        "BlynkEdgent.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(100);\n\n  BlynkEdgent.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "BlynkEdgent.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https"
      ],
      "libraries": [],
      "functions": []
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "publish",
        "delay",
        "millis",
        "timer"
      ],
      "libraries": [
        "BlynkEdgentNCP.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println();\n\n  // Give Serial Monitor some time to connect\n  delay(3000);\n\n  BLYNK_LOG(\"Main firmware: %s\", BLYNK_FIRMWARE_VERSION);\n  BLYNK_LOG(\"Build: %s\", __DATE__ \" \" __TIME__);\n\n  // Initialize the Blynk.NCP hardware\n  if (Blynk.initNCP()) {\n    String ver = Blynk.getNcpVersion();\n    BLYNK_LOG(\"Blynk.NCP firmware: %s\", ver.c_str());\n  } else {\n    BLYNK_LOG(\"Cannot communicate to Blynk.NCP\");\n    BLYNK_LOG(\"  Please ensure you have flashed your board with the Blynk.NCP firmware, before running this example.\");\n    BLYNK_LOG(\"  See: https://github.com/blynkkk/BlynkNcpExample\");\n    return;\n  }\n\n  // Print state changes\n  Blynk.onStateChange([]() {\n    BLYNK_LOG(\"State: %s\", Blynk.getStateString());\n  });\n\n  // Set config mode timeout to 30 minutes, for testing purposes\n  Blynk.setConfigTimeout(30*60);\n\n  // White labeling (use this ONLY if you have a branded Blynk App)\n  //Blynk.setVendorPrefix(\"MyCompany\");\n  //Blynk.setVendorServer(\"dashboard.mycompany.com\");\n\n  // Product setup\n  Blynk.begin(BLYNK_TEMPLATE_ID, BLYNK_TEMPLATE_NAME);\n\n  // Publish some data periodically\n  timer.setInterval(1000, []() {\n    Blynk.virtualWrite(V0, millis() / 1000);\n  });"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "timer.run();\n  Blynk.run();\n  delay(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "wifi",
        "delay",
        "led"
      ],
      "libraries": [
        "BlynkEdgent.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(100);\n\n  BlynkEdgent.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "BlynkEdgent.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "eeprom"
      ],
      "libraries": [
        "StreamUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize serial port\n  Serial.begin(9600);\n  while (!Serial)\n    continue;\n\n#if STREAMUTILS_ENABLE_EEPROM\n\n#if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)\n  Serial.println(\"Initializing EEPROM...\");\n  EEPROM.begin(512);\n#endif\n\n  Serial.println(\"Make sure to run the EepromWrite example first!\");\n\n  Serial.println(\"Reading EEPROM... \");\n  EepromStream s(0, 12);\n  Serial.print(s.readString());\n\n#else\n  Serial.println(\"EepromStream is not supported on this platform. Sorry\");\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// not used in this example"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "eeprom"
      ],
      "libraries": [
        "StreamUtils.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Initialize serial port\n  Serial.begin(9600);\n  while (!Serial)\n    continue;\n\n#if STREAMUTILS_ENABLE_EEPROM\n\n#if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)\n  Serial.println(\"Initializing EEPROM...\");\n  EEPROM.begin(512);\n#endif\n\n  Serial.println(\"Writing to EEPROM...\");\n  EepromStream s(0, 12);\n  s.print(\"Hello World!\");\n\n#if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)\n  Serial.println(\"Saving...\");\n  s.flush();  // only required on ESP\n#endif\n\n  Serial.println(\"Done!\");\n  Serial.println(\"Now, run the EepromRead example.\");\n\n#else\n  Serial.println(\"EepromStream is not supported on this platform. Sorry\");\n#endif"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// not used in this example"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ssl",
        "encryption",
        "https",
        "password",
        "auth",
        "buffer",
        "voltage",
        "power",
        "wifi",
        "delay",
        "millis",
        "nodemcu"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "dscKeybusInterface.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  delay(1000);\n  Serial.println();\n  Serial.println();\n\n  Serial.print(F(\"WiFi....\"));\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(wifiSSID, wifiPassword);\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(500);\n  }\n  Serial.print(F(\"connected: \"));\n  Serial.println(WiFi.localIP());\n  ipClient.setInsecure();\n\n  // Sends a message on startup to verify connectivity\n  Serial.print(F(\"Email....\"));\n  if (sendMessage(\"Initializing\")) Serial.println(F(\"connected.\"));\n  else Serial.println(F(\"connection error.\"));\n\n  // Starts the Keybus interface\n  dsc.begin();\n  Serial.println(F(\"DSC Keybus Interface is online.\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Updates status if WiFi drops and reconnects\n  if (!wifiConnected && WiFi.status() == WL_CONNECTED) {\n    Serial.println(\"WiFi reconnected\");\n    wifiConnected = true;\n    dsc.pauseStatus = false;\n    dsc.statusChanged = true;\n  }\n  else if (WiFi.status() != WL_CONNECTED && wifiConnected) {\n    Serial.println(\"WiFi disconnected\");\n    wifiConnected = false;\n    dsc.pauseStatus = true;\n  }\n\n  dsc.loop();\n\n  if (dsc.statusChanged) {      // Checks if the security system status has changed\n    dsc.statusChanged = false;  // Reset the status tracking flag\n\n    // If the Keybus data buffer is exceeded, the sketch is too busy to process all Keybus commands.  Call\n    // loop() more often, or increase dscBufferSize in the library: src/dscKeybus.h or src/dscClassic.h\n    if (dsc.bufferOverflow) {\n      Serial.println(F(\"Keybus buffer overflow\"));\n      dsc.bufferOverflow = false;\n    }\n\n    // Checks status per partition\n    for (byte partition = 0; partition < dscPartitions; partition++) {\n\n      // Skips processing if the partition is disabled or in installer programming\n      if (dsc.disabled[partition]) continue;\n\n      // Checks alarm triggered status\n      if (dsc.alarmChanged[partition]) {\n        dsc.alarmChanged[partition] = false;  // Resets the partition alarm status flag\n\n        if (dsc.alarm[partition]) {\n          char messageContent[19] = \"Alarm: Partition \";\n          appendPartition(partition, messageContent);  // Appends the message with the partition number\n          sendMessage(messageContent);\n        }\n        else {\n          char messageContent[34] = \"Disarmed after alarm: Partition \";\n          appendPartition(partition, messageContent);  // Appends the message with the partition number\n          sendMessage(messageContent);\n        }\n      }\n\n      if (dsc.fireChanged[partition]) {\n        dsc.fireChanged[partition] = false;  // Resets the fire status flag\n\n        if (dsc.fire[partition]) {\n          char messageContent[24] = \"Fire alarm: Partition \";\n          appendPartition(partition, messageContent);  // Appends the message with the partition number\n          sendMessage(messageContent);\n        }\n        else {\n          char messageContent[33] = \"Fire alarm restored: Partition \";\n          appendPartition(partition, messageContent);  // Appends the message with the partition number\n          sendMessage(messageContent);\n        }\n      }\n    }\n    // Checks trouble status\n    if (dsc.troubleChanged) {\n      dsc.troubleChanged = false;  // Resets the trouble status flag\n      if (dsc.trouble) sendMessage(\"Trouble status on\");\n      else sendMessage(\"Trouble status restored\");\n    }\n\n    // Checks for AC power status\n    if (dsc.powerChanged) {\n      dsc.powerChanged = false;  // Resets the battery trouble status flag\n      if (dsc.powerTrouble) sendMessage(\"AC power trouble\");\n      else sendMessage(\"AC power restored\");\n    }\n\n    // Checks panel battery status\n    if (dsc.batteryChanged) {\n      dsc.batteryChanged = false;  // Resets the battery trouble status flag\n      if (dsc.batteryTrouble) sendMessage(\"Panel battery trouble\");\n      else sendMessage(\"Panel battery restored\");\n    }\n\n    // Checks for keypad fire alarm status\n    if (dsc.keypadFireAlarm) {\n      dsc.keypadFireAlarm = false;  // Resets the keypad fire alarm status flag\n      sendMessage(\"Keypad Fire alarm\");\n    }\n\n    // Checks for keypad aux auxiliary alarm status\n    if (dsc.keypadAuxAlarm) {\n      dsc.keypadAuxAlarm = false;  // Resets the keypad auxiliary alarm status flag\n      sendMessage(\"Keypad Aux alarm\");\n    }\n\n    // Checks for keypad panic alarm status\n    if (dsc.keypadPanicAlarm) {\n      dsc.keypadPanicAlarm = false;  // Resets the keypad panic alarm status flag\n      sendMessage(\"Keypad Panic alarm\");\n    }\n  }"
        },
        {
          "name": "sendMessage",
          "parameters": "const char* messageContent",
          "body": "if (!ipClient.connect(\"smtp.example.com\", 465)) return false;       // Set the SMTP server address - for example: smtp.gmail.com\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"HELO ESP8266\"));\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"AUTH LOGIN\"));\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"myBase64encodedLogin\"));                        // Set the SMTP server login in base64\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"myBase64encodedPassword\"));                     // Set the SMTP server password in base64\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"MAIL FROM:<sender@example.com>\"));              // Set the sender address\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"RCPT TO:<recipient@example.com>\"));             // Set the recipient address - repeat to add multiple recipients\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"RCPT TO:<recipient2@example.com>\"));            // An optional additional recipient\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"DATA\"));\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"From: Security System <sender@example.com>\"));  // Set the sender displayed in the email header\n  ipClient.println(F(\"To: Recipient <recipient@example.com>\"));       // Set the recipient displayed in the email header\n  ipClient.print(F(\"Subject: \"));\n  ipClient.print(messagePrefix);\n  ipClient.println(messageContent);\n  ipClient.println();                                                 // Required blank line between the header and body\n  ipClient.print(messagePrefix);\n  ipClient.println(messageContent);\n  ipClient.println(F(\".\"));\n  if(!smtpValidResponse()) return false;\n  ipClient.println(F(\"QUIT\"));\n  if(!smtpValidResponse()) return false;\n  ipClient.stop();\n  return true;"
        },
        {
          "name": "smtpValidResponse",
          "parameters": "",
          "body": "// Waits for a response\n  unsigned long previousMillis = millis();\n  while (!ipClient.available()) {\n    dsc.loop();  // Processes Keybus data while waiting on the SMTP response\n    if (millis() - previousMillis > 3000) {\n      Serial.println(F(\"Connection timed out waiting for a response.\"));\n      ipClient.stop();\n      return false;\n    }\n  }\n\n  // Checks the first character of the SMTP reply code - the command was successful if the reply code begins\n  // with \"2\" or \"3\"\n  char replyCode = ipClient.read();\n\n  // Successful, reads the remainder of the response to clear the client buffer\n  if (replyCode == '2' || replyCode == '3') {\n    while (ipClient.available()) ipClient.read();\n    return true;\n  }\n\n  // Unsuccessful, prints the response to serial to help debug\n  else {\n    Serial.println(F(\"Email send error, response:\"));\n    Serial.print(replyCode);\n    while (ipClient.available()) Serial.print((char)ipClient.read());\n    Serial.println();\n    ipClient.println(F(\"QUIT\"));\n    smtpValidResponse();\n    ipClient.stop();\n    return false;\n  }"
        },
        {
          "name": "appendPartition",
          "parameters": "byte sourceNumber, char* messageContent",
          "body": "char partitionNumber[2];\n  itoa(sourceNumber + 1, partitionNumber, 10);\n  strcat(messageContent, partitionNumber);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "password",
        "token",
        "key",
        "auth",
        "ssl",
        "database",
        "payload",
        "buffer",
        "callback",
        "current",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the user sign in credentials */\n    auth.user.email = USER_EMAIL;\n    auth.user.password = USER_PASSWORD;\n\n    /* Assign the RTDB URL */\n    config.database_url = DATABASE_URL;\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    fbdo.setResponseSize(4096);\n\n    String base_path = \"/UsersData/\";\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    /* Initialize the library with the Firebase authen and config */\n    Firebase.begin(&config, &auth);\n\n    /** Now modify the database rules (if not yet modified)\n     *\n     * The user, <user uid> in this case will be granted to read and write\n     * at the certain location i.e. \"/UsersData/<user uid>\".\n     *\n     * If you database rules has been modified, please comment this code out.\n     *\n     * The character $ is to make a wildcard variable (can be any name) represents any node key\n     * which located at some level in the rule structure and use as reference variable\n     * in .read, .write and .validate rules\n     *\n     * For this case $userId represents any <user uid> node that places under UsersData node i.e.\n     * /UsersData/<user uid> which <user uid> is user UID.\n     *\n     * Please check your the database rules to see the changes after run the below code.\n     */\n    String var = \"$userId\";\n    String val = \"($userId === auth.uid && auth.token.premium_account === true && auth.token.admin === true)\";\n    Firebase.setReadWriteRules(fbdo, base_path, var, val, val, DATABASE_SECRET);\n\n    /** path for user data is now \"/UsersData/<user uid>\"\n     * The user UID can be taken from auth.token.uid\n     *\n     * The refresh token can be accessed from Firebase.getRefreshToken().\n     */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = \"/UsersData/\";\n        path += auth.token.uid.c_str(); //<- user uid of current user that sign in with Emal/Password\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());\n\n        // You can use refresh token from Firebase.getRefreshToken() to sign in next time without providing Email and Password.\n        // See SignInWithRefreshIDToken example.\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "delay",
        "flash",
        "eeprom"
      ],
      "libraries": [
        "FlashStorage_SAMD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EmulatedEEPROM on \")); Serial.println(BOARD_NAME);\n  Serial.println(FLASH_STORAGE_SAMD_VERSION);\n\n  Serial.print(\"EEPROM length: \");\n  Serial.println(EEPROM.length());\n\n  // Check signature at address 0\n  int signature;\n\n  EEPROM.get(0, signature);\n\n  // If the EEPROM is empty then no WRITTEN_SIGNATURE\n  if (signature != WRITTEN_SIGNATURE)\n  {\n    Serial.println(\"EEPROM is empty, writing WRITTEN_SIGNATURE and some example data:\");\n\n    EEPROM.put(0, WRITTEN_SIGNATURE);\n\n    Serial.print(\"->\");\n\n    for (int i = sizeof(WRITTEN_SIGNATURE); i < 20; i++)\n    {\n      EEPROM.write(i, 100 + i);\n      Serial.print(\" \");\n      Serial.print(100 + i);\n    }\n\n    // commit() saves all the changes to EEPROM, it must be called\n    // every time the content of virtual EEPROM is changed to make\n    // the change permanent.\n    // This operation burns Flash write cycles and should not be\n    // done too often. See readme for details:\n    // https://github.com/khoih-prog/FlashStorage_SAMD#limited-number-of-writes\n\n    EEPROM.commit();\n    Serial.println(\"\\nDone writing to emulated EEPROM. You can reset now to test\");\n  }\n  else\n  {\n    EEPROM.get(0, signature);\n\n    Serial.print(\"EEPROM has been written.Signature = 0x\"); Serial.println(signature, HEX);\n\n    Serial.println(\"Here is the content of the next 16 bytes:\");\n\n    Serial.print(\"->\");\n\n    for (int i = sizeof(WRITTEN_SIGNATURE); i < 20; i++)\n    {\n      Serial.print(\" \");\n      Serial.print(EEPROM.read(i));\n    }\n\n    Serial.println(\"\\nClearing WRITTEN_SIGNATURE for next try\");\n\n    EEPROM.put(0, 0);\n\n    if (!EEPROM.getCommitASAP())\n    {\n      Serial.println(\"CommitASAP not set. Need commit()\");\n      EEPROM.commit();\n    }\n    \n    Serial.println(\"Done clearing signature in emulated EEPROM. You can reset now\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "wificlient",
        "http",
        "password",
        "stream",
        "parse",
        "wifi",
        "delay",
        "millis"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/viz/mjpeg.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"__RE-ENCODE MJPEG STREAM__\");\n\n    // camera settings\n    // replace with your own model!\n    camera.pinout.aithinker();\n    camera.brownout.disable();\n    // higher resolution cannot be handled\n    camera.resolution.qvga();\n    camera.quality.best();\n\n    // since we want to access the raw pixels\n    // capture in RGB565 format\n    // keep in mind that you need a lot of RAM to store\n    // all this data at high resolutions\n    // (e.g. QVGA = 320 x 240 x 2 = 1536 kB)\n    camera.pixformat.rgb565();\n\n    // MJPEG settings\n    mjpeg.onFrame(&reencode_frame);\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    // connect to WiFi\n    while (!wifi.connect().isOk())\n        Serial.println(wifi.exception.toString());\n\n    // start mjpeg http server\n    while (!mjpeg.begin().isOk())\n        Serial.println(mjpeg.exception.toString());\n\n    // assert camera can capture frames\n    while (!camera.capture().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"ToF OK\");\n    Serial.println(\"WiFi OK\");\n    Serial.println(\"MjpegStream OK\");\n    Serial.println(mjpeg.address());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// nothing to do here, MJPEG server runs in background"
        },
        {
          "name": "reencode_frame",
          "parameters": "WiFiClient *client, camera_fb_t* frame",
          "body": "// log how much time elapsed from last frame\n    const size_t now = millis();\n    const uint16_t height = camera.resolution.getHeight();\n    const uint16_t width = camera.resolution.getWidth();\n\n    ESP_LOGI(\"benchmark\", \"%d ms elapsed from last frame\", now - tick);\n    tick = now;\n\n    // frame->buf contains RGB565 data\n    // that is, 2 bytes per pixel\n    //\n    // in this test, we're going to do a \"negative\" effect\n    // feel free to replace this with your own code\n    for (uint16_t y = 0; y < height; y++) {\n        uint16_t *row = (uint16_t*) (frame->buf + width * 2 * y);\n\n        for (uint16_t x = 0; x < width; x++) {\n            // read pixel and parse to R, G, B components\n            const uint16_t pixel = row[x];\n            uint16_t r = (pixel >> 11) & 0b11111;\n            uint16_t g = (pixel >> 5) & 0b111111;\n            uint16_t b = pixel & 0b11111;\n\n            // actual work: make negative\n            r = 31 - r;\n            g = 63 - g;\n            b = 31 - b;\n\n            // re-pack to RGB565\n            row[x] = (r << 11) | (g << 5) | b;\n        }\n    }\n\n    // encode to jpeg\n    uint8_t quality = 90;\n\n    frame2jpg_cb(frame, quality, &buffer_jpeg, NULL);\n    ESP_LOGI(\"var_dump\", \"JPEG size=%d\", jpeg_length);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "voltage",
        "delay",
        "led"
      ],
      "libraries": [
        "ArduinoMotorCarrier.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Establishing the communication with the Motor Carrier\n  if (controller.begin())\n  {\n    Serial.print(\"Motor Carrier connected, firmware version \");\n    Serial.println(controller.getFWVersion());\n  }\n  else\n  {\n    Serial.println(\"Couldn't connect! Is the red LED blinking? You may need to update the firmware with FWUpdater sketch\");\n    while (1);\n  }\n\n  //Serial port initialization\n  Serial.begin(115200);\n  while (!Serial);\n\n  // Reboot the motor controller; brings every value back to default\n  Serial.println(\"reboot\");\n  controller.reboot();\n  delay(500);\n\n  // Reset the encoder internal counter to zero (can be set to any initial value)\n  Serial.println(\"reset counters\");\n  encoder1.resetCounter(0);\n  encoder2.resetCounter(0);\n\n  M1.setDuty(30);\n  M2.setDuty(30);\n  M3.setDuty(30);\n  M4.setDuty(30);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "//Chose the encoder to use:encoder1(default) or encoder2\n  Serial.print(\"Encoder1 Pos [counts]: \");\n  Serial.print(encoder1.getRawCount());\n  Serial.print(\" Encoder1 vel [counts/sec]: \");\n  Serial.println(encoder1.getCountPerSecond());\n  Serial.print(\"Encoder2 Pos [counts]: \");\n  Serial.print(encoder2.getRawCount());\n  Serial.print(\" Encoder2 vel [counts/sec]: \");\n  Serial.println(encoder2.getCountPerSecond());\n  Serial.println(\"\");\n\n  //Keep active the communication between Nano & Motor Carrier\n  //Ping the SAMD11\n  controller.ping();\n  //wait\n  delay(50);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// put your main code here, to run repeatedly:\n  Serial.print(\"Encoder 0 State: \");\n  Serial.println(encoders[0].getCurrentState(),BIN);\n  Serial.print(\"Encoder 0 Pulses: \");\n  Serial.println(encoders[0].getPulses());\n  Serial.print(\"Encoder 0 Revolutions: \");\n  Serial.println(encoders[0].getRevolutions());\n  Serial.println();\n \n  Serial.print(\"Encoder 1 State: \");\n  Serial.println(encoders[1].getCurrentState(),BIN);\n  Serial.print(\"Encoder 1 Pulses: \");\n  Serial.println(encoders[1].getPulses());\n  Serial.print(\"Encoder 1 Revolutions: \");\n  Serial.println(encoders[1].getRevolutions());\n  Serial.println();\n  delay(25);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "callback",
        "current",
        "voltage",
        "ble",
        "wifi",
        "bluetooth",
        "delay",
        "digitalread",
        "millis",
        "digitalwrite",
        "analogread",
        "led",
        "clients",
        "devices",
        "device1mac",
        "device1irk",
        "device2mac",
        "device2irk",
        "device1ltk",
        "device2ltk"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);    // initialize serial communication\n  while (!Serial);\n\n  pinMode(CTRL_LED, OUTPUT); // initialize the built-in LED pin to indicate when a central is connected\n  pinMode(PAIR_LED, OUTPUT);\n  pinMode(PAIR_BUTTON, INPUT_PULLUP);\n\n\n  Serial.println(\"Serial connected\");\n  \n  // Callback function with confirmation code when new device is pairing.\n  BLE.setDisplayCode([](uint32_t confirmCode){\n    Serial.println(\"New device pairing request.\");\n    Serial.print(\"Confirm code matches pairing device: \");\n    char code[6];\n    sprintf(code, \"%06d\", confirmCode);\n    Serial.println(code);\n  });\n  \n  // Callback to allow accepting or rejecting pairing\n  BLE.setBinaryConfirmPairing([&acceptOrReject](){\n    Serial.print(\"Should we confirm pairing? \");\n    delay(5000);\n    if(acceptOrReject){\n      acceptOrReject = false;\n      Serial.println(\"yes\");\n      return true;\n    }else{\n      acceptOrReject = true;\n      Serial.println(\"no\");\n      return false;\n    }\n  });\n\n  // IRKs are keys that identify the true owner of a random mac address.\n  // Add IRKs of devices you are bonded with.\n  BLE.setGetIRKs([](uint8_t* nIRKs, uint8_t** BDaddrTypes, uint8_t*** BDAddrs, uint8_t*** IRKs){\n    // Set to number of devices\n    *nIRKs       = 2;\n\n    *BDAddrs     = new uint8_t*[*nIRKs];\n    *IRKs        = new uint8_t*[*nIRKs];\n    *BDaddrTypes = new uint8_t[*nIRKs];\n\n    // Set these to the mac and IRK for your bonded devices as printed in the serial console after bonding.\n    uint8_t device1Mac[6]    = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    uint8_t device1IRK[16]   = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n    uint8_t device2Mac[6]    = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    uint8_t device2IRK[16]   = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n\n    (*BDaddrTypes)[0] = 0; // Type 0 is for pubc address, type 1 is for static random\n    (*BDAddrs)[0] = new uint8_t[6]; \n    (*IRKs)[0]    = new uint8_t[16];\n    memcpy((*IRKs)[0]   , device1IRK,16);\n    memcpy((*BDAddrs)[0], device1Mac, 6);\n\n\n    (*BDaddrTypes)[1] = 0;\n    (*BDAddrs)[1] = new uint8_t[6];\n    (*IRKs)[1]    = new uint8_t[16];\n    memcpy((*IRKs)[1]   , device2IRK,16);\n    memcpy((*BDAddrs)[1], device2Mac, 6);\n\n\n    return 1;\n  });\n  // The LTK is the secret key which is used to encrypt bluetooth traffic\n  BLE.setGetLTK([](uint8_t* address, uint8_t* LTK){\n    // address is input\n    Serial.print(\"Received request for address: \");\n    btct.printBytes(address,6);\n\n    // Set these to the MAC and LTK of your devices after bonding.\n    uint8_t device1Mac[6]  = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    uint8_t device1LTK[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    uint8_t device2Mac[6]  = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    uint8_t device2LTK[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    \n\n    if(memcmp(device1Mac, address, 6) == 0) {\n      memcpy(LTK, device1LTK, 16);\n      return 1;\n    }else if(memcmp(device2Mac, address, 6) == 0) {\n      memcpy(LTK, device2LTK, 16);\n      return 1;\n    }\n    return 0;\n  });\n  BLE.setStoreIRK([](uint8_t* address, uint8_t* IRK){\n    Serial.print(F(\"New device with MAC : \"));\n    btct.printBytes(address,6);\n    Serial.print(F(\"Need to store IRK   : \"));\n    btct.printBytes(IRK,16);\n    return 1;\n  });\n  BLE.setStoreLTK([](uint8_t* address, uint8_t* LTK){\n    Serial.print(F(\"New device with MAC : \"));\n    btct.printBytes(address,6);\n    Serial.print(F(\"Need to store LTK   : \"));\n    btct.printBytes(LTK,16);\n    return 1;\n  });\n\n  while(1){\n    // begin initialization\n    if (!BLE.begin()) {\n      Serial.println(\"starting BLE failed!\");\n      delay(200);\n      continue;\n    }\n    Serial.println(\"BT init\");\n    delay(200);\n    \n    /* Set a local name for the BLE device\n       This name will appear in advertising packets\n       and can be used by remote devices to identify this BLE device\n       The name can be changed but maybe be truncated based on space left in advertisement packet\n    */\n\n    BLE.setDeviceName(\"Arduino\");\n    BLE.setLocalName(\"BatteryMonitor\");\n\n    BLE.setAdvertisedService(batteryService); // add the service UUID\n    batteryService.addCharacteristic(batteryLevelChar); // add the battery level characteristic\n    batteryService.addCharacteristic(stringcharacteristic);\n    batteryService.addCharacteristic(secretValue);\n\n    BLE.addService(batteryService);               // Add the battery service\n    batteryLevelChar.writeValue(oldBatteryLevel); // set initial value for this characteristic\n    char* stringCharValue = new char[32];\n    stringCharValue = \"string\";\n    stringcharacteristic.writeValue(stringCharValue);\n    secretValue.writeValue(0);\n    \n    delay(1000);\n\n    // prevent pairing until button is pressed (will show a pairing rejected message)\n    BLE.setPairable(false);\n  \n    /* Start advertising BLE.  It will start continuously transmitting BLE\n       advertising packets and will be visible to remote BLE central devices\n       until it receives a new connection */\n  \n    // start advertising\n    if(!BLE.advertise()){\n      Serial.println(\"failed to advertise bluetooth.\");\n      BLE.stopAdvertise();\n      delay(500);\n    }else{\n      Serial.println(\"advertising...\");\n      break;\n    }\n    BLE.end();\n    delay(100);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// wait for a BLE central\n  BLEDevice central = BLE.central();\n\n\n  // If button is pressed, allow pairing for 30 sec\n  if (!BLE.pairable() && digitalRead(PAIR_BUTTON) == LOW){\n    pairingStarted = millis();\n    BLE.setPairable(Pairable::ONCE);\n    Serial.println(\"Accepting pairing for 30s\");\n  } else if (BLE.pairable() && millis() > pairingStarted + PAIR_INTERVAL){\n    BLE.setPairable(false);\n    Serial.println(\"No longer accepting pairing\");\n  }\n  // Make LED blink while pairing is allowed\n  digitalWrite(PAIR_LED, (BLE.pairable() ? (millis()%400)<200 : BLE.paired()) ? PAIR_LED_ON : !PAIR_LED_ON); \n\n\n  // if a central is connected to the peripheral:\n  if (central && central.connected()) {\n    if (!wasConnected){\n      wasConnected = true;\n      Serial.print(\"Connected to central: \");\n      // print the central's BT address:\n      Serial.println(central.address());\n    }\n\n    // check the battery level every 200ms\n    // while the central is connected:\n    long currentMillis = millis();\n    // if 200ms have passed, check the battery level:\n    if (currentMillis - previousMillis >= 1000) {\n      previousMillis = currentMillis;\n      updateBatteryLevel();\n      digitalWrite(CTRL_LED, secretValue.value()>0 ? HIGH : LOW);\n    }\n  } else if (wasConnected){\n    wasConnected = false;\n    Serial.print(\"Disconnected from central: \");\n    Serial.println(central.address());\n  }"
        },
        {
          "name": "updateBatteryLevel",
          "parameters": "",
          "body": "/* Read the current voltage level on the A0 analog input pin.\n     This is used here to simulate the charge level of a battery.\n  */\n  int battery = analogRead(A0);\n  int batteryLevel = map(battery, 0, 1023, 0, 100);\n\n  if (batteryLevel != oldBatteryLevel) {      // if the battery level has changed\n    // Serial.print(\"Battery Level % is now: \"); // print it\n    // Serial.println(batteryLevel);\n    batteryLevelChar.writeValue(batteryLevel);  // and update the battery level characteristic\n    oldBatteryLevel = batteryLevel;           // save the level for next comparison\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "isBigEndian",
          "parameters": "",
          "body": "uint32_t test = 0x11223344;\n  uint8_t *pTest = reinterpret_cast<uint8_t *>(&test);\n  return pTest[0] == 0x11;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "isBigEndian",
          "parameters": "",
          "body": "uint32_t test = 0x11223344;\n  uint8_t *pTest = reinterpret_cast<uint8_t *>(&test);\n  return pTest[0] == 0x11;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "auth",
        "token",
        "ble"
      ],
      "libraries": [
        "BLE.h",
        "BlynkSimpleSerialBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  ble.setLogLevel(BLE_LOG_ERRORS);\n  ble.begin();\n  ble.serial();\n  ble.setAdvertName(\"Blynk BLE\");\n  ble.startAdvert();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(ble, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "blynk-cloud.com"
      ],
      "libraries": [
        "Ethernet.h",
        "BlynkSimpleEnergiaEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, \"blynk-cloud.com\", 80);\n  //Blynk.begin(auth, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token"
      ],
      "libraries": [
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial1.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "http",
        "https",
        "auth",
        "token",
        "password",
        "wifi",
        "spi",
        "blynk-cloud.com"
      ],
      "libraries": [
        "SPI.h",
        "WiFi.h",
        "BlynkSimpleEnergiaWiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 80);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "ble"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!BLE.begin()) {\n    Serial.println(\"failed to initialize BLE!\");\n    while (1);\n  }\n\n  myService.addCharacteristic(myCharacteristic);\n  BLE.addService(myService);\n\n  // Build scan response data packet\n  BLEAdvertisingData scanData;\n  // Set parameters for scan response packet\n  scanData.setLocalName(\"Test enhanced advertising\");\n  // Copy set parameters in the actual scan response packet\n  BLE.setScanResponseData(scanData);\n\n  // Build advertising data packet\n  BLEAdvertisingData advData;\n  // Set parameters for advertising packet\n  advData.setManufacturerData(0x004C, manufactData, sizeof(manufactData));\n  advData.setAdvertisedService(myService);\n  advData.setAdvertisedServiceData(0xfff0, serviceData, sizeof(serviceData));\n  // Copy set parameters in the actual advertising packet\n  BLE.setAdvertisingData(advData);\n\n  BLE.advertise();\n  Serial.println(\"advertising ...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "BLE.poll();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "rtc"
      ],
      "libraries": [
        "RTCZero.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  rtc.begin(); // initialize RTC\n\n  rtc.setEpoch(1451606400); // Jan 1, 2016"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(\"Unix time = \");\n  Serial.println(rtc.getEpoch());\n\n  Serial.print(\"Seconds since Jan 1 2000 = \");\n  Serial.println(rtc.getY2kEpoch());\n\n  // Print date...\n  Serial.print(rtc.getDay());\n  Serial.print(\"/\");\n  Serial.print(rtc.getMonth());\n  Serial.print(\"/\");\n  Serial.print(rtc.getYear());\n  Serial.print(\"\\t\");\n\n  // ...and time\n  print2digits(rtc.getHours());\n  Serial.print(\":\");\n  print2digits(rtc.getMinutes());\n  Serial.print(\":\");\n  print2digits(rtc.getSeconds());\n\n  Serial.println();\n\n  delay(1000);"
        },
        {
          "name": "print2digits",
          "parameters": "int number",
          "body": "if (number < 10) {\n    Serial.print(\"0\");\n  }\n  Serial.print(number);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "millis",
        "delay",
        "flash"
      ],
      "libraries": [
        "SerialFlash.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//uncomment these if using Teensy audio shield\n  //SPI.setSCK(14);  // Audio shield has SCK on pin 14\n  //SPI.setMOSI(7);  // Audio shield has MOSI on pin 7\n\n  //uncomment these if you have other SPI chips connected\n  //to keep them disabled while using only SerialFlash\n  //pinMode(4, INPUT_PULLUP);\n  //pinMode(10, INPUT_PULLUP);\n\n  Serial.begin(9600);\n\n  // wait up to 10 seconds for Arduino Serial Monitor\n  unsigned long startMillis = millis();\n  while (!Serial && (millis() - startMillis < 10000)) ;\n  delay(100);\n\n  SerialFlash.begin(FlashChipSelect);\n  unsigned char id[5];\n  SerialFlash.readID(id);\n  unsigned long size = SerialFlash.capacity(id);\n\n  if (size > 0) {\n    Serial.print(\"Flash Memory has \");\n    Serial.print(size);\n    Serial.println(\" bytes.\");\n    Serial.println(\"Erasing ALL Flash Memory:\");\n    // Estimate the (lengthy) wait time.\n    Serial.print(\"  estimated wait: \");\n    int seconds = (float)size / eraseBytesPerSecond(id) + 0.5;\n    Serial.print(seconds);\n    Serial.println(\" seconds.\");\n    Serial.println(\"  Yes, full chip erase is SLOW!\");\n    SerialFlash.eraseAll();\n    unsigned long dotMillis = millis();\n    unsigned char dotcount = 0;\n    while (SerialFlash.ready() == false) {\n      if (millis() - dotMillis > 1000) {\n        dotMillis = dotMillis + 1000;\n        Serial.print(\".\");\n        dotcount = dotcount + 1;\n        if (dotcount >= 60) {\n          Serial.println();\n          dotcount = 0;\n        }\n      }\n    }\n    if (dotcount > 0) Serial.println();\n    Serial.println(\"Erase completed\");\n    unsigned long elapsed = millis() - startMillis;\n    Serial.print(\"  actual wait: \");\n    Serial.print(elapsed / 1000ul);\n    Serial.println(\" seconds.\");\n  }"
        },
        {
          "name": "eraseBytesPerSecond",
          "parameters": "const unsigned char *id",
          "body": "if (id[0] == 0x20) return 152000.0; // Micron\n  if (id[0] == 0x01) return 500000.0; // Spansion\n  if (id[0] == 0xEF) return 419430.0; // Winbond\n  if (id[0] == 0xC2) return 279620.0; // Macronix\n  return 320000.0; // guess?"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite"
      ],
      "libraries": [
        "MIDI.h"
      ],
      "functions": [
        {
          "name": "handleError",
          "parameters": "int8_t err",
          "body": "digitalWrite(LED_BUILTIN, (err == 0)? LOW : HIGH);"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  MIDI.setHandleError(handleError);\n  MIDI.begin(1);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "MIDI.read();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "delay"
      ],
      "libraries": [
        "CanSatKit.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "SerialUSB.begin(115200);\n\n  // radio.begin() returns true if communication with radio module\n  // onboard is correct\n  bool ok = radio.begin();\n\n  if (ok) {\n      // print that radio is ok\n      SerialUSB.println(\"Radio OK!\");\n      // stop printing radio debug to SerialUSB since everything is OK\n      radio.disable_debug();\n  } else {\n      // print that radio configuration failed...\n      SerialUSB.println(\"Radio failed!\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// CanSatKitRadio.transmit returns true if there is enough space in\n  // radio transmission buffer\n  bool ok = radio.transmit(\"Hello World!\");\n\n  if (!ok) {\n      // if CanSatKitRadio.transmit returned false -- print that buffer is full\n      // to prevent from buffer overflow - increase delay or send less data...\n      SerialUSB.println(\"Transmit buffer full!\");\n  }\n\n  // adjust delay to prevent from radio transmission buffer overflow\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "esp8266webserver",
        "http",
        "websocket",
        "api",
        "webserver",
        "https",
        "password",
        "json",
        "payload",
        "buffer",
        "wifi",
        "delay",
        "millis",
        "spiffs",
        "html",
        "javascript"
      ],
      "libraries": [
        "Servo.h",
        "menu.h",
        "menuIO/esp8266Out.h",
        "menuIO/xmlFmt.h",
        "menuIO/serialIn.h",
        "menuIO/jsonFmt.h",
        "streamFlow.h",
        "Streaming.h",
        "menuIO/jsFmt.h",
        "FS.h",
        "Hash.h",
        "user_interface.h"
      ],
      "functions": [
        {
          "name": "webSocketEvent",
          "parameters": "uint8_t num, WStype_t type, uint8_t * payload, size_t length",
          "body": "switch(type) {\n    case WStype_DISCONNECTED:\n      //USE_SERIAL.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n    case WStype_CONNECTED: {\n        IPAddress ip = webSocket.remoteIP(num);\n        //USE_SERIAL.printf(\"[%u] Connected from %d.%d.%d.%d url: %s\\n\", num, ip[0], ip[1], ip[2], ip[3], payload);\n        webSocket.sendTXT(num, \"console.log('ArduinoMenu Connected')\");\n      }\n      break;\n    case WStype_TEXT: {\n        //USE_SERIAL.printf(\"[%u] get Text: %s\\n\", num, payload);\n        // nav.async((const char*)payload);//this is slow!!!!!!!!\n        __trace(Serial.printf(\"[%u] get Text: %s\\n\", num, payload));\n        char*s=(char*)payload;\n        _trace(Serial<<\"serve websocket menu\"<<endl);\n        wsOut.response.remove(0);\n        wsOut<<\"{\\\"output\\\":\\\"\";\n        wsNav.async((const char*)payload);\n        wsOut<<\"\\\",\\n\\\"menu\\\":\";\n        wsNav.doOutput();\n        wsOut<<\"\\n}\";\n        webSocket.sendTXT(num,wsOut.response);\n        // wsOut.response.remove(0);\n        // jsonEnd();\n      } break;\n    case WStype_BIN: {\n        USE_SERIAL<<\"[WSc] get binary length:\"<<length<<\"[\";\n        for(int c=0;c<length;c++) {\n          USE_SERIAL.print(*(char*)(payload+c),HEX);\n          USE_SERIAL.write(',');\n        }\n        USE_SERIAL<<\"]\"<<endl;\n        uint16_t id=*(uint16_t*) payload++;\n        idx_t len=*((idx_t*)++payload);\n        idx_t* pathBin=(idx_t*)++payload;\n        const char* inp=(const char*)(payload+len);\n        //Serial<<\"id:\"<<id<<endl;\n        if (id==nav.active().hash()) {\n          //Serial<<\"id ok.\"<<endl;Serial.flush();\n          //Serial<<\"input:\"<<inp<<endl;\n          //StringStream inStr(inp);\n          //while(inStr.available())\n          nav.doInput(inp);\n          webSocket.sendTXT(num, \"binBusy=false;\");//send javascript to unlock the state\n        } //else Serial<<\"id not ok!\"<<endl;\n        //Serial<<endl;\n      }\n      break;\n    default:break;\n  }"
        },
        {
          "name": "pageStart",
          "parameters": "",
          "body": "_trace(Serial<<\"pasgeStart!\"<<endl);\n  serverOut<<\"HTTP/1.1 200 OK\\r\\n\"\n    <<\"Content-Type: text/xml\\r\\n\"\n    <<\"Connection: close\\r\\n\"\n    <<\"Expires: 0\\r\\n\"\n    <<\"\\r\\n\";\n  serverOut<<\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\r\\n\"\n    \"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\";\n  serverOut<<xslt;\n  serverOut<<CUR_VERSION\"/device.xslt\";\n  serverOut<<\"\\\"?>\\r\\n<menuLib\"\n    #ifdef WEB_DEBUG\n      <<\" debug=\\\"yes\\\"\"\n    #endif\n    <<\" host=\\\"\";\n    serverOut.print(APName);\n    serverOut<<\"\\\">\\r\\n<sourceURL ver=\\\"\" CUR_VERSION \"/\\\">\";\n  if (server.hasHeader(\"host\"))\n    serverOut.print(server.header(\"host\"));\n  else\n    serverOut.print(APName);\n  serverOut<<\"</sourceURL>\";"
        },
        {
          "name": "pageEnd",
          "parameters": "",
          "body": "serverOut<<\"</menuLib>\";\n  server.client().stop();"
        },
        {
          "name": "jsonStart",
          "parameters": "",
          "body": "_trace(Serial<<\"jsonStart!\"<<endl);\n  serverOut<<\"HTTP/1.1 200 OK\\r\\n\"\n    <<\"Content-Type: application/json; charset=utf-8\\r\\n\"\n    <<\"Connection: close\\r\\n\"\n    <<\"Expires: 0\\r\\n\"\n    <<\"\\r\\n\";"
        },
        {
          "name": "jsonEnd",
          "parameters": "",
          "body": "server.client().stop();"
        },
        {
          "name": "handleMenu",
          "parameters": "navRoot& nav",
          "body": "_trace(\n    uint32_t free = system_get_free_heap_size();\n    Serial.print(F(\"free memory:\"));\n    Serial.print(free);\n    Serial.print(F(\" handleMenu \"));\n    Serial.println(server.arg(\"at\").c_str());\n  );\n  String at=server.arg(\"at\");\n  bool r;\n  r=nav.async(server.hasArg(\"at\")?at.c_str():\"/\");\n  return r;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  myservo.attach(ESCPIN);\n\n  webNav.canExit=false;\n  jsonNav.canExit=false;\n  wsNav.canExit=false;\n\n  for(uint8_t t = 4; t > 0; t--) {\n      Serial.printf(\"[SETUP] BOOT WAIT %d...\\n\", t);\n      Serial.flush();\n      delay(1000);\n  }\n\n  Serial.println();\n  Serial.println(\"Arduino menu webserver example\");\n\n  SPIFFS.begin();\n\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n\n  WiFi.begin(ssid, password);\n  // Wait for connection\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  webSocket.begin();\n  Serial.println(\"\");\n  webSocket.onEvent(webSocketEvent);\n  Serial.println(\"Connected.\");\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n  webSocket.begin();\n\n  nav.idleTask=idle;//point a function to be used when menu is suspended\n\n  server.on(\"/\",HTTP_GET,mainPage);\n\n  //menu xml server over http\n  server.on(\"/menu\", HTTP_GET, []() {\n    pageStart();\n    serverOut<<\"<output state=\\\"\"<<((int)&webNav.idleTask)<<\"\\\"><![CDATA[\";\n    _trace(Serial<<\"output count\"<<webNav.out.cnt<<endl);\n    handleMenu(webNav);//do navigation (read input) and produce output messages or reports\n    serverOut<<\"]]></output>\";\n    webNav.doOutput();\n    pageEnd();\n  });\n\n  //menu json server over http\n  server.on(\"/json\", HTTP_GET, []() {\n    _trace(Serial<<\"json request!\"<<endl);\n    jsonStart();\n    serverOut<<\"{\\\"output\\\":\\\"\";\n    handleMenu(jsonNav);\n    serverOut<<\"\\\",\\n\\\"menu\\\":\";\n    jsonNav.doOutput();\n    serverOut<<\"\\n}\";\n    jsonEnd();\n  });\n\n  server.begin();\n  Serial.println(\"HTTP server started\");\n  Serial.println(\"Serving ArduinoMenu example.\");\n  #ifdef MENU_DEBUG\n    server.serveStatic(\"/\", SPIFFS, \"/\",\"max-age=30\");\n  #else\n    server.serveStatic(\"/\", SPIFFS, \"/\",\"max-age=31536000\");\n  #endif"
        },
        {
          "name": "loop",
          "parameters": "void",
          "body": "wsOut.response.remove(0);//clear websocket json buffer\n  webSocket.loop();\n  server.handleClient();\n  delay(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "callback",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    // Connect to wifi\n    WiFi.begin(ssid, password);\n\n    // Wait some time to connect to wifi\n    for(int i = 0; i < 10 && WiFi.status() != WL_CONNECTED; i++) {\n        Serial.print(\".\");\n        delay(1000);\n    }\n\n    // Check if connected to wifi\n    if(WiFi.status() != WL_CONNECTED) {\n        Serial.println(\"No Wifi!\");\n        return;\n    }\n\n    Serial.println(\"Connected to Wifi, Connecting to server.\");\n    // try to connect to Websockets server\n    bool connected = client.connect(websockets_server_host, websockets_server_port, \"/\");\n    if(connected) {\n        Serial.println(\"Connected!\");\n        client.send(\"Hello Server\");\n    } else {\n        Serial.println(\"Not Connected!\");\n    }\n    \n    // run callback when messages are received\n    client.onMessage([&](WebsocketsMessage message){\n        Serial.print(\"Got Message: \");\n        Serial.println(message.data());\n    });"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// let the websockets client check for incoming messages\n    if(client.available()) {\n        client.poll();\n    }\n    delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "password",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  // Connect to wifi\n  WiFi.begin(ssid, password);\n\n  // Wait some time to connect to wifi\n  for(int i = 0; i < 15 && WiFi.status() != WL_CONNECTED; i++) {\n      Serial.print(\".\");\n      delay(1000);\n  }\n  \n  Serial.println(\"\");\n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());   //You can get IP address assigned to ESP\n\n  server.listen(80);\n  Serial.print(\"Is server live? \");\n  Serial.println(server.available());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "WebsocketsClient client = server.accept();\n  if(client.available()) {\n    WebsocketsMessage msg = client.readBlocking();\n\n    // log\n    Serial.print(\"Got Message: \");\n    Serial.println(msg.data());\n\n    // return echo\n    client.send(\"Echo: \" + msg.data());\n\n    // close the connection\n    client.close();\n  }\n  \n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "wifi",
        "delay",
        "flash",
        "javascript"
      ],
      "libraries": [
        "WiFi.h",
        "JS.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  WiFi.begin(ssid, pass);\n  while (WiFi.status() != WL_CONNECTED) Serial.print(\".\"), delay(300);\n  Serial.print(\"\\nConnected, IP address: \");\n  Serial.println(WiFi.localIP());\n\n  JS.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "password",
        "callback",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "ESP8266WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    // Connect to wifi\n    WiFi.begin(ssid, password);\n\n    // Wait some time to connect to wifi\n    for(int i = 0; i < 10 && WiFi.status() != WL_CONNECTED; i++) {\n        Serial.print(\".\");\n        delay(1000);\n    }\n\n    // Check if connected to wifi\n    if(WiFi.status() != WL_CONNECTED) {\n        Serial.println(\"No Wifi!\");\n        return;\n    }\n\n    Serial.println(\"Connected to Wifi, Connecting to server.\");\n    // try to connect to Websockets server\n    bool connected = client.connect(websockets_server_host, websockets_server_port, \"/\");\n    if(connected) {\n        Serial.println(\"Connecetd!\");\n        client.send(\"Hello Server\");\n    } else {\n        Serial.println(\"Not Connected!\");\n    }\n    \n    // run callback when messages are received\n    client.onMessage([&](WebsocketsMessage message) {\n        Serial.print(\"Got Message: \");\n        Serial.println(message.data());\n    });"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// let the websockets client check for incoming messages\n    if(client.available()) {\n        client.poll();\n    }\n    delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "websocket",
        "https",
        "password",
        "wifi",
        "delay"
      ],
      "libraries": [
        "ArduinoWebsockets.h",
        "ESP8266WiFi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  // Connect to wifi\n  WiFi.begin(ssid, password);\n\n  // Wait some time to connect to wifi\n  for(int i = 0; i < 15 && WiFi.status() != WL_CONNECTED; i++) {\n      Serial.print(\".\");\n      delay(1000);\n  }\n  \n  Serial.println(\"\");\n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());   //You can get IP address assigned to ESP\n\n  server.listen(80);\n  Serial.print(\"Is server live? \");\n  Serial.println(server.available());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "WebsocketsClient client = server.accept();\n  if(client.available()) {\n    WebsocketsMessage msg = client.readBlocking();\n\n    // log\n    Serial.print(\"Got Message: \");\n    Serial.println(msg.data());\n\n    // return echo\n    client.send(\"Echo: \" + msg.data());\n\n    // close the connection\n    client.close();\n  }\n  \n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalwrite"
      ],
      "libraries": [
        "Wire.h",
        "UnoWiFiDevEd.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(BAUD);\n  pinMode(13, OUTPUT);\n  digitalWrite(13, LOW);\n\n  ESPSerial.begin(BAUD);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "while (Serial.available()) {\n    char inChar = (char)Serial.read();\n    ESPSerial.write(inChar);\n  }\n\n  while (ESPSerial.available()) {\n    char inChar = (char)ESPSerial.read();\n    Serial.write(inChar);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);        // initialize serial communications with your computer"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int xAxis = Esplora.readAccelerometer(X_AXIS);    // read the X axis\n  int yAxis = Esplora.readAccelerometer(Y_AXIS);    // read the Y axis\n  int zAxis = Esplora.readAccelerometer(Z_AXIS);    // read the Z axis\n\n  Serial.print(\"x: \");      // print the label for X\n  Serial.print(xAxis);      // print the value for the X axis\n  Serial.print(\"\\ty: \");    // print a tab character, then the label for Y\n  Serial.print(yAxis);      // print the value for the Y axis\n  Serial.print(\"\\tz: \");    // print a tab character, then the label for Z\n  Serial.println(zAxis);    // print the value for the Z axis\n\n  delay(500);              // wait half a second (500 milliseconds)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "rgb",
        "led"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// There's nothing to set up for this sketch"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Esplora.writeRGB(255, 0, 0);  // make the LED red\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(0, 255, 0);  // make the LED green\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(0, 0, 255);  // make the LED blue\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(255, 255, 0); // make the LED yellow\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(0, 255, 255); // make the LED cyan\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(255, 0, 255); // make the LED magenta\n  delay(1000);                  // wait 1 second\n  Esplora.writeRGB(255, 255, 255); // make the LED white\n  delay(1000);                  // wait 1 second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);       // initialize serial communication with your computer\n  Mouse.begin();            // take control of the mouse"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "int xValue = Esplora.readJoystickX();        // read the joystick's X position\n  int yValue = Esplora.readJoystickY();        // read the joystick's Y position\n  int button = Esplora.readJoystickSwitch();   // read the joystick pushbutton\n  Serial.print(\"Joystick X: \");                // print a label for the X value\n  Serial.print(xValue);                        // print the X value\n  Serial.print(\"\\tY: \");                       // print a tab character and a label for the Y value\n  Serial.print(yValue);                        // print the Y value\n  Serial.print(\"\\tButton: \");                  // print a tab character and a label for the button\n  Serial.print(button);                        // print the button value\n\n  int mouseX = map(xValue, -512, 512, 10, -10);  // map the X value to a range of movement for the mouse X\n  int mouseY = map(yValue, -512, 512, -10, 10);  // map the Y value to a range of movement for the mouse Y\n  Mouse.move(mouseX, mouseY, 0);                 // move the mouse\n\n  if (button == 0) {                           // if the joystick button is pressed\n    Mouse.press();                             // send a mouse click\n  } else {\n    Mouse.release();                           // if it's not pressed, release the mouse button \n  }\n\n  delay(10);                                  // a short delay before moving again"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "key",
        "current",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Keyboard.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Iterate through all the buttons:\n  for (byte thisButton = 0; thisButton < 8; thisButton++) {\n    boolean lastState = buttonStates[thisButton];\n    boolean newState = Esplora.readButton(buttons[thisButton]);\n    if (lastState != newState) { // Something changed!\n      /*\n        The Keyboard library allows you to \"press\" and \"release\" the\n        keys as two distinct actions. These actions can be\n        linked to the buttons we're handling.\n       */\n      if (newState == PRESSED) {\n        Keyboard.press(keystrokes[thisButton]);\n      }\n      else if (newState == RELEASED) {\n        Keyboard.release(keystrokes[thisButton]);\n      }\n    }\n\n    // Store the new button state, so you can sense a difference later:\n    buttonStates[thisButton] = newState;\n  }\n\n  /*\n    Wait a little bit (50ms) between a check and another.\n    When a mechanical switch is pressed or released, the\n    contacts may bounce very rapidly. If the check is done too\n    fast, these bounces may be confused as multiple presses and\n    may lead to unexpected behaviour.\n   */\n  delay(50);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "light",
        "delay",
        "led",
        "rgb",
        "sensors"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the sensors into variables:\n  int xAxis = Esplora.readJoystickX();\n  int yAxis = Esplora.readJoystickY();\n  int slider = Esplora.readSlider();\n\n  // convert the sensor readings to light levels:\n  byte red   = map(xAxis, -512, 512, 0, 255);\n  byte green = map(yAxis, -512, 512, 0, 255);\n  byte blue  = slider / 4;\n\n  // print the light levels:\n  Serial.print(red);\n  Serial.print(' ');\n  Serial.print(green);\n  Serial.print(' ');\n  Serial.println(blue);\n\n  // write the light levels to the LED.\n  Esplora.writeRGB(red, green, blue);\n\n  // add a delay to keep the LED from flickering:\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "light",
        "delay",
        "led",
        "rgb",
        "sensors"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the sensors into variables:\n  int mic = Esplora.readMicrophone();\n  int light = Esplora.readLightSensor();\n  int slider = Esplora.readSlider();\n\n  // convert the sensor readings to light levels:\n  byte red   = constrain(mic, 0, 255);\n  byte green = constrain(\n                 map(light, lowLight, highLight, minGreen, maxGreen),\n                 0, 255);\n  byte blue  = slider / 4;\n\n  // print the light levels (to see what's going on):\n  Serial.print(red);\n  Serial.print(' ');\n  Serial.print(green);\n  Serial.print(' ');\n  Serial.println(blue);\n\n  // write the light levels to the LED.\n  // note that the green value is always 0:\n  Esplora.writeRGB(red, green, blue);\n\n  // add a delay to keep the LED from flickering:\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "light",
        "delay",
        "led"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);\n\n  // print an intial message\n  Serial.println(\"To calibrate the light sensor, press and hold Switch 1\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// if switch 1 is pressed, go to the calibration function again:\n  if (Esplora.readButton(1) == LOW) {\n    calibrate();\n  }\n  // read the sensor into a variable:\n  int light = Esplora.readLightSensor();\n\n  // map the light level to a brightness level for the LED\n  // using the calibration min and max:\n  int brightness = map(light, lightMin, lightMax, 0, 255);\n  // limit the brightness to a range from 0 to 255:\n  brightness = constrain(brightness, 0, 255);\n  // write the brightness to the blue LED.\n  Esplora.writeBlue(brightness);\n\n  // if the calibration's been done, show the sensor and brightness\n  // levels in the serial monitor:\n  if (calibrated == true) {\n    // print the light sensor levels and the LED levels (to see what's going on):\n    Serial.print(\"light sensor level: \");\n    Serial.print(light);\n    Serial.print(\" blue brightness: \");\n    Serial.println(brightness);\n  }\n  // add a delay to keep the LED from flickering:\n  delay(10);"
        },
        {
          "name": "calibrate",
          "parameters": "",
          "body": "// tell the user what do to using the serial monitor:\n  Serial.println(\"While holding switch 1, shine a light on the light sensor, then cover it.\");\n\n  // calibrate while switch 1 is pressed:\n  while (Esplora.readButton(1) == LOW) {\n    // read the sensor value:\n    int light  = Esplora.readLightSensor();\n\n    // record the maximum sensor value:\n    if (light > lightMax) {\n      lightMax = light;\n    }\n\n    // record the minimum sensor value:\n    if (light < lightMin) {\n      lightMin = light;\n    }\n    // note that you're calibrated, for future reference:\n    calibrated = true;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "tone"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": ""
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the button labeled SWITCH_DOWN. If it's low,\n  // then play a note:\n  if (Esplora.readButton(SWITCH_DOWN) == LOW) {\n    int slider = Esplora.readSlider();\n\n    // use map() to map the slider's range to the\n    // range of notes you have:\n    byte thisNote = map(slider, 0, 1023, 0, 13);\n    // play the note corresponding to the slider's position:\n    Esplora.tone(note[thisNote]);\n  }\n  else {\n    // if the button isn't pressed, turn the note off:\n    Esplora.noTone();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);     // initialize serial communication"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the slider and three of the buttons\n  int slider = Esplora.readSlider();\n  int resetButton = Esplora.readButton(SWITCH_1);\n  int serveButton = Esplora.readButton(SWITCH_3);\n  int switchPlayerButton = Esplora.readButton(SWITCH_4);\n\n  Serial.print(slider);                // print the slider value\n  Serial.print(\",\");                   // add a comma\n  Serial.print(resetButton);           // print the reset button value\n  Serial.print(\",\");                   // add another comma\n  Serial.print(serveButton);           // print the serve button value\n  Serial.print(\",\");                   // add another comma\n  Serial.println(switchPlayerButton);  // print the last button with a newline\n  delay(10);                           // delay before sending the next set"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "tone",
        "rgb",
        "led",
        "sensors"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "while (!Serial); // needed for Leonardo-based board like Esplora\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (Serial.available())\n    parseCommand();"
        },
        {
          "name": "parseCommand",
          "parameters": "",
          "body": "char cmd = Serial.read();\n  switch (cmd) {\n    case 'D':\n      dumpInputs();\n      break;\n    case 'R':\n      setRed();\n      break;\n    case 'G':\n      setGreen();\n      break;\n    case 'B':\n      setBlue();\n      break;\n    case 'T':\n      setTone();\n      break;\n  }"
        },
        {
          "name": "dumpInputs",
          "parameters": "",
          "body": "Serial.print(Esplora.readButton(SWITCH_1));\n  Serial.print(',');\n  Serial.print(Esplora.readButton(SWITCH_2));\n  Serial.print(',');\n  Serial.print(Esplora.readButton(SWITCH_3));\n  Serial.print(',');\n  Serial.print(Esplora.readButton(SWITCH_4));\n  Serial.print(',');\n  Serial.print(Esplora.readSlider());\n  Serial.print(',');\n  Serial.print(Esplora.readLightSensor());\n  Serial.print(',');\n  Serial.print(Esplora.readTemperature(DEGREES_C));\n  Serial.print(',');\n  Serial.print(Esplora.readMicrophone());\n  Serial.print(',');\n  Serial.print(Esplora.readJoystickSwitch());\n  Serial.print(',');\n  Serial.print(Esplora.readJoystickX());\n  Serial.print(',');\n  Serial.print(Esplora.readJoystickY());\n  Serial.print(',');\n  Serial.print(Esplora.readAccelerometer(X_AXIS));\n  Serial.print(',');\n  Serial.print(Esplora.readAccelerometer(Y_AXIS));\n  Serial.print(',');\n  Serial.print(Esplora.readAccelerometer(Z_AXIS));\n  Serial.println();"
        },
        {
          "name": "setRed",
          "parameters": "",
          "body": "Esplora.writeRed(Serial.parseInt());"
        },
        {
          "name": "setGreen",
          "parameters": "",
          "body": "Esplora.writeGreen(Serial.parseInt());"
        },
        {
          "name": "setBlue",
          "parameters": "",
          "body": "Esplora.writeBlue(Serial.parseInt());"
        },
        {
          "name": "setTone",
          "parameters": "",
          "body": "Esplora.tone(Serial.parseInt());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "led"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// initialize the serial communication:\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the sensor into a variable:\n  int loudness = Esplora.readMicrophone();\n\n  // map the sound level to a brightness level for the LED:\n  int brightness = map(loudness, 0, 1023, 0, 255);\n  // write the brightness to the green LED:\n  Esplora.writeGreen(brightness);\n\n\n  // print the microphone levels and the LED levels (to see what's going on):\n  Serial.print(\"sound level: \");\n  Serial.print(loudness);\n  Serial.print(\" Green brightness: \");\n  Serial.println(brightness);\n  // add a delay to keep the LED from flickering:\n  delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "millis",
        "delay",
        "led",
        "rgb"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Keyboard.begin();\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*\n   * note: we don't use Arduino's delay() here, because we can't\n   * normally do anything while delaying. Our own version lets us\n   * check for button presses often enough to not miss any event.\n   */\n  activeDelay(50);\n\n  /*\n   * the justActivated variable may be set to true in the\n   * checkSwitchPress() function. Here we check its status to\n   * print the table headers and configure what's needed to.\n   */\n  if (justActivated == true) {\n    justActivated = false; // do this just once\n    printHeaders();\n    // do next sampling ASAP\n    nextSampleAt = startedAt = millis();\n  }\n\n  if (active == true) {\n    if (nextSampleAt < millis()) {\n      // it's time to sample!\n      int slider = Esplora.readSlider();\n      // the row below maps the slider position to a range between\n      // 10 and 290 seconds.\n      int sampleInterval = map(slider, 0, 1023, 10, 290);\n      nextSampleAt = millis() + sampleInterval * 1000;\n\n      logAndPrint();\n    }\n\n    // let the RGB led blink green once per second, for 200ms.\n    unsigned int ms = millis() % 1000;\n    if (ms < 200)\n      Esplora.writeGreen(50);\n    else\n      Esplora.writeGreen(0);\n\n    Esplora.writeBlue(0);\n  }\n  else\n    // while not active, keep a reassuring blue color coming\n    // from the Esplora...\n    Esplora.writeBlue(20);"
        },
        {
          "name": "printHeaders",
          "parameters": "",
          "body": "Keyboard.print(\"Time\");\n  Keyboard.write(KEY_TAB);\n  activeDelay(300); // Some spreadsheets are slow, e.g. Google\n  // Drive that wants to save every edit.\n  Keyboard.print(\"Accel X\");\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(\"Accel Y\");\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(\"Accel Z\");\n  Keyboard.println();\n  activeDelay(300);"
        },
        {
          "name": "logAndPrint",
          "parameters": "",
          "body": "// do all the samplings at once, because keystrokes have delays\n  unsigned long timeSecs = (millis() - startedAt) / 1000;\n  int xAxis = Esplora.readAccelerometer(X_AXIS);\n  int yAxis = Esplora.readAccelerometer(Y_AXIS);\n  int zAxis = Esplora.readAccelerometer(Z_AXIS);\n\n  Esplora.writeRed(100);\n\n  Keyboard.print(timeSecs);\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(xAxis);\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(yAxis);\n  Keyboard.write(KEY_TAB);\n  activeDelay(300);\n  Keyboard.print(zAxis);\n  Keyboard.println();\n  activeDelay(300);\n  Keyboard.write(KEY_HOME);\n\n  Esplora.writeRed(0);"
        },
        {
          "name": "activeDelay",
          "parameters": "unsigned long amount",
          "body": "unsigned long at = millis() + amount;\n  while (millis() < at) {\n    checkSwitchPress();\n  }"
        },
        {
          "name": "checkSwitchPress",
          "parameters": "",
          "body": "boolean startBtn = Esplora.readButton(SWITCH_DOWN);\n\n  if (startBtn != lastStartBtn) {\n    if (startBtn == HIGH) { // button released\n      active = !active;\n      if (active)\n        justActivated = true;\n    }\n\n    lastStartBtn = startBtn;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "temperature",
        "delay"
      ],
      "libraries": [
        "Esplora.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);      // initialize serial communications with your computer"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// read the temperature sensor in Celsius, then Fahrenheit:\n  int celsius = Esplora.readTemperature(DEGREES_C);\n  int fahrenheit = Esplora.readTemperature(DEGREES_F);\n\n  // print the results:\n  Serial.print(\"Temperature is: \");\n  Serial.print(celsius);\n  Serial.print(\" degrees Celsius, or \");\n  Serial.print(fahrenheit);\n  Serial.println(\" degrees Fahrenheit.\");\n  Serial.println(\"     Fahrenheit = (9/5 * Celsius) + 32\");\n\n  // wait a second before reading again:\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http"
      ],
      "libraries": [
        "EthernetInterface.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    while (!Serial)\n        ;\n\n    Serial.println(\"Ethernet example for H7 + PMC\");\n\n    // Bring up the ethernet interface\n    net.connect();\n\n    // Show the network address\n    SocketAddress addr;\n    net.get_ip_address(&addr);\n    Serial.print(\"IP address: \");\n    Serial.println(addr.get_ip_address() ? addr.get_ip_address() : \"None\");\n\n    // Open a socket on the network interface, and create a TCP connection to mbed.org\n    TCPSocket socket;\n    socket.open(&net);\n\n    net.gethostbyname(\"ifconfig.io\", &addr);\n    addr.set_port(80);\n    socket.connect(addr);\n\n    String request;\n    request += \"GET / HTTP/1.1\\r\\n\";\n    request += \"Host: ifconfig.io\\r\\n\";\n    request += \"User-Agent: curl/7.64.1\\r\\n\";\n    request += \"Accept: */*\\r\\n\";\n    request += \"Connection: close\\r\\n\";\n    request += \"\\r\\n\";\n\n    auto scount = socket.send(request.c_str(), request.length());\n    Serial.print(\"Sent \");\n    Serial.print(scount);\n    Serial.println(\" bytes: \");\n    Serial.print(request);\n\n    // Receive a simple HTTP response\n    const size_t rlen { 64 };\n    char rbuffer[rlen + 1] {};\n    size_t rcount;\n    size_t rec { 0 };\n    String response;\n\n    while ((rec = socket.recv(rbuffer, rlen)) > 0) {\n        rcount += rec;\n        response += rbuffer;\n        memset(rbuffer, 0, rlen);\n    }\n    Serial.print(\"Received \");\n    Serial.print(rcount);\n    Serial.println(\" bytes: \");\n    Serial.println(response);\n\n    const String clTag = \"Content-Length: \";\n    auto clIndex = response.indexOf(clTag);\n    clIndex += clTag.length();\n    auto cl = response.substring(clIndex, clIndex + 2);\n    const String bodyTag = \"\\r\\n\\r\\n\";\n    auto bodyIndex = response.indexOf(bodyTag);\n    if (bodyIndex != -1) {\n        bodyIndex += bodyTag.length();\n        auto body = response.substring(bodyIndex, bodyIndex + cl.toInt());\n        Serial.print(\"My public IPv4 Address is: \");\n        Serial.println(body);\n    }\n\n\n    // Close the socket to return its memory and bring down the network interface\n    socket.close();\n\n    // Bring down the ethernet interface\n    net.disconnect();\n    Serial.println(\"Done\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "millis",
        "delay",
        "digitalwrite",
        "sd"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "digitalread",
        "millis",
        "delay",
        "digitalwrite",
        "sd",
        "timer",
        "interrupt"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "parameters": "",
          "body": "//isButtonPressed = !digitalRead(BUTTON_PIN); // Invert state, since button is \"Active LOW\"\n\n  if ( !isButtonPressed && !digitalRead(BUTTON_PIN)) // You can write any condition to trigger e-mail sending\n  {\n    isButtonPressed = true;\n    count++;\n    Serial.println(\"Button pressed\");\n  }"
        },
        {
          "name": "processButton",
          "parameters": "",
          "body": "// *** WARNING: You are limited to send ONLY ONE E-MAIL PER 5 SECONDS! ***\n  // Let's send an e-mail when you press the button\n  // connected to digital pin BUTTON_PIN (2) on your Arduino\n  static String body;\n\n  if (isButtonPressed) // You can write any condition to trigger e-mail sending\n  {\n    body = String(\"You pushed the button \") + count + \" times.\";\n\n    // This can be seen in the Serial Monitor\n    Serial.println(body);\n\n    Blynk.email(\"your_email@gmail.com\", \"Subject: Button Logger\", body);\n\n    isButtonPressed = false;\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_Email on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }\n\n  // Attach pin BUTTON_PIN (2) interrupt to our handler\n  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), emailOnButtonPress, FALLING /*CHANGE*/);\n\n  timer.setInterval(30000L, processButton);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "delay",
        "millis"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_RP2040 on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n\n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n  #if USE_LOCAL_SERVER\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #else\n    //Blynk.begin(auth);\n    // You can also specify server:\n    Blynk.begin(auth, BlynkServer, BLYNK_SERVER_HARDWARE_PORT);\n  #endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(BlynkServer);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "delay",
        "millis"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_SAMD on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "delay",
        "millis"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_SAM_DUE on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "delay",
        "millis"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart W5500_Blynk_Teensy on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#else\n  //Blynk.begin(auth);\n  // You can also specify server:\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "spi",
        "delay",
        "millis"
      ],
      "libraries": [
        "SPI.h",
        "defines.h",
        "Credentials.h",
        "dynamicParams.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_Blynk_nRF52 on \")); Serial.print(BOARD_NAME);\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n\n  BLYNK_LOG4(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n  \n  Ethernet.init (USE_THIS_SS_PIN);\n  \n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_SERVER_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n    #if USE_BLYNK_WM    \n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.print(Blynk.getToken());\n    Serial.print(F(\", IP = \"));   \n#else\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(server);\n    Serial.print(F(\", port = \"));\n    Serial.println(BLYNK_SERVER_HARDWARE_PORT);\n    Serial.print(F(\"Token = \"));\n    Serial.print(auth);\n    Serial.print(F(\", IP = \"));       \n#endif    \n    Serial.println(Ethernet.localIP());\n  }"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "displayCredentialsInLoop",
          "parameters": "",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "blynk",
        "https",
        "auth",
        "token",
        "dht11",
        "temperature",
        "humidity",
        "spi",
        "wifi",
        "millis",
        "delay",
        "digitalwrite",
        "sd",
        "timer"
      ],
      "libraries": [
        "defines.h",
        "Credentials.h",
        "dynamicParams.h",
        "SPI.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "parameters": "",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));\n    }\n    else\n    {\n      Blynk.virtualWrite(V17, F(\"NAN\"));\n      Blynk.virtualWrite(V18, F(\"NAN\"));\n    }\n  }\n\n  // Blynk Timer uses millis() and is still working even if WiFi/Blynk not connected\n  Serial.print(F(\"R\"));"
        },
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart EthernetENC_WM_Config on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  dht.begin();\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());\n  }\n\n  timer.setInterval(60000L, readAndSendData);"
        },
        {
          "name": "displayCredentials",
          "parameters": "",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;\n      }\n\n      if ( i == (NUM_MENU_ITEMS - 1) )\n      {\n        displayedCredentials = true;\n        displayCredentials();\n      }\n    }\n  }\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "spi",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "ArduinoRS485.h",
        "ArduinoModbus.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n  // start the Ethernet connection and the server:\n  Ethernet.begin(mac, ip);\n\n  // Check for Ethernet hardware present\n  if (Ethernet.hardwareStatus() == EthernetNoHardware) {\n    Serial.println(\"Ethernet shield was not found.  Sorry, can't run without hardware. :(\");\n    while (true) {\n      delay(1); // do nothing, no point running without Ethernet hardware\n    }\n  }\n  if (Ethernet.linkStatus() == LinkOFF) {\n    Serial.println(\"Ethernet cable is not connected.\");\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (!modbusTCPClient.connected()) {\n    // client not connected, start the Modbus TCP client\n    Serial.println(\"Attempting to connect to Modbus TCP server\");\n    \n    if (!modbusTCPClient.begin(server, 502)) {\n      Serial.println(\"Modbus TCP Client failed to connect!\");\n    } else {\n      Serial.println(\"Modbus TCP Client connected\");\n    }\n  } else {\n    // client connected\n\n    // write the value of 0x01, to the coil at address 0x00\n    if (!modbusTCPClient.coilWrite(0x00, 0x01)) {\n      Serial.print(\"Failed to write coil! \");\n      Serial.println(modbusTCPClient.lastError());\n    }\n\n    // wait for 1 second\n    delay(1000);\n\n    // write the value of 0x00, to the coil at address 0x00\n    if (!modbusTCPClient.coilWrite(0x00, 0x00)) {\n      Serial.print(\"Failed to write coil! \");\n      Serial.println(modbusTCPClient.lastError());\n    }\n\n    // wait for 1 second\n    delay(1000);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "spi",
        "delay",
        "digitalwrite",
        "led",
        "clients"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "ArduinoRS485.h",
        "ArduinoModbus.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n  Serial.println(\"Ethernet Modbus TCP Example\");\n\n  // start the Ethernet connection and the server:\n  Ethernet.begin(mac, ip);\n\n  // Check for Ethernet hardware present\n  if (Ethernet.hardwareStatus() == EthernetNoHardware) {\n    Serial.println(\"Ethernet shield was not found.  Sorry, can't run without hardware. :(\");\n    while (true) {\n      delay(1); // do nothing, no point running without Ethernet hardware\n    }\n  }\n  if (Ethernet.linkStatus() == LinkOFF) {\n    Serial.println(\"Ethernet cable is not connected.\");\n  }\n\n  // start the server\n  ethServer.begin();\n  \n  // start the Modbus TCP server\n  if (!modbusTCPServer.begin()) {\n    Serial.println(\"Failed to start Modbus TCP Server!\");\n    while (1);\n  }\n\n  // configure the LED\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n\n  // configure a single coil at address 0x00\n  modbusTCPServer.configureCoils(0x00, 1);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// listen for incoming clients\n  EthernetClient client = ethServer.available();\n  \n  if (client) {\n    // a new client connected\n    Serial.println(\"new client\");\n\n    // let the Modbus TCP accept the connection \n    modbusTCPServer.accept(client);\n\n    while (client.connected()) {\n      // poll for Modbus TCP requests, while client connected\n      modbusTCPServer.poll();\n\n      // update the LED\n      updateLED();\n    }\n\n    Serial.println(\"client disconnected\");\n  }"
        },
        {
          "name": "updateLED",
          "parameters": "",
          "body": "// read the current value of the coil\n  int coilValue = modbusTCPServer.coilRead(0x00);\n\n  if (coilValue) {\n    // coil value set, turn LED on\n    digitalWrite(ledPin, HIGH);\n  } else {\n    // coild value clear, turn LED off\n    digitalWrite(ledPin, LOW);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "password",
        "ssl",
        "token",
        "payload",
        "dns",
        "millis"
      ],
      "libraries": [
        "Arduino.h",
        "Ethernet.h",
        "FirebaseClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n    ssl_client.setClient(&eth);\n\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    printResult(aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "spi",
        "millis",
        "digitalwrite",
        "delay",
        "html"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "createPage",
          "parameters": "String &pageInput",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>EthernetWebServer_BigData-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\\\n</style>\\\n</head>\\\n<body>\\\n<h2>EthernetWebServer_W5500!</h2>\\\n<h3>running on %s</h3>\\\n<p>Uptime: %d d %02d:%02d:%02d</p>\\\n</body>\\\n</html>\", BOARD_NAME, BOARD_NAME, day, hr % 24, min % 60, sec % 60);\n\n  pageInput = temp;"
        },
        {
          "name": "handleRoot",
          "parameters": "",
          "body": "//out.reserve(STRING_SIZE);\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < (100 * MULTIPLY_FACTOR); lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"WiFiWebServer_BigData_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";\n  }\n\n  out += \"</table></body></html>\\r\\n\";\n\n  Serial.print(F(\"String Len = \")); Serial.println(out.length());\n\n  server.send(200, F(\"text/html\"), out);"
        },
        {
          "name": "handleNotFound",
          "parameters": "",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";\n  }\n\n  server.send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "initEthernet",
          "parameters": "",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if ( defined( ESP32 )  && USE_ETHERNET_GENERIC )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    SerialDebug.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware\n    }\n  }\n\n  if (Ethernet.linkStatus() == LinkOFF)\n  {\n    SerialDebug.println(\"Not connected Ethernet cable\");\n  }\n\n#endif\n\n  SerialDebug.print(F(\"Using mac index = \"));\n  SerialDebug.println(index);\n\n  SerialDebug.print(F(\"Connected! IP address: \"));\n  SerialDebug.println(Ethernet.localIP());"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "out.reserve(STRING_SIZE);\n\n  //Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart EthernetWebServer_BigData on \"));\n  SerialDebug.print(BOARD_NAME);\n  SerialDebug.print(F(\" with \"));\n  SerialDebug.println(SHIELD_TYPE);\n  SerialDebug.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));\n  });\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "key",
        "digitalwrite",
        "digitalread",
        "delay",
        "led"
      ],
      "libraries": [
        "Keypad.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    pinMode(ledPin, OUTPUT);              // Sets the digital pin as output.\n    digitalWrite(ledPin, HIGH);           // Turn the LED on.\n    ledPin_state = digitalRead(ledPin);   // Store initial LED state. HIGH when LED is on.\n    keypad.addEventListener(keypadEvent); // Add an event listener for this keypad"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "char key = keypad.getKey();\n\n    if (key) {\n        Serial.println(key);\n    }\n    if (blink){\n        digitalWrite(ledPin,!digitalRead(ledPin));    // Change the ledPin from Hi2Lo or Lo2Hi.\n        delay(100);\n    }"
        },
        {
          "name": "keypadEvent",
          "parameters": "KeypadEvent key",
          "body": "switch (keypad.getState()){\n    case PRESSED:\n        if (key == '#') {\n            digitalWrite(ledPin,!digitalRead(ledPin));\n            ledPin_state = digitalRead(ledPin);        // Remember LED state, lit or unlit.\n        }\n        break;\n\n    case RELEASED:\n        if (key == '*') {\n            digitalWrite(ledPin,ledPin_state);    // Restore LED state from before it started blinking.\n            blink = false;\n        }\n        break;\n\n    case HOLD:\n        if (key == '*') {\n            blink = true;    // Blink the LED when holding the * key.\n        }\n        break;\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "current",
        "digitalread",
        "millis"
      ],
      "libraries": [
        "CircularBuffer.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n    pinMode(BUTTON_PIN, INPUT_PULLUP);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (digitalRead(BUTTON_PIN) == LOW) {\n        // stores button click time in the buffer, appending after the last element\n        buffer.push(millis());\n    }\n    // checks if the buffer has reached maximum capacity to avoid overwrites\n    if (buffer.isFull()) {\n        Serial.println(\"Printing button clicks\");\n        // repeats until the buffer is empty\n        while (!buffer.isEmpty()) {\n            // prints current buffer size\n            Serial.print(buffer.size());\n            Serial.print(\": \");\n            // retrieves the last added button click and removes the event\n            // this outputs the events starting from the most recent\n            // switching from pop() to shift() the events would be printed\n            // in chronological order, starting from the least recent\n            Serial.println(buffer.pop());\n        }\n    }\n    // prints the buffer contents every minute \n    if (millis() - last > INTERVAL) {\n        last = millis();\n        Serial.print(\"Buffer contains \");\n        Serial.print(buffer.size());\n        Serial.print(\" elements: \");\n        // iterates over the events in chronological order\n        // you can replace byte with decltype(buffer)::index_t\n        for (byte i = 0; i < buffer.size(); i++) {\n            // retrieves the i-th element from the buffer without removing it\n            Serial.print(buffer[i]);\n            Serial.print(\" \");\n        }\n        Serial.println();\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "voltage",
        "delay",
        "led",
        "interrupt",
        "sensors"
      ],
      "libraries": [
        "SigFox.h",
        "ArduinoLowPower.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "if (debug == true) {\n\n    // We are using Serial1 instead of Serial because we are going into standby\n    // and the USB port could get confused during wakeup. To read the debug prints,\n    // connect pins 13-14 (TX-RX) to a 3.3 V USB-to-serial converter\n\n    Serial1.begin(115200);\n    while (!Serial1) {}\n  }\n\n  if (!SigFox.begin()) {\n    //something is really wrong, try rebooting\n    reboot();\n  }\n\n  //Send module to standby until we need to send a message\n  SigFox.end();\n\n  if (debug == true) {\n    // Enable debug prints and LED indication if we are testing\n    SigFox.debug();\n  }\n\n  // attach pin 0 and 1 to a switch and enable the interrupt on voltage falling event\n  pinMode(0, INPUT_PULLUP);\n  LowPower.attachInterruptWakeup(0, alarmEvent1, FALLING);\n\n  pinMode(1, INPUT_PULLUP);\n  LowPower.attachInterruptWakeup(1, alarmEvent2, FALLING);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// Sleep until an event is recognized\n  LowPower.sleep();\n\n  // if we get here it means that an event was received\n\n  SigFox.begin();\n\n  if (debug == true) {\n    Serial1.println(\"Alarm event on sensor \" + String(alarm_source));\n  }\n  delay(100);\n\n  // 3 bytes (ALM) + 8 bytes (ID as String) + 1 byte (source) < 12 bytes\n  String to_be_sent = \"ALM\" + SigFox.ID() +  String(alarm_source);\n\n  SigFox.beginPacket();\n  SigFox.print(to_be_sent);\n  int ret = SigFox.endPacket();\n\n  // shut down module, back to standby\n  SigFox.end();\n\n  if (debug == true) {\n    if (ret > 0) {\n      Serial1.println(\"No transmission\");\n    } else {\n      Serial1.println(\"Transmission ok\");\n    }\n\n    Serial1.println(SigFox.status(SIGFOX));\n    Serial1.println(SigFox.status(ATMEL));\n\n    // Loop forever if we are testing for a single event\n    while (1) {};\n  }"
        },
        {
          "name": "alarmEvent1",
          "parameters": "",
          "body": "alarm_source = 1;"
        },
        {
          "name": "alarmEvent2",
          "parameters": "",
          "body": "alarm_source = 2;"
        },
        {
          "name": "reboot",
          "parameters": "",
          "body": "NVIC_SystemReset();\n  while (1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "buffer",
        "callback",
        "light",
        "current",
        "spi",
        "analogread",
        "millis",
        "digitalwrite",
        "delay",
        "yield",
        "led",
        "sd",
        "rtc",
        "sensors"
      ],
      "libraries": [
        "SdFat.h",
        "FreeStack.h",
        "ExFatLogger.h",
        "RTClib.h",
        "MinimumSerial.h"
      ],
      "functions": [
        {
          "name": "logRecord",
          "parameters": "data_t* data, uint16_t overrun",
          "body": "if (overrun) {\n    // Add one since this record has no adc data. Could add overrun field.\n    overrun++;\n    data->adc[0] = 0X8000 | overrun;\n  } else {\n    for (size_t i = 0; i < ADC_COUNT; i++) {\n      data->adc[i] = analogRead(i);\n    }\n  }"
        },
        {
          "name": "printRecord",
          "parameters": "Print* pr, data_t* data",
          "body": "static uint32_t nr = 0;\n  if (!data) {\n    pr->print(F(\"LOG_INTERVAL_USEC,\"));\n    pr->println(LOG_INTERVAL_USEC);\n    pr->print(F(\"rec#\"));\n    for (size_t i = 0; i < ADC_COUNT; i++) {\n      pr->print(F(\",adc\"));\n      pr->print(i);\n    }\n    pr->println();\n    nr = 0;\n    return;\n  }\n  if (data->adc[0] & 0X8000) {\n    uint16_t n = data->adc[0] & 0X7FFF;\n    nr += n;\n    pr->print(F(\"-1,\"));\n    pr->print(n);\n    pr->println(F(\",overuns\"));\n  } else {\n    pr->print(nr++);\n    for (size_t i = 0; i < ADC_COUNT; i++) {\n      pr->write(',');\n      pr->print(data->adc[i]);\n    }\n    pr->println();\n  }"
        },
        {
          "name": "dateTime",
          "parameters": "uint16_t* date, uint16_t* time, uint8_t* ms10",
          "body": "DateTime now = rtc.now();\n\n  // Return date using FS_DATE macro to format fields.\n  *date = FS_DATE(now.year(), now.month(), now.day());\n\n  // Return time using FS_TIME macro to format fields.\n  *time = FS_TIME(now.hour(), now.minute(), now.second());\n\n  // Return low time bits in units of 10 ms.\n  *ms10 = now.second() & 1 ? 100 : 0;"
        },
        {
          "name": "binaryToCsv",
          "parameters": "",
          "body": "uint8_t lastPct = 0;\n  uint32_t t0 = millis();\n  data_t binData[FIFO_DIM];\n\n  if (!binFile.seekSet(512)) {\n\t  error(\"binFile.seek failed\");\n  }\n  uint32_t tPct = millis();\n  printRecord(&csvFile, nullptr);\n  while (!Serial.available() && binFile.available()) {\n    int nb = binFile.read(binData, sizeof(binData));\n    if (nb <= 0 ) {\n      error(\"read binFile failed\");\n    }\n    size_t nr = nb/sizeof(data_t);\n    for (size_t i = 0; i < nr; i++) {\n      printRecord(&csvFile, &binData[i]);\n    }\n\n    if ((millis() - tPct) > 1000) {\n      uint8_t pct = binFile.curPosition()/(binFile.fileSize()/100);\n      if (pct != lastPct) {\n        tPct = millis();\n        lastPct = pct;\n        Serial.print(pct, DEC);\n        Serial.println('%');\n        csvFile.sync();\n      }\n    }\n    if (Serial.available()) {\n      break;\n    }\n  }\n  csvFile.close();\n  Serial.print(F(\"Done: \"));\n  Serial.print(0.001*(millis() - t0));\n  Serial.println(F(\" Seconds\"));"
        },
        {
          "name": "clearSerialInput",
          "parameters": "",
          "body": "uint32_t m = micros();\n  do {\n    if (Serial.read() >= 0) {\n      m = micros();\n    }\n  } while (micros() - m < 10000);"
        },
        {
          "name": "createBinFile",
          "parameters": "",
          "body": "binFile.close();\n  while (sd.exists(binName)) {\n    char* p = strchr(binName, '.');\n    if (!p) {\n      error(\"no dot in filename\");\n    }\n    while (true) {\n      p--;\n      if (p < binName || *p < '0' || *p > '9') {\n        error(\"Can't create file name\");\n      }\n      if (p[0] != '9') {\n        p[0]++;\n        break;\n      }\n      p[0] = '0';\n    }\n  }\n  if (!binFile.open(binName, O_RDWR | O_CREAT)) {\n    error(\"open binName failed\");\n  }\n  Serial.println(binName);\n  if (!binFile.preAllocate(PREALLOCATE_SIZE)) {\n    error(\"preAllocate failed\");\n  }\n\n  Serial.print(F(\"preAllocated: \"));\n  Serial.print(PREALLOCATE_SIZE_MiB);\n  Serial.println(F(\" MiB\"));"
        },
        {
          "name": "createCsvFile",
          "parameters": "",
          "body": "char csvName[FILE_NAME_DIM];\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return false;\n  }\n\n  // Create a new csvFile.\n  binFile.getName(csvName, sizeof(csvName));\n  char* dot = strchr(csvName, '.');\n  if (!dot) {\n    error(\"no dot in filename\");\n  }\n  strcpy(dot + 1, \"csv\");\n  if (!csvFile.open(csvName, O_WRONLY | O_CREAT | O_TRUNC)) {\n    error(\"open csvFile failed\");\n  }\n  clearSerialInput();\n  Serial.print(F(\"Writing: \"));\n  Serial.print(csvName);\n  Serial.println(F(\" - type any character to stop\"));\n  return true;"
        },
        {
          "name": "logData",
          "parameters": "",
          "body": "int32_t delta;  // Jitter in log time.\n  int32_t maxDelta = 0;\n  uint32_t maxLogMicros = 0;\n  uint32_t maxWriteMicros = 0;\n  size_t maxFifoUse = 0;\n  size_t fifoCount = 0;\n  size_t fifoHead = 0;\n  size_t fifoTail = 0;\n  uint16_t overrun = 0;\n  uint16_t maxOverrun = 0;\n  uint32_t totalOverrun = 0;\n  uint32_t fifoBuf[128*FIFO_SIZE_SECTORS];\n  data_t* fifoData = (data_t*)fifoBuf;\n\n  // Write dummy sector to start multi-block write.\n  dbgAssert(sizeof(fifoBuf) >= 512);\n  memset(fifoBuf, 0, sizeof(fifoBuf));\n  if (binFile.write(fifoBuf, 512) != 512) {\n    error(\"write first sector failed\");\n  }\n  clearSerialInput();\n  Serial.println(F(\"Type any character to stop\"));\n\n  // Wait until SD is not busy.\n  while (sd.card()->isBusy()) {}\n\n  // Start time for log file.\n  uint32_t m = millis();\n\n  // Time to log next record.\n  uint32_t logTime = micros();\n  while (true) {\n    // Time for next data record.\n    logTime += LOG_INTERVAL_USEC;\n\n    // Wait until time to log data.\n    delta = micros() - logTime;\n    if (delta > 0) {\n      Serial.print(F(\"delta: \"));\n      Serial.println(delta);\n      error(\"Rate too fast\");\n    }\n    while (delta < 0) {\n      delta = micros() - logTime;\n    }\n\n    if (fifoCount < FIFO_DIM) {\n      uint32_t m = micros();\n      logRecord(fifoData + fifoHead, overrun);\n      m = micros() - m;\n      if (m > maxLogMicros) {\n        maxLogMicros = m;\n      }\n      fifoHead = fifoHead < (FIFO_DIM - 1) ? fifoHead + 1 : 0;\n      fifoCount++;\n      if (overrun) {\n        if (overrun > maxOverrun) {\n          maxOverrun = overrun;\n        }\n        overrun = 0;\n      }\n    } else {\n      totalOverrun++;\n      overrun++;\n      if (overrun > 0XFFF) {\n        error(\"too many overruns\");\n      }\n      if (ERROR_LED_PIN >= 0) {\n        digitalWrite(ERROR_LED_PIN, HIGH);\n      }\n    }\n    // Save max jitter.\n    if (delta > maxDelta) {\n      maxDelta = delta;\n    }\n    // Write data if SD is not busy.\n    if (!sd.card()->isBusy()) {\n      size_t nw = fifoHead > fifoTail ? fifoCount : FIFO_DIM - fifoTail;\n      // Limit write time by not writing more than 512 bytes.\n      const size_t MAX_WRITE = 512/sizeof(data_t);\n      if (nw > MAX_WRITE) nw = MAX_WRITE;\n      size_t nb = nw*sizeof(data_t);\n      uint32_t usec = micros();\n      if (nb != binFile.write(fifoData + fifoTail, nb)) {\n        error(\"write binFile failed\");\n      }\n      usec = micros() - usec;\n      if (usec > maxWriteMicros) {\n        maxWriteMicros = usec;\n      }\n      fifoTail = (fifoTail + nw) < FIFO_DIM ? fifoTail + nw : 0;\n      if (fifoCount > maxFifoUse) {\n        maxFifoUse = fifoCount;\n      }\n      fifoCount -= nw;\n      if (Serial.available()) {\n        break;\n      }\n    }\n  }\n  Serial.print(F(\"\\nLog time: \"));\n  Serial.print(0.001*(millis() - m));\n  Serial.println(F(\" Seconds\"));\n  binFile.truncate();\n  binFile.sync();\n  Serial.print((\"File size: \"));\n  // Warning cast used for print since fileSize is uint64_t.\n  Serial.print((uint32_t)binFile.fileSize());\n  Serial.println(F(\" bytes\"));\n  Serial.print(F(\"totalOverrun: \"));\n  Serial.println(totalOverrun);\n  Serial.print(F(\"FIFO_DIM: \"));\n  Serial.println(FIFO_DIM);\n  Serial.print(F(\"maxFifoUse: \"));\n  Serial.println(maxFifoUse);\n  Serial.print(F(\"maxLogMicros: \"));\n  Serial.println(maxLogMicros);\n  Serial.print(F(\"maxWriteMicros: \"));\n  Serial.println(maxWriteMicros);\n  Serial.print(F(\"Log interval: \"));\n  Serial.print(LOG_INTERVAL_USEC);\n  Serial.print(F(\" micros\\nmaxDelta: \"));\n  Serial.print(maxDelta);\n  Serial.println(F(\" micros\"));"
        },
        {
          "name": "openBinFile",
          "parameters": "",
          "body": "char name[FILE_NAME_DIM];\n  clearSerialInput();\n  Serial.println(F(\"Enter file name\"));\n  if (!serialReadLine(name, sizeof(name))) {\n    return;\n  }\n  if (!sd.exists(name)) {\n    Serial.println(name);\n    Serial.println(F(\"File does not exist\"));\n    return;\n  }\n  binFile.close();\n  if (!binFile.open(name, O_RDONLY)) {\n    Serial.println(name);\n    Serial.println(F(\"open failed\"));\n    return;\n  }\n  Serial.println(F(\"File opened\"));"
        },
        {
          "name": "printData",
          "parameters": "",
          "body": "if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;\n  }\n  // Skip first dummy sector.\n  if (!binFile.seekSet(512)) {\n    error(\"seek failed\");\n  }\n  clearSerialInput();\n  Serial.println(F(\"type any character to stop\\n\"));\n  delay(1000);\n  printRecord(&Serial, nullptr);\n  while (binFile.available() && !Serial.available()) {\n    data_t record;\n    if (binFile.read(&record, sizeof(data_t)) != sizeof(data_t)) {\n      error(\"read binFile failed\");\n    }\n    printRecord(&Serial, &record);\n  }"
        },
        {
          "name": "printUnusedStack",
          "parameters": "",
          "body": "#if HAS_UNUSED_STACK\n  Serial.print(F(\"\\nUnused stack: \"));\n  Serial.println(UnusedStack());\n#endif  // HAS_UNUSED_STACK"
        },
        {
          "name": "serialReadLine",
          "parameters": "char* str, size_t size",
          "body": "size_t n = 0;\n  while(!Serial.available()) {\n    yield();\n  }\n  while (true) {\n    int c = Serial.read();\n    if (c < ' ') break;\n    str[n++] = c;\n    if (n >= size) {\n      Serial.println(F(\"input too long\"));\n      return false;\n    }\n    uint32_t m = millis();\n    while (!Serial.available() && (millis() - m) < 100){}\n    if (!Serial.available()) break;\n  }\n  str[n] = 0;\n  return true;"
        },
        {
          "name": "testSensor",
          "parameters": "",
          "body": "const uint32_t interval = 200000;\n  int32_t diff;\n  data_t data;\n  clearSerialInput();\n  Serial.println(F(\"\\nTesting - type any character to stop\\n\"));\n  delay(1000);\n  printRecord(&Serial, nullptr);\n  uint32_t m = micros();\n  while (!Serial.available()) {\n    m += interval;\n    do {\n      diff = m - micros();\n    } while (diff > 0);\n    logRecord(&data, 0);\n    printRecord(&Serial, &data);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);\n    digitalWrite(ERROR_LED_PIN, HIGH);\n  }\n  Serial.begin(9600);\n\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();\n  }\n  delay(1000);\n  Serial.println(F(\"Type any character to begin\"));\n  while (!Serial.available()) {\n    yield();\n  }\n  FillStack();\n#if !ENABLE_DEDICATED_SPI\n  Serial.println(F(\n    \"\\nFor best performance edit SdFatConfig.h\\n\"\n    \"and set ENABLE_DEDICATED_SPI nonzero\"));\n#endif  // !ENABLE_DEDICATED_SPI\n\n  Serial.print(FIFO_DIM);\n  Serial.println(F(\" FIFO entries will be used.\"));\n\n  // Initialize SD.\n  if (!sd.begin(SD_CONFIG)) {\n    sd.initErrorHalt(&Serial);\n  }\n#if USE_RTC\n  if (!rtc.begin()) {\n    error(\"rtc.begin failed\");\n  }\n  if (!rtc.isrunning()) {\n    // Set RTC to sketch compile date & time.\n    // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));\n    error(\"RTC is NOT running!\");\n  }\n  // Set callback\n  FsDateTime::setCallback(dateTime);\n#endif  // USE_RTC"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "printUnusedStack();\n  // Read any Serial data.\n  clearSerialInput();\n\n  if (ERROR_LED_PIN >= 0) {\n    digitalWrite(ERROR_LED_PIN, LOW);\n  }\n  Serial.println();\n  Serial.println(F(\"type: \"));\n  Serial.println(F(\"b - open existing bin file\"));\n  Serial.println(F(\"c - convert file to csv\"));\n  Serial.println(F(\"l - list files\"));\n  Serial.println(F(\"p - print data to Serial\"));\n  Serial.println(F(\"r - record data\"));\n  Serial.println(F(\"t - test without logging\"));\n  while(!Serial.available()) {\n    yield();\n  }\n  char c = tolower(Serial.read());\n  Serial.println();\n\n  if (c == 'b') {\n    openBinFile();\n  } else if (c == 'c') {\n    if (createCsvFile()) {\n      binaryToCsv();\n    }\n  } else if (c == 'l') {\n    Serial.println(F(\"ls:\"));\n    sd.ls(&Serial, LS_DATE | LS_SIZE);\n  } else if (c == 'p') {\n    printData();\n  } else if (c == 'r') {\n    createBinFile();\n    logData();\n  } else if (c == 't') {\n    testSensor();\n  } else {\n    Serial.println(F(\"Invalid entry\"));\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "asyncwebserver",
        "websocket",
        "https",
        "key",
        "buffer",
        "power",
        "current",
        "spi",
        "wifi",
        "esp.restart",
        "digitalwrite",
        "delay",
        "littlefs",
        "interrupt",
        "html",
        "clients"
      ],
      "libraries": [
        "Arduino.h",
        "FS.h",
        "LittleFS.h",
        "SPI.h",
        "Esp.h",
        "SparkFun_WebServer_ESP32_W5500.h",
        "ESPAsyncWebServer.h",
        "Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "//Set up the W5500 Chip Select\n  pinMode(pin_W5500_CS, OUTPUT);\n  digitalWrite(pin_W5500_CS, HIGH);\n\n  //Set up the W5500 interrupt pin\n  pinMode(pin_W5500_INT, INPUT_PULLUP);\n  \n  //Check if the board has a power enable pin. Configure it if required\n  if (pin_POWER_CONTROL >= 0)\n  {\n    pinMode(pin_POWER_CONTROL, OUTPUT);\n    digitalWrite(pin_POWER_CONTROL, HIGH);\n  }\n  \n  delay(1000);\n\n  Serial.begin(115200);\n  Serial.println(\"SparkFun WebServer ESP32 W5500 Example\");\n\n  //Start LittleFS\n  if(!LittleFS.begin(true))\n  {\n    Serial.println(\"LittleFS mount failed\");\n    return;\n  }\n\n  //Empty the serial buffer\n  while (Serial.available())\n    Serial.read();\n\n  Serial.println();\n  Serial.println(\"Press any key (send any character) to change modes\");\n  Serial.println();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n  //If useArduinoEthernet.txt does not exist in LittleFS, use ESP32_W5500 and ESPAsyncWebServer\n\n  if (!LittleFS.exists(\"/useArduinoEthernet.txt\"))\n  {\n  \n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // ESP32_W5500\n\n    //Create useArduinoEthernet.txt so the code will use Arduino Ethernet next time\n    File file = LittleFS.open(\"/useArduinoEthernet.txt\", FILE_WRITE);\n    file.close();\n\n    Serial.println(\"Using ESP32_W5500:\");\n    Serial.println();\n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Configure the W5500\n  \n    //Must be called before ETH.begin()\n    ESP32_W5500_onEvent();\n  \n    //Start the ethernet connection\n    ETH.begin( pin_POCI, pin_PICO, pin_SCK, pin_W5500_CS, pin_W5500_INT ); //Use default clock speed and SPI Host\n  \n    ESP32_W5500_waitForConnect();\n  \n    // Print your local IP address:\n    Serial.print(\"My IP address: \");\n    Serial.println(ETH.localIP());\n    Serial.println();\n  \n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Configure the Web Server\n  \n    Serial.println(\"Starting Web Server\");\n\n    asyncWebServer = new AsyncWebServer(80); //Instantiate the web server. Use port 80\n    asyncWebSocket = new AsyncWebSocket(\"/ws\"); //Instantiate the web socket\n\n    asyncWebSocket->onEvent(onWsEvent);\n    asyncWebServer->addHandler(asyncWebSocket);\n\n    static char webPage[100];\n    snprintf(webPage, sizeof(webPage), \"<!DOCTYPE html>\\r\\n<html>\\r\\n<h2>I am an ESP32_W5500 web page</h2>\\r\\n<br>\\r\\n</html>\\r\\n\");\n    \n    asyncWebServer->on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request){\n      request->send(200, \"text/html\", webPage);\n      });\n    \n    asyncWebServer->onNotFound(notFound);\n\n    asyncWebServer->begin();\n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Loop until the user presses a key\n\n    while(1)\n    {\n      if (Serial.available()) //Check if the user has pressed a key\n      {\n        ETH.end(); //End ESP32_W5500. This is _really_ important!\n        \n        ESP.restart(); //Restart the ESP32\n      }\n      delay(1);\n    }\n  }\n\n  else\n  {\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Ethernet\n\n    //Delete useArduinoEthernet.txt so the code will use ESP32_W5500 next time\n    LittleFS.remove(\"/useArduinoEthernet.txt\");\n\n    Serial.println(\"Using Arduino Ethernet:\");\n    Serial.println();\n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Configure the W5500\n\n    Ethernet.init(pin_W5500_CS); //Set the chip select pin\n\n    //Get MAC address\n    uint8_t ethernetMACAddress[6];\n    esp_read_mac(ethernetMACAddress, ESP_MAC_WIFI_STA);\n    ethernetMACAddress[5] += 3; //Convert WiFi MAC address to Ethernet MAC (add 3)\n    \n    Ethernet.begin(ethernetMACAddress); //Use default mac and IP\n\n    if (Ethernet.hardwareStatus() == EthernetNoHardware)\n    {\n      Serial.println(\"W5500 was not found.  Sorry, can't run without hardware. :(\");\n      while (true)\n      {\n        delay(1); // do nothing, no point running without Ethernet hardware\n      }\n    }\n\n    // Print your local IP address:\n    Serial.print(\"My IP address: \");\n    Serial.println(Ethernet.localIP());\n    Serial.println();  \n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Configure the Web Server\n  \n    Serial.println(\"Starting Web Server\");\n\n    ethernetServer = new EthernetServer(80); //Instantiate the web server. Use port 80\n\n    ethernetServer->begin(); //Start the server\n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // Loop until the user presses a key\n\n    while(1)\n    {\n      // listen for incoming clients\n      EthernetClient client = ethernetServer->available();\n      if (client) {\n        Serial.println(\"New client conected\");\n        // an http request ends with a blank line\n        bool currentLineIsBlank = true;\n        while (client.connected())\n        {\n          if (client.available())\n          {\n            char c = client.read();\n            // if you've gotten to the end of the line (received a newline\n            // character) and the line is blank, the http request has ended,\n            // so you can send a reply\n            if (c == '\\n' && currentLineIsBlank) {\n              // send a standard http response header\n              client.println(\"HTTP/1.1 200 OK\");\n              client.println(\"Content-Type: text/html\");\n              client.println(\"Connection: close\");  // the connection will be closed after completion of the response\n              client.println(\"Refresh: 5\");  // refresh the page automatically every 5 sec\n              client.println();\n              client.println(\"<!DOCTYPE HTML>\");\n              client.println(\"<html>\");\n              client.println(\"<h2>I am an Ethernet web page</h2>\");\n              client.println(\"</html>\");\n              break;\n            }\n            \n            if (c == '\\n')\n            {\n              // you're starting a new line\n              currentLineIsBlank = true;\n            }\n            else if (c != '\\r')\n            {\n              // you've gotten a character on the current line\n              currentLineIsBlank = false;\n            }\n          }\n        }\n        // give the web browser time to receive the data\n        delay(1);\n        // close the connection:\n        client.stop();\n        Serial.println(\"Client disconnected\");\n      }\n\n      if (Serial.available()) //Check if the user has pressed a key\n      {\n        ESP.restart(); //Restart the ESP32\n      }\n    }\n  }"
        },
        {
          "name": "notFound",
          "parameters": "AsyncWebServerRequest *request",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "onWsEvent",
          "parameters": "AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len",
          "body": "if (type == WS_EVT_CONNECT) {\n    Serial.println(\"Websocket client connected\");\n  }\n  else if (type == WS_EVT_DISCONNECT) {\n    Serial.println(\"Websocket client disconnected\");\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "power",
        "i2c",
        "led"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "debug.begin(9600);\n  debug.println(\"MAX30105 Basic Readings Example\");\n\n  // Initialize sensor\n  if (particleSensor.begin() == false)\n  {\n    debug.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n\n  particleSensor.setup(); //Configure sensor. Use 6.4mA for LED drive"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "debug.print(\" R[\");\n  debug.print(particleSensor.getRed());\n  debug.print(\"] IR[\");\n  debug.print(particleSensor.getIR());\n  debug.print(\"] G[\");\n  debug.print(particleSensor.getGreen());\n  debug.print(\"]\");\n\n  debug.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "power",
        "i2c",
        "millis",
        "led"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Serial.println(\"MAX30105 Presence Sensing Example\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n\n  //Setup to sense up to 18 inches, max LED brightness\n  byte ledBrightness = 0xFF; //Options: 0=Off to 255=50mA\n  byte sampleAverage = 4; //Options: 1, 2, 4, 8, 16, 32\n  byte ledMode = 2; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green\n  int sampleRate = 400; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200\n  int pulseWidth = 411; //Options: 69, 118, 215, 411\n  int adcRange = 2048; //Options: 2048, 4096, 8192, 16384\n\n  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings\n\n  particleSensor.setPulseAmplitudeRed(0); //Turn off Red LED\n  particleSensor.setPulseAmplitudeGreen(0); //Turn off Green LED\n\n  //Take an average of IR readings at power up\n  unblockedValue = 0;\n  for (byte x = 0 ; x < 32 ; x++)\n  {\n    unblockedValue += particleSensor.getIR(); //Read the IR value\n  }\n  unblockedValue /= 32;\n\n  startTime = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "samplesTaken++;\n\n  Serial.print(\"IR[\");\n  Serial.print(particleSensor.getIR());\n  Serial.print(\"] Hz[\");\n  Serial.print((float)samplesTaken / ((millis() - startTime) / 1000.0), 2);\n  Serial.print(\"]\");\n\n  long currentDelta = particleSensor.getIR() - unblockedValue;\n\n  Serial.print(\" delta[\");\n  Serial.print(currentDelta);\n  Serial.print(\"]\");\n\n  if (currentDelta > (long)100)\n  {\n    Serial.print(\" Something is there!\");\n  }\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "temperature",
        "power",
        "i2c",
        "led",
        "interrupt"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n\n  //The LEDs are very low power and won't affect the temp reading much but\n  //you may want to turn off the LEDs to avoid any local heating\n  particleSensor.setup(0); //Configure sensor. Turn off LEDs\n  //particleSensor.setup(); //Configure sensor. Use 25mA for LED drive\n\n  particleSensor.enableDIETEMPRDY(); //Enable the temp ready interrupt. This is required."
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float temperature = particleSensor.readTemperature();\n\n  Serial.print(\"temperatureC=\");\n  Serial.print(temperature, 4);\n\n  float temperatureF = particleSensor.readTemperatureF(); //Because I am a bad global citizen\n\n  Serial.print(\" temperatureF=\");\n  Serial.print(temperatureF, 4);\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "pressure",
        "power",
        "i2c"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n\n  //Setup to sense a nice looking saw tooth on the plotter\n  byte ledBrightness = 0x1F; //Options: 0=Off to 255=50mA\n  byte sampleAverage = 8; //Options: 1, 2, 4, 8, 16, 32\n  byte ledMode = 3; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green\n  int sampleRate = 100; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200\n  int pulseWidth = 411; //Options: 69, 118, 215, 411\n  int adcRange = 4096; //Options: 2048, 4096, 8192, 16384\n\n  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings\n\n  //Arduino plotter auto-scales annoyingly. To get around this, pre-populate\n  //the plotter with 500 of an average reading from the sensor\n\n  //Take an average of IR readings at power up\n  const byte avgAmount = 64;\n  long baseValue = 0;\n  for (byte x = 0 ; x < avgAmount ; x++)\n  {\n    baseValue += particleSensor.getIR(); //Read the IR value\n  }\n  baseValue /= avgAmount;\n\n  //Pre-populate the plotter so that the Y scale is close to IR values\n  for (int x = 0 ; x < 500 ; x++)\n    Serial.println(baseValue);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(particleSensor.getIR()); //Send raw data to plotter"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "pressure",
        "power",
        "i2c",
        "millis",
        "led"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h",
        "heartRate.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n  Serial.println(\"Place your index finger on the sensor with steady pressure.\");\n\n  particleSensor.setup(); //Configure sensor with default settings\n  particleSensor.setPulseAmplitudeRed(0x0A); //Turn Red LED to low to indicate sensor is running\n  particleSensor.setPulseAmplitudeGreen(0); //Turn off Green LED"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "long irValue = particleSensor.getIR();\n\n  if (checkForBeat(irValue) == true)\n  {\n    //We sensed a beat!\n    long delta = millis() - lastBeat;\n    lastBeat = millis();\n\n    beatsPerMinute = 60 / (delta / 1000.0);\n\n    if (beatsPerMinute < 255 && beatsPerMinute > 20)\n    {\n      rates[rateSpot++] = (byte)beatsPerMinute; //Store this reading in the array\n      rateSpot %= RATE_SIZE; //Wrap variable\n\n      //Take average of readings\n      beatAvg = 0;\n      for (byte x = 0 ; x < RATE_SIZE ; x++)\n        beatAvg += rates[x];\n      beatAvg /= RATE_SIZE;\n    }\n  }\n\n  Serial.print(\"IR=\");\n  Serial.print(irValue);\n  Serial.print(\", BPM=\");\n  Serial.print(beatsPerMinute);\n  Serial.print(\", Avg BPM=\");\n  Serial.print(beatAvg);\n\n  if (irValue < 50000)\n    Serial.print(\" No finger?\");\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "power",
        "i2c",
        "millis",
        "led"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n\n  //Setup to sense up to 18 inches, max LED brightness\n  byte ledBrightness = 0xFF; //Options: 0=Off to 255=50mA\n  byte sampleAverage = 4; //Options: 1, 2, 4, 8, 16, 32\n  byte ledMode = 2; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green\n  int sampleRate = 400; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200\n  int pulseWidth = 411; //Options: 69, 118, 215, 411\n  int adcRange = 2048; //Options: 2048, 4096, 8192, 16384\n\n  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings\n//  particleSensor.setup(); //Configure sensor. Use 6.4mA for LED drive\n\n  startTime = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "particleSensor.check(); //Check the sensor, read up to 3 samples\n\n  while (particleSensor.available()) //do we have new data?\n  {\n    samplesTaken++;\n\n    Serial.print(\" R[\");\n    Serial.print(particleSensor.getFIFORed());\n    Serial.print(\"] IR[\");\n    Serial.print(particleSensor.getFIFOIR());\n    Serial.print(\"] G[\");\n    Serial.print(particleSensor.getFIFOGreen());\n    Serial.print(\"] Hz[\");\n    Serial.print((float)samplesTaken / ((millis() - startTime) / 1000.0), 2);\n    Serial.print(\"]\");\n\n    Serial.println();\n\n    particleSensor.nextSample(); //We're finished with this sample so move to next sample\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "buffer",
        "power",
        "i2c",
        "millis",
        "digitalread",
        "interrupt"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(interruptPin, INPUT);\n\n  Serial.begin(115200);\n  Serial.println(\"Initializing...\");\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n\n  //Let's configure the sensor to run fast so we can over-run the buffer and cause an interrupt\n  byte ledBrightness = 0x7F; //Options: 0=Off to 255=50mA\n  byte sampleAverage = 1; //Options: 1, 2, 4, 8, 16, 32\n  byte ledMode = 3; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green\n  int sampleRate = 400; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200\n  int pulseWidth = 69; //Options: 69, 118, 215, 411\n  int adcRange = 4096; //Options: 2048, 4096, 8192, 16384\n\n  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings\n\n  particleSensor.enableAFULL(); //Enable the almost full interrupt (default is 32 samples)\n  \n  particleSensor.setFIFOAlmostFull(3); //Set almost full int to fire at 29 samples\n\n  startTime = millis();"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "particleSensor.check(); //Check the sensor, read up to 3 samples\n\n  while (particleSensor.available()) //do we have new data?\n  {\n    samplesTaken++;\n\n    Serial.print(\" R[\");\n    Serial.print(particleSensor.getRed());\n    Serial.print(\"] IR[\");\n    Serial.print(particleSensor.getIR());\n    Serial.print(\"] G[\");\n    Serial.print(particleSensor.getGreen());\n    Serial.print(\"] Hz[\");\n    Serial.print((float)samplesTaken / ((millis() - startTime) / 1000.0), 2);\n    Serial.print(\"]\");\n\n    if (digitalRead(interruptPin) == LOW) //Hardware way of reading interrupts\n    {\n      Serial.print(\" INT!\");\n    }\n\n    byte flags = particleSensor.getINT1(); //Software way of reading interrupts\n    if (flags)\n    {\n      Serial.print(\" I[\");\n      Serial.print(flags, BIN);\n      Serial.print(\"]\");\n    }\n\n    Serial.println();\n\n    particleSensor.nextSample(); //We're finished with this sample so move to next sample\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "key",
        "buffer",
        "pressure",
        "power",
        "i2c",
        "uart",
        "digitalwrite",
        "digitalread",
        "led",
        "pwm"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h",
        "spo2_algorithm.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200); // initialize serial communication at 115200 bits per second:\n\n  pinMode(pulseLED, OUTPUT);\n  pinMode(readLED, OUTPUT);\n\n  // Initialize sensor\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(F(\"MAX30105 was not found. Please check wiring/power.\"));\n    while (1);\n  }\n\n  Serial.println(F(\"Attach sensor to finger with rubber band. Press any key to start conversion\"));\n  while (Serial.available() == 0) ; //wait until user presses a key\n  Serial.read();\n\n  byte ledBrightness = 60; //Options: 0=Off to 255=50mA\n  byte sampleAverage = 4; //Options: 1, 2, 4, 8, 16, 32\n  byte ledMode = 2; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green\n  byte sampleRate = 100; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200\n  int pulseWidth = 411; //Options: 69, 118, 215, 411\n  int adcRange = 4096; //Options: 2048, 4096, 8192, 16384\n\n  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "bufferLength = 100; //buffer length of 100 stores 4 seconds of samples running at 25sps\n\n  //read the first 100 samples, and determine the signal range\n  for (byte i = 0 ; i < bufferLength ; i++)\n  {\n    while (particleSensor.available() == false) //do we have new data?\n      particleSensor.check(); //Check the sensor for new data\n\n    redBuffer[i] = particleSensor.getRed();\n    irBuffer[i] = particleSensor.getIR();\n    particleSensor.nextSample(); //We're finished with this sample so move to next sample\n\n    Serial.print(F(\"red=\"));\n    Serial.print(redBuffer[i], DEC);\n    Serial.print(F(\", ir=\"));\n    Serial.println(irBuffer[i], DEC);\n  }\n\n  //calculate heart rate and SpO2 after first 100 samples (first 4 seconds of samples)\n  maxim_heart_rate_and_oxygen_saturation(irBuffer, bufferLength, redBuffer, &spo2, &validSPO2, &heartRate, &validHeartRate);\n\n  //Continuously taking samples from MAX30102.  Heart rate and SpO2 are calculated every 1 second\n  while (1)\n  {\n    //dumping the first 25 sets of samples in the memory and shift the last 75 sets of samples to the top\n    for (byte i = 25; i < 100; i++)\n    {\n      redBuffer[i - 25] = redBuffer[i];\n      irBuffer[i - 25] = irBuffer[i];\n    }\n\n    //take 25 sets of samples before calculating the heart rate.\n    for (byte i = 75; i < 100; i++)\n    {\n      while (particleSensor.available() == false) //do we have new data?\n        particleSensor.check(); //Check the sensor for new data\n\n      digitalWrite(readLED, !digitalRead(readLED)); //Blink onboard LED with every data read\n\n      redBuffer[i] = particleSensor.getRed();\n      irBuffer[i] = particleSensor.getIR();\n      particleSensor.nextSample(); //We're finished with this sample so move to next sample\n\n      //send samples and calculation result to terminal program through UART\n      Serial.print(F(\"red=\"));\n      Serial.print(redBuffer[i], DEC);\n      Serial.print(F(\", ir=\"));\n      Serial.print(irBuffer[i], DEC);\n\n      Serial.print(F(\", HR=\"));\n      Serial.print(heartRate, DEC);\n\n      Serial.print(F(\", HRvalid=\"));\n      Serial.print(validHeartRate, DEC);\n\n      Serial.print(F(\", SPO2=\"));\n      Serial.print(spo2, DEC);\n\n      Serial.print(F(\", SPO2Valid=\"));\n      Serial.println(validSPO2, DEC);\n    }\n\n    //After gathering 25 new samples recalculate HR and SP02\n    maxim_heart_rate_and_oxygen_saturation(irBuffer, bufferLength, redBuffer, &spo2, &validSPO2, &heartRate, &validHeartRate);\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "power",
        "i2c",
        "led"
      ],
      "libraries": [
        "Wire.h",
        "MAX30105.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial); //We must wait for Teensy to come online\n  Serial.println(\"Max sample rate example\");\n\n  // Initialize sensor\n  if (particleSensor.begin(Wire, I2C_SPEED_FAST) == false) //Use default I2C port, 400kHz speed\n  {\n    Serial.println(\"MAX30105 was not found. Please check wiring/power. \");\n    while (1);\n  }\n\n  //Setup to sense up to 18 inches, max LED brightness\n  byte ledBrightness = 0xFF; //Options: 0=Off to 255=50mA\n  byte sampleAverage = 1; //Options: 1, 2, 4, 8, 16, 32\n  byte ledMode = 1; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green\n  int sampleRate = 3200; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200\n  int pulseWidth = 69; //Options: 69, 118, 215, 411\n  int adcRange = 16384; //Options: 2048, 4096, 8192, 16384\n\n  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "byte samplesTaken = 0;\n  long startTime = micros();\n\n  while(samplesTaken < 10)\n  {\n    particleSensor.check(); //Check the sensor, read up to 3 samples\n    while (particleSensor.available()) //do we have new data?\n    {\n      samplesTaken++;\n      particleSensor.getFIFOIR();\n      particleSensor.nextSample(); //We're finished with this sample so move to next sample\n    }\n  }\n\n  long endTime = micros();\n\n  Serial.print(\"samples[\");\n  Serial.print(samplesTaken);\n\n  Serial.print(\"] Hz[\");\n  Serial.print((float)samplesTaken / ((endTime - startTime) / 1000000.0), 2);\n  Serial.print(\"]\");\n\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "password",
        "token",
        "database",
        "json",
        "wifi",
        "millis",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(user_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Database.resetApp();\n    app.getApp<RealtimeDatabase>(Database);\n\n    Database.url(DATABASE_URL);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);\n\n    Serial.print(\"Path existed... \");\n    bool status = Database.existed(aClient, \"/test/update/json\");\n\n    if (aClient.lastError().code() == 0)\n        Serial.println(status ? \"existed\" : \"not exist\");\n    else\n        printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Database.loop();"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "firebase",
        "api",
        "https",
        "key",
        "token",
        "database",
        "payload",
        "json",
        "wifi",
        "ntp",
        "delay",
        "millis",
        "client_email"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n    }\n    Serial.println();\n    Serial.print(\"Connected with IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.println();\n\n    Firebase.printf(\"Firebase Client v%s\\n\", FIREBASE_CLIENT_VERSION);\n\n    Serial.println(\"Initializing app...\");\n\n#if defined(ESP32) || defined(ESP8266) || defined(PICO_RP2040)\n    ssl_client.setInsecure();\n#if defined(ESP8266)\n    ssl_client.setBufferSizes(4096, 1024);\n#endif\n#endif\n\n    initializeApp(aClient, app, getAuth(sa_auth), aResult_no_callback);\n\n    authHandler();\n\n    // Binding the FirebaseApp for authentication handler.\n    // To unbind, use Databases.resetApp();\n    app.getApp<Firestore::Databases>(Databases);\n\n    // In case setting the external async result to the sync task (optional)\n    // To unset, use unsetAsyncResult().\n    aClient.setAsyncResult(aResult_no_callback);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "authHandler();\n\n    Databases.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        Serial.println(\"Export documents to the Storage bucket... \");\n\n        // This required the Owner and Editor permissions for the account.\n        // See how to add permission here, https://github.com/mobizt/Firebase-ESP-Client#iam-permission-and-api-enable\n\n        EximDocumentOptions exportOptions(\"\" /* Which collection ids to export. Unspecified means all collections. */, STORAGE_BUCKET_ID, \"test_path\" /* The path in the Firebase Storage bucket to store the data */);\n\n        String payload = Databases.exportDocuments(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), exportOptions);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());\n    }"
        },
        {
          "name": "authHandler",
          "parameters": "",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);\n    }"
        },
        {
          "name": "timeStatusCB",
          "parameters": "uint32_t &ts",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);\n        }\n    }\n    ts = time(nullptr);\n#elif __has_include(<WiFiNINA.h>) || __has_include(<WiFi101.h>)\n    ts = WiFi.getTime();\n#endif"
        },
        {
          "name": "printResult",
          "parameters": "AsyncResult &aResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());\n    }\n\n    if (aResult.isDebug())\n    {\n        Firebase.printf(\"Debug task: %s, msg: %s\\n\", aResult.uid().c_str(), aResult.debug().c_str());\n    }\n\n    if (aResult.isError())\n    {\n        Firebase.printf(\"Error task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.error().message().c_str(), aResult.error().code());\n    }\n\n    if (aResult.available())\n    {\n        Firebase.printf(\"task: %s, payload: %s\\n\", aResult.uid().c_str(), aResult.c_str());\n    }"
        },
        {
          "name": "printError",
          "parameters": "int code, const String &msg",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "power",
        "digitalwrite",
        "delay",
        "interrupt"
      ],
      "libraries": [
        "ArduinoLowPower.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  // Set pin 8 as INPUT_PULLUP to avoid spurious wakeup\n  pinMode(pin, INPUT_PULLUP);\n  // Attach a wakeup interrupt on pin 8, calling repetitionsIncrease when the device is woken up\n  LowPower.attachInterruptWakeup(pin, repetitionsIncrease, CHANGE);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "for (int i = 0; i < repetitions; i++) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(500);\n    digitalWrite(LED_BUILTIN, LOW);\n    delay(500);\n  }\n  // Triggers an infinite sleep (the device will be woken up only by the registered wakeup sources)\n  // The power consumption of the chip will drop consistently\n  LowPower.sleep();"
        },
        {
          "name": "repetitionsIncrease",
          "parameters": "",
          "body": "// This function will be called once on device wakeup\n  // You can do some little operations here (like changing variables which will be used in the loop)\n  // Remember to avoid calling delay() and long running functions since this functions executes in interrupt context\n  repetitions ++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Audio.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  \n  // Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(12);\n\n  // Configure the window algorithm to use\n  myFFT.windowFunction(AudioWindowHanning1024);\n  //myFFT.windowFunction(NULL);\n\n  // Create a synthetic sine wave, for testing\n  // To use this, edit the connections above\n  sinewave.amplitude(0.8);\n  sinewave.frequency(1034.007);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "float n;\n  int i;\n\n  if (myFFT.available()) {\n    // each time new FFT data is available\n    // print it all to the Arduino Serial Monitor\n    Serial.print(\"FFT: \");\n    for (i=0; i<40; i++) {\n      n = myFFT.read(i);\n      if (n >= 0.01) {\n        Serial.print(n);\n        Serial.print(\" \");\n      } else {\n        Serial.print(\"  -  \"); // don't print \"0.00\"\n      }\n    }\n    Serial.println();\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "power",
        "delay"
      ],
      "libraries": [
        "arduinoFFT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Build raw data */\n  double ratio = twoPi * signalFrequency / samplingFrequency; // Fraction of a complete cycle stored at each sample (in radians)\n  for (uint16_t i = 0; i < samples; i++)\n  {\n    vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n    //vReal[i] = uint8_t((amplitude * (sin(i * ratio) + 1.0)) / 2.0);/* Build data displaced on the Y axis to include only positive values*/\n    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows\n  }\n  /* Print the results of the simulated sampling according to time */\n  Serial.println(\"Data:\");\n  PrintVector(vReal, samples, SCL_TIME);\n  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);\t/* Weigh data */\n  Serial.println(\"Weighed data:\");\n  PrintVector(vReal, samples, SCL_TIME);\n  FFT.compute(FFTDirection::Forward); /* Compute FFT */\n  Serial.println(\"Computed Real values:\");\n  PrintVector(vReal, samples, SCL_INDEX);\n  Serial.println(\"Computed Imaginary values:\");\n  PrintVector(vImag, samples, SCL_INDEX);\n  FFT.complexToMagnitude(); /* Compute magnitudes */\n  Serial.println(\"Computed magnitudes:\");\n  PrintVector(vReal, (samples >> 1), SCL_FREQUENCY);\n  double x = FFT.majorPeak();\n  Serial.println(x, 6);\n  while(1); /* Run Once */\n  // delay(2000); /* Repeat after delay */"
        },
        {
          "name": "PrintVector",
          "parameters": "double *vData, uint16_t bufferSize, uint8_t scaleType",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\tbreak;\n    }\n    Serial.print(abscissa, 6);\n    if(scaleType==SCL_FREQUENCY)\n      Serial.print(\"Hz\");\n    Serial.print(\" \");\n    Serial.println(vData[i], 4);\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "millis",
        "delay"
      ],
      "libraries": [
        "arduinoFFT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Frequency\\tDetected\\ttakes (ms)\");\n  Serial.println(\"=======================================\\n\");\n  for(double frequency = startFrequency; frequency<=stopFrequency; frequency+=step_size)\n  {\n    /* Build raw data */\n    double ratio = twoPi * frequency / sampling; // Fraction of a complete cycle stored at each sample (in radians)\n    for (uint16_t i = 0; i < samples; i++)\n    {\n      vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n      vImag[i] = 0; //Reset the imaginary values vector for each new frequency\n    }\n    /*Serial.println(\"Data:\");\n    PrintVector(vReal, samples, SCL_TIME);*/\n    startTime=millis();\n    FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);\t/* Weigh data */\n    /*Serial.println(\"Weighed data:\");\n    PrintVector(vReal, samples, SCL_TIME);*/\n    FFT.compute(FFTDirection::Forward); /* Compute FFT */\n    /*Serial.println(\"Computed Real values:\");\n    PrintVector(vReal, samples, SCL_INDEX);\n    Serial.println(\"Computed Imaginary values:\");\n    PrintVector(vImag, samples, SCL_INDEX);*/\n    FFT.complexToMagnitude(); /* Compute magnitudes */\n    /*Serial.println(\"Computed magnitudes:\");\n    PrintVector(vReal, (samples >> 1), SCL_FREQUENCY);*/\n    double x = FFT.majorPeak();\n    Serial.print(frequency);\n    Serial.print(\": \\t\\t\");\n    Serial.print(x, 4);\n    Serial.print(\"\\t\\t\");\n    Serial.print(millis()-startTime);\n    Serial.println(\" ms\");\n    // delay(2000); /* Repeat after delay */\n  }\n  while(1); /* Run Once */"
        },
        {
          "name": "PrintVector",
          "parameters": "double *vData, uint16_t bufferSize, uint8_t scaleType",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / sampling);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * sampling) / samples);\n\tbreak;\n    }\n    Serial.print(abscissa, 6);\n    if(scaleType==SCL_FREQUENCY)\n      Serial.print(\"Hz\");\n    Serial.print(\" \");\n    Serial.println(vData[i], 4);\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "power",
        "analogread",
        "delay"
      ],
      "libraries": [
        "arduinoFFT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "sampling_period_us = round(1000000*(1.0/samplingFrequency));\r\n  Serial.begin(115200);\r\n  while(!Serial);\r\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*SAMPLING*/\r\n  microseconds = micros();\r\n  for(int i=0; i<samples; i++)\r\n  {\r\n      vReal[i] = analogRead(CHANNEL);\r\n      vImag[i] = 0;\r\n      while(micros() - microseconds < sampling_period_us){\r\n        //empty loop\r\n      }\r\n      microseconds += sampling_period_us;\r\n  }\r\n  /* Print the results of the sampling according to time */\r\n  Serial.println(\"Data:\");\r\n  PrintVector(vReal, samples, SCL_TIME);\r\n  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);\t/* Weigh data */\r\n  Serial.println(\"Weighed data:\");\r\n  PrintVector(vReal, samples, SCL_TIME);\r\n  FFT.compute(FFTDirection::Forward); /* Compute FFT */\r\n  Serial.println(\"Computed Real values:\");\r\n  PrintVector(vReal, samples, SCL_INDEX);\r\n  Serial.println(\"Computed Imaginary values:\");\r\n  PrintVector(vImag, samples, SCL_INDEX);\r\n  FFT.complexToMagnitude(); /* Compute magnitudes */\r\n  Serial.println(\"Computed magnitudes:\");\r\n  PrintVector(vReal, (samples >> 1), SCL_FREQUENCY);\r\n  double x = FFT.majorPeak();\r\n  Serial.println(x, 6); //Print out what frequency is the most dominant.\r\n  while(1); /* Run Once */\r\n  // delay(2000); /* Repeat after delay */"
        },
        {
          "name": "PrintVector",
          "parameters": "double *vData, uint16_t bufferSize, uint8_t scaleType",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\r\n  {\r\n    double abscissa;\r\n    /* Print abscissa value */\r\n    switch (scaleType)\r\n    {\r\n      case SCL_INDEX:\r\n        abscissa = (i * 1.0);\r\n\tbreak;\r\n      case SCL_TIME:\r\n        abscissa = ((i * 1.0) / samplingFrequency);\r\n\tbreak;\r\n      case SCL_FREQUENCY:\r\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\r\n\tbreak;\r\n    }\r\n    Serial.print(abscissa, 6);\r\n    if(scaleType==SCL_FREQUENCY)\r\n      Serial.print(\"Hz\");\r\n    Serial.print(\" \");\r\n    Serial.println(vData[i], 4);\r\n  }\r\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "power",
        "delay"
      ],
      "libraries": [
        "arduinoFFT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Build raw data */\n  double ratio = twoPi * signalFrequency / samplingFrequency; // Fraction of a complete cycle stored at each sample (in radians)\n  for (uint16_t i = 0; i < samples; i++)\n  {\n    vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n    //vReal[i] = uint8_t((amplitude * (sin(i * ratio) + 1.0)) / 2.0);/* Build data displaced on the Y axis to include only positive values*/\n    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows\n  }\n  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);\t/* Weigh data */\n  FFT.compute(FFTDirection::Forward); /* Compute FFT */\n  FFT.complexToMagnitude(); /* Compute magnitudes */\n  PrintVector(vReal, samples>>1, SCL_PLOT);\n  double x = FFT.majorPeak();\n  while(1); /* Run Once */\n  // delay(2000); /* Repeat after delay */"
        },
        {
          "name": "PrintVector",
          "parameters": "double *vData, uint16_t bufferSize, uint8_t scaleType",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\t      break;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n        break;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\t      break;\n    }\n    if(scaleType!=SCL_PLOT)\n    {\n      Serial.print(abscissa, 6);\n      if(scaleType==SCL_FREQUENCY)\n        Serial.print(\"Hz\");\n      Serial.print(\" \");\n    }\n    Serial.println(vData[i], 4);\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "power",
        "delay"
      ],
      "libraries": [
        "arduinoFFT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/* Build raw data */\n  double ratio = twoPi * signalFrequency / samplingFrequency; // Fraction of a complete cycle stored at each sample (in radians)\n  for (uint16_t i = 0; i < samples; i++)\n  {\n    vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n    //vReal[i] = uint8_t((amplitude * (sin(i * ratio) + 1.0)) / 2.0);/* Build data displaced on the Y axis to include only positive values*/\n    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows\n  }\n  /* Print the results of the simulated sampling according to time */\n  Serial.println(\"Data:\");\n  PrintVector(vReal, samples, SCL_TIME);\n  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);\t/* Weigh data */\n  Serial.println(\"Weighed data:\");\n  PrintVector(vReal, samples, SCL_TIME);\n  FFT.compute(FFTDirection::Forward); /* Compute FFT */\n  Serial.println(\"Computed Real values:\");\n  PrintVector(vReal, samples, SCL_INDEX);\n  Serial.println(\"Computed Imaginary values:\");\n  PrintVector(vImag, samples, SCL_INDEX);\n  FFT.complexToMagnitude(); /* Compute magnitudes */\n  Serial.println(\"Computed magnitudes:\");\n  PrintVector(vReal, (samples >> 1), SCL_FREQUENCY);\n  double x;\n  double v;\n  FFT.majorPeak(&x, &v);\n  Serial.print(x, 6);\n  Serial.print(\", \");\n  Serial.println(v, 6);\n  while(1); /* Run Once */\n  // delay(2000); /* Repeat after delay */"
        },
        {
          "name": "PrintVector",
          "parameters": "double *vData, uint16_t bufferSize, uint8_t scaleType",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    double abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\tbreak;\n    }\n    Serial.print(abscissa, 6);\n    if(scaleType==SCL_FREQUENCY)\n      Serial.print(\"Hz\");\n    Serial.print(\" \");\n    Serial.println(vData[i], 4);\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "buffer",
        "callback",
        "ble"
      ],
      "libraries": [
        "PDM.h",
        "Transform.h"
      ],
      "functions": [
        {
          "name": "zero",
          "parameters": "int32_t* v, uint16_t size",
          "body": "for (uint16_t i=0; i<size; i++) {\n        v[i] = 0;\n    }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n    while(!Serial);\n    Serial.println(\"Ready\");\n      // Configure the data receive callback\n    PDM.onReceive(onPDMdata);\n\n    // Optionally set the gain\n    // Defaults to 20 on the BLE Sense and 24 on the Portenta Vision Shield\n    // PDM.setGain(30);\n\n    PDM.setBufferSize(SAMPLES<<1);\n\n    // Initialize PDM with:\n    // - one channel (mono mode)\n    // - a 16 kHz sample rate for the Arduino Nano 33 BLE Sense\n    // - a 32 kHz or 64 kHz sample rate for the Arduino Portenta Vision Shield\n    if (!PDM.begin(channels, frequency)) {\n        Serial.println(\"Failed to start PDM!\");\n        while (1);\n    }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "if (samplesRead == SAMPLES) {\n\n    // do the FFT and extract the peak\n    zero(imag, SAMPLES);\n    IntSignal signal(real, imag, SAMPLES);\n    transformer.FFT(signal);\n    signal.getSignalModule(module);\n    float peak_position = getApproxMaxPosition(module, SAMPLES>>1);\n    float peak_frequency = (peak_position*frequency)/SAMPLES;\n\n    // print the peak value on Serial\n    Serial.println(peak_frequency);\n    \n    // Clear the read count\n    samplesRead = 0;\n  } else if (samplesAvailable) {\n    // append to real\n    int j=0;\n    for (int i=0; i<samplesAvailable; i++) {\n      real[samplesRead+i] = sampleBuffer[i];\n      j++;\n      if (samplesRead+j==SAMPLES){break;}\n    }\n    \n    samplesRead += j;\n    samplesAvailable = 0;\n  }"
        },
        {
          "name": "onPDMdata",
          "parameters": "",
          "body": "// Query the number of available bytes\n  int bytesAvailable = PDM.available();\n\n  // Read into the sample buffer only if we have enogh bytes (2*SAMPLES)\n  PDM.read(sampleBuffer, bytesAvailable);\n\n  // 16-bit, 2 bytes per sample\n  samplesAvailable = bytesAvailable / 2;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "power",
        "analogread",
        "delay"
      ],
      "libraries": [
        "arduinoFFT.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "sampling_period_us = round(1000000*(1.0/samplingFrequency));\n  Serial.begin(115200);\n  Serial.println(\"Ready\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "/*SAMPLING*/\n  microseconds = micros();\n  for(int i=0; i<samples; i++)\n  {\n      vReal[i] = analogRead(CHANNEL);\n      vImag[i] = 0;\n      while(micros() - microseconds < sampling_period_us){\n        //empty loop\n      }\n      microseconds += sampling_period_us;\n  }\n  /* Print the results of the sampling according to time */\n  Serial.println(\"Data:\");\n  PrintVector(vReal, samples, SCL_TIME);\n  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);\t/* Weigh data */\n  Serial.println(\"Weighed data:\");\n  PrintVector(vReal, samples, SCL_TIME);\n  FFT.compute(FFTDirection::Forward); /* Compute FFT */\n  Serial.println(\"Computed Real values:\");\n  PrintVector(vReal, samples, SCL_INDEX);\n  Serial.println(\"Computed Imaginary values:\");\n  PrintVector(vImag, samples, SCL_INDEX);\n  FFT.complexToMagnitude(); /* Compute magnitudes */\n  Serial.println(\"Computed magnitudes:\");\n  PrintVector(vReal, (samples >> 1), SCL_FREQUENCY);\n  float x = FFT.majorPeak();\n  Serial.println(x, 6); //Print out what frequency is the most dominant.\n  while(1); /* Run Once */\n  // delay(2000); /* Repeat after delay */"
        },
        {
          "name": "PrintVector",
          "parameters": "float *vData, uint16_t bufferSize, uint8_t scaleType",
          "body": "for (uint16_t i = 0; i < bufferSize; i++)\n  {\n    float abscissa;\n    /* Print abscissa value */\n    switch (scaleType)\n    {\n      case SCL_INDEX:\n        abscissa = (i * 1.0);\n\tbreak;\n      case SCL_TIME:\n        abscissa = ((i * 1.0) / samplingFrequency);\n\tbreak;\n      case SCL_FREQUENCY:\n        abscissa = ((i * 1.0 * samplingFrequency) / samples);\n\tbreak;\n    }\n    Serial.print(abscissa, 6);\n    if(scaleType==SCL_FREQUENCY)\n      Serial.print(\"Hz\");\n    Serial.print(\" \");\n    Serial.println(vData[i], 4);\n  }\n  Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "tone"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for FSK4\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize FSK4 client\n  // NOTE: FSK4 frequency shift will be rounded\n  //       to the nearest multiple of frequency step size.\n  //       The exact value depends on the module:\n  //         SX127x/RFM9x - 61 Hz\n  //         RF69 - 61 Hz\n  //         CC1101 - 397 Hz\n  //         SX126x - 1 Hz\n  //         nRF24 - 1000000 Hz\n  //         Si443x/RFM2x - 156 Hz\n  //         SX128x - 198 Hz\n  Serial.print(F(\"[FSK4] Initializing ... \"));\n  // low (\"space\") frequency:     434.0 MHz\n  // frequency shift:             270 Hz\n  // baud rate:                   100 baud\n  state = fsk4.begin(434.0, 270, 100);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // sometimes, it may be needed to set some manual corrections\n  // this can be done for tone frequencies,\n  // as well as tone lengths\n  /*\n    // set frequency shift offsets to -120, 60, 0 and 60 Hz and decrease tone length to 95%\n    int offsets[4] = { -120, -60, 0, 60 };\n    Serial.print(F(\"[FSK4] Setting corrections ... \"));\n    state = fsk4.setCorrection(offsets, 0.95);\n    if(state == RADIOLIB_ERR_NONE) {\n      Serial.println(F(\"success!\"));\n    } else {\n      Serial.print(F(\"failed, code \"));\n      Serial.println(state);\n      while (true) { delay(10); }\n    }\n  */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[FSK4] Sending FSK4 data packet ... \"));\n\n  // send out idle condition for 1000 ms\n  fsk4.idle();\n  delay(1000);\n\n  // FSK4Client supports binary write methods\n\n  // send some bytes as a preamble\n  for(int i = 0; i < 8; i++) {\n    fsk4.write(0x1B);\n  }\n\n  // now send the encoded packet\n  fsk4.write(horusPacket, horusPacketLen);\n\n  Serial.println(F(\"done!\"));\n\n  // wait for a second before transmitting again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "api",
        "https",
        "lora",
        "delay",
        "tone"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for RTTY\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // initialize FSK4 client\n  // NOTE: Unlike FSK FSK4, AFSK requires no rounding of\n  //       the frequency shift.\n  Serial.print(F(\"[FSK4] Initializing ... \"));\n  // lowest (\"space\") frequency:     400 Hz\n  // frequency shift:             270 Hz\n  // baud rate:                   100 baud\n  state = fsk4.begin(400, 270, 100);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));\n  } else {\n    Serial.print(F(\"failed, code \"));\n    Serial.println(state);\n    while (true) { delay(10); }\n  }\n\n  // sometimes, it may be needed to set some manual corrections\n  // this can be done for tone frequencies,\n  // as well as tone lengths\n  /*\n    // set audio tone offsets to -10, 20, 0 and 5 Hz and decrease tone length to 95%\n    int offsets[4] = { -10, 20, 0, 5 };\n    Serial.print(F(\"[FSK4] Setting corrections ... \"));\n    state = fsk4.setCorrection(offsets, 0.95);\n    if(state == RADIOLIB_ERR_NONE) {\n      Serial.println(F(\"success!\"));\n    } else {\n      Serial.print(F(\"failed, code \"));\n      Serial.println(state);\n      while (true) { delay(10); }\n    }\n  */"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.print(F(\"[FSK4] Sending FSK4 data packet ... \"));\n\n  // send out idle condition for 500 ms\n  fsk4.idle();\n  delay(1000);\n\n  // FSK4Client supports binary write methods\n\n  // send some bytes as a preamble\n  for(int i = 0; i < 8; i++) {\n    fsk4.write(0x1B);\n  }\n\n  // now send the encoded packet\n  fsk4.write(horusPacket, horusPacketLen);\n\n  Serial.println(F(\"done!\"));\n\n  // wait for a second before transmitting again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "webserver",
        "http",
        "https",
        "stream",
        "json",
        "callback",
        "current",
        "spi",
        "millis",
        "delay",
        "analogread",
        "littlefs",
        "spiffs",
        "html",
        "css",
        "javascript"
      ],
      "libraries": [
        "defines.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "parameters": "",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));        // H means alive\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;\n  }\n  else if (num++ % 10 == 0)\n  {\n    Serial.print(F(\" \"));\n  }"
        },
        {
          "name": "check_status",
          "parameters": "",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong current_millis;\n\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Print hearbeat every HEARTBEAT_INTERVAL (10) seconds.\n  if ((current_millis > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = current_millis + HEARTBEAT_INTERVAL;\n  }"
        },
        {
          "name": "formatBytes",
          "parameters": "size_t bytes",
          "body": "if (bytes < 1024)\n  {\n    return String(bytes) + \"B\";\n  }\n  else if (bytes < (1024 * 1024))\n  {\n    return String(bytes / 1024.0) + \"KB\";\n  }\n  else if (bytes < (1024 * 1024 * 1024))\n  {\n    return String(bytes / 1024.0 / 1024.0) + \"MB\";\n  }\n  else\n  {\n    return String(bytes / 1024.0 / 1024.0 / 1024.0) + \"GB\";\n  }"
        },
        {
          "name": "getContentType",
          "parameters": "const String& filename",
          "body": "if (server.hasArg(\"download\"))\n  {\n    return \"application/octet-stream\";\n  }\n  else if (filename.endsWith(\".htm\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".html\"))\n  {\n    return \"text/html\";\n  }\n  else if (filename.endsWith(\".css\"))\n  {\n    return \"text/css\";\n  }\n  else if (filename.endsWith(\".js\"))\n  {\n    return \"application/javascript\";\n  }\n  else if (filename.endsWith(\".png\"))\n  {\n    return \"image/png\";\n  }\n  else if (filename.endsWith(\".gif\"))\n  {\n    return \"image/gif\";\n  }\n  else if (filename.endsWith(\".jpg\"))\n  {\n    return \"image/jpeg\";\n  }\n  else if (filename.endsWith(\".ico\"))\n  {\n    return \"image/x-icon\";\n  }\n  else if (filename.endsWith(\".xml\"))\n  {\n    return \"text/xml\";\n  }\n  else if (filename.endsWith(\".pdf\"))\n  {\n    return \"application/x-pdf\";\n  }\n  else if (filename.endsWith(\".zip\"))\n  {\n    return \"application/x-zip\";\n  }\n  else if (filename.endsWith(\".gz\"))\n  {\n    return \"application/x-gzip\";\n  }\n\n  return \"text/plain\";"
        },
        {
          "name": "handleFileRead",
          "parameters": "String path",
          "body": "Serial.println(\"handleFileRead: \" + path);\n\n  if (path.endsWith(\"/\"))\n  {\n    path += \"index.htm\";\n  }\n\n  String contentType = getContentType(path);\n  String pathWithGz = path + \".gz\";\n\n  if (filesystem->exists(pathWithGz) || filesystem->exists(path))\n  {\n    if (filesystem->exists(pathWithGz))\n    {\n      path += \".gz\";\n    }\n\n    File file = filesystem->open(path, \"r\");\n    server.streamFile(file, contentType);\n    file.close();\n    return true;\n  }\n\n  return false;"
        },
        {
          "name": "handleFileDelete",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileDelete: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (!filesystem->exists(path))\n  {\n    return server.send(404, \"text/plain\", \"FileNotFound\");\n  }\n\n  filesystem->remove(path);\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileCreate",
          "parameters": "",
          "body": "if (server.args() == 0)\n  {\n    return server.send(500, \"text/plain\", \"BAD ARGS\");\n  }\n\n  String path = server.arg(0);\n  Serial.println(\"handleFileCreate: \" + path);\n\n  if (path == \"/\")\n  {\n    return server.send(500, \"text/plain\", \"BAD PATH\");\n  }\n\n  if (filesystem->exists(path))\n  {\n    return server.send(500, \"text/plain\", \"FILE EXISTS\");\n  }\n\n  File file = filesystem->open(path, \"w\");\n\n  if (file)\n  {\n    file.close();\n  }\n  else\n  {\n    return server.send(500, \"text/plain\", \"CREATE FAILED\");\n  }\n\n  server.send(200, \"text/plain\", \"\");\n  path.clear();"
        },
        {
          "name": "handleFileUpload",
          "parameters": "",
          "body": "if (server.uri() != \"/edit\")\n  {\n    return;\n  }\n\n  ethernetHTTPUpload& upload = server.upload();\n\n  if (upload.status == UPLOAD_FILE_START)\n  {\n    String filename = upload.filename;\n\n    if (!filename.startsWith(\"/\"))\n    {\n      filename = \"/\" + filename;\n    }\n\n    Serial.print(F(\"handleFileUpload Name: \"));\n    Serial.println(filename);\n    fsUploadFile = filesystem->open(filename, \"w\");\n    filename.clear();\n  }\n  else if (upload.status == UPLOAD_FILE_WRITE)\n  {\n    //Serial.print(F(\"handleFileUpload Data: \")); Serial.println(upload.currentSize);\n\n    if (fsUploadFile)\n    {\n      fsUploadFile.write(upload.buf, upload.currentSize);\n    }\n  }\n  else if (upload.status == UPLOAD_FILE_END)\n  {\n    if (fsUploadFile)\n    {\n      fsUploadFile.close();\n    }\n\n    Serial.print(F(\"handleFileUpload Size: \"));\n    Serial.println(upload.totalSize);\n  }"
        },
        {
          "name": "handleFileList",
          "parameters": "",
          "body": "if (!server.hasArg(\"dir\"))\n  {\n    server.send(500, \"text/plain\", \"BAD ARGS\");\n    return;\n  }\n\n  String path = server.arg(\"dir\");\n  Serial.println(\"handleFileList: \" + path);\n  Dir dir = filesystem->openDir(path);\n  path.clear();\n\n  String output = \"[\";\n\n  while (dir.next())\n  {\n    File entry = dir.openFile(\"r\");\n\n    if (output != \"[\")\n    {\n      output += ',';\n    }\n\n    bool isDir = false;\n    output += \"{\\\"type\\\":\\\"\";\n    output += (isDir) ? \"dir\" : \"file\";\n    output += \"\\\",\\\"name\\\":\\\"\";\n\n    if (entry.name()[0] == '/')\n    {\n      output += &(entry.name()[1]);\n    }\n    else\n    {\n      output += entry.name();\n    }\n\n    output += \"\\\"}\";\n    entry.close();\n  }\n\n  output += \"]\";\n  server.send(200, \"text/json\", output);"
        },
        {
          "name": "initFS",
          "parameters": "",
          "body": "// Initialize LittleFS/SPIFFS file-system\n  if (!FileFS.begin())\n  {\n    FileFS.format();\n\n    if (!FileFS.begin())\n    {\n      while (true)\n      {\n#if USE_LITTLEFS\n        Serial.println(F(\"LittleFS failed!. Please use SPIFFS.\"));\n#else\n        Serial.println(F(\"SPIFFS failed!. Please use LittleFS.\"));\n#endif\n        // Stay forever here as useless to go further\n        delay(5000);\n      }\n    }\n  }"
        },
        {
          "name": "listDir",
          "parameters": "",
          "body": "Dir dir = filesystem->openDir(\"/\");\n  Serial.println(F(\"Opening / directory\"));\n\n  while (dir.next())\n  {\n    String fileName = dir.fileName();\n    size_t fileSize = dir.fileSize();\n    Serial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());\n  }\n\n  Serial.println();"
        },
        {
          "name": "initWebserver",
          "parameters": "",
          "body": "//SERVER INIT\n  //list directory\n  server.on(\"/list\", HTTP_GET, handleFileList);\n\n  //load editor\n  server.on(\"/edit\", HTTP_GET, []()\n  {\n    if (!handleFileRead(\"/edit.htm\"))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //create file\n  server.on(\"/edit\", HTTP_PUT, handleFileCreate);\n\n  //delete file\n  server.on(\"/edit\", HTTP_DELETE, handleFileDelete);\n\n  //first callback is called after the request has ended with all parsed arguments\n  //second callback handles file uploads at that location\n  server.on(\"/edit\", HTTP_POST, []()\n  {\n    server.send(200, \"text/plain\", \"\");\n  }, handleFileUpload);\n\n  //called when the url is not defined here\n  //use it to load content from SPIFFS\n  server.onNotFound([]()\n  {\n    if (!handleFileRead(server.uri()))\n    {\n      server.send(404, \"text/plain\", \"FileNotFound\");\n    }\n  });\n\n  //get heap status, analog input value and all GPIO statuses in one json call\n  server.on(\"/all\", HTTP_GET, []()\n  {\n    String json('{');\n    json += \"\\\"heap\\\":\" + String(ESP.getFreeHeap());\n    json += \", \\\"analog\\\":\" + String(analogRead(A0));\n    json += \", \\\"gpio\\\":\" + String((uint32_t)(((GPI | GPO) & 0xFFFF) | ((GP16I & 0x01) << 16)));\n    json += \"}\";\n    server.send(200, \"text/json\", json);\n    json.clear();\n  });\n\n  // Web Page handlers\n  server.serveStatic(\"/\", FileFS, \"/page1.html\");\n  server.serveStatic(\"/page2\", FileFS, \"/page2.html\");\n  server.serveStatic(\"/page3\", FileFS, \"/page3.html\");\n\n  //server.serveStatic(\"/\", SPIFFS, \"/page1.html\");\n  //server.serveStatic(\"/page2\", SPIFFS, \"/page2.html\");\n  //server.serveStatic(\"/page3\", SPIFFS, \"/page3.html\");\n\n  // Other usage with various web site assets:\n  // server.serveStatic(\"/assets/css/test.css\", SPIFFS, \"/assets/css/test.css\"); // Style sheet\n  // server.serveStatic(\"/assets/js/test_script.js\", SPIFFS,\"/assets/js/test_script.js\"); // Javascript\n  // server.serveStatic(\"/assets/font/fonticons.ttf\", SPIFFS,\"/assets/font/fonticons.ttf\"); // font\n  // server.serveStatic(\"/assets/picture.png\", SPIFFS,\"/assets/picture.png\"); // Picture\n\n  server.begin();"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStarting FS_EthernetWebServer on \" + String(BOARD_TYPE));\n  Serial.print(\" using \");\n  Serial.println(FS_Name);\n  Serial.println(\"With \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n#if USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // Ethernet           0                 X            X            X            X        0\n  // Ethernet2          X                 X            X            X            X        0\n  // Ethernet3          X                 X            X            X            X        0\n  // EthernetLarge      X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  // Just info to know how to connect correctly\n  Serial.println(\"=========================\");\n  Serial.println(\"Currently Used SPI pinout:\");\n  Serial.print(\"MOSI:\");\n  Serial.println(MOSI);\n  Serial.print(\"MISO:\");\n  Serial.println(MISO);\n  Serial.print(\"SCK:\");\n  Serial.println(SCK);\n  Serial.print(\"CS/SS:\");\n  Serial.println(USE_THIS_SS_PIN);\n  Serial.println(F(\"=========================\"));\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  initFS();\n  listDir();\n  initWebserver();\n\n  Serial.print(\"HTTP server started @\");\n  Serial.println(Ethernet.localIP());\n\n  Serial.print(F(\"Open http://\"));\n  Serial.print(Ethernet.localIP());\n  Serial.println(F(\"/edit to see the file browser\"));"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "password",
        "ssl",
        "buffer",
        "power",
        "lte",
        "spi",
        "nb-iot",
        "gprs",
        "digitalwrite",
        "delay",
        "led",
        "sd",
        "timestamp"
      ],
      "libraries": [
        "BotleticsSIM7000.h",
        "SPI.h",
        "SD.h",
        "SoftwareSerial.h",
        "HardwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(9600);\n  Serial.println(F(\"*** FTP Example ***\"));\n\n  #ifdef LED\n    pinMode(LED, OUTPUT);\n    digitalWrite(LED, LOW);\n  #endif\n  \n  pinMode(RST, OUTPUT);\n  digitalWrite(RST, HIGH); // Default state\n\n  modem.powerOn(BOTLETICS_PWRKEY); // Power on the module\n  moduleSetup(); // Establishes first-time serial comm and prints IMEI\n\n  // Set modem to full functionality\n  modem.setFunctionality(1); // AT+CFUN=1\n\n  // Configure a GPRS APN, username, and password.\n  // You might need to do this to access your network's GPRS/data\n  // network.  Contact your provider for the exact APN, username,\n  // and password values.  Username and password are optional and\n  // can be removed, but APN is required.\n  //modem.setNetworkSettings(F(\"your APN\"), F(\"your username\"), F(\"your password\"));\n  //modem.setNetworkSettings(F(\"m2m.com.attz\")); // For AT&T IoT SIM card\n  //modem.setNetworkSettings(F(\"telstra.internet\")); // For Telstra (Australia) SIM card - CAT-M1 (Band 28)\n  modem.setNetworkSettings(F(\"hologram\")); // For Hologram SIM card\n\n  // Optionally configure HTTP gets to follow redirects over SSL.\n  // Default is not to follow SSL redirects, however if you uncomment\n  // the following line then redirects over SSL will be followed.\n  //modem.setHTTPSRedirect(true);\n\n  /*\n  // Other examples of some things you can set:\n  modem.setPreferredMode(38); // Use LTE only, not 2G\n  modem.setPreferredLTEMode(1); // Use LTE CAT-M only, not NB-IoT\n  modem.setOperatingBand(\"CAT-M\", 12); // AT&T uses band 12\n//  modem.setOperatingBand(\"CAT-M\", 13); // Verizon uses band 13\n  modem.enableRTC(true);\n  \n  modem.enableSleepMode(true);\n  modem.set_eDRX(1, 4, \"0010\");\n  modem.enablePSM(true);\n\n  // Set the network status LED blinking pattern while connected to a network (see AT+SLEDS command)\n  modem.setNetLED(true, 2, 64, 3000); // on/off, mode, timer_on, timer_off\n  modem.setNetLED(false); // Disable network status LED\n  */\n\n  // Connect to cell network and verify connection\n  // If unsuccessful, keep retrying every 2s until a connection is made\n  while (!netStatus()) {\n    Serial.println(F(\"Failed to connect to cell network, retrying...\"));\n    delay(2000); // Retry every 2s\n  }\n  Serial.println(F(\"Connected to cell network!\"));\n\n  // Disable data connection before attempting to connect\n  modem.enableGPRS(false);\n\n  // Turn on data connection\n  while (!modem.enableGPRS(true)) {\n    Serial.println(F(\"Failed to enable data, retrying...\"));\n    delay(2000);\n  }\n  Serial.println(F(\"Enabled data!\"));\n\n  // Connect to FTP server\n  Serial.println(F(\"Connecting to FTP server...\"));\n  while (!modem.FTP_Connect(serverIP, serverPort, username, password)) {\n    Serial.println(F(\"Failed to connect to FTP server!\"));\n    delay(2000);\n  }\n\n  // Initialize SD card\n  Serial.print(F(\"Initializing SD card... \"));\n  \n  if (!SD.begin(CS_pin)) {\n    Serial.println(F(\"failed!\"));\n    while (1);\n  }\n  Serial.println(F(\"done!\"));\n\n  // Read the contents of a text file in the root directory of the FTP server\n  // Make sure the file exists on your FTP server in the specified directory!\n  Serial.println(F(\"Reading file from FTP server...\"));\n\n  char * readContent = modem.FTP_GET(\"test.txt\", \"/\", 1024);\n  Serial.println(readContent); // DEBUG\n  free(readContent); // Free up memory alloc\n\n  // Write the content we just read from the FTP file onto our local copy\n  if (!writeToFile(\"test.txt\", readContent)) Serial.println(F(\"Failed to write to file!\"));\n\n  // Close FTP connection for good measure before performing next task\n  if (!modem.FTP_Quit()) {\n    Serial.println(F(\"Failed to close FTP connection!\"));\n  }\n\n  // Connect again to FTP server\n  Serial.println(F(\"Connecting to FTP server...\"));\n  while (!modem.FTP_Connect(serverIP, serverPort, username, password)) {\n    Serial.println(F(\"Failed to connect to FTP server!\"));\n    delay(2000);\n  }\n  \n  // Upload text to a file in the server's root directory\n  const char* content = \"This is an FTP test 123!\"; // Text to put in the file. Could be from an SD card, etc.\n\n  // Upload a new file\n  Serial.println(F(\"Uploading file to FTP server...\"));\n  if (!modem.FTP_PUT(\"upload.txt\", \"/\", content, strlen(content))) { // File name, file path, content, content length\n    Serial.println(F(\"Failed to upload!\"));\n  }\n\n  // Let's rename the file we just uploaded!\n  Serial.println(F(\"Renaming file on FTP server...\"));\n  if (!modem.FTP_Rename(\"/\", \"upload.txt\", \"newFile.txt\")) { // Path, old name, new name\n    Serial.println(F(\"Failed to change file name!\"));\n  }\n\n  // You can also delete it if you want. I am leaving this commented\n  // out so you can check that it was really there to begin with.\n  // Uncomment then upload again and watch it disappear!\n  /*\n  Serial.println(F(\"Deleting file from FTP server...\"));\n  if (!modem.FTP_Delete(\"newFile.txt\", \"/\")) { // File name, file path\n    Serial.println(F(\"Failed to delete file!\"));\n  }\n  */\n\n  // Get the timestamp of when the file we just renamed was last modified\n//  char timestamp[20];\n  uint16_t year;\n  uint8_t month, day, hour, minute, second;\n\n  Serial.println(F(\"Checking last modified timestamp...\"));\n  if (!modem.FTP_MDTM(\"newFile.txt\", \"/\", &year, &month, &day, &hour, &minute, &second)) {\n    Serial.println(F(\"Failed to get timestamp!\"));\n  }\n  else {\n    Serial.print(F(\"Year: \")); Serial.println(year);\n    Serial.print(F(\"Month: \")); Serial.println(month);\n    Serial.print(F(\"Day: \")); Serial.println(day);\n    Serial.print(F(\"Hour: \")); Serial.println(hour);\n    Serial.print(F(\"Minute: \")); Serial.println(minute);\n    Serial.print(F(\"Second: \")); Serial.println(second);\n  }\n  \n  // Now the really cool part! We're going to upload\n  // a picture to the server using the extended PUT\n  // method (auto-detected inside the FTP_PUT method\n  // based on the content size\n  // NOTE: Haven't tested extended PUT method yet because\n  // SIM7000G firmware does not support it for some reason...\n  /*\n  size_t fileSize;\n  char * uploadContent = readFromFile(\"test.png\", &fileSize);\n\n  Serial.print(\"File size: \"); Serial.print(fileSize); Serial.println(F(\" bytes\"));\n\n  // Upload picture via FTP\n  if (!modem.FTP_PUT(\"test.png\", \"/\", uploadContent, fileSize)) { // File name, file path, content, content length\n    Serial.println(F(\"Failed to upload!\"));\n  }\n  */\n\n  // Close FTP connection\n  // Note that with FTP GET/PUT requests, connection to FTP server is automatically\n  // closed after the request is successfully completed so the following function\n  // might give an error.\n  if (!modem.FTP_Quit()) {\n    Serial.println(F(\"Failed to close FTP connection!\"));\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        },
        {
          "name": "moduleSetup",
          "parameters": "",
          "body": "// SIM7000 takes about 3s to turn on and SIM7500 takes about 15s\n  // Press Arduino reset button if the module is still turning on and the board doesn't find it.\n  // When the module is on it should communicate right after pressing reset\n\n  // Software serial:\n  modemSS.begin(115200); // Default SIM7000 shield baud rate\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modemSS.println(\"AT+IPR=9600\"); // Set baud rate\n  delay(100); // Short pause to let the command run\n  modemSS.begin(9600);\n  if (! modem.begin(modemSS)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while (1); // Don't proceed if it couldn't find the device\n  }\n\n  // Hardware serial:\n  /*\n  modemSerial->begin(115200); // Default SIM7000 baud rate\n\n  if (! modem.begin(*modemSerial)) {\n    DEBUG_PRINTLN(F(\"Couldn't find SIM7000\"));\n  }\n  */\n\n  // The commented block of code below is an alternative that will find the module at 115200\n  // Then switch it to 9600 without having to wait for the module to turn on and manually\n  // press the reset button in order to establish communication. However, once the baud is set\n  // this method will be much slower.\n  /*\n  modemSerial->begin(115200); // Default LTE shield baud rate\n  modem.begin(*modemSerial); // Don't use if statement because an OK reply could be sent incorrectly at 115200 baud\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modem.setBaudrate(9600); // Set to 9600 baud\n  modemSerial->begin(9600);\n  if (!modem.begin(*modemSerial)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while(1); // Don't proceed if it couldn't find the device\n  }\n  */\n\n  type = modem.type();\n  Serial.println(F(\"Modem is OK\"));\n  Serial.print(F(\"Found \"));\n  switch (type) {\n    case SIM800L:\n      Serial.println(F(\"SIM800L\")); break;\n    case SIM800H:\n      Serial.println(F(\"SIM800H\")); break;\n    case SIM808_V1:\n      Serial.println(F(\"SIM808 (v1)\")); break;\n    case SIM808_V2:\n      Serial.println(F(\"SIM808 (v2)\")); break;\n    case SIM5320A:\n      Serial.println(F(\"SIM5320A (American)\")); break;\n    case SIM5320E:\n      Serial.println(F(\"SIM5320E (European)\")); break;\n    case SIM7000:\n      Serial.println(F(\"SIM7000\")); break;\n    case SIM7070:\n      Serial.println(F(\"SIM7070\")); break;\n    case SIM7500:\n      Serial.println(F(\"SIM7500\")); break;\n    case SIM7600:\n      Serial.println(F(\"SIM7600\")); break;\n    default:\n      Serial.println(F(\"???\")); break;\n  }\n  \n  // Print module IMEI number.\n  uint8_t imeiLen = modem.getIMEI(imei);\n  if (imeiLen > 0) {\n    Serial.print(\"Module IMEI: \"); Serial.println(imei);\n  }\n\n  // Needed for rare cases in which firmware on SIM7000 sets CFUN to 0 on start-up\n  modem.setFunctionality(1); // Enable cellular (RF) with AT+CFUN=1"
        },
        {
          "name": "netStatus",
          "parameters": "",
          "body": "int n = modem.getNetworkStatus();\n  \n  Serial.print(F(\"Network status \")); Serial.print(n); Serial.print(F(\": \"));\n  if (n == 0) Serial.println(F(\"Not registered\"));\n  if (n == 1) Serial.println(F(\"Registered (home)\"));\n  if (n == 2) Serial.println(F(\"Not registered (searching)\"));\n  if (n == 3) Serial.println(F(\"Denied\"));\n  if (n == 4) Serial.println(F(\"Unknown\"));\n  if (n == 5) Serial.println(F(\"Registered roaming\"));\n\n  if (!(n == 1 || n == 5)) return false;\n  else return true;"
        },
        {
          "name": "writeToFile",
          "parameters": "const char fileName, char * content",
          "body": "myFile = SD.open(fileName, FILE_WRITE);\n\n  // If the file opened successfully, write to it\n  if (myFile) {\n    Serial.print(\"Writing to file...\");\n    myFile.println(content); // Write the desired content onto the file\n    myFile.close(); // Close the file\n    Serial.println(\" done!\");\n  }\n  else {\n    Serial.println(\"Error opening file!\");\n    return false;\n  }\n  \n  return true;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "https",
        "lora",
        "delay",
        "digitalwrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial1.begin(115200, SERIAL_8E1);\n  Serial2.begin(115200, SERIAL_8E1);\n\n  delay(1000);\n\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(LORA_BOOT0, OUTPUT);\n  digitalWrite(LORA_BOOT0, HIGH);\n  pinMode(LORA_RESET, OUTPUT);\n  digitalWrite(LORA_RESET, HIGH);\n  delay(200);\n  digitalWrite(LORA_RESET, LOW);\n  delay(200);\n  digitalWrite(LORA_RESET, HIGH);"
        },
        {
          "name": "resetModule",
          "parameters": "",
          "body": "Serial.println(\"resetting module\");\n  digitalWrite(LORA_RESET, HIGH);\n  delay(100);\n  digitalWrite(LORA_RESET, LOW);\n  delay(100);\n  digitalWrite(LORA_RESET, HIGH);\n\n  while (!Serial);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "while (Serial1.available()) {      // If anything comes in Serial (USB),\n    tx_buf[tx++] = Serial1.read();   // read it and send it out Serial1 (pins 0 & 1)\n  }\n\n  if (tx > 0) {\n    Serial2.write(tx_buf, tx);\n    tx = 0;\n  }\n\n  while (Serial2.available()) {      // If anything comes in Serial (USB),\n    rx_buf[rx++] = Serial2.read();   // read it and send it out Serial1 (pins 0 & 1)\n  }\n\n  if (rx > 0) {\n    Serial1.write(rx_buf, rx);\n    rx = 0;\n  }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "millis"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/face/detection.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___FACE DETECTION___\");\n\n    // camera settings\n    // !!!!REPLACE WITH YOUR OWN MODEL!!!!\n    camera.pinout.freenove_s3(); // e.g. xiao(), lilygo_tcamera_s3(), ...\n    camera.brownout.disable();\n    // face detection only works at 240x240\n    camera.resolution.face();\n    camera.quality.high();\n\n    // you can choose fast detection (50ms)\n    detection.fast();\n    // or accurate detection (80ms)\n    detection.accurate();\n\n    // you can set a custom confidence score\n    // to consider a face valid\n    // (in range 0 - 1, default is 0.5)\n    detection.confidence(0.7);\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Awaiting for face...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;\n    }\n\n    // run detection\n    if (!detection.run().isOk()) {\n        Serial.println(detection.exception.toString());\n        return;\n    }\n\n    // if face is not found, abort\n    if (detection.notFound())\n      return;\n      \n    Serial.printf(\n        \"Face(s) detected in %dms!\\n\", \n        detection.benchmark.millis()\n    );\n\n    // you can access the first detected face\n    // at detection.first\n    Serial.printf(\n      \" > face #1 located at (%d, %d)\\n\"\n      \"   proba is %.2f\\n\",\n      detection.first.x,\n      detection.first.y,\n      detection.first.score\n    );\n\n    // if you expect multiple faces, you use forEach\n    if (detection.count() > 1) {\n      detection.forEach([](int i, face_t face) {\n          Serial.printf(\n              \" > face #%d located at (%d, %d)\\n\", \n              i + 1, \n              face.x, \n              face.y\n          );\n  \n          // if you enabled accurate detection\n          // you have access to the keypoints\n          if (face.hasKeypoints()) {\n              Serial.printf(\n                \"   > left  eye   at (%d, %d)\\n\"\n                \"   > right eye   at (%d, %d)\\n\"\n                \"   > nose        at (%d, %d)\\n\"\n                \"   > left mouth  at (%d, %d)\\n\"\n                \"   > right mouth at (%d, %d)\\n\",\n                face.leftEye.x,\n                face.leftEye.y,\n                face.rightEye.x,\n                face.rightEye.y,\n                face.nose.x,\n                face.nose.y,\n                face.leftMouth.x,\n                face.leftMouth.y,\n                face.rightMouth.x,\n                face.rightMouth.y\n              );\n          }\n          \n      });\n    }"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "delay",
        "millis"
      ],
      "libraries": [
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/face/detection.h",
        "eloquent_esp32cam/face/recognition.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "delay(4000);\n    Serial.begin(115200);\n    Serial.println(\"Begin\");\n\n    // !!!!REPLACE WITH YOUR OWN MODEL!!!!\n    camera.pinout.freenove_s3(); // e.g. xiao(), lilygo_tcamera_s3(), ...\n    camera.brownout.disable();\n    // face recognition only works at 240x240\n    camera.resolution.face();\n    camera.quality.high();\n\n    // face recognition only works with accurate detection\n    detection.accurate();\n    detection.confidence(0.7);\n\n    // face recognition confidence\n    recognition.confidence(0.85);\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    // init recognizer\n    while (!recognition.begin().isOk())\n        Serial.println(recognition.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Face recognizer OK\");\n\n    // delete stored data, if user confirms\n    if (prompt(\"Do you want to delete all existing faces? [yes|no]\").startsWith(\"y\")) {\n        Serial.println(\"Deleting all existing faces...\");\n        recognition.deleteAll();\n    }\n\n    // dump stored faces, if user confirms\n    if (prompt(\"Do you want to dump existing faces? [yes|no]\").startsWith(\"y\")) {\n        recognition.dump();\n    }\n\n    Serial.println(\"Awaiting for face...\");"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;\n    }\n\n    // run face detection (not recognition!)\n    if (!recognition.detect().isOk())\n        return;\n\n    // if face is found, ask user to enroll or recognize\n    String answer = prompt(\"Do you want to enroll or recognize? [e|r]\");\n\n    if (answer.startsWith(\"e\"))\n        enroll();\n    else if (answer.startsWith(\"r\"))\n        recognize();\n\n    Serial.println(\"Awaiting for face...\");"
        },
        {
          "name": "prompt",
          "parameters": "String message",
          "body": "String answer;\n\n    do {\n        Serial.print(message);\n\n        while (!Serial.available())\n            delay(1);\n\n        answer = Serial.readStringUntil('\\n');\n        answer.trim();\n    } while (!answer);\n\n    Serial.print(\" \");\n    Serial.println(answer);\n    return answer;"
        },
        {
          "name": "enroll",
          "parameters": "",
          "body": "String name = prompt(\"Enter person name:\");\n\n    if (recognition.enroll(name).isOk())\n        Serial.println(\"Success!\");\n    else\n        Serial.println(recognition.exception.toString());"
        },
        {
          "name": "recognize",
          "parameters": "",
          "body": "if (!recognition.recognize().isOk()) {\n        Serial.println(recognition.exception.toString());\n        return;\n    }\n\n    Serial.print(\"Recognized face as \");\n    Serial.print(recognition.match.name.c_str());\n    Serial.print(\" with confidence \");\n    Serial.print(recognition.match.similarity);\n    Serial.print(\" (\");\n    Serial.print(recognition.benchmark.millis());\n    Serial.println(\"ms)\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "http",
        "https",
        "gsm",
        "delay"
      ],
      "libraries": [
        "TinyGsmClient.h",
        "SoftwareSerial.h",
        "StreamDebugger.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // Set GSM module baud rate\n  SerialAT.begin(9600);\n  delay(6000);\n\n  if (!modem.init()) {\n    SerialMon.println(\n        F(\"***********************************************************\"));\n    SerialMon.println(F(\" Cannot initialize modem!\"));\n    SerialMon.println(\n        F(\"   Use File -> Examples -> TinyGSM -> tools -> AT_Debug\"));\n    SerialMon.println(F(\"   to find correct configuration\"));\n    SerialMon.println(\n        F(\"***********************************************************\"));\n    return;\n  }\n\n  bool ret = modem.factoryDefault();\n\n  SerialMon.println(\n      F(\"***********************************************************\"));\n  SerialMon.print(F(\" Return settings to Factory Defaults: \"));\n  SerialMon.println((ret) ? \"OK\" : \"FAIL\");\n  SerialMon.println(\n      F(\"***********************************************************\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setID",
          "parameters": "int id",
          "body": "BraccioClass::setID(id);\n  }"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  factory.begin();\n  while (!Serial);"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "Serial.println(\"Write the ID you want to use for this motor:\");\n  String ret = \"\";\n  do {\n    ret = Serial.readStringUntil('\\n');\n  } while (ret == \"\");\n\n  int selected = ret.toInt();\n\n  Serial.println(\"Writing ID \" + String(selected));\n  factory.setID(selected);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "current",
        "servo",
        "millis",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "set_initial_servo_position",
          "parameters": "int const id, float const target_angle",
          "body": "auto isTimeout = [](unsigned long const start) -> bool { return ((millis() - start) > 2000); };\n\n  auto start = millis();\n  Serial.print(\"Connecting .... \");\n  for (; !Braccio.get(id).connected() && !isTimeout(start); delay(10)) { }\n  if (!isTimeout(start))\n    Serial.println(\"OK.\");\n  else\n  {\n    Serial.print(\"Error: Can not connect to servo \");\n    Serial.print(id);\n    Serial.println(\" within time limit.\");\n    Serial.println();\n    return false;\n  }\n  delay(500);\n\n  Serial.print(\"Disengaging ... \");\n  Braccio.get(id).disengage();\n  Serial.println(\"OK.\");\n  delay(500);\n\n  Serial.print(\"Engaging ...... \");\n  Braccio.get(id).engage();\n  Serial.println(\"OK.\");\n  delay(500);\n\n  /* Drive to the position for assembling the servo horn. */\n  auto isTargetAngleReached = [target_angle, id](float const epsilon) -> bool { return (fabs(Braccio.get(id).position() - target_angle) <= epsilon); };\n\n  static float constexpr EPSILON = 2.0f;\n\n  start = millis();\n  for ( float current_angle = Braccio.get(id).position();\n       !isTargetAngleReached(EPSILON) && !isTimeout(start);)\n  {\n    Braccio.get(id).move().to(target_angle);\n    delay(250);\n  \n    char msg[64] = {0};\n    snprintf(msg, sizeof(msg), \"Angle (Target | Current) = %.2f | %.2f\", target_angle, Braccio.get(id).position());\n    Serial.println(msg);\n  }\n\n  if (!isTargetAngleReached(EPSILON))\n  {\n    Serial.print(\"Error: Servo \");\n    Serial.print(id);\n    Serial.print(\" did not reach target angle.\");\n    Serial.println();\n    return false;\n  }\n\n  if (isTimeout(start))\n  {\n    Serial.print(\"Error: Servo \");\n    Serial.print(id);\n    Serial.println(\" did not reach target angle within time limit.\");\n    Serial.println();\n    return false;\n  }\n\n  Serial.println(\"Calibration ... OK\");\n  return true;"
        },
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  while(!Serial) { }\n\n  if (!Braccio.begin(nullptr, false)) {\n    Serial.println(\"Braccio.begin() failed.\");\n    for(;;) { }\n  }\n\n  Braccio.disengage();\n\n  int success_cnt = 0;\n  for (auto & servo : INITIAL_SERVO_POSITION)\n  {\n    Serial.print(\"Servo \");\n    Serial.print(servo.id());\n    Serial.print(\": Target Angle = \");\n    Serial.print(servo.angle());\n    Serial.println();\n\n    if (set_initial_servo_position(servo.id(), servo.angle()))\n      success_cnt++;\n  }\n\n  if (success_cnt == SmartServoClass::NUM_MOTORS)\n  {\n    Serial.println(\"SUCCESS : all servos are set to their initial position.\");\n  }\n  else\n  {\n    Serial.print(\"ERROR: only \");\n    Serial.print(success_cnt);\n    Serial.print(\" of \");\n    Serial.print(SmartServoClass::NUM_MOTORS);\n    Serial.print(\" could be set to the desired initial position.\");\n    Serial.println();\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogwrite",
        "delay",
        "led",
        "pwm"
      ],
      "libraries": [
        "Adafruit_seesaw.h"
      ],
      "functions": [
        {
          "name": "setup",
          "parameters": "",
          "body": "Serial.begin(115200);\n  \n  while (!Serial) delay(10);   // wait until serial port is opened\n  \n  if(!ss.begin()){\n    Serial.println(\"seesaw not found!\");\n    while(1) delay(10);\n  }"
        },
        {
          "name": "loop",
          "parameters": "",
          "body": "// set the brightness of the LED:\n  ss.analogWrite(led, brightness);\n\n  // change the brightness for next time through the loop:\n  brightness = brightness + fadeAmount;\n\n  // reverse the direction of the fading at the ends of the fade:\n  if (brightness <= 0 || brightness >= 255) {\n    fadeAmount = -fadeAmount;\n  }\n  // wait for 30 milliseconds to see the dimming effect\n  delay(30);"
        }
      ]
    }
  ],
  "vocab": [
    "power",
    "millis",
    "delay",
    "analogread",
    "blynk",
    "auth",
    "wifi",
    "digitalwrite",
    "analogwrite",
    "timer",
    "blynk-cloud.com",
    "https",
    "led",
    "digitalread",
    "device_name",
    "eventsource",
    "interrupt",
    "key",
    "distance",
    "fetch",
    "meterscreen",
    "buffer",
    "current",
    "http",
    "rtc",
    "html",
    "matrix",
    "display",
    "token",
    "spi",
    "lcd",
    "hc-sr04",
    "pulsein",
    "rgb",
    "api",
    "ssl",
    "json",
    "tft",
    "sd",
    "i2c",
    "ili9341",
    "pwm",
    "light",
    "uart",
    "encryption",
    "timestamp",
    "lora",
    "tone",
    "mpu6050",
    "motion",
    "devices",
    "sensors",
    "servo",
    "segment",
    "flash",
    "debounce",
    "dht11",
    "temperature",
    "humidity",
    "password",
    "dns",
    "littlefs",
    "spiffs",
    "eeprom",
    ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(read_interval, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if (use_littlefs)\n    serial.println(f(",
    ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  if (blynk.connected())\n  {\n#if ( use_littlefs || use_spiffs)\n    serial.print(f(",
    "wifiserver",
    "wificlient",
    "clients",
    "webserver",
    "monitored",
    "publish",
    "callback",
    "mqtt",
    "certificate",
    "tls",
    "subscribe",
    "stream",
    "gsm",
    "gprs",
    "clientid",
    "lte",
    "payload",
    "stringify",
    "parse",
    "gatewayip",
    "sensorid",
    "sensorxyz",
    "sensor_id_acc",
    "sensor_id_gyro",
    "acceleration",
    "sensor_float_vec_t",
    "meters",
    "sensor_int16_vec_t",
    "firebase",
    "client_id",
    "client_secret",
    "clientsecret",
    "ntp",
    "sensoractivity",
    "sensor_id_ar",
    "voltage",
    "nb-iot",
    "sensor_val",
    "ble",
    "blynk.cloud",
    "esp.restart",
    "pm10",
    "nodebug_websockets",
    "device_id",
    "dht22",
    "soil",
    "moisture",
    "ph",
    "rest",
    "yield",
    "sensor_count",
    "database",
    "device_registration_id_token",
    "device_token",
    "monitors",
    "schedule",
    "mosquitto",
    "nodes",
    "deviceid",
    "bluetooth",
    "gateway_ip",
    "asyncwebserver",
    "detectors",
    "sensorvalue",
    "javascript",
    "clientconnected",
    "nodemcu",
    "thingspeak",
    "sensordht22",
    "sensordht22_label",
    "sensornumber",
    "esp8266webserver",
    "watchdog",
    "devicebound",
    "bme280",
    "pressure",
    "bmp280",
    "sensorbsec",
    "sensor_id_bsec",
    "sensorbsec2",
    "sensor_id_bsec2",
    "sensortec",
    "sensorbsec2collector",
    "sensor_id_bsec2_collector",
    "ina219",
    "devicenumber",
    "devicesfound",
    "pubsubclient",
    "md5",
    "sensorstatus",
    "sensorname",
    "devicename",
    "client_email",
    "energy",
    "bootstrap",
    "nodelay",
    "device_host_name",
    "oled",
    "st7789",
    "device_registration_id_token_1",
    "device_token_1",
    "device_registration_id_token_2",
    "device_token_2",
    "device_registration_id_token_3",
    "device_token_3",
    "telegram",
    "4g",
    "sensors_event_t",
    "deviceevent",
    "sensorkit",
    "websocket",
    "devicetoken",
    "devicecreds",
    "deviceconfig",
    "sensorreading",
    "node1",
    "pid",
    ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(60 * 1000, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if (use_littlefs)\n    serial.println(f(",
    ");\n  blynk.begin(host_name);\n#else\n  wifi.begin(ssid, pass);\n\n#if use_local_server\n  blynk.config(auth, blynk_server, blynk_hardware_port);\n#else\n  blynk.config(auth);\n#endif\n\n  blynk.connect();\n#endif\n\n  timer.setinterval(60 * 1000, readandsenddata);\n\n  if (blynk.connected())\n  {\n#if ( use_littlefs || use_spiffs)\n    serial.print(f(",
    "sensor1data",
    "sensor2data",
    "sensor3data",
    "sensor_t",
    "sensor_id",
    "ds18b20",
    "onewire",
    "sensor_id_acc_pass",
    "device_state",
    "css",
    ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp32_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp32_config);\n\n  serial.print(f(",
    "sensorupdate",
    "sensor_check_interval",
    "clientip",
    ");\n  \n#else\n  blynk_wf.begin(wifi_blynk_tok, ssid, pass, blynk_server, blynk_hardware_port);\n\n  blynk_gsm.config(modem, gsm_blynk_tok, blynk_server, blynk_hardware_port);\n  gsm_connect_ok = blynk_gsm.connectnetwork(apn, gprsuser, gprspass);\n\n  if (gsm_connect_ok)\n    blynk_gsm.connect();\n#endif\n\n#if use_blynk_wm\n  blynk_wf_configuration localblynkgsm_esp8266_config;\n\n  blynk_wf.getfullconfigdata(&localblynkgsm_esp8266_config);\n\n  serial.print(f(",
    "device_ip",
    "sensor1_reading",
    "sensor2_reading",
    "device1mac",
    "device1irk",
    "device2mac",
    "device2irk",
    "device1ltk",
    "device2ltk"
  ]
}