{
  "templates": [
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"0-5V Input Channel \");\n    switch (inputChannels[inputChannelIndex]) {\n        case INPUT_05V_CH01: Serial.print(\"01\"); break;\n        case INPUT_05V_CH02: Serial.print(\"02\"); break;\n        case INPUT_05V_CH03: Serial.print(\"03\"); break;\n        case INPUT_05V_CH04: Serial.print(\"04\"); break;\n        case INPUT_05V_CH05: Serial.print(\"05\"); break;\n        case INPUT_05V_CH06: Serial.print(\"06\"); break;\n        case INPUT_05V_CH07: Serial.print(\"07\"); break;\n        case INPUT_05V_CH08: Serial.print(\"08\"); break;\n        default: break;"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "digitalWrite",
        "analogWrite",
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "blynkAnotherDevice",
          "body": "//向被控制端发送数据\n  if (value) {\n    bridge1.digitalWrite(12, HIGH);  //被控制端的12号管脚将被设为 HIGH\n    bridge1.virtualWrite(V5, 1); // 向被控制端V5管脚发送1，被控制端需要用BLYNK_WRITE(V5) 接收\n\n    /////////////////////////////////////////////////////////////////////////////////////////\n    //特别注意，如果向被控制端的虚拟管脚发送数据，\n    //被控制端需要用 BLYNK_WRITE函数来接收，类似于接收来自app端的虚拟管脚数据\n    //\n    //    BLYNK_WRITE(V5){\n    //    int pinData = param.asInt(); // 接收来自bridge的数据\n    //"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, blynkAnotherDevice);  // 每秒钟调用 blynkAnotherDevice 函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(2, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(2, HIGH);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "attachInterrupt"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "notifyOnButtonPress",
          "body": "int isButtonPressed = !digitalRead(2);\n  if (isButtonPressed) {\n    Serial.println(\"Button is pressed.\");\n    Blynk.notify(\"Yaaay... button is pressed!\");\n    // 你也可以使用 {DEVICE_NAME"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  pinMode(2, INPUT_PULLUP);//设置GPIO2为中断管脚\n  attachInterrupt(digitalPinToInterrupt(2), notifyOnButtonPress, CHANGE);//GPIO2添加中断函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin(custom_main_menu)) {\n    app.enableButtons();\n    /* Allow greater angular velocity than the default one. */\n    Braccio.setAngularVelocity(45.0f);"
        },
        {
          "name": "loop",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // Configure and start Serial Communication\n  Serial.begin(9600); \n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward() == HIGH)\n    Serial.println(\"Forward Button was pressed!\");\n\n  // Check the backward button signal\n  if(axis.readBtnBackward() == HIGH)\n    Serial.println(\"Backward Button was pressed!\");\n  \n  // Check the Endstop Home switch signal\n  if(axis.readEndstopHome() == HIGH)\n    Serial.println(\"Endstop Home was pressed!\");\n\n  // Check the Endstop Far switch signal\n  if(axis.readEndstopFar() == HIGH)\n    Serial.println(\"Endstop Far was pressed!\");\n  \n  // Check the Emergency Stop Button signal\n  if(axis.readBtnEmergencyStop() == LOW)\n    // The emergency stop button is attached in the interrupt service routine\n    // So when you click the button, you will see the Emergency message printed too\n    Serial.println(\"Emergency Stop Button was pressed!\");"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "COLOR_TEAL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();"
        },
        {
          "name": "loop",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();"
        },
        {
          "name": "directionScreen",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "TIME_DELAY",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin()){\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n\n    /* Move to home position. */\n    gripper.move().to(initialAngle);       delay(TIME_DELAY);\n    wristRoll.move().to(initialAngle);     delay(TIME_DELAY);\n    wristPitch.move().to(initialAngle);    delay(TIME_DELAY);\n    elbow.move().to(initialAngle);         delay(TIME_DELAY);\n    shoulder.move().to(initialAngle);      delay(TIME_DELAY);\n    base.move().to(initialBase);           delay(TIME_DELAY);"
        },
        {
          "name": "loop",
          "body": "// Fetch the joints positions\n  Braccio.positions(angles);\n\n  // Print the joint angles\n  Serial.println(\"************* Joints Angles *************\");\n  Serial.println(\"|\\tMotor ID\\t|\\tAngle\\t|\");\n  Serial.println(\"----------------------------------------\");\n  Serial.print(\"| 1 - Gripper\\t\\t|\\t\" + String(angles[0]) + \"\\t|\\n\" + \n               \"| 2 - Wrist Rotation\\t|\\t\" + String(angles[1]) + \"\\t|\\n\" +\n               \"| 3 - Wrist Vertical\\t|\\t\" + String(angles[2]) + \"\\t|\\n\" + \n               \"| 4 - Elbow\\t\\t|\\t\" + String(angles[3]) + \"\\t|\\n\" + \n               \"| 5 - Shoulder\\t\\t|\\t\" + String(angles[4]) + \"\\t|\\n\" + \n               \"| 6 - Base\\t\\t|\\t\" + String(angles[5]) + \"\\t|\\n\");\n  Serial.println(\"*****************************************\\n\\n\\n\\n\\n\");\n  Serial.println(\"\\n\\n\\n\\n\");\n  \n  delay(TIME_DELAY);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  lv_obj_t * btn1 = lv_btn_create(lv_scr_act());\n  lv_obj_set_size(btn1, 120, 75);\n  lv_obj_t * label1 = lv_label_create(btn1);\n  lv_label_set_text(label1, \"BTN 1\");\n  lv_obj_align(btn1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_center(label1);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "/* Set the meter value */\n  Braccio.lvgl_lock();\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 8, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(meterScreen);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle <= 315 ) {\n      currentAngle += 15.0;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial){"
        },
        {
          "name": "loop",
          "body": "int joystickPos = Braccio.getKey();\n  message = checkJoystick(joystickPos);\n  if(message != \"\"){\n    Serial.println(message);\n    message = \"\";"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin();\n  delay(500);\n  \n  Serial.begin(115200);\n  while(!Serial){"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"To start, send any key to the serial port:\");\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n   Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);\n// 创建LabeledValue组件，输入管脚设置为V5"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n   Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "notifyUptime",
          "body": "long uptime = millis() / 60000L;\n  Blynk.notify(String(\"Running for \") + uptime + \" minutes.\");//通知手机该项目运行时间\n  // 你也可以使用 {DEVICE_NAME"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  Blynk.notify(\"Device started\");//开机是发送通知\n  timer.setInterval(60000L, notifyUptime);//每分钟调用一次该函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "TimeLib.h",
        "WidgetRTC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  // 更多资料，请参考: http://www.pjrc.com/teensy/td_libs_Time.html\n  setSyncInterval(10 * 60); // 设置同步间隔时间，10分钟。\n  timer.setInterval(1000L, clockDisplay);//每隔1s，运行clockDisplay，显示时间"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "requestTime",
          "body": "//查询时间\n  Blynk.sendInternal(\"rtc\", \"sync\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(10000L, requestTime);//每隔10s运行requestTime"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward() == HIGH)\n    axis.moveForward();  // Motor rotates clockwise\n\n  // Check the backward button signal\n  if(axis.readBtnBackward() == HIGH)\n    axis.moveBackward(); // Motor rotates anticlockwise"
        }
      ]
    },
    {
      "name": "COLOR_TEAL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  if (Braccio.begin(directionScreen))\n  {\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);\n    /* Init state. */\n    app.update(Button::None);\n    /* Enable buttons. */\n    Braccio.lvgl_lock();\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n    lv_btnmatrix_clear_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n    Braccio.lvgl_unlock();"
        },
        {
          "name": "loop",
          "body": "/* Execute every 10 ms. */\n  {\n    static auto prev = millis();\n    auto const now = millis();\n    if ((now - prev) > 10)\n    {\n      prev = now;\n      handle_ButtonPressedReleased();"
        },
        {
          "name": "directionScreen",
          "body": "Braccio.lvgl_lock();\n  \n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_white());\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_text_color(&style_btn, lv_color_white());\n\n  direction_btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_obj_set_size(direction_btnm, 240, 240);\n  lv_btnmatrix_set_map(direction_btnm, DIRECTION_BTNM_MAP);\n  lv_obj_align(direction_btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(direction_btnm, &style_bg, 0);\n  lv_obj_add_style(direction_btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 0, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 1, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 2, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 3, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 4, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 5, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 6, LV_BTNMATRIX_CTRL_HIDDEN);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 7, LV_BTNMATRIX_CTRL_DISABLED);\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, 8, LV_BTNMATRIX_CTRL_HIDDEN);\n\n  lv_btnmatrix_set_one_checked(direction_btnm, true);\n  lv_btnmatrix_set_selected_btn(direction_btnm, 1);\n\n  label = lv_label_create(lv_scr_act());\n  lv_obj_set_width(label, 240);\n  lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n  lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n  lv_label_set_text(label, \"\");\n  \n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_ButtonPressedReleased",
          "body": "/* ENTER */\n\n  static bool prev_joystick_pressed_enter = false;\n  bool const curr_joystick_pressed_enter = Braccio.isButtonPressed_ENTER();\n  if (!prev_joystick_pressed_enter && curr_joystick_pressed_enter) {\n    app.update(Button::Enter);"
        },
        {
          "name": "handle_OnButtonDownPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonDownReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_DOWN, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonUpReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_UP, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonLeftReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_LEFT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightPressed",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_set_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "handle_OnButtonRightReleased",
          "body": "Braccio.lvgl_lock();\n  lv_btnmatrix_clear_btn_ctrl(direction_btnm, BTN_RIGHT, LV_BTNMATRIX_CTRL_CHECKED);\n  Braccio.lvgl_unlock();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward() == HIGH)\n    axisX.moveForward();\n  \n  // Check the forward button signal\n  if(axisY.readBtnForward() == HIGH)\n    axisY.moveForward();\n\n  // Check the forward button signal\n  if(axisX.readBtnBackward() == HIGH)\n    axisX.moveBackward();\n\n  // Check the forward button signal\n  if(axisY.readBtnBackward() == HIGH)\n    axisY.moveBackward();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin(custom_main_menu)) {\n    app.enableButtons();"
        },
        {
          "name": "loop",
          "body": "/* Only execute every 50 ms. */\n  static auto prev = millis();\n  auto const now = millis();\n\n  if ((now - prev) > 50)\n  {\n    prev = now;\n    app.update(EventSource::TimerTick);"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of steps: \");\n\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "COLOR_TEAL",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style;\n  lv_style_init(&style);\n  lv_style_set_bg_color(&style, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style, lv_color_hex(COLOR_TEAL));\n  lv_style_set_border_width(&style, 5);\n  lv_style_set_text_color(&style, lv_color_hex(COLOR_ORANGE));\n\n  lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); \n  lv_obj_set_size(btn1, 120, 75);\n  \n  lv_obj_t * label1 = lv_label_create(btn1);\n  lv_label_set_text(label1, \"BTN 1\");\n  \n  lv_obj_align(btn1, LV_ALIGN_CENTER, 0, 0);\n  lv_obj_center(label1);\n\n  lv_obj_add_style(btn1, &style, 0);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_PRESSED) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was selected\\n\", txt);\n    Serial.println(String(txt) + \" was selected.\");"
        },
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n  \n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object"
        },
        {
          "name": "eventHandlerMenu",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen(); // Load meter screen\n  lv_obj_del(btnm); // Delete the object"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 8, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(motorMenu);\n\n  delay(5000); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1500); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 15.00;"
        }
      ]
    },
    {
      "name": "BUTTON_ENTER",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin();\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for(int i = 1; i <= 6; i++){\n    Braccio.move(i).to(0.0f);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "// Check if the control key pressed is the Enter Button\n  if(Braccio.getKey() == BUTTON_ENTER){\n    \n    if(motorID <= 6){\n      \n      motorID++;  // Increment the ID\n      \n      if(motorID > 6){\n        motorID = 1; // Restart the ID to motor 1"
        }
      ]
    },
    {
      "name": "BUTTON_ENTER",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin()){\n    /* Warning:\n       Keep a safe distance from the robot until you make sure the code is properly\n       working. Be mindful of the robot’s movement prior to that, as it could be\n       speedy and accidentally hit someone.\n    */\n\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(TIME_DELAY);"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n    movement = true; // Trigger joints' movements\n\n  if (movement) {\n    Braccio.moveTo(WAVE_POS[0], WAVE_POS[1], WAVE_POS[2], WAVE_POS[3], WAVE_POS[4], WAVE_POS[5]);\n    delay(TIME_DELAY);\n\n    for (int i = 1; i <= 5; i++) {\n      wristPitch.move().to(120.0f);         delay(TIME_DELAY);\n      wristPitch.move().to(200.0f);         delay(2*TIME_DELAY);\n      wristPitch.move().to(WAVE_POS[3]);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "attachInterrupt"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "body": "int isButtonPressed = !digitalRead(2); \n  if (isButtonPressed) // 你可以在此设置任何触发邮件发送的条件\n  {//按钮按下时，发送邮件\n    Serial.println(\"Button is pressed.\"); // 串口输出\n    Blynk.email(\"your_email@mail.com\", \"Subject: Button Logger\", \"You just pushed the button...\");\n    // 如果只是想在手机app上显示，可以用以下格式\n    //Blynk.email(\"Subject: Button Logger\", \"You just pushed the button...\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  //当开发板连接到服务器时，发送一封邮件\n  //收件人，邮件主题，邮件内容\n  Blynk.email(\"your_email@mail.com\", \"Subject\", \"My Blynk project is online.\");\n  // 设置按钮管脚为中断输入\n  pinMode(2, INPUT_PULLUP);\n  // 为GPIO2设置中断，中断函数为emailOnButtonPress\n  attachInterrupt(digitalPinToInterrupt(2), emailOnButtonPress, CHANGE);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, blinkLedWidget);//每隔1秒执行blinkLedWidget函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "blinkLedWidget",
          "body": "if (ledStatus) {\n    led1.setColor(BLYNK_RED);//设置为红色\n    Serial.println(\"LED on V1: red\");\n    ledStatus = false;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  led1.on();//点亮LED\n  timer.setInterval(1000L, blinkLedWidget);//每隔一秒运行blinkLedWidget函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(300L, fadeLedWidget);//每隔300毫秒执行fadeLedWidget函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "buttonLedWidget",
          "body": "boolean isPressed = (digitalRead(btnPin) == LOW);//读取按钮是否按下，注意，此处是针对 低电平 有效的按钮\n  if (isPressed != btnState) {//如果当前按钮状态与之前不一样\n    if (isPressed) {//如果当前是按下的\n      led3.on();//点亮led"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  pinMode(btnPin, INPUT_PULLUP);//btnPin管脚设为上升中断模式\n  timer.setInterval(500L, buttonLedWidget);//每隔500毫秒执行buttonLedWidget"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  // Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);          // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(motor.readBtnForward() == HIGH)\n    motor.moveForward();        // Motor rotates clockwise\n\n  // Check the backward button signal\n  if(motor.readBtnBackward() == HIGH)\n    motor.moveBackward();       // Motor rotates anticlockwise"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the step: \");\n  \n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object"
        },
        {
          "name": "eventHandlerMenu",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen();\n  lv_obj_del(btnm);"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 22, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 1, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(motorMenu);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 10.00;"
        }
      ]
    },
    {
      "name": "BUTTON_ENTER",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "if (Braccio.begin()){\n    /* Warning: keep a safe distance from the robot and watch out for the robot's\n       movement. It could be speedy and hit someone. */\n\n    /* Move to home position. */\n    Braccio.moveTo(HOME_POS[0], HOME_POS[1], HOME_POS[2], HOME_POS[3], HOME_POS[4], HOME_POS[5]);\n    delay(500);"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  if (pressedKey == BUTTON_ENTER)\n    movement = true; // Trigger joints' movements\n\n  if (movement) {\n    Braccio.moveTo(AGREE_POS[0], AGREE_POS[1], AGREE_POS[2], AGREE_POS[3], AGREE_POS[4], AGREE_POS[5]);\n    delay(TIME_DELAY/10);\n\n    for (int i = 1; i <= 10; i++) {\n      wristPitch.move().to(190.0f);       delay(TIME_DELAY/2);\n      wristPitch.move().to(240.0f);       delay(TIME_DELAY);\n      wristPitch.move().to(AGREE_POS[3]);"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin(); // Initialize Braccio\n  \n  delay(500); // Waits for the Braccio initialization\n  \n  // Sets the initial angle for the motors\n  for(int i = 1; i <= 6; i++){\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n  \n  // Check if the control key pressed is the Enter Button\n  if(pressedKey == BUTTON_ENTER){\n    if(motorID < 6){\n      \n      motorID++;  // Increment the ID"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_PRESSING) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s is pressed\\n\", txt);\n    Serial.println(String(txt) + \" is pressed.\");"
        },
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n\n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n\n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the step for X-axis: \");\n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n//Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the position: \");\n  \n  // Waits for the user to send a value via serial port\n  while((Serial.available() <= 0)){"
        }
      ]
    },
    {
      "name": "motor01",
      "keywords": [
        "Serial",
        "analogRead"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// read the input pin\n  speedMotor = analogRead(potentiometer);\n\n  // Re-maps an analog value to speed value\n  speedMotor = map(speedMotor, 0, 1023, MIN_SPEED, MAX_SPEED);\n\n  Serial.println(speedMotor); // Send the new value to serial monitor\n\n  motor.setSpeed(speedMotor); // Sets the motor speed\n  \n  // Check the forward button signal\n  if(motor.readBtnForward() == HIGH)\n    motor.moveForward();      // Motor rotates clockwise"
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandlerMeter",
          "body": "uint32_t pressed_key = Braccio.getKey();\n\n  if (pressed_key == BUTTON_ENTER) {\n    motorID = 0; // No motor selected\n    motorMenu(); // Load motor menu screen\n    lv_obj_del(meter); // Delete the object"
        },
        {
          "name": "eventHandlerMenu",
          "body": "lv_obj_t * obj = lv_event_get_target(e);\n  uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n\n  motorID = id + 1;\n  currentAngle = angles[motorID - 1];\n  meterScreen();\n  lv_obj_del(btnm);"
        },
        {
          "name": "meterScreen",
          "body": "Braccio.lvgl_lock();\n  meter = lv_meter_create(lv_scr_act());\n\n  lv_obj_center(meter);\n  lv_obj_set_size(meter, 200, 200);\n\n  /*Remove the circle from the middle*/\n  lv_obj_remove_style(meter, NULL, LV_PART_INDICATOR);\n\n  static lv_style_t style_meter;\n  lv_style_init(&style_meter);\n  lv_style_set_text_color(&style_meter, lv_color_hex(COLOR_TEAL));\n  lv_obj_add_style(meter, &style_meter, 0);\n\n  /*Add a scale first*/\n  lv_meter_scale_t * scale = lv_meter_add_scale(meter);\n  lv_meter_set_scale_ticks(meter, scale, 22, 2, 10, lv_color_hex(COLOR_ORANGE));\n  lv_meter_set_scale_major_ticks(meter, scale, 3, 2, 20, lv_color_hex(COLOR_ORANGE), 20);\n  lv_meter_set_scale_range(meter, scale, 0, 315, 315, 90);\n\n  /*Add a arc indicator*/\n  indic = lv_meter_add_arc(meter, scale, 10, lv_color_hex(COLOR_LIGHT_TEAL), 0);\n\n  lv_obj_add_event_cb(meter, eventHandlerMeter, LV_EVENT_KEY, NULL);\n\n  lv_meter_set_indicator_end_value(meter, indic, (int32_t)angles[motorID - 1]);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(meter);"
        },
        {
          "name": "motorMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_WHITE));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_LIGHT_TEAL));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n  btnm = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm, btnm_map);\n  lv_obj_align(btnm, LV_ALIGN_CENTER, 0, 0);\n\n  lv_obj_add_style(btnm, &style_bg, 0);\n  lv_obj_add_style(btnm, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm, true);\n\n  lv_obj_add_event_cb(btnm, eventHandlerMenu, LV_EVENT_PRESSED, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(motorMenu);\n\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  Braccio.positions(angles);\n  currentAngle = angles[motorID - 1];\n\n  // Check if the Joystick Left is pressed\n  if (pressedKey == JOYSTICK_LEFT) {\n    if (currentAngle < 315 ) {\n      currentAngle += 10.00;"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "eventHandler",
          "body": "Braccio.lvgl_lock();\n  lv_event_code_t code = lv_event_get_code(e);\n  lv_obj_t * obj = lv_event_get_target(e);\n  if (code == LV_EVENT_RELEASED) {\n    uint32_t id = lv_btnmatrix_get_selected_btn(obj);\n    const char * txt = lv_btnmatrix_get_btn_text(obj, id);\n\n    LV_LOG_USER(\"%s was released\\n\", txt);\n    Serial.println(String(txt) + \" was released.\");"
        },
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_WHITE));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n\n\n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n\n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n\n  lv_btnmatrix_set_btn_ctrl(btnm1, 0, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 1, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 2, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 3, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 4, LV_BTNMATRIX_CTRL_CHECKABLE);\n  lv_btnmatrix_set_btn_ctrl(btnm1, 5, LV_BTNMATRIX_CTRL_CHECKABLE);\n\n  lv_btnmatrix_set_one_checked(btnm1, true);\n\n  lv_obj_add_event_cb(btnm1, eventHandler, LV_EVENT_ALL, NULL);\n  Braccio.lvgl_unlock();\n\n  Braccio.connectJoystickTo(btnm1);"
        },
        {
          "name": "setup",
          "body": "Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "JOYSTICK_LEFT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Braccio.begin();\n  delay(500); // Waits for the Braccio initialization\n\n  // Sets the initial angle for the motors\n  for (int i = 1; i <= 6; i++) {\n    Braccio.move(i).to(initialAngle);\n    delay(1000); // Necessary to set the motor ID correctly"
        },
        {
          "name": "loop",
          "body": "int pressedKey = Braccio.getKey();\n\n  // Check if the control key pressed is the Joystick Up\n  if (pressedKey == JOYSTICK_UP) {\n\n    if (motorID < 6) {\n      motorID++;  // Increment the ID"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_LIGHT_TEAL));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(0xFFFFFF));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_YELLOW));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEAL));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_width(btnm1, 3, 2);  // Make \"Option 4\" twice as wide as \"Option 5\"\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);         // Configure and start Serial Communication\n  while (!Serial)\n  {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  Serial.println(\"Enter the number of the position for X-axis: \");\n  // Waits for the user to send a value via serial port\n  while ((Serial.available() <= 0))\n  {"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "sendFlagToServer",
          "body": "if (flag) {\n    Blynk.virtualWrite(V0, 1);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  timer.setInterval(1000L, sendFlagToServer);//每秒执行一次"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  // Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n\n  lcd.clear(); //LCD清屏\n  lcd.print(4, 0, \"Hello\"); // 使用格式: (X坐标: 0-15, Y坐标: 0-1, \"Message you want to print\")\n  lcd.print(4, 1, \"World\");\n  //如果在主函数中使用该函数，请通过调用事件的方式显示，如果直接显示会导致硬件掉线。"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "sendSeconds",
          "body": "//发送秒到V0\n  Blynk.virtualWrite(V0, millis() / 1000);"
        },
        {
          "name": "sendMillis",
          "body": "//发送微秒到V1\n  Blynk.virtualWrite(V1, millis());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n\n  timer.setInterval(1000L, sendSeconds);//发送秒\n  timer.setInterval(1000L, sendMillis);//发送微秒"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  // Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n\n  // If you want to remove all points:\n  //myMap.clear();\n\n  int index = 0;\n  float lat = 51.5074;\n  float lon = 0.1278;\n  myMap.location(index, lat, lon, \"value\");"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    robot.drawLine(5,5,5,10);   // Draws one line\n    delay(500);\n\n    robot.drawLine(5,10,10,10); // Draws other line\n    delay(500);\n\n    robot.drawLine(10,10,5,5);  // Draws a diagonal line\n    delay(500);"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "digitalWrite",
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(trigPin, OUTPUT);     // Sets the trigPin as an OUTPUT\n  pinMode(echoPin, INPUT);      // Sets the echoPin as an INPUT\n\n  Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axis.readBtnForward()){\n    positionNum = readUltrasonic() - motorOffset;\n    // Moves the robot carriage\n    axis.toPosition(positionNum);"
        }
      ]
    },
    {
      "name": "MARGIN_LEFT",
      "keywords": [],
      "libraries": [
        "Braccio++.h"
      ],
      "functions": [
        {
          "name": "customMenu",
          "body": "Braccio.lvgl_lock();\n  static lv_style_t style_bg;\n  lv_style_init(&style_bg);\n  lv_style_set_bg_color(&style_bg, lv_color_hex(COLOR_BG));\n\n  static lv_style_t style_btn;\n  lv_style_init(&style_btn);\n  lv_style_set_bg_color(&style_btn, lv_color_hex(COLOR_BTN));\n  lv_style_set_border_color(&style_btn, lv_color_hex(COLOR_BORDER));\n  lv_style_set_border_width(&style_btn, 2);\n  lv_style_set_text_color(&style_btn, lv_color_hex(COLOR_TEXT));\n  \n  \n  lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act());\n  lv_btnmatrix_set_map(btnm1, btnm_map);\n  lv_btnmatrix_set_btn_width(btnm1, 1, 2);  // Make \"Button 2\" twice as wide as \"Button 3\"\n  lv_obj_align(btnm1, LV_ALIGN_CENTER, MARGIN_LEFT, MARGIN_TOP);\n  \n  lv_obj_add_style(btnm1, &style_bg, 0);\n  lv_obj_add_style(btnm1, &style_btn, LV_PART_ITEMS);\n  Braccio.lvgl_unlock();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Braccio.begin(customMenu);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "DHT.h"
      ],
      "functions": [
        {
          "name": "myTimerEvent",
          "body": "// 发送数据的频率不要超过每秒10次。\n  Blynk.virtualWrite(V5, millis() / 1000);\n  Blynk.virtualWrite(V6, millis() / 1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  // Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);\n   timer.setInterval(1000L, myTimerEvent);//每隔1000毫秒执行一次myTimerEvent函数"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run(); //初始化定时器"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    robot.drawLine(5,5,5,10);   // Draws horizontal line\n    delay(500);\n\n    robot.drawLine(5,10,10,10); // Draws vertical line\n    delay(500);\n\n    robot.drawLine(10,10,10,5); // Draws horizontal line\n    delay(500);\n\n    robot.drawLine(10,5,5,5);   // Draws a vertical line\n    delay(500);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h",
        "Adafruit_NeoPixel.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);\n  strip.begin();\n  strip.show();"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 163), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n\n  // Clear the terminal content\n  terminal.clear();\n\n  // This will print Blynk Software version to the Terminal Widget when\n  // your hardware gets connected to Blynk Server\n  terminal.println(F(\"Blynk v\" BLYNK_VERSION \": Device started\"));\n  terminal.println(F(\"-------------\"));\n  terminal.println(F(\"Type 'Marco' and get a reply, or type\"));\n  terminal.println(F(\"anything else and get it printed back.\"));\n  terminal.flush();"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 1, 158), 8080);//自建服务器ip模式\n  Blynk.virtualWrite(V0, \"https://raw.githubusercontent.com/blynkkk/blynk-library/master/extras/logo.txt\");\n\n  // You can perform HTTPS requests even if your hardware alone can't handle SSL\n  // 如果您使用的开发板有足够的RAM，\n  //Blynk也可以接收更大的消息。你可以设置BLYNK_MAX_READBYTES 为4096\n  //Blynk.virtualWrite(V0, \"https://api.sunrise-sunset.org/json?lat=50.4495484&lng=30.5253873&date=2016-10-01\");"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "X_AXIS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // Configure and start Serial Communication\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // Check the forward button signal\n  if(axisX.readBtnForward()){\n    // Draws a circle\n    robot.drawCircle(CENTER_X, CENTER_Y, RADIUS);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_19V);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"19V Input Channel \");\n    Serial.print(\": \");\n\n    auto [ voltsMuxer, voltsReference ] = getAverageAnalogRead(INPUT_19V_REF);\n\n    Serial.print(voltsReference);\n    Serial.print(\" (\");\n    Serial.print(voltsMuxer);\n    Serial.println(\")\");\n    delay(1000);"
        }
      ]
    },
    {
      "name": "LGFX_M5STACK",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp",
        "LGFX_AUTODETECT.hpp",
        "lgfx_user/LGFX_ESP32_sample.hpp",
        "LGFX_TFT_eSPI.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// 最初に初期化関数を呼び出します。\n  lcd.init();\n\n\n// 回転方向を 0～3 の4方向から設定します。(4～7を使用すると上下反転になります。)\n  lcd.setRotation(1);\n\n\n// バックライトの輝度を 0～255 の範囲で設定します。\n  lcd.setBrightness(128);\n\n\n// 必要に応じてカラーモードを設定します。（初期値は16）\n// 16の方がSPI通信量が少なく高速に動作しますが、赤と青の諧調が5bitになります。\n// 24の方がSPI通信量が多くなりますが、諧調表現が綺麗になります。\n//lcd.setColorDepth(16);  // RGB565の16ビットに設定\n  lcd.setColorDepth(24);  // RGB888の24ビットに設定(表示される色数はパネル性能によりRGB666の18ビットになります)\n\n\n// 基本的な図形の描画関数は以下の通りです。\n/*\n  fillScreen    (                color);  // 画面全体の塗り潰し\n  drawPixel     ( x, y         , color);  // 点\n  drawFastVLine ( x, y   , h   , color);  // 垂直線\n  drawFastHLine ( x, y, w      , color);  // 水平線\n  drawRect      ( x, y, w, h   , color);  // 矩形の外周\n  fillRect      ( x, y, w, h   , color);  // 矩形の塗り\n  drawRoundRect ( x, y, w, h, r, color);  // 角丸の矩形の外周\n  fillRoundRect ( x, y, w, h, r, color);  // 角丸の矩形の塗り\n  drawCircle    ( x, y      , r, color);  // 円の外周\n  fillCircle    ( x, y      , r, color);  // 円の塗り\n  drawEllipse   ( x, y, rx, ry , color);  // 楕円の外周\n  fillEllipse   ( x, y, rx, ry , color);  // 楕円の塗り\n  drawLine      ( x0, y0, x1, y1        , color); // ２点間の直線\n  drawTriangle  ( x0, y0, x1, y1, x2, y2, color); // ３点間の三角形の外周\n  fillTriangle  ( x0, y0, x1, y1, x2, y2, color); // ３点間の三角形の塗り\n  drawBezier    ( x0, y0, x1, y1, x2, y2, color); // ３点間のベジエ曲線\n  drawBezier    ( x0, y0, x1, y1, x2, y2, x3, y3, color); // ４点間のベジエ曲線\n  drawArc       ( x, y, r0, r1, angle0, angle1, color);   // 円弧の外周\n  fillArc       ( x, y, r0, r1, angle0, angle1, color);   // 円弧の塗り\n*/\n\n\n// 例えばdrawPixelで点を書く場合は、引数は X座標,Y座標,色 の３つ。\n  lcd.drawPixel(0, 0, 0xFFFF); // 座標0:0に白の点を描画\n\n\n// カラーコードを生成する関数が用意されており、色の指定に使用できます。\n// 引数は、赤,緑,青をそれぞれ 0～255で指定します。\n// 色情報の欠落を防ぐため、color888を使う事を推奨します。\n  lcd.drawFastVLine(2, 0, 100, lcd.color888(255,   0,   0)); // 赤で垂直の線を描画\n  lcd.drawFastVLine(4, 0, 100, lcd.color565(  0, 255,   0)); // 緑で垂直の線を描画\n  lcd.drawFastVLine(6, 0, 100, lcd.color332(  0,   0, 255)); // 青で垂直の線を描画\n\n\n// カラーコード生成関数を使用しない場合は以下のようになります。\n// RGB888 24ビットで指定 uint32_t型\n// RGB565 16ビットで指定 uint16_t型、int32_t型\n// RGB332  8ビットで指定 uint8_t型\n\n// uint32_t型を使用すると、RGB888の24ビットとして扱われます。\n// 16進数2桁で赤緑青の順に記述できます。\n// uint32_t型の変数を使うか、末尾にUを付けるか、uint32_t型にキャストして使用します。\n  uint32_t red = 0xFF0000;\n  lcd.drawFastHLine(0, 2, 100, red);            // 赤で水平の線を描画\n  lcd.drawFastHLine(0, 4, 100, 0x00FF00U);      // 緑で水平の線を描画\n  lcd.drawFastHLine(0, 6, 100, (uint32_t)0xFF); // 青で水平の線を描画\n\n\n// uint16_t型およびint32_t型を使用すると、RGB565の16ビットとして扱われます。\n// 特別な書き方をしない場合はint32_t型として扱われるので、この方式になります。\n// （AdafruitGFX や TFT_eSPI との互換性のために、このようにしています。）\n  uint16_t green = 0x07E0;\n  lcd.drawRect(10, 10, 50, 50, 0xF800);         // 赤で矩形の外周を描画\n  lcd.drawRect(12, 12, 50, 50, green);          // 緑で矩形の外周を描画\n  lcd.drawRect(14, 14, 50, 50, (uint16_t)0x1F); // 青で矩形の外周を描画\n\n\n// int8_t型、uint8_t型を使用すると、RGB332の8ビットとして扱われます。\n  uint8_t blue = 0x03;\n  lcd.fillRect(20, 20, 20, 20, (uint8_t)0xE0);  // 赤で矩形の塗りを描画\n  lcd.fillRect(30, 30, 20, 20, (uint8_t)0x1C);  // 緑で矩形の塗りを描画\n  lcd.fillRect(40, 40, 20, 20, blue);           // 青で矩形の塗りを描画\n\n\n// 描画関数の引数の色は省略できます。\n// 省略した場合、setColor関数で設定した色 または最後に使用した色を描画色として使用します。\n// 同じ色で繰り返し描画する場合は、省略した方がわずかに速く動作します。\n  lcd.setColor(0xFF0000U);                        // 描画色に赤色を指定\n  lcd.fillCircle ( 40, 80, 20    );               // 赤色で円の塗り\n  lcd.fillEllipse( 80, 40, 10, 20);               // 赤色で楕円の塗り\n  lcd.fillArc    ( 80, 80, 20, 10, 0, 90);        // 赤色で円弧の塗り\n  lcd.fillTriangle(80, 80, 60, 80, 80, 60);       // 赤色で三角の塗り\n  lcd.setColor(0x0000FFU);                        // 描画色に青色を指定\n  lcd.drawCircle ( 40, 80, 20    );               // 青色で円の外周\n  lcd.drawEllipse( 80, 40, 10, 20);               // 青色で楕円の外周\n  lcd.drawArc    ( 80, 80, 20, 10, 0, 90);        // 青色で円弧の外周\n  lcd.drawTriangle(60, 80, 80, 80, 80, 60);       // 青色で三角の外周\n  lcd.setColor(0x00FF00U);                        // 描画色に緑色を指定\n  lcd.drawBezier( 60, 80, 80, 80, 80, 60);        // 緑色で二次ベジエ曲線\n  lcd.drawBezier( 60, 80, 80, 20, 20, 80, 80, 60);// 緑色で三次ベジエ曲線\n\n// グラデーションの線を描画するdrawGradientLine は色の指定を省略できません。\n  lcd.drawGradientLine( 0, 80, 80, 0, 0xFF0000U, 0x0000FFU);// 赤から青へのグラデーション直線\n\n  delay(1000);\n\n// clearまたはfillScreenで画面全体を塗り潰せます。\n// fillScreenはfillRectの画面全体を指定したのと同じで、色の指定は描画色の扱いになります。\n  lcd.fillScreen(0xFFFFFFu);  // 白で塗り潰し\n  lcd.setColor(0x00FF00u);    // 描画色に緑色を指定\n  lcd.fillScreen();           // 緑で塗り潰し\n\n// clearは描画系の関数とは別で背景色という扱いで色を保持しています。\n// 背景色は出番が少ないですが、スクロール機能使用時の隙間を塗る色としても使用されます。\n  lcd.clear(0xFFFFFFu);       // 背景色に白を指定して塗り潰し\n  lcd.setBaseColor(0x000000u);// 背景色に黒を指定\n  lcd.clear();                // 黒で塗り潰し\n\n\n// SPIバスの確保と解放は描画関数を呼び出した時に自動的に行われますが、\n// 描画スピードを重視する場合は、描画処理の前後に startWriteとendWriteを使用します。\n// SPIバスの確保と解放が抑制され、速度が向上します。\n// 電子ペーパー(EPD)の場合、startWrite()以降の描画は、endWrite()を呼ぶ事で画面に反映されます。\n  lcd.drawLine(0, 1, 39, 40, red);       // SPIバス確保、線を描画、SPIバス解放\n  lcd.drawLine(1, 0, 40, 39, blue);      // SPIバス確保、線を描画、SPIバス解放\n  lcd.startWrite();                      // SPIバス確保\n  lcd.drawLine(38, 0, 0, 38, 0xFFFF00U); // 線を描画\n  lcd.drawLine(39, 1, 1, 39, 0xFF00FFU); // 線を描画\n  lcd.drawLine(40, 2, 2, 40, 0x00FFFFU); // 線を描画\n  lcd.endWrite();                        // SPIバス解放\n\n\n// startWriteとendWriteは呼出し回数を内部でカウントしており、\n// 繰り返し呼び出した場合は最初と最後のみ動作します。\n// startWriteとendWriteは必ず対になるように使用してください。\n// (SPIバスを占有して構わない場合は、最初にstartWriteを一度呼び、endWriteしない使い方も可能です。)\n  lcd.startWrite();     // カウント+1、SPIバス確保\n  lcd.startWrite();     // カウント+1\n  lcd.startWrite();     // カウント+1\n  lcd.endWrite();       // カウント-1\n  lcd.endWrite();       // カウント-1\n  lcd.endWrite();       // カウント-1、SPIバス解放\n  lcd.endWrite();       // 何もしない\n// なお過剰にendWriteを呼び出した場合は何も行わず、カウントがマイナスになることもありません。\n\n\n// startWriteのカウントの状態に依らず、強制的にSPIバスを解放・確保したい場合は、\n// endTransaction・beginTransactionを使用します。\n// カウントはクリアされないので、辻褄が合わなくならないよう注意してください。\n  lcd.startWrite();       // カウント+1、SPIバス確保\n  lcd.startWrite();       // カウント+1\n  lcd.drawPixel(0, 0);    // 描画\n  lcd.endTransaction();   // SPIバス解放\n  // ここで他のSPIデバイスの使用が可能\n  // 同じSPIバスの別のデバイス(SDカード等)を使う場合、\n  // 必ずSPIバスが解放された状態で行ってください。\n  lcd.beginTransaction(); // SPIバスの確保\n  lcd.drawPixel(0, 0);    // 描画\n  lcd.endWrite();         // カウント-1\n  lcd.endWrite();         // カウント-1、SPIバス解放\n\n\n\n// drawPixelとは別に、writePixelという点を描画する関数があります。\n// drawPixelは必要に応じてSPIバスの確保を行うのに対し、\n// writePixelはSPIバスの状態をチェックしません。\n  lcd.startWrite();  // SPIバス確保\n  for (uint32_t x = 0; x < 128; ++x) {\n    for (uint32_t y = 0; y < 128; ++y) {\n      lcd.writePixel(x, y, lcd.color888( x*2, x + y, y*2));"
        },
        {
          "name": "loop",
          "body": "static int count = 0;\n  static int a = 0;\n  static int x = 0;\n  static int y = 0;\n  static float zoom = 3;\n  ++count;\n  if ((a += 1) >= 360) a -= 360;\n  if ((x += 2) >= lcd.width()) x -= lcd.width();\n  if ((y += 1) >= lcd.height()) y -= lcd.height();\n  sprite.setPaletteColor(1, lcd.color888( 0, 0, count & 0xFF));\n  sprite.setPaletteColor(2, lcd.color888( 0,~count & 0xFF, 0));\n  sprite.setPaletteColor(3, lcd.color888( count & 0xFF, 0, 0));\n\n  sprite.pushRotateZoom(x, y, a, zoom, zoom, 0);\n\n  if ((count % 100) == 0) lcd.display(); // 電子ペーパーの場合の表示更新を 100回に一度行う"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// SPIバスとパネルの初期化を実行すると使用可能になります。\n  display.init();\n\n  display.setTextSize((std::max(display.width(), display.height()) + 255) >> 8);\n\n  // タッチが使用可能な場合のキャリブレーションを行います。（省略可）\n  if (display.touch())\n  {\n    if (display.width() < display.height()) display.setRotation(display.getRotation() ^ 1);\n\n    // 画面に案内文章を描画します。\n    display.setTextDatum(textdatum_t::middle_center);\n    display.drawString(\"touch the arrow marker.\", display.width()>>1, display.height() >> 1);\n    display.setTextDatum(textdatum_t::top_left);\n\n    // タッチを使用する場合、キャリブレーションを行います。画面の四隅に表示される矢印の先端を順にタッチしてください。\n    std::uint16_t fg = TFT_WHITE;\n    std::uint16_t bg = TFT_BLACK;\n    if (display.isEPD()) std::swap(fg, bg);\n    display.calibrateTouch(nullptr, fg, bg, std::max(display.width(), display.height()) >> 3);"
        },
        {
          "name": "loop",
          "body": "display.startWrite();\n  display.setRotation(++count & 7);\n  display.setColorDepth((count & 8) ? 16 : 24);\n\n  display.setTextColor(TFT_WHITE);\n  display.drawNumber(display.getRotation(), 16, 0);\n\n  display.setTextColor(0xFF0000U);\n  display.drawString(\"R\", 30, 16);\n  display.setTextColor(0x00FF00U);\n  display.drawString(\"G\", 40, 16);\n  display.setTextColor(0x0000FFU);\n  display.drawString(\"B\", 50, 16);\n\n  display.drawRect(30,30,display.width()-60,display.height()-60,count*7);\n  display.drawFastHLine(0, 0, 10);\n\n  display.endWrite();\n\n  int32_t x, y;\n  if (display.getTouch(&x, &y)) {\n    display.fillRect(x-2, y-2, 5, 5, count*7);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    while(!Serial);\n\n    delay(1000);\n\n    Serial.println(\"3-Wire Valve Demo\");\n\n    EdgeControl.begin();\n    Latching.begin();\n\n    Serial.println(\"Starting\");"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Closing\");\n    Latching.channelDirection(LATCHING_OUT_1, POSITIVE);\n    Latching.strobe(4500);\n\n    delay(2500);\n\n    Serial.println(\"Opening\");\n    Latching.channelDirection(LATCHING_OUT_1, NEGATIVE);\n    Latching.strobe(4500);\n    delay(2500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "drawGradation",
          "body": "// 背景にグラデーションを描画する\n  lcd.startWrite();\n  lcd.setAddrWindow(0, 0, lcd.width(), lcd.height());\n  for (int y = 0; y < lcd.height(); ++y) {\n    for (int x = 0; x < lcd.width(); ++x) {\n      lcd.writeColor(lcd.color888(x>>1, (x + y) >> 2, y>>1), 1);"
        },
        {
          "name": "setup",
          "body": "lcd.init();\n\n  drawGradation();\n\n  // 文字の描画方法には大きく分けて２通り、print 系の関数と drawString 系の関数があります。\n\n  // drawString 関数では、第１引数で文字列を指定し、第２引数でX座標、第３引数でY座標を指定します。\n  lcd.drawString(\"string!\", 10, 10);\n\n  // drawNumber 関数では、第１引数が数値になります。\n  lcd.drawNumber(123, 100, 10);\n\n  // drawFloat 関数では、第１引数が数値、第２引数が小数点以下の桁数になり、第３引数がX座標、第４引数がY座標になります。\n  lcd.drawFloat(3.14, 2, 150, 10);\n\n  // print 関数では、setCursor関数で指定した座標 (またはprint関数で最後に描画した文字の続き)に描画します。\n  lcd.setCursor(10, 20);\n  lcd.print(\"print!\");\n\n  // printf関数で、第２引数以降の内容を描画できます。(C言語のprintf準拠ですので文字列や浮動小数も描画できます)\n  int value = 123;\n  lcd.printf(\"test %d\", value);\n\n  // println関数で、文字列を描画後に改行できます。print(\"\\n\");と同じ効果です。\n  lcd.println(\"println\");\n\n  // フォントを変更するには、setFont関数を使用します。\n  // TFT_eSPIのsetTextFont関数と同じフォントは Font0 ～ Font8 になります。\n  // ※ エディタの入力支援が使える場合、引数に&fonts::まで入力する事でフォント一覧が表示されます\n  lcd.setFont(&fonts::Font4);\n  lcd.println(\"TestFont4\");\n\n  // TFT_eSPIとの互換性のためにsetTextFont関数による番号でのフォント変更にも対応しています。\n  // 引数に指定できる数字は 0, 2, 4, 6, 7, 8 です。(TFT_eSPI準拠です)\n  // ※ ただし この方法は、他の番号のフォントも強制的にバイナリに含まれサイズが膨らむため、非推奨です。\n  lcd.setTextFont(2);\n  lcd.println(\"TestFont2\");\n\n\n  // setTextColorで色を変更できます。\n  // １つ目の引数が文字色、２つ目の引数が背景色になります。\n  lcd.setTextColor(0x00FFFFU, 0xFF0000U);\n  lcd.print(\"CyanText RedBack\");\n  // ※ 同じ場所に文字を繰り返し描画し直したい場合、背景色を指定して重ね書きすることを推奨します。\n  //    fillRect等で消去してから書き直すと、ちらつきが発生する可能性があります。\n\n\n  // setTextColorで第１引数のみを指定し第２引数を省略した場合は、\n  // 背景を塗り潰さず文字だけを描画します。\n  lcd.setTextColor(0xFFFF00U);\n  lcd.print(\"YellowText ClearBack\");\n\n\n  // Font6は時計用の文字のみが収録されています。\n  lcd.setFont(&fonts::Font6);\n  lcd.print(\"apm.:-0369\");\n\n  // Font7は７セグメント液晶風のフォントが収録されています。\n  lcd.setFont(&fonts::Font7);\n  lcd.print(\".:-147\");\n\n  // Font8は数字のみが収録されています。\n  lcd.setFont(&fonts::Font8);\n  lcd.print(\".:-258\");\n\n\n  delay(3000);\n  drawGradation();\n\n// IPAフォントをコンバートした日本語フォントが４種類ｘ９サイズ = 36通りプリセットされています。\n// 末尾の数字がサイズを表しており、8, 12, 16, 20, 24, 28, 32, 36, 40 が用意されています。\n// fonts::lgfxJapanMincho_12      // 明朝体 サイズ12 固定幅フォント\n// fonts::lgfxJapanMinchoP_16     // 明朝体 サイズ16 プロポーショナルフォント\n// fonts::lgfxJapanGothic_20      // ゴシック体 サイズ20 固定幅フォント\n// fonts::lgfxJapanGothicP_24     // ゴシック体 サイズ24 プロポーショナルフォント\n\n// efontをコンバートした日本語・韓国語・中国語（簡体字・繁体字）フォントが各４種類ｘ５サイズ＝20通りプリセットされています。\n// 数字がサイズを表しており、10, 12, 14, 16, 24 が用意されています。\n// 末尾の文字は b= ボールド(太字) / i= イタリック(斜体) を表しています。\n// fonts::efontJA_10              // 日本語 サイズ10\n// fonts::efontCN_12_b            // 簡体字 サイズ12 ボールド\n// fonts::efontTW_14_bi           // 繁体字 サイズ14 ボールドイタリック\n// fonts::efontKR_16_i            // 韓国語 サイズ16 イタリック\n\n  lcd.setCursor(0, 0);\n  lcd.setFont(&fonts::lgfxJapanMincho_16);   lcd.print(\"明朝体 16 Hello World\\nこんにちは世界\\n\");\n//lcd.setFont(&fonts::lgfxJapanMinchoP_16);  lcd.print(\"明朝 P 16 Hello World\\nこんにちは世界\\n\");\n  lcd.setFont(&fonts::lgfxJapanGothic_16);   lcd.print(\"ゴシック体 16 Hello World\\nこんにちは世界\\n\");\n//lcd.setFont(&fonts::lgfxJapanGothicP_16);  lcd.print(\"ゴシック P 16 Hello World\\nこんにちは世界\\n\");\n\n// ※ やまねこ氏の [日本語フォントサブセットジェネレーター](https://github.com/yamamaya/lgfxFontSubsetGenerator)\n//    を使用することで、必要な文字だけを含む小サイズのフォントデータを作成できます。\n\n\n  delay(3000);\n  drawGradation();\n\n\n  // LovyanGFXでは AdafruitGFX フォントも setFont 関数で使用できます。\n  // (TFT_eSPIとの互換性のために setFreeFont関数も用意しています)\n  lcd.setFont(&fonts::FreeSerif9pt7b);\n\n\n  // 右揃え や 中央揃え で描画したい場合は、setTextDatum 関数で基準位置を指定します。\n  // 縦方向が top、middle、baseline、bottomの4通り、横方向が left、center、rightの3通りです。\n  // 縦と横の指定を組み合わせた12通りの中から指定します。\n  lcd.setTextDatum( textdatum_t::top_left        );\n  lcd.setTextDatum( textdatum_t::top_center      );\n  lcd.setTextDatum( textdatum_t::top_right       );\n  lcd.setTextDatum( textdatum_t::middle_left     );\n  lcd.setTextDatum( textdatum_t::middle_center   );\n  lcd.setTextDatum( textdatum_t::middle_right    );\n  lcd.setTextDatum( textdatum_t::baseline_left   );\n  lcd.setTextDatum( textdatum_t::baseline_center );\n  lcd.setTextDatum( textdatum_t::baseline_right  );\n  lcd.setTextDatum( textdatum_t::bottom_left     );\n  lcd.setTextDatum( textdatum_t::bottom_center   );\n  lcd.setTextDatum( textdatum_t::bottom_right    );\n  // ※  \"textdatum_t::\" は省略可能です\n  // ※ print系関数には縦方向の指定のみ効果があり、横方向の指定は効果がありません。\n\n  // 右下揃え\n  lcd.setTextDatum( bottom_right );\n  lcd.drawString(\"bottom_right\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 左下揃え\n  lcd.setTextDatum( bottom_left );\n  lcd.drawString(\"bottom_left\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 右上揃え\n  lcd.setTextDatum( top_right );\n  lcd.drawString(\"top_right\",  lcd.width() / 2,  lcd.height() / 2);\n\n  // 左上揃え\n  lcd.setTextDatum( top_left );\n  lcd.drawString(\"top_left\",  lcd.width() / 2,  lcd.height() / 2);\n\n\n  // 基準座標に中心線を描画\n  lcd.drawFastVLine(lcd.width() / 2, 0, lcd.height(), 0xFFFFFFU);\n  lcd.drawFastHLine(0, lcd.height() / 2, lcd.width(), 0xFFFFFFU);\n\n\n  delay(3000);\n  drawGradation();\n\n  lcd.setFont(&Font2);\n  lcd.setCursor(0, 0);\n\n\n  lcd.drawRect(8, 8, lcd.width() - 16, lcd.height() - 16, 0xFFFFFFU);\n\n  // setClipRect関数で描画する範囲を限定できます。指定した範囲外には描画されなくなります。\n  // ※ テキスト系のみならず、すべての描画関数に影響します。\n  lcd.setClipRect(10, 10, lcd.width() - 20, lcd.height() - 20);\n\n\n  // setTextSize 関数で 文字の拡大率を指定します。\n  // 第１引数で横方向の倍率、第２引数で縦方向の倍率を指定します。\n  // 第２引数を省略した場合は、第１引数の倍率が縦と横の両方に反映されます。\n  lcd.setTextSize(2.7, 4);\n  lcd.println(\"Size 2.7 x 4\");\n\n  lcd.setTextSize(2.5);\n  lcd.println(\"Size 2.5 x 2.5\");\n\n  lcd.setTextSize(1.5, 2);\n  lcd.println(\"Size 1.5 x 2\");\n\n  delay(1000);\n\n  lcd.setTextColor(0xFFFFFFU, 0);\n  for (float i = 0; i < 30; i += 0.01) {\n    lcd.setTextSize(sin(i)+1.1, cos(i)+1.1);\n    lcd.drawString(\"size test\", 10, 10);"
        },
        {
          "name": "drawNumberTest",
          "body": "lcd.setFont(font);\n\n  lcd.fillScreen(0x0000FF);\n\n  lcd.setColor(0xFFFF00U);\n  lcd.drawFastVLine( 80, 0, 240);\n  lcd.drawFastVLine(160, 0, 240);\n  lcd.drawFastVLine(240, 0, 240);\n  lcd.drawFastHLine(0,  45, 320);\n  lcd.drawFastHLine(0,  95, 320);\n  lcd.drawFastHLine(0, 145, 320);\n  lcd.drawFastHLine(0, 195, 320);\n\n  for (int i = 0; i < 200; ++i) {\n    lcd.setTextDatum( textdatum_t::bottom_right    );     lcd.drawNumber(i,  80,  45);\n    lcd.setTextDatum( textdatum_t::bottom_center   );     lcd.drawNumber(i, 160,  45);\n    lcd.setTextDatum( textdatum_t::bottom_left     );     lcd.drawNumber(i, 240,  45);\n    lcd.setTextDatum( textdatum_t::baseline_right  );     lcd.drawNumber(i,  80,  95);\n    lcd.setTextDatum( textdatum_t::baseline_center );     lcd.drawNumber(i, 160,  95);\n    lcd.setTextDatum( textdatum_t::baseline_left   );     lcd.drawNumber(i, 240,  95);\n    lcd.setTextDatum( textdatum_t::middle_right    );     lcd.drawNumber(i,  80, 145);\n    lcd.setTextDatum( textdatum_t::middle_center   );     lcd.drawNumber(i, 160, 145);\n    lcd.setTextDatum( textdatum_t::middle_left     );     lcd.drawNumber(i, 240, 145);\n    lcd.setTextDatum( textdatum_t::top_right       );     lcd.drawNumber(i,  80, 195);\n    lcd.setTextDatum( textdatum_t::top_center      );     lcd.drawNumber(i, 160, 195);\n    lcd.setTextDatum( textdatum_t::top_left        );     lcd.drawNumber(i, 240, 195);"
        },
        {
          "name": "loop",
          "body": "// ※ 名前が\"Free\"で始まるフォントは 9pt 12pt 18pt 24ptの４種類があります。\n  drawNumberTest( &fonts::Font0                   );\n  drawNumberTest( &fonts::Font2                   );\n  drawNumberTest( &fonts::Font4                   );\n  drawNumberTest( &fonts::Font6                   );\n  drawNumberTest( &fonts::Font7                   );\n  drawNumberTest( &fonts::Font8                   );\n  drawNumberTest( &fonts::TomThumb                );\n  drawNumberTest( &fonts::FreeMono9pt7b           );\n  drawNumberTest( &fonts::FreeMonoBold9pt7b       );\n  drawNumberTest( &fonts::FreeMonoOblique9pt7b    );\n  drawNumberTest( &fonts::FreeMonoBoldOblique9pt7b);\n  drawNumberTest( &fonts::FreeSans9pt7b           );\n  drawNumberTest( &fonts::FreeSansBold9pt7b       );\n  drawNumberTest( &fonts::FreeSansOblique9pt7b    );\n  drawNumberTest( &fonts::FreeSansBoldOblique9pt7b);\n  drawNumberTest( &fonts::FreeSerif9pt7b          );\n  drawNumberTest( &fonts::FreeSerifBold9pt7b      );\n  drawNumberTest( &fonts::FreeSerifItalic9pt7b    );\n  drawNumberTest( &fonts::FreeSerifBoldItalic9pt7b);\n  drawNumberTest( &fonts::Orbitron_Light_24       );\n  drawNumberTest( &fonts::Roboto_Thin_24          );\n  drawNumberTest( &fonts::Satisfy_24              );\n  drawNumberTest( &fonts::Yellowtail_32           );"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n    auto startNow = millis() + 2500;\n    while (!Serial && millis() < startNow)\n        ;\n\n    delay(1000);\n    Serial.println(\"Hello, Challenge!\");\n\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_19V);\n\n    Wire.begin();\n    Expander.begin();\n\n    Serial.print(\"Waiting for IO Expander Initialization...\");\n    while (!Expander) {\n        Serial.print(\".\");\n        delay(100);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"4-20mA Input Channel \");\n    switch (inputChannels[inputChannelIndex]) {\n        case INPUT_420mA_CH01: Serial.print(\"01\"); break;\n        case INPUT_420mA_CH02: Serial.print(\"02\"); break;\n        case INPUT_420mA_CH03: Serial.print(\"03\"); break;\n        case INPUT_420mA_CH04: Serial.print(\"04\"); break;\n        default: break;"
        }
      ]
    },
    {
      "name": "R",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "lcd.init();\n  lcd.startWrite();"
        },
        {
          "name": "loop",
          "body": "/*\n  画像データを描画する関数は幾つか種類があります。\n\n方法１．事前に描画範囲を設定しておき、次にデータの長さを指定して描画する方法\n方法２．描画する座標と幅・高さを指定してデータを描画する方法\n\n\n\n方法１．事前に描画範囲を設定しておき、次にデータの長さを指定して描画する方法\n\nこの方法では、setWindow/setAddrWindow関数で描画範囲を設定したあと、\nwritePixels/pushPixels関数で画像データの長さを指定して描画します。\n\n  setWindow( x0, y0, x1, y1 );   // 描画範囲の指定。左上座標と右下座標を指定します。\n  setAddrWindow( x, y, w, h );   // 描画範囲の指定。左上座標と幅と高さを指定します。\n\nsetWindow は画面外の座標を指定した場合の動作は保証されません。\nsetAddrWindow は描画範囲外が指定された場合は範囲内に調整されます。\n ※ ただし自動調整された結果、実際に設定される幅や高さが指定した値より小さくなる可能性があるので注意が必要です。\n\n  writePixels   ( *data, len, swap );  // 画像を描画する。(事前にstartWrite、事後にendWriteが必要）\n  pushPixels    ( *data, len, swap );  // 画像を描画する。(startWrite・endWriteは不要）\n\n ※ writePixelsはAdafruitGFX由来の関数で、pushPixelsはTFT_eSPI由来の関数です。\n    描画内容は同等ですが、startWrite/endWriteが自動で行われるか否かが違います。\n\n第１引数：画像データのポインタ（データ型に応じて色の形式を判断して変換が行われます。）\n第２引数：画像データのピクセル数（バイト数でない点に注意。）\n第３引数：バイト順変換フラグ（省略時は事前にsetSwapBytes関数で設定した値が使用されます。）\n\n第１引数のdataの型に基づいて色の形式変換が行われます。\n  uint8_t*  の場合、 8bitカラー RGB332として扱います。\n  uint16_t* の場合、16bitカラー RGB565として扱います。\n  void*     の場合、24bitカラー RGB888として扱います。\n ※ （３バイトのプリミティブ型が無いため、void*型を24bitカラー扱いとしています）\n\n ※ LCDに描画する際に、LCDの色数モードに応じて色形式の変換が自動的に行われます。\n*/\n  lcd.clear(TFT_DARKGREY);\n  lcd.setColorDepth(16);  // LCDを16bitカラーモードに設定する。\n  lcd.setSwapBytes(true); // バイト順変換を有効にする。\n  int len = image_width * image_height;\n\n  // 画像の幅と高さをsetAddrWindowで事前に設定し、writePixelsで描画します。\n  lcd.setAddrWindow(0, 0, image_width, image_height);         // 描画範囲を設定。\n  lcd.writePixels((uint16_t*)rgb565, len); // RGB565の16bit画像データを描画。\n\n  // データとバイト順変換の指定が一致していない場合、色化けします。\n  lcd.setAddrWindow(0, 40, image_width, image_height);\n  // 第3引数でfalseを指定することでバイト順変換の有無を指定できます。\n  lcd.writePixels((uint16_t*)rgb565, len, false); // RGB565の画像をバイト順変換無しで描画すると色が化ける。\n\n  // 描画範囲が画面外にはみ出すなどして画像の幅や高さと合わなくなった場合、描画結果が崩れます。\n  lcd.setAddrWindow(-1, 80, image_width, image_height); // X座標が-1（画面外）のため、正しく設定できない。\n  lcd.writePixels((uint16_t*)rgb565, len); // 描画先の幅と画像の幅が不一致のため描画内容が崩れる。\n\n  // データと型が一致していない場合も、描画結果が崩れます。\n  lcd.setAddrWindow(0, 120, image_width, image_height);\n  // RGB565のデータをわざとuint8_tにキャストし、RGB332の8bitカラーとして扱わせる。\n  lcd.writePixels((uint8_t*)rgb565, len);  // 画像の形式と型が一致していないため描画が乱れる。\n\n  // データと型が一致していれば、描画先の色数に合わせて適切な形式変換が行われます。\n  lcd.setAddrWindow(0, 160, image_width, image_height);\n  lcd.writePixels((uint8_t*)rgb332, len);  // RGB332のデータでも16bitカラーのLCDに正しく描画できる。\n\n\n// ※ LCDへの画像データの送信は、メモリの若いアドレスにあるデータから順に1Byte単位で送信されます。\n//    このため、例えばRGB565の16bit型のデータを素直にuint16_tの配列で用意すると、送信の都合としてはバイト順が入れ替わった状態になります。\n//    この場合は事前にsetSwapBytes(true)を使用したり、第３引数にtrueを指定する事で、バイト順の変換が行われて正常に描画できます。\n//    なお用意する画像データを予め上位下位バイトを入れ替えた状態で作成すれば、この変換は不要になり速度面で有利になります。\n\n  lcd.setAddrWindow(40,  0, image_width, image_height);\n  lcd.writePixels((uint16_t*)swap565, len, false); // 予め上位下位が入れ替わった16bitデータの場合はバイト順変換を無効にする。\n\n  lcd.setAddrWindow(40, 40, image_width, image_height);\n  lcd.writePixels((uint16_t*)swap565, len, true);  // 逆に、予め上位下位が入れ替わったデータにバイト順変換を行うと色が化ける。\n\n  lcd.setAddrWindow(40, 80, image_width, image_height);\n  lcd.writePixels((void*)rgb888, len, true);  // 24bitのデータも同様に、RGB888の青が下位側にあるデータはバイト順変換が必要。\n\n  lcd.setAddrWindow(40, 120, image_width, image_height);\n  lcd.writePixels((void*)bgr888, len, false);  // 同様に、BGR888の赤が下位側にあるデータはバイト順変換は不要。\n\n  lcd.setAddrWindow(40, 160, image_width, image_height);\n  lcd.writePixels((void*)bgr888, len, true);  // 設定を誤ると、色が化ける。（赤と青が入れ替わる）\n\n  lcd.display();\n  delay(4000);\n  lcd.clear(TFT_DARKGREY);\n\n/*\n方法２．描画する座標と幅・高さを指定してデータを描画する方法\n\nこの方法では、pushImage関数を用いて描画範囲と描画データを指定して描画します。\n\n  pushImage( x, y, w, h, *data);                  // 指定された座標に画像を描画する。\n\n方法１と違い、画面外にはみ出す座標を指定しても描画が乱れることはありません。（はみ出した部分は描画されません。）\n方法１と違い、バイト順の変換を指定する引数が無いため、事前にsetSwapBytesによる設定が必要です。\nなお方法１と同様に、dataの型に応じて色変換が行われます。\n*/\n\n  lcd.setSwapBytes(true); // バイト順変換を有効にする。\n\n  // 描画先の座標と画像の幅・高さを指定して画像データを描画します。\n  lcd.pushImage(   0, 0, image_width, image_height, (uint16_t*)rgb565); // RGB565の16bit画像データを描画。\n\n  // データとバイト順変換の指定が一致していない場合、色化けします。\n  lcd.pushImage(   0, 40, image_width, image_height, (uint16_t*)swap565); // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n\n  // 描画範囲が画面外にはみ出すなどした場合でも、描画結果が崩れることはありません。\n  lcd.pushImage(-1, 80, image_width, image_height, (uint16_t*)rgb565); // X座標-1（画面外）を指定しても描画は乱れない。\n\n  // データと型が一致していない場合は、描画結果が崩れます。\n  lcd.pushImage(0, 120, image_width, image_height, (uint8_t*)rgb565); // RGB565のデータをuint8_tにキャストし、RGB332として扱わせると描画が乱れる。\n\n  // データと型が一致していれば、適切に形式変換が行われます。\n  lcd.pushImage(0, 160, image_width, image_height, (uint8_t*)rgb332); // RGB332のデータでも正しく描画できる。\n\n\n  lcd.setSwapBytes(false);   // バイト順の変換を無効にする。\n  lcd.pushImage( 40,   0, image_width, image_height, (uint8_t* )rgb332);  // good. RGB332のデータはバイト順変換の影響を受けない。\n  lcd.pushImage( 40,  40, image_width, image_height, (uint16_t*)rgb565);  // NG. RGB565のデータはバイト順変換が必要。\n  lcd.pushImage( 40,  80, image_width, image_height, (void*    )rgb888);  // NG. RGB888のデータはバイト順変換が必要。\n  lcd.pushImage( 40, 120, image_width, image_height, (uint16_t*)swap565); // good. バイト順変換済みRGB565のデータは色化けしない。\n  lcd.pushImage( 40, 160, image_width, image_height, (void*    )bgr888);  // good. バイト順変換済みRGB888のデータは色化けしない。\n\n  lcd.setSwapBytes(true);   // バイト順の変換を有効にする。\n  lcd.pushImage( 80,   0, image_width, image_height, (uint8_t* )rgb332);  // good. RGB332のデータはバイト順変換の影響を受けない。\n  lcd.pushImage( 80,  40, image_width, image_height, (uint16_t*)rgb565);  // good. バイト順変換が有効ならRGB565のデータは色化けしない。\n  lcd.pushImage( 80,  80, image_width, image_height, (void*    )rgb888);  // good. バイト順変換が有効ならRGB888のデータは色化けしない。\n  lcd.pushImage( 80, 120, image_width, image_height, (uint16_t*)swap565); // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n  lcd.pushImage( 80, 160, image_width, image_height, (void*    )bgr888);  // NG. バイト順変換済みデータにバイト順変換を行うと色化けする。\n\n// データの型として、lgfx::名前空間に定義されている型を利用する事もできます。\n// これらの型にキャストする場合はsetSwapBytesの設定は無視されます。\n  lcd.pushImage(120,   0, image_width, image_height, (lgfx:: rgb332_t*) rgb332); // good  8bitデータ\n  lcd.pushImage(120,  40, image_width, image_height, (lgfx:: rgb565_t*) rgb565); // good 16bitデータ\n  lcd.pushImage(120,  80, image_width, image_height, (lgfx:: rgb888_t*) rgb888); // good 24bitデータ\n  lcd.pushImage(120, 120, image_width, image_height, (lgfx::swap565_t*)swap565); // good バイト順変換済み16bitデータ\n  lcd.pushImage(120, 160, image_width, image_height, (lgfx:: bgr888_t*) bgr888); // good バイト順変換済み24bitデータ\n\n// 第６引数で透過色を指定できます。透過指定された色のある部分は描画されません。\n  lcd.pushImage(160,   0, image_width, image_height, (lgfx:: rgb332_t*) rgb332, 0);                   // 黒を透過指定\n  lcd.pushImage(160,  40, image_width, image_height, (lgfx:: rgb565_t*) rgb565, (uint8_t)0xE0);       // 赤を透過指定\n  lcd.pushImage(160,  80, image_width, image_height, (lgfx:: rgb888_t*) rgb888, (uint16_t)0x07E0);    // 緑を透過指定\n  lcd.pushImage(160, 120, image_width, image_height, (lgfx::swap565_t*)swap565, (uint32_t)0x0000FFU); // 青を透過指定\n  lcd.pushImage(160, 160, image_width, image_height, (lgfx:: bgr888_t*) bgr888, TFT_WHITE);           // 白を透過指定\n\n  lcd.display();\n  delay(4000);\n  lcd.clear(TFT_DARKGREY);\n\n// pushImageRotateZoom関数を使うと、画像を回転拡大縮小させて描画できます。\n  for (int angle = 0; angle <= 360; ++angle) {\n    lcd.pushImageRotateZoom\n      ( lcd.width()  >> 2  // 描画先の中心座標X\n      , lcd.height() >> 1  // 描画先の中心座標Y\n      , image_width  >> 1  // 画像の中心座標X\n      , image_height >> 1  // 画像の中心座標Y\n      , angle              // 回転角度\n      , 3.0                // X方向の描画倍率 (マイナス指定で反転可能)\n      , 3.0                // Y方向の描画倍率 (マイナス指定で反転可能)\n      , image_width        // 画像データの幅\n      , image_height       // 画像データの高さ\n      , rgb332             // 画像データのポインタ\n      );\n\n// pushImageRotateZoomWithAA関数を使うと、アンチエイリアスが有効になります。\n    lcd.pushImageRotateZoomWithAA\n      ( lcd.width()*3>> 2\n      , lcd.height() >> 1\n      , image_width  >> 1\n      , image_height >> 1\n      , angle\n      , 3.0\n      , 3.0\n      , image_width\n      , image_height\n      , rgb332\n      );\n\n    if ((angle % 36) == 0) { lcd.display();"
        }
      ]
    },
    {
      "name": "EXPANDER_ID",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n//\twhile (!Serial);\t\t// For Leonardo only. No effect on other Arduino.\n\n\tAccessories::begin();\n\n\t// Ports setups\n\n\texpander.begin(EXPANDER_ID, 1, 2, 3, 4);\n\n\tPortLight0.begin(EXPANDER_PIN(EXPANDER_ID, 0), DIGITAL);\n\tPortLight1.begin(EXPANDER_PIN(EXPANDER_ID, 4), DIGITAL);\n\tPortLight2.begin(EXPANDER_PIN(EXPANDER_ID, 7), DIGITAL);\n\t\n\t// Accessories setups\n\n    // Declare accessories.\n\tlight0.begin(&PortLight0, 1, 1000);\n\tlight1.begin(&PortLight1, 2, 550);\n\tlight2.begin(&PortLight2, 3, 1500);\n\t\n\t// Declare light fading/dimming.\n\t//light0.SetFading(20, 10);\n\t//light1.SetFading(20, 10);\n\t//light2.SetFading(20, 10);\n\n\tlight0.Blink();\n\tlight1.Blink();\n\tlight2.Blink();"
        },
        {
          "name": "loop",
          "body": "Accessories::loop();"
        }
      ]
    },
    {
      "name": "FAULT_ADDRESS",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  A4963.begin();\n  \n  A4963.setPWM(pwm_value);"
        },
        {
          "name": "ping",
          "body": "Serial.write(\"A4963\");"
        },
        {
          "name": "write",
          "body": "uint8_t data[3];\n  Serial.readBytes(data, 3);\n  \n  uint16_t address=data[0];\n  uint16_t value=(uint16_t(data[1]) | uint16_t(data[2])<<8);\n  uint16_t result=0;\n\n  if(address<8)\n  {\n    result=A4963.write(address<<13, value);"
        },
        {
          "name": "read",
          "body": "uint8_t data[1];\n  Serial.readBytes(data, 1);\n  \n  uint16_t address=data[0];\n  uint16_t result=0;\n\n  if(address<8)\n  {\n    result=A4963.read(address<<13);"
        },
        {
          "name": "loop",
          "body": "uint8_t command=Serial.read();\n  switch(command)\n  {\n    case 'p':\n      ping();\n      break;\n    case 'w':\n      write();\n      break;\n    case 'r':\n      read();\n      break;\n    default:;"
        }
      ]
    },
    {
      "name": "LED_PIN",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "A4990MotorShield.h"
      ],
      "functions": [
        {
          "name": "stopIfFault",
          "body": "if (motors.getFault())\n  {\n    motors.setSpeeds(0,0);\n    Serial.println(\"Fault\");\n    while(1);"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_PIN, OUTPUT);\n  Serial.begin(115200);\n  Serial.println(\"Pololu A4990 Dual Motor Driver Shield for Arduino\");\n  \n  // uncomment one or both of the following lines if your motors' directions need to be flipped\n  //motors.flipM1(true);\n  //motors.flipM2(true);"
        },
        {
          "name": "loop",
          "body": "// run M1 motor with positive speed\n\n  digitalWrite(LED_PIN, HIGH);\n  \n  for (int speed = 0; speed <= 400; speed++)\n  {\n    motors.setM1Speed(speed);\n    stopIfFault();\n    delay(2);"
        }
      ]
    },
    {
      "name": "RCVSIZE",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "stdio.h",
        "adk.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "cpu_irq_enable();\n  printf(\"\\r\\nADK demo start\\r\\n\");\n  delay(200);"
        },
        {
          "name": "loop",
          "body": "uint8_t buf[RCVSIZE];\n  uint32_t nbread = 0;\n  char helloworld[] = \"Hello World!\\r\\n\";\n\n  Usb.Task();\n\n  if (adk.isReady()) {\n    /* Write hello string to ADK */\n    adk.write(strlen(helloworld), (uint8_t *)helloworld);\n\n    delay(1000);\n\n    /* Read data from ADK and print to UART */\n    adk.read(&nbread, RCVSIZE, buf);\n    if (nbread > 0) {\n      printf(\"RCV: \");\n      for (uint32_t i = 0; i < nbread; ++i) {\n        printf(\"%c\", (char)buf[i]);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoBearSSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"Key: \");\n  printHex(key, 16);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(enc_iv, 16);\n  Serial.println(\" \");\n  Serial.print(\"AES128 Encryption of '\");\n  printHex(input, 16);\n  Serial.print(\"' is 0x\");\n  AES128.runEnc(key, 16, input, 16, enc_iv);   // expect 0x65D0F7758B094114AFA6D33A5EA0716A\n  printHex(input, 16);\n  Serial.println(\" \");\n  Serial.println(\" \");\n  Serial.print(\"Key: \");\n  printHex(key, 16);\n  Serial.println(\" \");\n  Serial.print(\"IV: \");\n  printHex(dec_iv, 16);\n  Serial.println(\" \");\n  Serial.print(\"AES128 Decryption of '\");\n  printHex(input, 16);\n  Serial.print(\"' is 0x\");\n  AES128.runDec(key, 16, input, 16, dec_iv);\n  printHex(input, 16);\n  Serial.println(\" \");\n  while (1);"
        },
        {
          "name": "printHex",
          "body": "for (byte i = 0; i < size; i = i + 1) {\n    if (text[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AccelStepper.h",
        "AFMotor.h"
      ],
      "functions": [
        {
          "name": "forwardstep",
          "body": "motor1.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep",
          "body": "motor1.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n   Serial.println(\"Stepper test!\");\n  \n   stepper.setSpeed(50);"
        },
        {
          "name": "loop",
          "body": "stepper.runSpeed();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "AccelStepper.h",
        "AFMotor.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "body": "motor1.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "body": "motor1.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "forwardstep2",
          "body": "motor2.onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep2",
          "body": "motor2.onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "body": "stepper1.setMaxSpeed(200.0);\n    stepper1.setAcceleration(100.0);\n    stepper1.moveTo(24);\n    \n    stepper2.setMaxSpeed(300.0);\n    stepper2.setAcceleration(100.0);\n    stepper2.moveTo(1000000);"
        },
        {
          "name": "loop",
          "body": "// Change direction at the limits\n    if (stepper1.distanceToGo() == 0)\n\tstepper1.moveTo(-stepper1.currentPosition());\n    stepper1.run();\n    stepper2.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize AX.25 client\n  Serial.print(F(\"[AX.25] Initializing ... \"));\n  // source station callsign:     \"N7LEM\"\n  // source station SSID:         0\n  // preamble length:             8 bytes\n  int16_t state = ax25.begin(\"N7LEM\");\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[APRS] Sending position ... \"));\n  \n  // send a location without message or timestamp\n  char destination[] = \"N0CALL\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  int state = aprs.sendPosition(destination, 0, latitude, longitude);\n  delay(500);\n  \n  // send a location with message and without timestamp\n  char message[] = \"I'm here!\";\n  state |= aprs.sendPosition(destination, 0, latitude, longitude, message);\n  delay(500);\n  \n  // send a location with message and timestamp\n  char timestamp[] = \"093045z\";\n  state |= aprs.sendPosition(destination, 0, latitude, longitude, message, timestamp);\n  delay(500);\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[AFSK] Executing Order 66 ... \"));\n\n  // calculate whole note duration\n  int wholenote = (60000 * 4) / 120;\n\n  // iterate over the melody\n  for(unsigned int note = 0; note < sizeof(melody) / sizeof(melody[0]); note += 2) {\n    // calculate the duration of each note\n    int noteDuration = 0;\n    int divider = melody[note + 1];\n    if(divider > 0) {\n      // regular note, just proceed\n      noteDuration = wholenote / divider;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// AFSKClient can be used to transmit tones,\n  // same as Arduino tone() function\n  \n  // 400 Hz tone\n  Serial.print(F(\"[AFSK] 400 Hz tone ... \"));\n  audio.tone(400);\n  delay(1000);\n\n  // silence\n  Serial.println(F(\"done!\"));\n  audio.noTone();\n  delay(1000);\n\n  // AFSKClient can also be used to transmit HAM-friendly\n  // RTTY, Morse code, Hellschreiber, SSTV and AX.25.\n  // Details on how to use AFSK are in the example\n  // folders for each of the above modes."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// AFSKClient can be used to transmit tones,\n  // same as Arduino tone() function\n\n  // 400 Hz tone\n  Serial.print(F(\"[AFSK] 400 Hz tone ... \"));\n  audio.tone(400);\n  delay(1000);\n\n  // silence\n  Serial.println(F(\"done!\"));\n  audio.noTone();\n  delay(1000);\n\n  // AFSKClient can also be used to transmit HAM-friendly\n  // RTTY, Morse code, Hellschreiber, SSTV and AX.25.\n  // Details on how to use AFSK are in the example\n  // folders for each of the above modes.\n\n  // CAUTION: Unlike standard AFSK, the result when using OOK\n  // must be demodulated as AM!"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(13, OUTPUT); // Set Digital Pin 13 as an Output"
        },
        {
          "name": "loop",
          "body": "digitalWrite(13, HIGH); // Turn the LED ON\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)\n\tdigitalWrite(13, LOW); // Turn the LED OFF\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(12, INPUT_PULLUP); // Set Digital Pin 12 as an Input with a Pullup to 5V\n\tpinMode(13, OUTPUT); // Set Digital Pin 13 as an Output"
        },
        {
          "name": "loop",
          "body": "// See if button is being pushed\n\t// BUtton UN-Pushed returns high (pull-up)\n\t// Button PUSHED returns LOW (switch connects D12 to Ground)\n\t// Notice the double == in the line below\n\t// - a single = sets the two sides equal (not what we want)\n\t// - a double == Compares the two sides\n\tif (digitalRead(12) == LOW)\n\t{\n\t\t// Button is pressed, wait until it's released\n\t\twhile (digitalRead(12) == LOW)\n\t\t\t; // Do nothing while we wait\n\t\tblink = !blink; // Reverse the value of blink (if it was true, make it false, and vice-versa)\n\t\tledState = LOW;\n\t\tdigitalWrite(13, ledState);\n\t\tdelay(200); // Delay for 200ms to ignore any \"bounce\" in the switch"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(buzzer_pin, OUTPUT); // Configure the buzzer pin as an output pin"
        },
        {
          "name": "loop",
          "body": "// Play low to high frequencies\n\tfor(i = 25; i < 120; i++)\n\t{\n\t\ttone(buzzer_pin, 20 * i, 200); // Create a tone/note from 500 to 2400 Hz\n\t\tdelay(20);"
        }
      ]
    },
    {
      "name": "USE_ALB_DS1302",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Start Serial port so we can see the results\n\n\tSerial.println(\"DS1302RTC Read Test\");\n\tSerial.println(\"-------------------\");\n\n\tSerial.println(\"RTC module activated\");\n\tSerial.println();\n\tdelay(500);\n\n\tif (RTC.haltRTC())\n\t{\n\t\tSerial.println(\"The DS1302 is stopped.  Set the time as shown\");\n\t\tSerial.println(\"below to initialize the clock and begin running.\");\n\t\tSerial.println();"
        },
        {
          "name": "loop",
          "body": "tmElements_t tm;\n\ttime_t t;\n\n\t//check for input to set the RTC, minimum length is 12, i.e. yy,m,d,h,m,s\n\tif (Serial.available() >= 12)\n\t{\n\t\t//note that the tmElements_t Year member is an offset from 1970,\n\t\t//but the RTC wants the last two digits of the calendar year.\n\t\t//use the convenience macros from Time.h to do the conversions.\n\t\tint y = Serial.parseInt();\n\t\tif (y >= 100 && y < 1000)\n\t\t\tSerial.println(\"Error: Year must be two digits or four digits!\");\n\t\telse\n\t\t{\n\t\t\tif (y >= 1000)\n\t\t\t\ttm.Year = CalendarYrToTm(y);\n\t\t\telse    //(y < 100)\n\t\t\t\ttm.Year = y2kYearToTm(y);\n\t\t\ttm.Month = Serial.parseInt();\n\t\t\ttm.Day = Serial.parseInt();\n\t\t\ttm.Hour = Serial.parseInt();\n\t\t\ttm.Minute = Serial.parseInt();\n\t\t\ttm.Second = Serial.parseInt();\n\t\t\tt = makeTime(tm);\n\t\t\t//use the time_t value to ensure correct weekday is set\n\t\t\tif(RTC.set(t) == 0)   // Success\n\t\t\t{\n\t\t\t\tsetTime(t);\n\t\t\t\tSerial.println(\"RTC set.\");"
        },
        {
          "name": "print2digits",
          "body": "if (number >= 0 && number < 10)\n\t\tSerial.write('0');\n\tSerial.print(number);"
        }
      ]
    },
    {
      "name": "USE_ALB_I2C_Scan",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoLearningBoard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial port at 9600 baud for debugging\n\tSerial.begin(9600);\n\n\ti2c_scan.scan();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Vx",
      "keywords": [
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(Vx, INPUT); // Configure Vx (A0) as an Input\n\tpinMode(Vy, INPUT); // Configure Vy (A1) as an Input\n\tpinMode(Button, INPUT_PULLUP); // Configure Button (A2) as an Input, internally \"pulled-up\" to 5V\n\t                               // Note, we're configuring an Analog input as digital input\n\t                               // which is perfectly fine.  I did this to make the wiring easier\n\t                               // and keep all of the wires on the same side of the board\n\n\tSerial.begin(9600); // Initialize Serial Port at 9600 baud to display the results"
        },
        {
          "name": "loop",
          "body": "int x, y, btn;\n\t\n\tx = analogRead(Vx);\t// Read the analog value of Vx (Analog Values are from 0-1023 which equate to 0V to 5V)\n\ty = analogRead(Vy); // Read the analog value of Vy\n\tbtn = digitalRead(Button); // Read the button.  When the button is open (unpushed),\n\t                           // the input will read High (+5V)\n\t                           // When the button is closed (pressed), the input pin\n\t                           // is connected to ground and will read Low (0V)\n\t\n\tSerial.print(x);\t// Print the X value to the serial port\n\tSerial.print(\"\\t\"); // Print a Tab character \n\tSerial.print(y); \t// Print the Y value\n\tSerial.print(\"\\t\"); // Print a Tab\n\tSerial.println(btn); // Print the value of the Btn (0=Pushed, 1 = Not Pushed)\n\t\n\tdelay(250); // Delay 250ms so the results don't print too quickly"
        }
      ]
    },
    {
      "name": "USE_ALB_LCD_I2C",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "lcd.init(); // Initialize the LCD\n\tlcd.clear(); // Clear the LCD (set cursor to 0, 0)\n\tlcd.backlight(); // Turn on the LCD backlight\n\tlcd.print(\"Arduino Learning\"); // Print \"Arduino Learning\" on the first line\n\tlcd.setCursor(5, 1); // Move the cursor to (x, y)  (y=1 is 2nd line)\n\tlcd.print(\"Board!\"); // Print \"Board!\" in the middle of the 2nd line"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USE_ALB_LCD_I2C",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "lcd.init(); // Initialize the LCD\n\tlcd.clear(); // Clear the LCD (set cursor to 0, 0)\n\tlcd.backlight(); // Turn on the LCD backlight\n\tlcd.print(\"Arduino Learning\"); // Print \"Arduino Learning\" on the first line\n\tlcd.setCursor(5, 1); // Move the cursor to (x, y)  (y=1 is 2nd line)\n\tlcd.print(\"Board!\"); // Print \"Board!\" in the middle of the 2nd line\n\t\n\tdelay(3000); // Wait 3 seconds\n\tlcd.clear(); // Clear Display"
        },
        {
          "name": "loop",
          "body": "lcd.setCursor(0, 0);\n\tlcd.print(\"counter = \"); // Display \"counter =\"\n\tlcd.print(counter);\n\t\n\tcounter++;  // Increment the counter value\n\tif (counter > 9999) {\n\t\tcounter = 0; // Reset counter to 0 after it reaches 9999\n\t\tlcd.clear();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(10, OUTPUT); // Set Digital Pin 10 as an Output"
        },
        {
          "name": "loop",
          "body": "digitalWrite(10, HIGH); // Turn the LED ON\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)\n\tdigitalWrite(10, LOW); // Turn the LED OFF\n\tdelay(500); // delay (do nothing) for 500ms (1/2 of a second)"
        }
      ]
    },
    {
      "name": "USE_ALB_MPU6050",
      "keywords": [
        "Serial",
        "Wire",
        "attachInterrupt",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "dmpDataReady",
          "body": "mpuInterrupt = true;"
        },
        {
          "name": "setup",
          "body": "// join I2C bus (I2Cdev library doesn't do this automatically)\n\tWire.begin();\n\tTWBR = 24; // 400kHz I2C clock (200kHz if CPU is 8MHz)\n\n\t// initialize serial communication\n\t// (115200 chosen because it is required for Teapot Demo output, but it's\n\t// really up to you depending on your project)\n\tSerial.begin(115200);\n\n\t// initialize device\n\tSerial.println(F(\"Initializing I2C devices...\"));\n\tmpu.initialize();\n\n\t// verify connection\n\tSerial.println(F(\"Testing device connections...\"));\n\tSerial.println(mpu.testConnection() ? F(\"MPU6050 connection successful\") : F(\"MPU6050 connection failed\"));\n\n\t// wait for ready\n\tSerial.println(F(\"\\nSend any character to begin DMP programming and demo: \"));\n\twhile (Serial.available() && Serial.read()); // empty buffer\n\twhile (!Serial.available());                 // wait for data\n\twhile (Serial.available() && Serial.read()); // empty buffer again\n\n\t// load and configure the DMP\n\tSerial.println(F(\"Initializing DMP...\"));\n\tdevStatus = mpu.dmpInitialize();\n\n\t// supply your own gyro offsets here, use the output of ALB_MPU650_Calibrate\n\t// since each gyro is a little different from the factory\n\tmpu.setXAccelOffset(-3058);\n\tmpu.setYAccelOffset(2105);\n\tmpu.setZAccelOffset(1313);\n\tmpu.setXGyroOffset(8);\n\tmpu.setYGyroOffset(-11);\n\tmpu.setZGyroOffset(11);\n\n\t// make sure it worked (returns 0 if so)\n\tif (devStatus == 0)\n\t{\n\t\t// turn on the DMP, now that it's ready\n\t\tSerial.println(F(\"Enabling DMP...\"));\n\t\tmpu.setDMPEnabled(true);\n\n\t\t// enable Arduino interrupt detection\n\t\tSerial.println(F(\"Enabling interrupt detection (Arduino external interrupt 0)...\"));\n\t\tattachInterrupt(0, dmpDataReady, RISING);\n\t\tmpuIntStatus = mpu.getIntStatus();\n\n\t\t// set our DMP Ready flag so the main loop() function knows it's okay to use it\n\t\tSerial.println(F(\"DMP ready! Waiting for first interrupt...\"));\n\t\tdmpReady = true;\n\n\t\t// get expected DMP packet size for later comparison\n\t\tpacketSize = mpu.dmpGetFIFOPacketSize();"
        },
        {
          "name": "loop",
          "body": "// if programming failed, don't try to do anything\n\tif (!dmpReady) return;\n\n\t// wait for MPU interrupt or extra packet(s) available\n\twhile (!mpuInterrupt && fifoCount < packetSize)\n\t{\n\t\t// other program behavior stuff here\n\t\t// .\n\t\t// .\n\t\t// .\n\t\t// if you are really paranoid you can frequently test in between other\n\t\t// stuff to see if mpuInterrupt is true, and if so, \"break;\" from the\n\t\t// while() loop to immediately process the MPU data\n\t\t// .\n\t\t// .\n\t\t// ."
        }
      ]
    },
    {
      "name": "USE_ALB_MPU6050",
      "keywords": [
        "Serial",
        "Wire",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// join I2C bus (I2Cdev library doesn't do this automatically)\n\tWire.begin();\n\t// COMMENT NEXT LINE IF YOU ARE USING ARDUINO DUE\n\tTWBR = 24; // 400kHz I2C clock (200kHz if CPU is 8MHz). Leonardo measured 250kHz.\n\n\t// initialize serial communication\n\tSerial.begin(115200);\n\n\t// initialize device\n\tmpu.initialize();\n\n\t// wait for ready\n\twhile (Serial.available() && Serial.read()); // empty buffer\n\twhile (!Serial.available())\n\t{\n\t\tSerial.println(F(\"Send any character to start sketch.\\n\"));\n\t\tdelay(1500);"
        },
        {
          "name": "loop",
          "body": "if (state == 0)\n\t{\n\t\tSerial.println(\"\\nReading sensors for first time...\");\n\t\tmeansensors();\n\t\tstate++;\n\t\tdelay(1000);"
        },
        {
          "name": "meansensors",
          "body": "long i = 0, buff_ax = 0, buff_ay = 0, buff_az = 0, buff_gx = 0, buff_gy = 0, buff_gz = 0;\n\n\twhile (i < (buffersize + 101))\n\t{\n\t\t// read raw accel/gyro measurements from device\n\t\tmpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n\n\t\tif (i > 100 && i <= (buffersize + 100)) //First 100 measures are discarded\n\t\t{\n\t\t\tbuff_ax = buff_ax + ax;\n\t\t\tbuff_ay = buff_ay + ay;\n\t\t\tbuff_az = buff_az + az;\n\t\t\tbuff_gx = buff_gx + gx;\n\t\t\tbuff_gy = buff_gy + gy;\n\t\t\tbuff_gz = buff_gz + gz;"
        },
        {
          "name": "calibration",
          "body": "ax_offset = -mean_ax / 8;\n\tay_offset = -mean_ay / 8;\n\taz_offset = (16384 - mean_az) / 8;\n\n\tgx_offset = -mean_gx / 4;\n\tgy_offset = -mean_gy / 4;\n\tgz_offset = -mean_gz / 4;\n\n\twhile (1) \n\t{\n\t\tint ready = 0;\n\t\tmpu.setXAccelOffset(ax_offset);\n\t\tmpu.setYAccelOffset(ay_offset);\n\t\tmpu.setZAccelOffset(az_offset);\n\n\t\tmpu.setXGyroOffset(gx_offset);\n\t\tmpu.setYGyroOffset(gy_offset);\n\t\tmpu.setZGyroOffset(gz_offset);\n\n\t\tmeansensors();\n\n\t\t// Serial.println(\"...\");\n\t\t/*\n\t\tSerial.print(\"ax: \");\n\t\tSerial.print(mean_ax);\n\t\tSerial.print(\"\\tay: \");\n\t\tSerial.print(mean_ay);\n\t\tSerial.print(\"\\taz: \");\n\t\tSerial.print(mean_az);\n\t\tSerial.print(\"\\tgx: \");\n\t\tSerial.print(mean_gx);\n\t\tSerial.print(\"\\tgy: \");\n\t\tSerial.print(mean_gy);\n\t\tSerial.print(\"\\tgz: \");\n\t\tSerial.print(mean_gz);\n\t\t*/\n\n\t\tif (abs(mean_ax) <= acel_deadzone) ready++;\n\t\telse ax_offset = ax_offset - mean_ax / acel_deadzone;\n\n\t\tif (abs(mean_ay) <= acel_deadzone) ready++;\n\t\telse ay_offset = ay_offset - mean_ay / acel_deadzone;\n\n\t\tif (abs(16384 - mean_az) <= acel_deadzone) ready++;\n\t\telse az_offset = az_offset + (16384 - mean_az) / acel_deadzone;\n\n\t\tif (abs(mean_gx) <= giro_deadzone) ready++;\n\t\telse gx_offset = gx_offset - mean_gx / (giro_deadzone + 1);\n\n\t\tif (abs(mean_gy) <= giro_deadzone) ready++;\n\t\telse gy_offset = gy_offset - mean_gy / (giro_deadzone + 1);\n\n\t\tif (abs(mean_gz) <= giro_deadzone) ready++;\n\t\telse gz_offset = gz_offset - mean_gz / (giro_deadzone + 1);\n\n\t\tSerial.print(ready);\n\t\tSerial.println(\" of 6 offsets calculated.\");\n\n\t\tif (ready == 6) break;"
        }
      ]
    },
    {
      "name": "USE_ALB_RFID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\tSPI.begin();\n\trfid.init();"
        },
        {
          "name": "loop",
          "body": "if(rfid.isCard())\n\t{\n\t\tif(rfid.readCardSerial())\n\t\t{\n\t\t\tSerial.print(rfid.serNum[0], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[1], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[2], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[3], HEX);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(rfid.serNum[4], HEX);\n\t\t\tSerial.println(\"\");\n\t\t\tdelay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(2, OUTPUT); // Set Digital Pin 2 as an Output (Relay Control)\n\tpinMode(3, INPUT_PULLUP); // Set Digital Pin 3 as an Input (From the Button)\n\tpinMode(13, OUTPUT); // Set Digital Pin 13 as an Output (Nano LED)"
        },
        {
          "name": "loop",
          "body": "button = digitalRead(3); // Read from D3\n\t\n\t// Reverse the value of button (! = \"Not\", so !button = \"Not\" Button)\n\t// If Button is HIGH (or 1), !button will be LOW (or 0)\n\tbutton = !button;\n\tdigitalWrite(2, button); // Set the relay control to the button\n\tdigitalWrite(13, button); // Mirror the button and relay on the Nano LED\n\t\n\tdelay(250); // Delay for 250ms to reduce the bounce in the relay"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// Start serial communications at 9600 baud\n\tSerial.begin(9600);\n\n\t// Print \"Hello World!\" and move to the next line\n\tSerial.println(\"Hello World!\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Start serial communications at 9600 baud\n\tSerial.println(\"Hello World!\");"
        },
        {
          "name": "loop",
          "body": "Serial.print(\"i = \"); // Print \"i = \" to the serial port\n\tSerial.println(i);    // Print the value of \"i\"\n\ti = i + 1;\t\t\t  // Add one to \"i\" (so it's higher for the next time)\n\tdelay(1000);\t\t  // delay 1 second"
        }
      ]
    },
    {
      "name": "USE_ALB_Servo",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "myservo.attach(2);  // attaches the servo on pin 2 to the servo object\n\tmyservo.write(90);  // Center Servo\n\tdelay(3000);        // Delay 3 seconds"
        },
        {
          "name": "loop",
          "body": "for(pos = 0; pos <= 180; pos++) // goes from 0 degrees to 180 degrees\n\t{\n\t\tmyservo.write(pos);         // tell servo to go to position in variable 'pos'\n\t\tdelay(10);                  // waits 10ms for the servo to reach the position"
        }
      ]
    },
    {
      "name": "USE_ALB_SevenSegment",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte numDigits = 4; // Only 1 digit for this demo\n  byte digitPins[] = { 2, 5, 6, 13"
        },
        {
          "name": "loop",
          "body": "static unsigned long timer = millis();\n  static int value = 0;\n  \n  if (millis() >= timer) {\n    value++;\n    timer += 100; \n    if (value == 10000) { // Reset to 0 after counting past 9999\n      value = 0;"
        }
      ]
    },
    {
      "name": "USE_ALB_SevenSegment",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte numDigits = 1; // Only 1 digit for this demo\n  byte digitPins[] = { 5"
        },
        {
          "name": "loop",
          "body": "static unsigned long timer = millis();\n  static int value = 0;\n  \n  if (millis() >= timer) {\n    value++;\n    timer += 500; \n    if (value == 10) { // Reset to 0 after counting past 9\n      value = 0;"
        }
      ]
    },
    {
      "name": "trigPin",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\tpinMode(trigPin, OUTPUT);\n\tpinMode(echoPin, INPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(trigPin, LOW);\n\tdelayMicroseconds(2);\n\tdigitalWrite(trigPin, HIGH);\n\tdelayMicroseconds(10);\n\tdigitalWrite(trigPin, LOW);\n\n\t// Call pulseIn function to wait for High pulse\n\t// result will be time in microseconds until pulse is detected\n\tduration = pulseIn(echoPin, HIGH);\n\n\tif (duration < 100000)\n\t{\n\t\tinches = microSecondsToInches(duration);\n\t\tcm = microSecondsToCentimeters(duration);\n\n\t\tSerial.print(\"Ping Time: \");\n\t\tSerial.print(duration);\n\t\tSerial.print(\"uS, \");\n\t\tSerial.print(cm);\n\t\tSerial.print(\"cm, \");\n\t\tSerial.print(inches);\n\t\tSerial.println(\"in\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);  \t\t// Configure on-board LED pin as an output\n\tdigitalWrite(led, lamp);\t// Set LED to On or Off to simulate Lamp\n\tpinMode(digitalPin, INPUT);\t// Configure D2 as an input from Sound Sensor module\n\n\tSerial.begin(9600);\t\t\t// Open Serial Port\n\tSerial.println(\"Sound Sensor Test\");\n\n\tdigitalVal = digitalRead(digitalPin); // Read current value from Sound Sensor\n\tSerial.println(digitalVal);\t// Print current value of sound sensor (0 or 1)\n\tprevVal = digitalVal;\t    // Keep track of prior value (so we know when it changes)"
        },
        {
          "name": "loop",
          "body": "digitalVal = digitalRead(digitalPin); // Read current value from Sound Sensor\n\tif (digitalVal != prevVal)\t// Detect change\n\t{\n\t\tSerial.println(digitalVal);  // Print new value\n\t\tlamp = !lamp;\t// If lamp was On, turn it Off and vice-versa\n\t\tdigitalWrite(led, lamp);\t// Set LED to On or Off to simulate Lamp\n\t\tdelay(500);\t// Delay 500ms to \"debounce\" input\n\t\tdigitalVal = digitalRead(digitalPin); // Read current value again\n\t\tSerial.println(digitalVal);\t// Print new value\n\t\tprevVal = digitalVal;\t// Keep track of prior value"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n\tdigitalWrite(led, lamp);\n\tpinMode(analogPin, INPUT);\n\n\tSerial.begin(115200);\n\tSerial.println(\"Sound Sensor Test\");\n\n\tanalogVal = analogRead(analogPin);\n\tSerial.println(analogVal);\n\tprevVal = analogVal;"
        },
        {
          "name": "loop",
          "body": "analogVal = analogRead(analogPin);\n\tif ((analogVal > analogTrigger) && (prevVal < analogTrigger))\n\t{\n\t\tSerial.println(analogVal);\n\t\tlamp = !lamp;\n\t\tdigitalWrite(led, lamp);\n\t\tdelay(500);\n\t\tanalogVal = analogRead(analogPin);\n\t\tSerial.println(analogVal);\n\t\tprevVal = analogVal;"
        }
      ]
    },
    {
      "name": "USE_ALB_Stepper",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  \n  stepper1.setMaxSpeed(1000.0);\n  stepper1.setAcceleration(300.0);\n  stepper1.setSpeed(1000);\n  stepper1.moveTo(5000);\n\n  Serial.println(\"Moving Stepper to Position 5000\");"
        },
        {
          "name": "loop",
          "body": "// Serial.println(stepper1.currentPosition());\n  \t\n  //Change direction when the stepper reaches the target position\n  if (stepper1.distanceToGo() == 0) {\n  \tSerial.print(\"Stepper Arrived at Destination. MoveTo(\");\n  \tSerial.print(-stepper1.currentPosition());\n  \tSerial.println(\")\");\n    stepper1.moveTo(-stepper1.currentPosition());"
        }
      ]
    },
    {
      "name": "USE_ALB_DHT11",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Start Serial port so we can see the results\n\t\n\tdht11.begin(); // Get the DHT11 class to start reading"
        },
        {
          "name": "loop",
          "body": "// Wait a few seconds between measurements.\n\tdelay(2000);\n\n\t// Reading temperature or humidity takes about 250 milliseconds\n\tfloat h = dht11.readHumidity();\n\t// Read temperature as Celsius (the default)\n\tfloat c = dht11.readTemperatureC();\n\t// Read temperature as Fahrenheit (isFahrenheit = true)\n\tfloat f = dht11.readTemperatureF();\n\n\t// Check if any reads failed and exit early (to try again).\n\tif (isnan(h) || isnan(c) || isnan(f))\n\t{\n\t\tSerial.println(\"Failed to read from DHT sensor!\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(tiltPin, INPUT_PULLUP); // Configure Tilt Pin as Input w/ Pullup\n\tpinMode(ledPin, OUTPUT);\t\t// Configure LED pin as Output\n\tdigitalWrite(ledPin, LOW);\t\t// Initially turn off LED"
        },
        {
          "name": "loop",
          "body": "tiltValue = digitalRead(tiltPin); // Read current value from digital input\n\t// When the sensor is still, the two pins are connected and \n\t// D2 is pulled LOW.  On motion, the switch opens and the digital input\n\t// will report a High value\n\tif (tiltValue == HIGH) {\n\t\tdigitalWrite(ledPin, HIGH);  // Turn on the LED\n\t\tdelay(1500);\t// Delay 1.5 Seconds so we can see that the LED turned on\n\t\tdigitalWrite(ledPin, LOW);   // Turn off the LED"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// Configure Touch Buttons as Inputs\n\tpinMode(2, INPUT);\n\tpinMode(3, INPUT);\n\tpinMode(4, INPUT);\n\tpinMode(5, INPUT);\n\t\n\tSerial.begin(9600); // Initialize serial communications"
        },
        {
          "name": "loop",
          "body": "// Read buttons (HIGH = button pushed, LOW = button not pushed)\n\tb1 = digitalRead(2);\n\tb2 = digitalRead(3);\n\tb3 = digitalRead(4);\n\tb4 = digitalRead(5);\n\t\n\t// Output values of all buttons to serial port\n\tSerial.print(b1);\n\tSerial.print(\" \");\n\tSerial.print(b2);\n\tSerial.print(\" \");\n\tSerial.print(b3);\n\tSerial.print(\" \");\n\tSerial.println(b4);\n\t\n\tdelay(500);"
        }
      ]
    },
    {
      "name": "C4",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// Configure Touch Buttons as Inputs\n\tpinMode(2, INPUT);\n\tpinMode(3, INPUT);\n\tpinMode(4, INPUT);\n\tpinMode(5, INPUT);\n\t\n\t// Configure Passive Buzzer pin as Outputs\n\tpinMode(12, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// Read buttons (HIGH = button pushed, LOW = button not pushed)\n\tb1 = digitalRead(2);\n\tb2 = digitalRead(3);\n\tb3 = digitalRead(4);\n\tb4 = digitalRead(5);\n\n\tif (b1)\n\t\ttone(12, C4);\n\telse if (b2)\n\t\ttone(12, E4);\n\telse if (b3)\n\t\ttone(12, G4);\n\telse if (b4)\n\t\ttone(12, C5);\n\telse\n\t\tnoTone(12);"
        }
      ]
    },
    {
      "name": "AM2315_DEBUG",
      "keywords": [
        "Wire",
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "static float temperature, humidity;\n\n  temperature = AM2315.readTemperature();\n  humidity    = AM2315.readHumidity();\n\n  if (!isnan(temperature) && !isnan(humidity))\n  {\n    Blynk.virtualWrite(V1, String(temperature, 1));\n    Blynk.virtualWrite(V2, String(humidity, 1));\n\n#if AM2315_DEBUG\n    Serial.println(\"Temp *C: \" + String(temperature));\n    Serial.println(\"Humid %: \" + String(humidity));\n#endif"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(HIGH);\n    led_ticker.once_ms(111, set_led, (byte) LOW);\n    Serial.print(F(\"B\"));"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if (USE_LITTLEFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using LITTLEFS\"));\n#elif (USE_SPIFFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using SPIFFS\"));  \n#else\n  Serial.print(F(\"\\nStarting AM2315_ESP32_SSL using EEPROM\"));\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "AM2315_DEBUG",
      "keywords": [
        "Wire",
        "Serial",
        "digitalWrite",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "Ticker.h",
        "Ticker.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(\"Failed to read data from AM2315\");\n#endif\n\n    return;"
        },
        {
          "name": "set_led",
          "body": "digitalWrite(LED_BUILTIN, status);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n  {\n    set_led(LOW);\n    led_ticker.once_ms(111, set_led, (byte) HIGH);\n    Serial.print(\"B\");"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    // report status to Blynk\n    heartBeatPrint();\n\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStarting AM2315_ESP8266 using \"));\n  Serial.print(CurrentFileFS);\n#else\n  Serial.print(\"\\nStarting AM2315_ESP8266 using EEPROM\");\n#endif\n\n#if USE_SSL\n  Serial.print(F(\" with SSL on \")); Serial.println(ARDUINO_BOARD);\n#else\n  Serial.print(F(\" without SSL on \")); Serial.println(ARDUINO_BOARD);\n#endif\n\n#if USE_BLYNK_WM\n  Serial.println(ESP8266_CORE_VERSION);\n  Serial.println(BLYNK_WM_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "W5100_CS",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(F(\"Failed to read data from AM2315\"));\n#endif\n\n    return;"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart AM2315_W5100 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "AM2315_DEBUG",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Wire.h",
        "Adafruit_AM2315.h"
      ],
      "functions": [
        {
          "name": "ReadData",
          "body": "static float temperature, humidity;\n\n  if (!AM2315.readTemperatureAndHumidity(&temperature, &humidity))\n  {\n#if AM2315_DEBUG\n    Serial.println(F(\"Failed to read data from AM2315\"));\n#endif\n\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n#if ( USE_LITTLEFS || USE_SPIFFS)\n  Serial.print(F(\"\\nStart AM2315_W5500 using \")); Serial.print(CurrentFileFS);\n  Serial.print(F(\" on \")); Serial.print(BOARD_NAME);\n#else\n  Serial.print(F(\"\\nStart AM2315_W5500 on \")); Serial.print(BOARD_NAME);\n#endif\n\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n \n#if USE_BLYNK_WM \n  Serial.println(BLYNK_ETHERNET_WM_VERSION);\n#endif;\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  if (!AM2315.begin())\n  {\n    Serial.println(F(\"Sensor not found, check wiring & pullups!\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(\"\\nYour stored Credentials :\");\n\n  for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.println(String(myMenuItems[i].displayName) + \" = \" + myMenuItems[i].pdata);"
        },
        {
          "name": "displayCredentialsInLoop",
          "body": "static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint8_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  displayCredentialsInLoop();\n#endif"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  // NOTE: moved to ISM band on purpose\n  //       DO NOT transmit in APRS bands without ham radio license!\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[APRS] Sending Mic-E position ... \"));\n  int state = aprs.sendMicE(49.1945, 16.6000, 120, 10, RADIOLIB_APRS_MIC_E_TYPE_EN_ROUTE);\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  // NOTE: moved to ISM band on purpose\n  //       DO NOT transmit in APRS bands without ham radio license!\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK(434.0);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.println(F(\"[APRS] Sending location reports\"));\n  \n  // send a location without message or timestamp\n  char destination[] = \"N0CALL\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  int state = aprs.sendPosition(destination, 0, latitude, longitude);\n  if(state != RADIOLIB_ERR_NONE) {\n    Serial.print(F(\"[APRS] Failed to send location, code \"));\n    Serial.println(state);"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with the settings necessary for LoRa iGates\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // frequency:                   433.775 MHz\n  // bandwidth:                   125 kHz\n  // spreading factor:            12\n  // coding rate:                 4/5\n  int state = radio.begin(433.775, 125, 12, 5);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[APRS] Sending position ... \"));\n  \n  // send a location with message and timestamp\n  // SSID is set to 1, as APRS over LoRa uses WIDE1-1 path by default\n  char destination[] = \"GPS\";\n  char latitude[] = \"4911.67N\";\n  char longitude[] = \"01635.96E\";\n  char message[] = \"I'm here!\";\n  char timestamp[] = \"093045z\";\n  int state = aprs.sendPosition(destination, 1, latitude, longitude, message, timestamp);\n  delay(500);\n\n  // you can also send Mic-E encoded messages\n  state |= state = aprs.sendMicE(49.1945, 16.6000, 120, 10, RADIOLIB_APRS_MIC_E_TYPE_EN_ROUTE);\n  delay(500);\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// compare the previous status to the current status\n  if (status != WiFi.status()) {\n    // it has changed update the variable\n    status = WiFi.status();\n\n    if (status == WL_AP_CONNECTED) {\n      byte remoteMac[6];\n\n      // a device has connected to the AP\n      Serial.print(\"Device connected to AP, MAC address: \");\n      WiFi.APClientMacAddress(remoteMac);\n      printMacAddress(remoteMac);"
        },
        {
          "name": "printWiFiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your WiFi shield's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");\n  // print where to go in a browser:\n  Serial.print(\"To see this page in action, open a browser to http://\");\n  Serial.println(ip);"
        },
        {
          "name": "printMacAddress",
          "body": "for (int i = 5; i >= 0; i--) {\n    if (mac[i] < 16) {\n      Serial.print(\"0\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoGraphics.h"
      ],
      "functions": [
        {
          "name": "set",
          "body": "// the r parameter is (mis)used to set the character to draw with\n      _canvasBuffer[x][y] = r;\n      // cast unused parameters to void to fix \"unused parameter\" warning\n      (void)g;\n      (void)b;"
        },
        {
          "name": "endDraw",
          "body": "ArduinoGraphics::endDraw();\n\n      for (byte row = 0; row < canvasHeight; row++) {\n        for (byte column = 0; column < canvasWidth; column++) {\n          // handle unset parts of buffer\n          if (_canvasBuffer[column][row] == 0) {\n            _canvasBuffer[column][row] = ' ';"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "SERIAL_PORT_MONITOR",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "createPage",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>ATWebServer_BigData-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleRoot",
          "body": "//out.reserve(STRING_SIZE);\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < (100 * MULTIPLY_FACTOR); lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"ATWebServer_BigData_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "out.reserve(STRING_SIZE);\n\n  //Initialize serial and wait for port to open:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStart ATWebServer_BigData on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "TINY_GSM_MODEM_SIM800",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(6000);"
        },
        {
          "name": "loop",
          "body": "if (!rate) { rate = TinyGsmAutoBaud(SerialAT);"
        }
      ]
    },
    {
      "name": "BAUD_RATE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AltSoftSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SPY.begin(115200);\n\n  MODEM_TX.begin(BAUD_RATE);\n  BOARD_TX.begin(BAUD_RATE);\n  delay(6000);"
        },
        {
          "name": "loop",
          "body": "while (MODEM_TX.available()) {\n    SPY.write(MODEM_TX.read());"
        }
      ]
    },
    {
      "name": "OTETHERNET",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "SD.h",
        "Ethernet.h",
        "ArduinoOTA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//Initialize serial:\n  Serial.begin(9600);\n  while (!Serial);\n\n  // setup SD card\n  Serial.print(\"Initializing SD card...\");\n  if (!SD.begin(SDCARD_SS_PIN)) {\n    Serial.println(\"initialization failed!\");\n    // don't continue:\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// check for updates\n  ArduinoOTA.poll();\n\n  // add your normal loop code below ..."
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleStream.h",
        "SoftwareServo.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  // Blynk will work through SoftwareSerial\n  // Do not read or write this serial manually in your sketch\n  SwSerial.begin(9600);\n  Blynk.begin(SwSerial, auth);\n\n  // Sometimes you need to calibrate your ATtiny timer\n  //OSCCAL = 175;"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "TX_PIN",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "initTXPin();\n    Serial.println(F(\"START \" __FILE__ \" from \" __DATE__ \"\\r\\nUsing library version \" VERSION_ATTINY_SERIAL_OUT));\n\n    writeString(\"OSCCAL=\");\n#if !defined(__AVR_ATtiny13__) && !defined(__AVR_ATtiny13A__)\n    writeUnsignedByteHexWithPrefix(OSCCAL);\n#endif"
        },
        {
          "name": "loop",
          "body": "static uint8_t tIndex = 0;\n    /*\n     * Example of 3 byte output. View in combined ASSCI / HEX View in HTerm (http://www.der-hammer.info/terminal/)\n     * Otherwise use writeUnsignedByteHexWithoutPrefix or writeUnsignedByteHex\n     */\n    write1Start8Data1StopNoParityWithCliSei('I');\n    writeBinary(tIndex);                    // 1 byte binary output\n\n#if !defined(__AVR_ATtiny13__) && !defined(__AVR_ATtiny13A__) // the utoa() function used in writeUnsignedByte etc. requires too much program space!\n    writeUnsignedByte(tIndex);              // 1-3 byte ASCII output\n    writeUnsignedByteHexWithPrefix(tIndex); // 4 byte output\n    writeUnsignedByteHex(tIndex);           // 2 byte output\n    write1Start8Data1StopNoParityWithCliSei('\\n');\n\n    /*\n     * Serial.print usage example\n     */\n    Serial.print(\"I=\");\n    Serial.print((char) tIndex);\n    Serial.print(\" | \");\n    Serial.print(tIndex);\n    Serial.print(\" | \");\n    Serial.print(tIndex, HEX);\n    Serial.print(\" | \");\n    Serial.printHex(tIndex);\n    Serial.print(\" | \");\n    Serial.println(tIndex);\n#endif\n    tIndex++;\n    delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif\n\n#if USE_AUNIT == 1\n  // These are useful for debugging.\n  //TestRunner::setVerbosity(Verbosity::kAll);\n  //TestRunner::setVerbosity(Verbosity::kTestRunSummary);\n  //TestRunner::list();\n\n  // If set to 0, meaning infinite timeout, some testing() may accidentally run\n  // forever. Default is 10s, let's set it to 5s to verify that it can be\n  // changed.\n  TestRunner::setTimeout(5);\n#else\n  //Test::min_verbosity = TEST_VERBOSITY_ALL;\n#endif"
        },
        {
          "name": "loop",
          "body": "#if USE_AUNIT == 1\n  // Should get something like:\n  // TestRunner summary:\n  //    10 passed, 0 failed, 2 skipped, 0 timed out, out of 12 test(s).\n  TestRunner::run();\n#else\n  // Should get something like:\n  // Test summary: 6 passed, 1 failed, and 1 skipped, out of 8 test(s).\n  Test::run();\n#endif"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif"
        },
        {
          "name": "loop",
          "body": "TestRunner::run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AUnit.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // wait for stability on some boards to prevent garbage Serial\n#endif\n  Serial.begin(115200); // ESP8266 default of 74880 not supported on Linux\n  while(!Serial); // for the Arduino Leonardo/Micro only\n#if defined(EPOXY_DUINO)\n  Serial.setLineModeUnix();\n#endif"
        },
        {
          "name": "loop",
          "body": "aunit::TestRunner::run();"
        }
      ]
    },
    {
      "name": "USE_AUNIT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AUnit.h",
        "AUnitVerbose.h",
        "aunit/string_util.h",
        "ArduinoUnit.h"
      ],
      "functions": [
        {
          "name": "testCommon",
          "body": "assertLess(m, subject);"
        },
        {
          "name": "assertFailing",
          "body": "assertEqual(1, 2);"
        },
        {
          "name": "testCommon",
          "body": "assertLess(m, subject);"
        },
        {
          "name": "setup",
          "body": "#if ! defined(EPOXY_DUINO)\n  delay(1000); // Wait for stability on some boards, otherwise garage on Serial\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (! SERIAL_PORT_MONITOR); // Wait until Serial is ready - Leonardo/Micro\n#if defined(EPOXY_DUINO)\n  SERIAL_PORT_MONITOR.setLineModeUnix();\n#endif\n\n#if USE_AUNIT == 1\n  // These are useful for debugging.\n  //TestRunner::setVerbosity(Verbosity::kAll);\n  //TestRunner::setVerbosity(Verbosity::kTestRunSummary);\n  //TestRunner::list();\n#else\n  //Test::min_verbosity = TEST_VERBOSITY_ALL;\n#endif"
        },
        {
          "name": "loop",
          "body": "#if USE_AUNIT == 1\n  // Should get something like:\n  // TestRunner summary:\n  //    21 passed, 0 failed, 0 skipped, 0 timed out, out of 23 test(s).\n  TestRunner::run();\n#else\n  // Should get something like:\n  // Test summary: 12 passed, 0 failed, and 0 skipped, out of 12 test(s).\n  Test::run();\n#endif"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Das Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 100)\n  {\n    t1 = millis();\n\n    byte note = random(15, 80);\n    byte velocity = random(55, 100);\n    byte channel = 1;\n\n    //   DBG(F(\"\\nsendNoteOn\"), note, velocity, channel);\n    MIDI.sendNoteOn(note, velocity, channel);\n    //MIDI.sendNoteOff(note, velocity, channel);"
        },
        {
          "name": "OnAppleMidiException",
          "body": "switch (e)\n  {\n    case APPLEMIDI_NAMESPACE::Exception::BufferFullException:\n      DBG(F(\"*** BufferFullException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParseException:\n      DBG(F(\"*** ParseException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::TooManyParticipantsException:\n      DBG(F(\"*** TooManyParticipantsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UnexpectedInviteException:\n      DBG(F(\"*** UnexpectedInviteException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ParticipantNotFoundException:\n      DBG(F(\"*** ParticipantNotFoundException\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ComputerNotInDirectory:\n      DBG(F(\"*** ComputerNotInDirectory\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NotAcceptingAnyone:\n      DBG(F(\"*** NotAcceptingAnyone\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ListenerTimeOutException:\n      DBG(F(\"*** ListenerTimeOutException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::MaxAttemptsException:\n      DBG(F(\"*** MaxAttemptsException\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::NoResponseFromConnectionRequestException:\n      DBG(F(\"***:yyy did't respond to the connection request. Check the address and port, and any firewall or router settings. (time)\"));\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::SendPacketsDropped:\n      DBG(F(\"*** SendPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::ReceivedPacketsDropped:\n      DBG(F(\"*** ReceivedPacketsDropped\"), value);\n      break;\n    case APPLEMIDI_NAMESPACE::Exception::UdpBeginPacketFailed:\n      DBG(F(\"*** UdpBeginPacketFailed\"), value);\n      break;"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    //    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet3.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n//    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "onUpdateCallback",
          "body": "Serial.print(F(\"DDNSGeneric - IP Change Detected: \"));\n  Serial.println(newIP);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart AVR_ESP_AT_DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n  \n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "onUpdateCallback",
          "body": "Serial.print(\"DDNSGeneric - IP Change Detected: oldIP = \");\n  Serial.print(oldIP);\n  Serial.print(\", newIP = \");\n  Serial.println(newIP);"
        },
        {
          "name": "initEthernet",
          "body": "#if USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));  \n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#elif USE_UIP_ETHERNET\n  ET_LOGWARN(F(\"=========== USE_UIP_ETHERNET ===========\"));  \n#else\n  ET_LOGWARN(F(\"=========== USE_CUSTOM_ETHERNET ===========\"));\n#endif\n\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n\n  // For other boards, to change if necessary\n  #if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n    // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n    Ethernet.init (USE_THIS_SS_PIN);\n    \n  #elif USE_CUSTOM_ETHERNET\n    // You have to add initialization for your Custom Ethernet here\n    // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n    //Ethernet.init(USE_THIS_SS_PIN);\n    \n  #endif  //( ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  \n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AVR_Ethernet_DuckDNS_Client on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(DDNS_GENERIC_VERSION);\n\n  initEthernet();\n\n  Serial.print(F(\"\\nHTTP WebServer is @ IP : \"));\n  Serial.println(Ethernet.localIP());\n\n  server.begin();\n\n  DDNSGeneric.service(\"duckdns\");    // Enter your DDNS Service Name - \"duckdns\" / \"noip\"\n\n  /*\n    For DDNS Providers where you get a token:\n    DDNSGeneric.client(\"domain\", \"token\");\n\n    For DDNS Providers where you get username and password: ( Leave the password field empty \"\" if not required )\n    DDNSGeneric.client(\"domain\", \"username\", \"password\");\n  */\n  DDNSGeneric.client(\"account.duckdns.org\", \"12345678-1234-1234-1234-123456789012\");\n\n  DDNSGeneric.onUpdate(onUpdateCallback);"
        },
        {
          "name": "loop",
          "body": "// Check for New Ip Every 10 mins.\n  DDNSGeneric.update(600000);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send note on/off every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "ONE_PARTICIPANT",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  if (Ethernet.begin(mac) == 0)  for (;;);\n\n  MIDI.begin();\n\n  // Stay informed on connection status\n  AppleMIDI.setHandleConnected([](const APPLEMIDI_NAMESPACE::ssrc_t & ssrc, const char*) {\n    isConnected++;\n    digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    MIDI.sendNoteOn(54, 100, 1);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI1.read();\n  MIDI2.read();\n\n  // send note on/off every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n\n    MIDI1.sendNoteOn(note, velocity, 1);\n    MIDI2.sendNoteOn(note, velocity, 2);"
        },
        {
          "name": "OnAppleMidiConnected",
          "body": "isConnected++;\n  DBG(F(\"Connected to session\"), ssrc, name);"
        },
        {
          "name": "OnAppleMidiDisconnected",
          "body": "isConnected--;\n  DBG(F(\"Disconnected\"), ssrc);"
        },
        {
          "name": "OnMidiNoteOn",
          "body": "DBG(F(\"in\\tNote on\"), note, \" Velocity\", velocity, \"\\t\", channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n    t1 = millis();\n\n    byte note = random(1, 127);\n    byte velocity = 55;\n    byte channel = 1;\n\n    MIDI.sendNoteOn(note, velocity, channel);\n//    MIDI.sendNoteOff(note, velocity, channel);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();"
        },
        {
          "name": "OnAppleMidiStartReceived",
          "body": "DBG(F(\"Start receiving\"), ssrc);"
        },
        {
          "name": "OnAppleMidiReceivedByte",
          "body": "SerialMon.println(data, HEX);"
        },
        {
          "name": "OnAppleMidiEndReceive",
          "body": "DBG(F(\"End receiving\"), ssrc);"
        }
      ]
    },
    {
      "name": "SerialMon",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Ethernet.h",
        "AppleMIDI_Debug.h",
        "AppleMIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "DBG_SETUP(115200);\n  DBG(\"Booting\");\n\n  if (Ethernet.begin(mac) == 0) {\n    DBG(F(\"Failed DHCP, check network cable & reboot\"));\n    for (;;);"
        },
        {
          "name": "loop",
          "body": "// Listen to incoming notes\n  MIDI.read();\n\n  // send a note every second\n  // (dont cáll delay(1000) as it will stall the pipeline)\n  if ((isConnected > 0) && (millis() - t1) > 1000)\n  {\n //   MIDI.sendSysEx(sizeof(sysexBig), sysexBig, true);\n    t1 = millis();"
        },
        {
          "name": "OnMidiSysEx",
          "body": "SerialMon.print(F(\"SYSEX: (\"));\n  SerialMon.print(getSysExStatus(data, length));\n  SerialMon.print(F(\", \"));\n  SerialMon.print(length);\n  SerialMon.print(F(\" bytes) \"));\n  for (uint16_t i = 0; i < length; i++)\n  {\n    SerialMon.print(data[i], HEX);\n    SerialMon.print(\" \");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (gsmAccess.status() != GSM_READY || gprs.status() != GPRS_READY) {\n    connectGSM();"
        },
        {
          "name": "connectGSM",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((gsmAccess.begin(pinnumber) != GSM_READY) ||\n         (gprs.attachGPRS(gprs_apn, gprs_login, gprs_password) != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "MKRNB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (nbAccess.status() != NB_READY || gprs.status() != GPRS_READY) {\n    connectNB();"
        },
        {
          "name": "connectNB",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((nbAccess.begin(pinnumber) != NB_READY) ||\n         (gprs.attachGPRS() != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "Arduino_ConnectionHandler.h",
        "Arduino_JSON.h",
        "NTPClient.h",
        "mbed_mktime.h",
        "Ethernet.h",
        "EthernetUdp.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    // Wait for Serial Monitor or start after 2.5s\n    for (const auto startNow = millis() + 2500; !Serial && millis() < startNow; delay(250));\n\n    // Set the callbacks for connectivity management\n    conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n    conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n    conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n    // Check for HSM\n    if (!ECCX08.begin()) {\n        Serial.println(\"No ECCX08 present!\");\n        while (1)\n            ;"
        },
        {
          "name": "loop",
          "body": "// Automatically manage connectivity\n    const auto conStatus = conMan.check();\n\n    if (conStatus != NetworkConnectionState::CONNECTED)\n        return;\n\n    if (!mqttClient.connected()) {\n        // MQTT client is disconnected, connect\n        connectMQTT();"
        },
        {
          "name": "setNtpTime",
          "body": "timeClient.forceUpdate();\n    const auto epoch = timeClient.getEpochTime();\n    set_time(epoch);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n    Serial.print(broker);\n    Serial.print(\":\");\n    Serial.print(port);\n    Serial.println();\n\n    int status;\n    while ((status = mqttClient.connect(broker, port)) == 0) {\n        // failed, retry\n        Serial.println(status);\n        delay(1000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n    JSONVar payload;\n    String msg = \"Hello, World! \";\n    msg += millis();\n    payload[\"message\"] = msg;\n\n    JSONVar message;\n    message[\"ts\"] = static_cast<unsigned long>(time(nullptr));\n    message[\"payload\"] = payload;\n\n    String messageString = JSON.stringify(message);\n    Serial.println(messageString);\n\n    // send message, the Print interface can be used to set the message contents\n    constexpr char outgoingTopic[] { \"arduino/outgoing\""
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n    Serial.println();\n    Serial.print(\"Received a message with topic '\");\n    Serial.print(mqttClient.messageTopic());\n    Serial.print(\"', length \");\n    Serial.print(messageSize);\n    Serial.println(\" bytes:\");\n\n    /*\n    // Message from AWS MQTT Test Client\n    {\n      \"message\": \"Hello from AWS IoT console\""
        },
        {
          "name": "onNetworkConnect",
          "body": "Serial.println(\">>>> CONNECTED to network\");\n    printEthernetStatus();\n\n    setNtpTime();\n    connectMQTT();"
        },
        {
          "name": "onNetworkDisconnect",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "body": "Serial.println(\">>>> ERROR\");"
        },
        {
          "name": "printEthernetStatus",
          "body": "// print your board's IP address:\n    Serial.print(\"Local IP: \");\n    Serial.println(Ethernet.localIP());\n    Serial.print(\"Local GW: \");\n    Serial.println(Ethernet.gatewayIP());\n    Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "Arduino_ConnectionHandler.h",
        "Arduino_JSON.h",
        "NTPClient.h",
        "mbed_mktime.h",
        "WiFi.h",
        "WiFiUdp.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    // Wait for Serial Monitor or start after 2.5s\n    for (const auto startNow = millis() + 2500; !Serial && millis() < startNow; delay(250));\n\n    // Set the callbacks for connectivity management\n    conMan.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);\n    conMan.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);\n    conMan.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);\n\n    // Check for HSM\n    if (!ECCX08.begin()) {\n        Serial.println(\"No ECCX08 present!\");\n        while (1)\n            ;"
        },
        {
          "name": "loop",
          "body": "// Automatically manage connectivity\n    const auto conStatus = conMan.check();\n\n    if (conStatus != NetworkConnectionState::CONNECTED)\n        return;\n\n    if (!mqttClient.connected()) {\n        // MQTT client is disconnected, connect\n        connectMQTT();"
        },
        {
          "name": "setNtpTime",
          "body": "timeClient.forceUpdate();\n    const auto epoch = timeClient.getEpochTime();\n    set_time(epoch);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n    Serial.print(broker);\n    Serial.print(\":\");\n    Serial.print(port);\n    Serial.println();\n\n    int status;\n    while ((status = mqttClient.connect(broker, port)) == 0) {\n        // failed, retry\n        Serial.println(status);\n        delay(1000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n    JSONVar payload;\n    String msg = \"Hello, World! \";\n    msg += millis();\n    payload[\"message\"] = msg;\n    payload[\"rssi\"] = WiFi.RSSI();\n\n    JSONVar message;\n    message[\"ts\"] = static_cast<unsigned long>(time(nullptr));\n    message[\"payload\"] = payload;\n\n    String messageString = JSON.stringify(message);\n    Serial.println(messageString);\n\n    // send message, the Print interface can be used to set the message contents\n    constexpr char outgoingTopic[] { \"arduino/outgoing\""
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n    Serial.println();\n    Serial.print(\"Received a message with topic '\");\n    Serial.print(mqttClient.messageTopic());\n    Serial.print(\"', length \");\n    Serial.print(messageSize);\n    Serial.println(\" bytes:\");\n\n    /*\n    // Message from AWS MQTT Test Client\n    {\n      \"message\": \"Hello from AWS IoT console\""
        },
        {
          "name": "onNetworkConnect",
          "body": "Serial.println(\">>>> CONNECTED to network\");\n\n    printWifiStatus();\n    setNtpTime();\n    connectMQTT();"
        },
        {
          "name": "onNetworkDisconnect",
          "body": "Serial.println(\">>>> DISCONNECTED from network\");"
        },
        {
          "name": "onNetworkError",
          "body": "Serial.println(\">>>> ERROR\");"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n    Serial.print(\"SSID: \");\n    Serial.println(WiFi.SSID());\n\n    // print the received signal strength:\n    Serial.print(\"signal strength (RSSI):\");\n    Serial.print(WiFi.RSSI());\n    Serial.println(\" dBm\");\n    Serial.println();\n\n    // print your board's IP address:\n    Serial.print(\"Local IP: \");\n    Serial.println(WiFi.localIP());\n    Serial.print(\"Local GW: \");\n    Serial.println(WiFi.gatewayIP());\n    Serial.println();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "ArduinoMqttClient.h",
        "WiFiNINA.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    connectWiFi();"
        },
        {
          "name": "connectWiFi",
          "body": "Serial.print(\"Attempting to connect to SSID: \");\n  Serial.print(ssid);\n  Serial.print(\" \");\n\n  while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"arduino/outgoing\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // carrier frequency:           434.0 MHz\n  // bit rate:                    1.2 kbps (1200 baud 2-FSK AX.25)\n  // frequency deviation:         0.5 kHz  (1200 baud 2-FSK AX.25)\n  int state = radio.beginFSK(434.0, 1.2, 0.5);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// create AX.25 Unnumbered Information frame\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  // source station callsign:          \"N7LEM\"\n  // source station SSID:              0\n  // control field:                    UI, P/F not used, unnumbered frame\n  // protocol identifier:              no layer 3 protocol implemented\n  // information field:                \"Hello World!\"\n  AX25Frame frameUI(\"NJ7P\", 0, \"N7LEM\", 0, RADIOLIB_AX25_CONTROL_U_UNNUMBERED_INFORMATION |\n                    RADIOLIB_AX25_CONTROL_POLL_FINAL_DISABLED | RADIOLIB_AX25_CONTROL_UNNUMBERED_FRAME,\n                    RADIOLIB_AX25_PID_NO_LAYER_3, \"Hello World (unnumbered)!\");\n\n  // send the frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  int state = ax25.sendFrame(&frameUI);\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  // carrier frequency:           434.0 MHz\n  // bit rate:                    1.2 kbps (1200 baud 2-FSK AX.25)\n  int state = radio.beginFSK(434.0, 1.2);\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// send AX.25 unnumbered information frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  int state = ax25.transmit(\"Hello World!\", \"NJ7P\");\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "RADIO_BOARD_AUTO",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h",
        "RadioBoards.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AX.25\n  // (RF69, CC1101,, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "// send AX.25 unnumbered information frame\n  Serial.print(F(\"[AX.25] Sending UI frame ... \"));\n  // destination station callsign:     \"NJ7P\"\n  // destination station SSID:         0\n  int state = ax25.transmit(\"Hello World!\", \"NJ7P\");\n  if (state == RADIOLIB_ERR_NONE) {\n    // the packet was successfully transmitted\n    Serial.println(F(\"success!\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte value;\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 1: Find Chip Address.\");\n\n  psg.begin();\n\n  // Find chip address\n  byte foundAddress;\n  foundAddress = psg.findChipAddress();\n  Serial.print(\"Default Chip Address: \");\n  Serial.println(psg.getChipAddress(), HEX);\n\n  if (foundAddress == 0xFF) {\n    Serial.println(\"ERROR: Unable to detect chip address, check hardware.\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "byte value;\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 2: Test Regsiters.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered with non-default address.\n\n  Serial.println(\"\");\n  Serial.println(\"Note that registers 0x1, 0x3, 0x5, 0xD are only 4 bits wide, and\");\n  Serial.println(\"registers 0x6, 0x8, 0x9, 0xA are only 5 bits wide.\");\n  Serial.println(\"\");\n\n  for (byte i = AY3891x::ChA_Tone_Period_Fine_Reg; i <= AY3891x:: IO_Port_B_Reg; i++) {\n    Serial.print(\"Write value 0x\");\n    Serial.print(0x50 | i, HEX);\n    Serial.print(\" to register:   0x\");\n    Serial.println(i, HEX);\n    psg.write(i, 0x50 | i);\n    value = psg.read(i);\n    Serial.print(\"Read value  0x\");\n    Serial.print(value, HEX);\n    Serial.print(\" from register: 0x\");\n    Serial.println(i, HEX);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n  Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 3: Simple Tone Generator.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  // Use less than max amplitude, in case external amp can't handle the higher level (start low and increase after testing)\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  psg.write(AY3891x::Enable_Reg, ~(MIXER_TONE_A_DISABLE | MIXER_TONE_B_DISABLE));   // Enable Channel A and B tone generator output\n\n  for (byte i = 0; i < sizeof(notes_to_play) / sizeof(notes_to_play[0]); i++) {\n    Serial.print(\"Playing note freq: \");\n    Serial.println(1000000UL/16/pgm_read_word(&Notes[notes_to_play[i]]));\n    psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[notes_to_play[i]]) >> 8);\n    psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[notes_to_play[i]]) & TONE_GENERATOR_FINE);\n    psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[notes_to_play[i]]) >> 8);\n    psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[notes_to_play[i]]) & TONE_GENERATOR_FINE);\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(38400);\n  Serial.println(\"\");\n  Serial.println(\"AY-3-891x Sound Chip Library Example 4: I/O Ports.\");\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  // By default, the I/O ports are set up as inputs.\n  // There are internal pull-ups connected to the input ports, so if the pins\n  // are left floating, they should read as zero when set to input.\n  psg.write(AY3891x::Enable_Reg, ~(MIXER_INPUTS_DISABLE));  // Disable audio, I/O ports to input mode\n  Serial.println(\"Input Mode has internal pullups.\");\n  Serial.print(\"Input Port A read value: 0x\");\n  Serial.println(psg.read(AY3891x::IO_Port_A_Reg), HEX);\n  Serial.print(\"Input Port B read value: 0x\");\n  Serial.println(psg.read(AY3891x::IO_Port_B_Reg), HEX);\n  delay(1000);\n\n  // Set lines to output with value 0xA5 on Port A and 0x5A on Port B\n  // Measure with a DMM or scope to test\n  Serial.println(\"Setting ports to OUTPUT...\");\n  delay(1000);\n  psg.write(AY3891x::Enable_Reg, MIXER_ALL_DISABLED); // Ports to output mode, audio disabled\n  Serial.println(\"Writing 0xA5 to A and 0x5A to B.\");\n  psg.write(AY3891x::IO_Port_A_Reg, 0xA5);\n  psg.write(AY3891x::IO_Port_B_Reg, 0x5A);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "cmd_unrecognized",
          "body": "sender->GetSerial()->print(F(\"Unrecognized command [\"));\n\tsender->GetSerial()->print(cmd);\n\tsender->GetSerial()->println(F(\"]\"));"
        },
        {
          "name": "cmd_enable",
          "body": "// \"enable all\"        -- enables all tone and noise generators\n  // \"enable all tones\"  -- enables all tone generators\n  // \"enable all noises\" -- enables all noise generators\n  // \"enable tone a\"     -- enables tone generator A\n  // \"enable tone b\"     -- enables tone generator A\n  // \"enable tone c\"     -- enables tone generator A\n  // \"enable noise a\"    -- enables noise generator A\n  // \"enable noise b\"    -- enables noise generator B\n  // \"enable noise c\"    -- enables noise generator C\n  enum{ALL, TONE, NOISE, TONES, NOISES, CHANA, CHANB, CHANC, NONE"
        },
        {
          "name": "cmd_disable",
          "body": "// \"disable\"        -- disables all tone and noise generators\n  byte value;\n\n  sender->GetSerial()->println(F(\"Disabling all tones and noises.\"));\n\n  value = psg.read(AY3891x::Enable_Reg);\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONES_DISABLE | value);"
        },
        {
          "name": "cmd_write",
          "body": "char* param1 = sender->Next();  // Register\n  char* param2 = sender->Next();  // Value\n  byte p1, p2;\n\n  if (param1 == NULL) cmd_unrecognized(sender, buffer);\n  else\n  {\n    p1 = atoi(param1);\n    if (p1 > AY3891x::IO_Port_B_Reg) cmd_unrecognized(sender, buffer);\n    else\n    {\n      if (param2 == NULL) cmd_unrecognized(sender, buffer);\n      else\n      {\n        p2 = atoi(param2);\n        sender->GetSerial()->print(F(\"Writing register 0x\"));\n        sender->GetSerial()->print(p1, HEX);\n        sender->GetSerial()->print(F(\" with value 0x\"));\n        sender->GetSerial()->println(p2, HEX);\n        psg.write(p1, p2);"
        },
        {
          "name": "cmd_read",
          "body": "char* param1 = sender->Next();  // Register\n  byte p1;\n  if (param1 == NULL) cmd_unrecognized(sender, buffer);\n  else\n  {\n    p1 = atoi(param1);\n    if (p1 > AY3891x::IO_Port_B_Reg) cmd_unrecognized(sender, buffer);\n    else\n    {\n      sender->GetSerial()->print(F(\"Reading value from register 0x\"));\n      sender->GetSerial()->print(p1, HEX);\n      sender->GetSerial()->print(F(\": 0x\"));\n      sender->GetSerial()->println(psg.read(p1), HEX);"
        },
        {
          "name": "cmd_middlec",
          "body": "sender->GetSerial()->println(\"Enable Middle C on channels A and B\");\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONE_C_DISABLE);    // Disable the noise, enable tones on A and B\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n  psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);"
        },
        {
          "name": "cmd_gunshot",
          "body": "sender->GetSerial()->println(\"Playing gunshot sound on A, B, C\");\n  // Register programming values adopted from AY-3-8910 Data Manual, Secion 6.2\n  psg.write(AY3891x::Noise_Period_Reg, 0xF); // Set Noise period to mid-value\n  psg.write(AY3891x::Enable_Reg, MIXER_TONES_DISABLE); // Enable noise only on A,B,C\n  psg.write(AY3891x::ChA_Amplitude, 0x10); // Set full amplitude range under direct control of Envelope Generator\n  psg.write(AY3891x::ChB_Amplitude, 0x10);\n  psg.write(AY3891x::ChC_Amplitude, 0x10);\n  psg.write(AY3891x::Env_Period_Coarse_Reg, 4); // Set envlope period\n  psg.write(AY3891x::Env_Period_Fine_Reg, 0);\n  psg.write(AY3891x::Env_Shape_Cycle, 0);  // Envelope decay, one cycle only"
        },
        {
          "name": "cmd_explosion",
          "body": "sender->GetSerial()->println(\"Playing explosion sound on A, B, C\");\n  // Register programming values adopted from AY-3-8910 Data Manual, Secion 6.2\n  psg.write(AY3891x::Noise_Period_Reg, 0x0); // Set Noise period to max value\n  psg.write(AY3891x::Enable_Reg, MIXER_TONES_DISABLE); // Enable noise only on A,B,C\n  psg.write(AY3891x::ChA_Amplitude, 0x10); // Set full amplitude range under direct control of Envelope Generator\n  psg.write(AY3891x::ChB_Amplitude, 0x10);\n  psg.write(AY3891x::ChC_Amplitude, 0x10);\n  psg.write(AY3891x::Env_Period_Coarse_Reg, 0x1c); // Set envlope period\n  psg.write(AY3891x::Env_Period_Fine_Reg, 0);\n  psg.write(AY3891x::Env_Shape_Cycle, 0);  // Envelope decay, one cycle only"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\tSerial.begin(38400);\n\n\tserial_commands_.SetDefaultHandler(cmd_unrecognized);\n\tserial_commands_.AddCommand(&cmd_enable_);\n  serial_commands_.AddCommand(&cmd_disable_);\n  serial_commands_.AddCommand(&cmd_write_);\n  serial_commands_.AddCommand(&cmd_read_);\n  serial_commands_.AddCommand(&cmd_middlec_);\n  serial_commands_.AddCommand(&cmd_gunshot_);\n  serial_commands_.AddCommand(&cmd_explosion_);\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n  // Set up a tone on channel A and B to make testing easier.\n  // By default, the tone and noise generators are enabled when the chip comes out of reset, I/O pins are set to INPUT\n  psg.write(AY3891x::Enable_Reg, MIXER_NOISES_DISABLE | MIXER_TONE_C_DISABLE);    // Disable the noise and channel C\n  psg.write(AY3891x::ChA_Amplitude, 0x04); // Lower amplitude\n  psg.write(AY3891x::ChB_Amplitude, 0x08); // Mid amplitude\n  Serial.print(F(\"Configuring note: C4 (middle C)\"));\n  psg.write(AY3891x::ChA_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChA_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n  psg.write(AY3891x::ChB_Tone_Period_Coarse_Reg, pgm_read_word(&Notes[C_4]) >> 8);\n  psg.write(AY3891x::ChB_Tone_Period_Fine_Reg, pgm_read_word(&Notes[C_4]) & TONE_GENERATOR_FINE);\n\n  Serial.println(F(\"\"));\n  Serial.println(F(\"AY-3-891x Sound Chip Library Example 5: Serial Commands.\"));\n  Serial.println(F(\"\"));\n  Serial.println(F(\"Available commands:\"));\n  Serial.println(F(\"  enable all [tones|noises]\"));\n  Serial.println(F(\"  enable tone a|b|c\"));\n  Serial.println(F(\"  enable noise a|b|c\"));\n  Serial.println(F(\"  disable\"));\n  Serial.println(F(\"  write register value\"));\n  Serial.println(F(\"  read register\"));\n  Serial.println(F(\"  middlec\"));\n  Serial.println(F(\"  gunshot\"));\n  Serial.println(F(\"  explosion\"));\n  Serial.println(F(\"Enter command: \"));"
        },
        {
          "name": "loop",
          "body": "serial_commands_.ReadSerial();"
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address."
        },
        {
          "name": "loop",
          "body": "byte i;\n\n  if (micros() - prev_micros > INTERVAL)\n  {\n    prev_micros = micros();\n\n    for (i= 0; i < 14; i++) {\n      psg.write(i, pgm_read_byte(&psg_data[data_index++]));"
        }
      ]
    },
    {
      "name": "HARDWARE_GENERATED_CLOCK",
      "keywords": [
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "clockSetup",
          "body": "TCCR1A = (1 << COM1A0);\n  TCCR1B = (1 << WGM12) | (1 << CS10);\n  TCCR1C = 0;\n  TIMSK1 = 0;\n  OCR1AH = 0;\n  OCR1AL = DIVISOR;"
        },
        {
          "name": "setup",
          "body": "#ifdef HARDWARE_GENERATED_CLOCK\n  // Hardware-specific microcontroller code to generate a clock signal for the AY-3-891x chip\n  pinMode(clkOUT, OUTPUT);\n  digitalWrite(clkOUT, LOW);\n  clockSetup();\n#endif\n\n  pinMode(CS, OUTPUT);\n  pinMode(NEXT_BUTTON, INPUT_PULLUP);\n  Serial.begin(9600);\n\n  psg.begin();\n  // psg.setAddress(TheChipsAddress);   // Only need this for special-ordered chips with non-default address.\n\n  Serial.println(F(\"\"));\n  Serial.println(F(\"AY-3-891x Sound Chip Library Example 7: Sound Chip YM data player.\"));\n  Serial.print(F(\"Press button on pin \"));\n  Serial.print(NEXT_BUTTON);\n  Serial.println(F(\" to advance to next song on SD card.\"));\n  Serial.println(F(\"\"));\n\n  if (!SD.begin(CS))\n  {\n    Serial.println(F(\"SD Initialization Failed: program stopped.\"));\n    while (1); // Infinite loop here"
        },
        {
          "name": "loop",
          "body": "int i;\n  byte register_data[14];\n\n  switch (state) {\n\n    case PLAYING:\n      if (micros() - prev_micros > INTERVAL)\n      {\n        prev_micros = micros();\n        if (current_song.available())\n        {\n          for (i = 0; i < 14; i++) {\n            register_data[i] = current_song.read();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  BHY2.begin();\n  accel.begin();\n  gyro.begin();"
        },
        {
          "name": "loop",
          "body": "static auto printTime = millis();\n\n  // Update function should be continuously polled\n  BHY2.update();\n\n  if (millis() - printTime >= 50) {\n    printTime = millis();\n\n    // Accelerometer values\n    Serial.print(\"acc_X:\");\n    Serial.print(accel.x());\n    Serial.print(\",\");\n    Serial.print(\"acc_Y:\");\n    Serial.print(accel.y());\n    Serial.print(\",\");\n    Serial.print(\"acc_Z:\");\n    Serial.print(accel.z());\n    Serial.print(\",\");\n\n    // Gyroscope values\n    Serial.print(\"gyro_X:\");\n    Serial.print(gyro.x());\n    Serial.print(\",\");\n    Serial.print(\"gyro_Y:\");\n    Serial.print(gyro.y());\n    Serial.print(\",\");\n    Serial.print(\"gyro_Z:\");\n    Serial.println(gyro.z());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h",
        "AccelStepper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "SPI.begin();\n  stepper.init(amisSlaveSelect);\n  delay(1);\n\n  stepper.resetSettings();\n  stepper.setCurrentMilliamps(132);\n  stepper.setStepMode(32);\n  stepper.enableDriver();\n\n  accelStepper.setMaxSpeed(2000.0);\n  accelStepper.setAcceleration(500.0);"
        },
        {
          "name": "loop",
          "body": "accelStepper.runToNewPosition(0);\n  delay(500);\n  accelStepper.runToNewPosition(10000);\n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AccelStepper.h",
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "body": "myStepper1->onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "body": "myStepper1->onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);           // set up Serial library at 9600 bps\n   Serial.println(\"Stepper test!\");\n\n  if (!AFMS.begin()) {         // create with the default frequency 1.6KHz\n  // if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz\n    Serial.println(\"Could not find Motor Shield. Check wiring.\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "Astepper1.runSpeed();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "AccelStepper.h",
        "Adafruit_MotorShield.h"
      ],
      "functions": [
        {
          "name": "forwardstep1",
          "body": "myStepper1->onestep(FORWARD, SINGLE);"
        },
        {
          "name": "backwardstep1",
          "body": "myStepper1->onestep(BACKWARD, SINGLE);"
        },
        {
          "name": "forwardstep2",
          "body": "myStepper2->onestep(FORWARD, DOUBLE);"
        },
        {
          "name": "backwardstep2",
          "body": "myStepper2->onestep(BACKWARD, DOUBLE);"
        },
        {
          "name": "forwardstep3",
          "body": "myStepper3->onestep(FORWARD, INTERLEAVE);"
        },
        {
          "name": "backwardstep3",
          "body": "myStepper3->onestep(BACKWARD, INTERLEAVE);"
        },
        {
          "name": "setup",
          "body": "AFMSbot.begin(); // Start the bottom shield\n  AFMStop.begin(); // Start the top shield\n\n  stepper1.setMaxSpeed(100.0);\n  stepper1.setAcceleration(100.0);\n  stepper1.moveTo(24);\n\n  stepper2.setMaxSpeed(200.0);\n  stepper2.setAcceleration(100.0);\n  stepper2.moveTo(50000);\n\n  stepper3.setMaxSpeed(300.0);\n  stepper3.setAcceleration(100.0);\n  stepper3.moveTo(1000000);"
        },
        {
          "name": "loop",
          "body": "// Change direction at the limits\n    if (stepper1.distanceToGo() == 0)\n\tstepper1.moveTo(-stepper1.currentPosition());\n\n    if (stepper2.distanceToGo() == 0)\n\tstepper2.moveTo(-stepper2.currentPosition());\n\n    if (stepper3.distanceToGo() == 0)\n\tstepper3.moveTo(-stepper3.currentPosition());\n\n    stepper1.run();\n    stepper2.run();\n    stepper3.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(9600);\n  while(!Serial);\n  \n  Accelerometer.begin();"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  // 3 axis\n  Serial.print(\"x:\"); \n  Serial.print(Accelerometer.readX()); \n  Serial.print(\"  \");\n  Serial.print(\"y:\"); \n  Serial.print(Accelerometer.readY());        \n  Serial.print(\"  \");\n  Serial.print(\"z:\"); \n  Serial.println(Accelerometer.readZ());\n \n  delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 bits per second for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n    accelerometer.initialize(); // Set-up for MPU \n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelrometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G"
        },
        {
          "name": "loop",
          "body": "acc = accelerometer.getSample(); // Gets and saves 3-axis acceleration reading (G)\n\n    Serial.print(\"Acceleration in Gs, X-Axis: \"); Serial.print(acc.x, 8); // Prints out 3-axis acceleration (G)\n    Serial.print(\" Y-Axis: \"); Serial.print(acc.y, 8);\n    Serial.print(\" Z-Axis: \"); Serial.print(acc.z, 8);\n    Serial.println();\n    \n    delay(500); // Waits 500ms (half a second)"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n\n    accelerometer.initialize(); // Set-up for MPU \n\n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelrometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G\n\n    pinMode(LED, OUTPUT); // Sets LED\n    \n    delay(50); // Allow time for sensor initialization to complete\n\n    for(int i = 0; i < 3; i++){ // Calibration period of 3 seconds\n        startTime = millis(); // Keeps track of start time before getting measurements\n\n        accelRaw = accelerometer.getRawAcc(); // Gets and saves raw acceleration \n        accelG = accelerometer.getGAccel(accelRaw); // Gets and saves acceleration in G's\n        accelMPS = accelerometer.getMPSAccel(accelG); // Gets and saves acceleration in MPS\n        \n        Serial.print(\"MPS, X-Axis: \"); // Prints out 3-axis acceleration (MPS)\n        Serial.println(accelMPS.x, 8);\n        Serial.print(\"MPS, Y-Axis: \");\n        Serial.println(accelMPS.y, 8);\n        Serial.print(\"MPS, Z-Axis: \");\n        Serial.println(accelMPS.z, 8);\n        Serial.println();\n    \n        staticAcceleration = staticAcceleration + sqrt(pow(accelMPS.x,2) + pow(accelMPS.y,2) + pow(accelMPS.z,2)); // Adds up magnitude of \n                                                                                                                   // current acceleration\n        endTime = millis(); // Keeps track of end time after getting measurements \n        delay(1000 - (endTime - startTime)); // Change of time factored into a one second delay"
        },
        {
          "name": "loop",
          "body": "startTime = millis(); // Keeps track of start time before getting measurements\n\n    accelRaw = accelerometer.getRawAcc(); // Gets and saves raw acceleration\n    accelG = accelerometer.getGAccel(accelRaw); // Gets and saves acceleration in G's\n    accelMPS = accelerometer.getMPSAccel(accelG); // Gets and saves acceleration in MPS\n\n    Serial.print(\"MPS, X-Axis: \"); // Prints out 3-axis acceleration (MPS)\n    Serial.println(accelMPS.x, 8);\n    Serial.print(\"MPS, Y-Axis: \");\n    Serial.println(accelMPS.y, 8);\n    Serial.print(\"MPS, Z-Axis: \");\n    Serial.println(accelMPS.z, 8);\n    Serial.println();\n\n    dynamicAcceleration = sqrt(pow(accelMPS.x,2) + pow(accelMPS.y,2) + pow(accelMPS.z,2)); // Adds up magnitude of current acceleration\n\n    accelDif = abs(dynamicAcceleration - staticAcceleration); // Subtracts and saves static acceleration from dynamic acceleration\n\n    Serial.print(F(\"Calculated Difference in Acceleration: \")); Serial.println(accelDif); // Print out difference in acceleration\n\n    if(accelDif >= impactThreshold){ // If the difference in acceleration is greater than or equal to the threshhold set above\n        Serial.println(\"Impact detected\"); // Notify impact has been detected\n\n        digitalWrite(LED, HIGH); // LEDs blink\n        delay(500);\n        digitalWrite(LED, LOW);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // Sets baud rate to 9600 for serial transmission \n                        // and starts serial communication\n    accelerometer.begin(); // Begins transmission to the I2C slave device\n    accelerometer.initialize(); // Set-up for MPU \n    accelerometer.setAccelRange(MPU6000_RANGE_2_G); // Sets range of acccelerometer \n                                                    // Range options: 2_G, 4_G, 8_G, 16_G\n\n    // Calibration (LunaSat flat on table)\n    sensor_float_vec_t calibrationPoints[calibrationSize];  // Array of vectors for storing calibration points  \n    for(int i = 0; i < calibrationSize; i++){\n        calibrationPoints[i] = accelerometer.getSample();"
        },
        {
          "name": "loop",
          "body": "acc = accelerometer.getSample(); // Gets and saves 3-axis acceleration reading (G)\n\n    accMPS = accelerometer.getMPSAccel(acc); // Converts acceleration measurements from G's to meters per second squared\n\n    // Subtract baseline values from current sample\n\n    accMPS.x = accMPS.x - avgX*9.81; // Multiply by 9.81 to convert G's to m/s^2\n    accMPS.y = accMPS.y - avgY*9.81;\n    \n    // Find the net acceleration for each pair of axes\n    yzAcceleration = sqrt(pow(accMPS.y,2) + pow(accMPS.z,2)); \n    xzAcceleration = sqrt(pow(accMPS.x,2) + pow(accMPS.z,2)); \n    xyAcceleration = sqrt(pow(accMPS.x,2) + pow(accMPS.y,2)); \n\n    // Calculate x angle (roll)\n    xAngle = accMPS.x/yzAcceleration;\n    xAngle = atan(xAngle)*(180/3.141);\n    Serial.print(\"X Angle (Roll): \");\n    Serial.print(xAngle);\n    Serial.println(\"º\");\n\n    // Calculate y angle (pitch)\n    yAngle = accMPS.y/xzAcceleration;\n    yAngle = atan(yAngle)*(180/3.141);\n    Serial.print(\"Y Angle (Pitch): \");\n    Serial.print(yAngle);\n    Serial.println(\"º\");\n\n    // Calculate z angle (yaw)\n    zAngle = accMPS.z/xyAcceleration;\n    zAngle = (atan(zAngle)*(180/3.141));\n    Serial.print(\"Z Angle (Yaw): \");\n    Serial.print(zAngle);\n    Serial.println(\"º\");\n    Serial.println();\n    \n    delay(500); // Waits half a second"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && millis() - dataMillis > 5000)\n  {\n    dataMillis = millis();\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count++) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "SKETCH_DEBUG",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AccessoryShield.h",
        "Mouse.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the Accessory Shield library\n  accessoryShield.begin();\n  // initialize mouse control:\n  Mouse.begin();\n  \n#ifdef SKETCH_DEBUG\n  Serial.begin(9600);\n  while(!Serial) ;\n#endif"
        },
        {
          "name": "loop",
          "body": "// read a new value from th joystick\n  JoystickMode joystickValue = accessoryShield.getJoystickValue();\n  \n  // set the distance offset using the pot trimmer of Accessory Shield\n  unsigned int distanceOffset = accessoryShield.readPot();\n  // calibrate and map the pot value \n  distanceOffset = map(distanceOffset, 0, 1023, minDistanceOffset, maxDistanceOffset);\n  // set the X and Y distance :\n  // xDistance and yDistance are used to set how the mouse sould be moved\n  // in orizontal (X axis) or in vertical (Y axis) \n  xDistance = yDistance = distanceOffset;\n\n  // check if the joystick has been moved\n#if (defined(_VARIANT_ARDUINO_101_X_) || defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAMD))\n  if(joystickValue != JOYSTICK_NONE_OR_DOWN) {\n#else\n  if(joystickValue != JOYSTICK_NONE) {\n#endif\n    // print values of X and Y distance\n#ifdef SKETCH_DEBUG\n    Serial.print(\"X distance offset= \");\n    Serial.println(xDistance);\n    Serial.print(\"Y distance offset= \");\n    Serial.println(yDistance);\n#endif\n    \n    switch(joystickValue) {\n      // if the joystick has been pushed, click with mouse left button\n      case JOYSTICK_PUSH :\n        Mouse.click(MOUSE_LEFT);\n        break;\n      // if the joystick has been moved up, move up the mouse cursor\n      case JOYSTICK_UP :\n        Mouse.move(0, -yDistance, 0);\n        break;\n#if !(defined(_VARIANT_ARDUINO_101_X_) || defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAMD))\n      // if the joystick has been moved down, move down the mouse cursor\n      case JOYSTICK_DOWN :\n        Mouse.move(0, yDistance, 0);\n        break;\n#endif\n      // if the joystick has been moved right, move right the mouse cursor\n      case JOYSTICK_RIGHT :\n        Mouse.move(xDistance, 0, 0);\n        break;\n      // if the joystick has been moved left, move left the mouse cursor\n      case JOYSTICK_LEFT :\n        Mouse.move(-xDistance, 0, 0);\n        break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  BHY2.begin();\n  active.begin();"
        },
        {
          "name": "loop",
          "body": "BHY2.update();\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis >= interval) {\n    previousMillis = currentMillis;\n    Serial.println(String(\"Activity info: \") + active.toString());"
        }
      ]
    },
    {
      "name": "Serial",
      "keywords": [
        "Serial",
        "delay",
        "Wire",
        "digitalWrite"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "HardwareSerial.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Serial.println(F(\"*** SIMCom Module MQTT Example ***\"));\n\n  #ifdef LED\n    pinMode(LED, OUTPUT);\n    digitalWrite(LED, LOW);\n  #endif\n  \n  pinMode(RST, OUTPUT);\n  digitalWrite(RST, HIGH); // Default state\n\n  modem.powerOn(BOTLETICS_PWRKEY); // Power on the module\n  moduleSetup(); // Establishes first-time serial comm and prints IMEI\n\n  if (!tempsensor.begin()) {\n    Serial.println(\"Couldn't find the MCP9808!\");\n    tempsensor.wake(); // Wake up the MCP9808 if it was sleeping and retry\n    if (!tempsensor.begin()) while (1);"
        },
        {
          "name": "loop",
          "body": "// Connect to cell network and verify connection\n  // If unsuccessful, keep retrying every 2s until a connection is made\n  while (!netStatus()) {\n    Serial.println(F(\"Failed to connect to cell network, retrying...\"));\n    delay(2000); // Retry every 2s"
        },
        {
          "name": "moduleSetup",
          "body": "// SIM7000 takes about 3s to turn on and SIM7500 takes about 15s\n  // Press Arduino reset button if the module is still turning on and the board doesn't find it.\n  // When the module is on it should communicate right after pressing reset\n\n  // Software serial:\n  modemSS.begin(115200); // Default SIM7000 shield baud rate\n\n  Serial.println(F(\"Configuring to 9600 baud\"));\n  modemSS.println(\"AT+IPR=9600\"); // Set baud rate\n  delay(100); // Short pause to let the command run\n  modemSS.begin(9600);\n  if (! modem.begin(modemSS)) {\n    Serial.println(F(\"Couldn't find modem\"));\n    while (1); // Don't proceed if it couldn't find the device"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  // Stop if already connected.\n  if (mqtt.connected()) {\n    return;"
        },
        {
          "name": "MQTT_publish_checkSuccess",
          "body": "Serial.println(F(\"Sending data...\"));\n  if (! feed.publish(feedContent)) {\n    Serial.println(F(\"Failed\"));\n    txfailures++;"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleBLEPeripheral.h",
        "BLEPeripheral.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  SerialBLE.setLocalName(\"Blynk\");\n  SerialBLE.setDeviceName(\"Blynk\");\n  SerialBLE.setAppearance(0x0080);\n  SerialBLE.begin();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(SerialBLE, auth);"
        },
        {
          "name": "loop",
          "body": "SerialBLE.poll();\n\n  if (SerialBLE) {    // If BLE is connected...\n    Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleSerialBLE.h",
        "Adafruit_BLE.h",
        "Adafruit_BluefruitLE_SPI.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  ble.begin(BLUEFRUIT_VERBOSE_MODE);\n  ble.factoryReset(); // Optional\n  ble.setMode(BLUEFRUIT_MODE_DATA);\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(auth, ble);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFi101.h",
        "BlynkSimpleWiFiShield101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  WiFi.setPins(8, 7, 4, 2);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(pin, INPUT);"
        },
        {
          "name": "loop",
          "body": "for (int i = 0; i < repetitions; i++) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(500);\n    digitalWrite(LED_BUILTIN, LOW);\n    delay(500);"
        },
        {
          "name": "repetitionsIncrease",
          "body": "// This function will be called once on device wakeup\n  // You can do some little operations here (like changing variables which will be used in the loop)\n  // Remember to avoid calling delay() and long running functions since this functions executes in interrupt context\n  repetitions ++;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Checking Connection\");\n  if (WifiConnection::isConnected()) {\n    \n    // add that value to array in the server\n    bool isOk = storage.add(\"times_alive\", millis());\n    \n    // notify if error occurred\n    if(isOk == false) {\n      Serial.println(\"Something went wrong...\");"
        }
      ]
    },
    {
      "name": "INT_FREQ",
      "keywords": [
        "Wire",
        "Serial",
        "attachInterrupt",
        "digitalWrite"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Begin Serial communication\n    Serial.begin(9600);\n    while (!Serial);\n\n    // Set the DS3231 clock mode to 24-hour\n    myRTC.setClockMode(false); // false = not using the alternate, 12-hour mode\n\n    // Set the clock to an arbitrarily chosen time of\n    // 00:00:00 midnight the morning of January 1, 2020\n    // using a suitable Unix-style timestamp\n    myRTC.setEpoch(1640995200);\n\n    // Assign parameter values for Alarm 1\n    alarmDay = myRTC.getDate();\n    alarmHour = myRTC.getHour(alarmH12, alarmPM);\n    alarmMinute = myRTC.getMinute();\n    alarmSecond = INT_FREQ; // initialize to the interval length\n    alarmBits = 0b00001110; // Alarm 1 when seconds match\n    alarmDayIsDay = false; // using date of month\n\n    // Upload initial parameters of Alarm 1\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(\n       alarmDay, alarmHour, alarmMinute, alarmSecond,\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // clear Alarm 1 flag after setting the alarm time\n    myRTC.checkIfAlarm(1);\n    // now it is safe to enable interrupt output\n    myRTC.turnOnAlarm(1);\n\n    // When using interrupt with only one of the DS3231 alarms, as in this example,\n    // it may be possible to prevent the other alarm entirely,\n    // so it will not covertly block the outgoing interrupt signal.\n\n    // Try to prevent Alarm 2 altogether by assigning a \n    // nonsensical alarm minute value that cannot match the clock time,\n    // and an alarmBits value to activate \"when minutes match\".\n    alarmMinute = 0xFF; // a value that will never match the time\n    alarmBits = 0b01100000; // Alarm 2 when minutes match, i.e., never\n    \n    // Upload the parameters to prevent Alarm 2 entirely\n    myRTC.setA2Time(\n        alarmDay, alarmHour, alarmMinute,\n        alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // disable Alarm 2 interrupt\n    myRTC.turnOffAlarm(2);\n    // clear Alarm 2 flag\n    myRTC.checkIfAlarm(2);\n\n    // NOTE: both of the alarm flags must be clear\n    // to enable output of a FALLING interrupt\n\n    // attach clock interrupt\n    pinMode(CLINT, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(CLINT), isr_TickTock, FALLING);\n\n    // Configure the LED for blinking\n    pinMode(LED_BUILTIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // Do when alarm interrupt received:\n    if (tick) {\n        // right away, capture the current time in a DateTime variable\n        // for later processing\n        DateTime alarmDT = RTClib::now();\n\n        // disable Alarm 1 interrupt\n        myRTC.turnOffAlarm(1);\n        \n        // Clear Alarm 1 flag\n        myRTC.checkIfAlarm(1);\n        \n        tick = 0; // reset the local interrupt-received flag\n        state = ~state; // reverse the state of the LED\n        digitalWrite(LED_BUILTIN, state);\n\n        // optional serial output\n        Serial.print(\"Turning LED \");\n        Serial.print((state ? \"ON\" : \"OFF\"));\n        Serial.print(\" at \");\n        Serial.print(alarmDT.hour());\n        Serial.print(\":\");\n        Serial.print(alarmDT.minute());\n        Serial.print(\":\");\n        Serial.println(alarmDT.second());\n\n        // extract the DateTime values as a timestamp \n        uint32_t nextAlarm = alarmDT.unixtime();\n        // add the INT_FREQ number of seconds\n        nextAlarm += INT_FREQ;\n        // update the DateTime with the new timestamp\n        alarmDT = DateTime(nextAlarm);\n\n        // upload the new time to Alarm 1\n       myRTC.setA1Time(\n         alarmDT.day(), alarmDT.hour(), alarmDT.minute(), alarmDT.second(),\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n       \n       // enable Alarm 1 interrupts\n       myRTC.turnOnAlarm(1);\n      // clear Alarm 1 flag again after enabling interrupts\n        myRTC.checkIfAlarm(1);"
        },
        {
          "name": "isr_TickTock",
          "body": "// interrupt signals to loop\n    tick = 1;\n    return;"
        }
      ]
    },
    {
      "name": "TRIGGER_PIN",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP  \n  Serial.begin(115200);\n  Serial.setDebugOutput(true);  \n  delay(3000);\n  Serial.println(\"\\n Starting\");\n\n  pinMode(TRIGGER_PIN, INPUT);\n  \n  // wm.resetSettings(); // wipe settings\n\n  if(wm_nonblocking) wm.setConfigPortalBlocking(false);\n\n  // add a custom input field\n  int customFieldLength = 40;\n\n\n  // new (&custom_field) WiFiManagerParameter(\"customfieldid\", \"Custom Field Label\", \"Custom Field Value\", customFieldLength,\"placeholder=\\\"Custom Field Placeholder\\\"\");\n  \n  // test custom html input type(checkbox)\n  // new (&custom_field) WiFiManagerParameter(\"customfieldid\", \"Custom Field Label\", \"Custom Field Value\", customFieldLength,\"placeholder=\\\"Custom Field Placeholder\\\" type=\\\"checkbox\\\"\"); // custom html type\n  \n  // test custom html(radio)\n  const char* custom_radio_str = \"<br/><label for='customfieldid'>Custom Field Label</label><input type='radio' name='customfieldid' value='1' checked> One<br><input type='radio' name='customfieldid' value='2'> Two<br><input type='radio' name='customfieldid' value='3'> Three\";\n  new (&custom_field) WiFiManagerParameter(custom_radio_str); // custom html input\n  \n  wm.addParameter(&custom_field);\n  wm.setSaveParamsCallback(saveParamCallback);\n\n  // custom menu via array or vector\n  // \n  // menu tokens, \"wifi\",\"wifinoscan\",\"info\",\"param\",\"close\",\"sep\",\"erase\",\"restart\",\"exit\" (sep is seperator) (if param is in menu, params will not show up in wifi page!)\n  // const char* menu[] = {\"wifi\",\"info\",\"param\",\"sep\",\"restart\",\"exit\""
        },
        {
          "name": "checkButton",
          "body": "// check for button press\n  if ( digitalRead(TRIGGER_PIN) == LOW ) {\n    // poor mans debounce/press-hold, code not ideal for production\n    delay(50);\n    if( digitalRead(TRIGGER_PIN) == LOW ){\n      Serial.println(\"Button Pressed\");\n      // still holding button for 3000 ms, reset settings, code not ideaa for production\n      delay(3000); // reset delay hold\n      if( digitalRead(TRIGGER_PIN) == LOW ){\n        Serial.println(\"Button Held\");\n        Serial.println(\"Erasing Config, restarting\");\n        wm.resetSettings();\n        ESP.restart();"
        },
        {
          "name": "saveParamCallback",
          "body": "Serial.println(\"[CALLBACK] saveParamCallback fired\");\n  Serial.println(\"PARAM customfieldid = \" + getParam(\"customfieldid\"));"
        },
        {
          "name": "loop",
          "body": "if(wm_nonblocking) wm.process(); // avoid delays() in loop when non-blocking and other long running code  \n  checkButton();\n  // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the Ethernet device\n  Ethernet.begin(ip, subnet, gateway, myDns);\n  // start listening for clients\n  server.begin();\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// wait for a new client:\n  EthernetClient client = server.available();\n\n  // when the client sends the first byte, say hello:\n  if (client) {\n\n    bool newClient = true;\n    for (byte i = 0; i < 4; i++) {\n      //check whether this client refers to the same socket as one of the existing instances:\n      if (clients[i] == client) {\n        newClient = false;\n        break;"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    WS_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "//out.reserve(ORIGINAL_STR_LEN);\n\n  pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AdvancedWebServer on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if ! (ESP32 || ESP8266)\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_ESP32_SPI2 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ETG_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  Serial.println(\"=========================\");\n  Serial.println(\"Currently Used SPI pinout:\");\n  Serial.print(\"MOSI:\");\n  Serial.println(PIN_MOSI);\n  Serial.print(\"MISO:\");\n  Serial.println(PIN_MISO);\n  Serial.print(\"SCK:\");\n  Serial.println(PIN_SCK);\n  Serial.print(\"SS:\");\n  Serial.println(USE_THIS_SS_PIN);\n  Serial.println(F(\"=========================\"));\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  if (Ethernet.getChip() == w5500)\n  {\n    Serial.print(F(\"Speed: \"));\n    Serial.print(Ethernet.speedReport());\n    Serial.print(F(\", Duplex: \"));\n    Serial.print(Ethernet.duplexReport());\n    Serial.print(F(\", Link status: \"));\n    Serial.println(Ethernet.linkReport());"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n\n#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AdvancedWebServer %s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += server.uri();\n  message += \"\\nMethod: \";\n  message += (server.method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += server.args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  \n  delay(2000);\n \n  Serial.println(\"\\nStart AdvancedWebServer_LAN8720 on \" + String(BOARD_NAME) + \", using \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n  \n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());\n\n  server.on(\"/\", handleRoot);\n  server.on(\"/test.svg\", drawGraph);\n  server.on(\"/inline\", []()\n  {\n    server.send(200, \"text/plain\", \"This works as well\");"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "WEBSERVER_PORT",
      "keywords": [
        "delay",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server->uri();\n  message += F(\"\\nMethod: \");\n  message += (server->method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server->args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server->args(); i++)\n  {\n    message += \" \" + server->argName(i) + \": \" + server->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "SerialDebug.begin(115200);\n\n  while (!SerialDebug && millis() < 5000);\n\n  delay(1000);\n\n  SerialDebug.print(\"\\nStarting AdvancedWebServer_Ptr on \");\n  SerialDebug.print(BOARD_NAME);\n  SerialDebug.print(F(\" with \"));\n  SerialDebug.println(SHIELD_TYPE);\n  SerialDebug.println(ETHERNET_WEBSERVER_VERSION);\n\n#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    SerialDebug.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  SerialDebug.print(F(\".\"));\n\n  if (num == 80)\n  {\n    SerialDebug.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server->handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "initEthernet",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    Serial.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_RP2040_SPI1 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "SERIAL_PORT_MONITOR",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n  \n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf_P(temp, BUFFER_SIZE - 1,\n           PSTR(\"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  \n  String message = F(\"File Not Found\\n\\n\");\n  \n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n  \n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    AT_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n  \n  Serial.print(F(\"\\nStarting AdvancedWebServer_STM32 on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE); \n  Serial.println(ESP8266_AT_WEBSERVER_VERSION);\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n  // check for the presence of the shield\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "server.handleClient();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    ET_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "initEthernet",
          "body": "#if USE_ETHERNET_PORTENTA_H7\n  ET_LOGWARN(F(\"======== USE_PORTENTA_H7_ETHERNET ========\"));\n#elif USE_NATIVE_ETHERNET\n  ET_LOGWARN(F(\"======== USE_NATIVE_ETHERNET ========\"));\n#elif USE_ETHERNET_GENERIC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_GENERIC ===========\"));\n#elif USE_ETHERNET_ESP8266\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ESP8266 ===========\"));\n#elif USE_ETHERNET_ENC\n  ET_LOGWARN(F(\"=========== USE_ETHERNET_ENC ===========\"));\n#else\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n\n#if (USING_SPI2)\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n#else\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n  ET_LOGWARN(F(\"=========================\"));\n#endif\n\n#if defined(ESP8266)\n  // For ESP8266, change for other boards if necessary\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   D2    // For ESP8266\n#endif\n\n  ET_LOGWARN1(F(\"ESP8266 setCsPin:\"), USE_THIS_SS_PIN);\n\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // For ESP8266\n  // Pin                D0(GPIO16)    D1(GPIO5)    D2(GPIO4)    D3(GPIO0)    D4(GPIO2)    D8\n  // EthernetGeneric    X                 X            X            X            X        0\n  // Ethernet_ESP8266   0                 0            0            0            0        0\n  // D2 is safe to used for Ethernet, Ethernet2, Ethernet3, EthernetLarge libs\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif defined(ESP32)\n\n  // You can use Ethernet.init(pin) to configure the CS pin\n  //Ethernet.init(10);  // Most Arduino shields\n  //Ethernet.init(5);   // MKR ETH shield\n  //Ethernet.init(0);   // Teensy 2.0\n  //Ethernet.init(20);  // Teensy++ 2.0\n  //Ethernet.init(15);  // ESP8266 with Adafruit Featherwing Ethernet\n  //Ethernet.init(33);  // ESP32 with Adafruit Featherwing Ethernet\n\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   5   //22    // For ESP32\n#endif\n\n  ET_LOGWARN1(F(\"ESP32 setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // ESP32 => GPIO2,4,5,13,15,21,22 OK with Ethernet, Ethernet2, EthernetLarge\n  // ESP32 => GPIO2,4,5,15,21,22 OK with Ethernet3\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#elif ETHERNET_USE_RPIPICO\n\n  pinMode(USE_THIS_SS_PIN, OUTPUT);\n  digitalWrite(USE_THIS_SS_PIN, HIGH);\n\n  // ETHERNET_USE_RPIPICO, use default SS = 5 or 17\n#ifndef USE_THIS_SS_PIN\n#if defined(ARDUINO_ARCH_MBED)\n#define USE_THIS_SS_PIN   5     // For Arduino Mbed core\n#else\n#define USE_THIS_SS_PIN   17    // For E.Philhower core\n#endif\n#endif\n\n  ET_LOGWARN1(F(\"RPIPICO setCsPin:\"), USE_THIS_SS_PIN);\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n  // Must use library patch for Ethernet, EthernetLarge libraries\n  // For RPI Pico using Arduino Mbed RP2040 core\n  // SCK: GPIO2,  MOSI: GPIO3, MISO: GPIO4, SS/CS: GPIO5\n  // For RPI Pico using E. Philhower RP2040 core\n  // SCK: GPIO18,  MOSI: GPIO19, MISO: GPIO16, SS/CS: GPIO17\n  // Default pin 5/17 to SS/CS\n\n  //Ethernet.setCsPin (USE_THIS_SS_PIN);\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#endif    //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#else   //defined(ESP8266)\n  // unknown board, do nothing, use default SS = 10\n#ifndef USE_THIS_SS_PIN\n#define USE_THIS_SS_PIN   10    // For other boards\n#endif\n\n#if defined(BOARD_NAME)\n  ET_LOGWARN3(F(\"Board :\"), BOARD_NAME, F(\", setCsPin:\"), USE_THIS_SS_PIN);\n#else\n  ET_LOGWARN1(F(\"Unknown board setCsPin:\"), USE_THIS_SS_PIN);\n#endif\n\n  // For other boards, to change if necessary\n#if ( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC || USE_NATIVE_ETHERNET )\n  // Must use library patch for Ethernet, Ethernet2, EthernetLarge libraries\n\n  Ethernet.init (USE_THIS_SS_PIN);\n\n#elif USE_CUSTOM_ETHERNET\n\n  // You have to add initialization for your Custom Ethernet here\n  // This is just an example to setCSPin to USE_THIS_SS_PIN, and can be not correct and enough\n  Ethernet.init(USE_THIS_SS_PIN);\n\n#endif  //( USE_ETHERNET_GENERIC || USE_ETHERNET_ENC )\n\n#endif    // defined(ESP8266)\n\n#endif    // #if !(USE_NATIVE_ETHERNET)\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[0], ip);\n  Ethernet.begin(mac[index]);\n\n#if !(USE_NATIVE_ETHERNET || USE_ETHERNET_PORTENTA_H7)\n  ET_LOGWARN(F(\"=========================\"));\n\n#if defined( ESP32 )\n  // Just info to know how to connect correctly\n  // To change for other SPI\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   PIN_SS);\n#else\n#if defined(CUR_PIN_MISO)\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), CUR_PIN_MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), CUR_PIN_MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  CUR_PIN_SCK);\n  ET_LOGWARN1(F(\"SS:\"),   CUR_PIN_SS);\n#else\n  ET_LOGWARN(F(\"Currently Used SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI);\n  ET_LOGWARN1(F(\"MISO:\"), MISO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK);\n  ET_LOGWARN1(F(\"SS:\"),   SS);\n#endif\n#endif\n\n  ET_LOGWARN(F(\"=========================\"));\n\n#elif (USE_ETHERNET_PORTENTA_H7)\n\n  if (Ethernet.hardwareStatus() == EthernetNoHardware)\n  {\n    Serial.println(\"No Ethernet found. Stay here forever\");\n\n    while (true)\n    {\n      delay(1); // do nothing, no point running without Ethernet hardware"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial);\n\n  delay(1000);\n\n  Serial.print(\"\\nStarting AdvancedWebServer_Teensy4x_SPI1 on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ETHERNET_WEBSERVER_VERSION);\n\n  initEthernet();\n\n  server.on(F(\"/\"), handleRoot);\n  server.on(F(\"/test.svg\"), drawGraph);\n  server.on(F(\"/inline\"), []()\n  {\n    server.send(200, F(\"text/plain\"), F(\"This works as well\"));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     512\n\n  digitalWrite(led, 1);\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  hr = hr % 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n\n  String message = F(\"File Not Found\\n\\n\");\n\n  message += F(\"URI: \");\n  message += server.uri();\n  message += F(\"\\nMethod: \");\n  message += (server.method() == HTTP_GET) ? F(\"GET\") : F(\"POST\");\n  message += F(\"\\nArguments: \");\n  message += server.args();\n  message += F(\"\\n\");\n\n  for (uint8_t i = 0; i < server.args(); i++)\n  {\n    message += \" \" + server.argName(i) + \": \" + server.arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "static String out;\n  static uint16_t previousStrLen = ORIGINAL_STR_LEN;\n\n  if (out.length() == 0)\n  {\n    WS_LOGWARN1(F(\"String Len = 0, extend to\"), ORIGINAL_STR_LEN);\n    out.reserve(ORIGINAL_STR_LEN);"
        },
        {
          "name": "check_WiFi",
          "body": "#if ( defined(ARDUINO_PORTENTA_H7_M7) || defined(ARDUINO_PORTENTA_H7_M4) )\n\n  // Workaround for bug in https://github.com/arduino/ArduinoCore-mbed/issues/381\n  if ( (WiFi.status() != WL_CONNECTED) || (WiFi.RSSI() == 0) )\n#elif ( defined(ARDUINO_RASPBERRY_PI_PICO_W) )\n  if (!isWiFiConnected())\n#else\n  if ( (WiFi.status() != WL_CONNECTED) )\n#endif\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AdvancedWebServer_WiFiMulti on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFIMULTI_GENERIC_VERSION);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if ! (ESP32 || ESP8266)\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n\n  if (WiFiConnected)\n#else\n  if (WiFi.status() == WL_CONNECTED)\n#endif\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static uint32_t checkstatus_timeout  = 0;\n  static uint32_t checkwifi_timeout    = 0;\n\n  static uint32_t current_millis;\n\n#if ( defined(ARDUINO_RASPBERRY_PI_PICO_W) )\n#define WIFICHECK_INTERVAL    10000L\n#else\n#define WIFICHECK_INTERVAL    1000L\n#endif\n\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "server.handleClient();\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WifiConnection.h",
        "CloudStorage.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  // Try to connect to a wifi network\n  WifiConnection::tryConnect(\"WIFI_SSID\", \"WIFI_PASSWORD\");  \n\n  // Give the ESP some time to connect\n  delay(3 * 1000);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"Checking Connection\");\n  if (WifiConnection::isConnected()) {\n    \n    float averageTemperture = storage.avg(\"today_temperture_samples\");\n    float highestTemperture = storage.max<float>(\"today_temperture_samples\");\n    float lowestTemperture = storage.min<float>(\"today_temperture_samples\");\n    int numSamples = storage.count(\"today_temperture_samples\");\n\n    Serial.print(\"Today's tempertures ranged from \");\n    Serial.print(lowestTemperture); \n    Serial.print(\" degrees to \");\n    Serial.print(highestTemperture);\n    Serial.println(\" degrees celsius.\");\n\n    Serial.print(\"With the average \");\n    Serial.print(averageTemperture);\n    Serial.println(\" degrees celsius.\");\n\n    Serial.print(\"Total of \");\n    Serial.print(numSamples);\n    Serial.println(\" samples.\");"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setupWiFi",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);"
        },
        {
          "name": "setupSinricPro",
          "body": "// add device to SinricPro\n  SinricProAirQualitySensor& mySinricProAirQualitySensor = SinricPro[DEVICE_ID];\n\n  // set callback function to device\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting AirQualitySensor on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();\n\n  if ((long)(millis() - dispatchTime) >= 0) \n  {\n    SinricProAirQualitySensor &mySinricProAirQualitySensor = SinricPro[DEVICE_ID]; // get sensor device\n\n    int pm1   = 0;\n    int pm2_5 = 0;\n    int pm10  = 0;\n\n    mySinricProAirQualitySensor.sendAirQualityEvent(pm1, pm2_5, pm10, \"PERIODIC_POLL\");\n    dispatchTime += MIN;\n    \n    Serial.println(\"Sending Air Quality event ..\");"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "GP2YDustSensor.h",
        "ESP8266WiFi.h",
        "WiFi.h"
      ],
      "functions": [
        {
          "name": "setupWiFi",
          "body": "Serial.print(\"\\n[Wifi]: Connecting\");\n  WiFi.begin(WIFI_SSID, WIFI_PASS);\n\n  while (WiFi.status() != WL_CONNECTED) \n  {\n    Serial.print(\".\");\n    delay(250);"
        },
        {
          "name": "setupSinricPro",
          "body": "// add device to SinricPro\n  SinricProAirQualitySensor& mySinricProAirQualitySensor = SinricPro[DEVICE_ID];\n\n  // set callback function to device\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setupDustSensor",
          "body": "//dustSensor.setBaseline(0.4); // set no dust voltage according to your own experiments\n  //dustSensor.setCalibrationFactor(1.1); // calibrate against precision instrument\n  dustSensor.begin();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.println(\"\\nStarting AirQualitySensor_GP2Y1014AU0F on \" + String(ARDUINO_BOARD));\n  Serial.println(\"Version : \" + String(SINRICPRO_VERSION_STR));\n  \n  setupWiFi();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();\n\n  if ((long)(millis() - dispatchTime) >= 0) \n  {\n    Serial.print(\"Dust density: \");\n    Serial.print(dustSensor.getDustDensity());\n    Serial.print(\" ug/m3; Running average: \");\n    Serial.print(dustSensor.getRunningAverage());\n    Serial.println(\" ug/m3\");\n\n    SinricProAirQualitySensor &mySinricProAirQualitySensor = SinricPro[DEVICE_ID]; // get air q sensor device\n\n    int pm1 = 0;\n    int pm2_5 = dustSensor.getRunningAverage();\n    int pm10 = 0;\n\n    mySinricProAirQualitySensor.sendAirQualityEvent(pm1, pm2_5, pm10, \"PERIODIC_POLL\");\n    dispatchTime += MIN;\n\n    Serial.println(\"Sending Air Quality event ..\");"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [
        "Wire.h",
        "WiFi.h",
        "WiFiClientSecure.h",
        "UniversalTelegramBot.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  pinMode(heaterPin, OUTPUT);\n  pinMode(fanPin, OUTPUT);\n  pinMode(soilMoisturePin, INPUT);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  dhtSensor.begin();\n  \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.println(\"Connecting to WiFi...\");"
        },
        {
          "name": "loop",
          "body": "// Baca kelembapan tanah\n  int soilMoistureValue = analogRead(soilMoisturePin);\n  Serial.print(\"Soil Moisture Value: \");\n  Serial.println(soilMoistureValue);\n\n  // Tentukan kondisi kelembapan tanah\n  String soilCondition;\n  float soil_ph = 7.0; // Default nilai pH netral\n  if (soilMoistureValue < 300) {\n    soilCondition = \"Dry\";\n    soil_ph += 0.5; // Menambahkan 0.5 untuk kondisi tanah kering"
        },
        {
          "name": "handAKMMes",
          "body": "for (int i = 0; i < numNewMessages; i++) {\n    String chat_id = String(bot.messages[i].chat_id);\n    String text = bot.messages[i].text;\n\n    if (text == \"/start@AkseleratorHumanisasiKomposBot\") {\n      String welcome_message = \n          \"Selamat datang di grup! Berikut adalah perintah yang tersedia:\\n\"\n          \"/kondisi - Menampilkan kondisi suhu dan pH saat ini\\n\"\n          \"/on - Menyalakan pemanas\\n\";\n      bot.sendMessage(chat_id, welcome_message, \"\");"
        }
      ]
    },
    {
      "name": "CLINT",
      "keywords": [
        "Wire",
        "Serial",
        "attachInterrupt",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Begin Serial communication\n    Serial.begin(9600);\n    while (!Serial);\n    Serial.println();\n    Serial.println(\"Starting Serial\");\n\n    // Assign parameter values for Alarm 1\n    alarmDay = 0;\n    alarmHour = 0;\n    alarmMinute = 0;\n    alarmSecond = 0;\n    alarmBits = 0b00001111; // Alarm 1 every second\n    alarmDayIsDay = false;\n    alarmH12 = false;\n    alarmPM = false;    \n\n    // Set alarm 1 to fire at one-second intervals\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(\n       alarmDay, alarmHour, alarmMinute, alarmSecond,\n       alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // enable Alarm 1 interrupts\n    myRTC.turnOnAlarm(1);\n    // clear Alarm 1 flag\n    myRTC.checkIfAlarm(1);\n\n    // When using interrupt with only one of the DS3231 alarms, as in this example,\n    // it may be advisable to prevent the other alarm entirely,\n    // so it will not covertly block the outgoing interrupt signal.\n\n    // Prevent Alarm 2 altogether by assigning a \n    // nonsensical alarm minute value that cannot match the clock time,\n    // and an alarmBits value to activate \"when minutes match\".\n    alarmMinute = 0xFF; // a value that will never match the time\n    alarmBits = 0b01100000; // Alarm 2 when minutes match, i.e., never\n    \n    // Upload the parameters to prevent Alarm 2 entirely\n    myRTC.setA2Time(\n        alarmDay, alarmHour, alarmMinute,\n        alarmBits, alarmDayIsDay, alarmH12, alarmPM);\n    // disable Alarm 2 interrupt\n    myRTC.turnOffAlarm(2);\n    // clear Alarm 2 flag\n    myRTC.checkIfAlarm(2);\n\n    // NOTE: both of the alarm flags must be clear\n    // to enable output of a FALLING interrupt\n\n    // attach clock interrupt\n    pinMode(CLINT, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(CLINT), isr_TickTock, FALLING);\n\n    // Use builtin LED to blink\n    pinMode(LED_BUILTIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // if alarm went of, do alarm stuff\n    if (tick) {\n        tick = 0;\n        state = ~state;\n        digitalWrite(LED_BUILTIN, state);\n\n        // optional serial output\n        Serial.print(\"Turning LED \");\n        Serial.println((state ? \"ON\" : \"OFF\"));\n\n        // Clear Alarm 1 flag\n        myRTC.checkIfAlarm(1);"
        },
        {
          "name": "isr_TickTock",
          "body": "// interrupt signals to loop\n    tick = 1;\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "DS3231.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Begin I2C communication\n    Wire.begin();\n\n    // Setup alarm one to fire every second\n    myRTC.turnOffAlarm(1);\n    myRTC.setA1Time(0, 0, 0, 0, 0b01111111, false, false, false);\n    myRTC.turnOnAlarm(1);\n    myRTC.checkIfAlarm(1);\n\n    // Use builtin LED to blink\n    pinMode(LED_BUILTIN, OUTPUT);\n    digitalWrite(LED_BUILTIN, HIGH);"
        },
        {
          "name": "loop",
          "body": "// static variable to keep track of LED on/off state\n    static byte state = false;\n\n    // if alarm went of, do alarm stuff\n    // first call to checkIFAlarm does not clear alarm flag\n    if (myRTC.checkIfAlarm(1, false)) {\n        state = ~state;\n        digitalWrite(LED_BUILTIN, state);\n        // Clear alarm state\n        myRTC.checkIfAlarm(1, true);"
        }
      ]
    },
    {
      "name": "TINY_GSM_MODEM_SIM800",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "TinyGsmClient.h",
        "StreamDebugger.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Set console baud rate\n  SerialMon.begin(115200);\n  delay(10);\n\n  // !!!!!!!!!!!\n  // Set your reset, enable, power pins here\n  // !!!!!!!!!!!\n\n  DBG(\"Wait...\");\n  delay(6000L);\n\n  // Set GSM module baud rate\n  TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n  // SerialAT.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// Restart takes quite some time\n  // To skip it, call init() instead of restart()\n  DBG(\"Initializing modem...\");\n  if (!modem.restart()) {\n    // if (!modem.init()) {\n    DBG(\"Failed to restart modem, delaying 10s and retrying\");\n    // restart autobaud in case GSM just rebooted\n    // TinyGsmAutoBaud(SerialAT, GSM_AUTOBAUD_MIN, GSM_AUTOBAUD_MAX);\n    return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // open the serial port to send the information of what you are reading\n  Serial.begin(9600);"
        },
        {
          "name": "loop",
          "body": "// read all the D inputs at the Motor Board as analog\n  //analogReadB_Ds();\n\n  // read all the D inputs at the Motor Board as digital\n  //digitalReadB_Ds();\n\n  // read all the M inputs at the Control Board as analog\n  //analogReadMs();\n\n  // read all the M inputs at the Control Board as digital\n  //digitalReadMs();\n\n  // read all the D inputs at the Control Board as analog\n  analogReadT_Ds();\n\n  // read all the D inputs at the Control Board as digital\n  //digitalReadT_Ds();\n\n  // write all the D outputs at the Motor Board as digital\n  //digitalWriteB_Ds();\n\n  // write all the D outputs at the Control Board as digital\n  //digitalWriteT_Ds();\n  delay(40);"
        },
        {
          "name": "analogReadMs",
          "body": "for (int i = 0; i < 8; i++) {\n    Serial.print(Robot.analogRead(arr[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalReadMs",
          "body": "for (int i = 0; i < 8; i++) {\n    Serial.print(Robot.digitalRead(arr[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "analogReadT_Ds",
          "body": "for (int i = 0; i < 6; i++) {\n    Serial.print(Robot.analogRead(arr2[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalReadT_Ds",
          "body": "for (int i = 0; i < 6; i++) {\n    Serial.print(Robot.digitalRead(arr2[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalWriteT_Ds",
          "body": "// turn all the pins on\n  for (int i = 0; i < 6; i++) {\n    Robot.digitalWrite(arr2[i], HIGH);"
        },
        {
          "name": "digitalWriteB_Ds",
          "body": "// turn all the pins on\n  for (int i = 0; i < 4; i++) {\n    Robot.digitalWrite(arr3[i], HIGH);"
        },
        {
          "name": "analogReadB_Ds",
          "body": "for (int i = 0; i < 4; i++) {\n    Serial.print(Robot.analogRead(arr3[i]));\n    Serial.print(\",\");"
        },
        {
          "name": "digitalReadB_Ds",
          "body": "for (int i = 0; i < 4; i++) {\n    Serial.print(Robot.digitalRead(arr3[i]));\n    Serial.print(\",\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogRead"
      ],
      "libraries": [
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "sendPort",
          "body": "portValue = portValue & portStatus[portNumber];\n  if (previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;"
        },
        {
          "name": "setup",
          "body": "byte i, port, status;\n\n  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n\n  for (pin = 0; pin < TOTAL_PINS; pin++) {\n    if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT);"
        },
        {
          "name": "loop",
          "body": "byte i;\n\n  for (i = 0; i < TOTAL_PORTS; i++) {\n    sendPort(i, readPort(i, 0xff));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  MIDI.begin(4);                    // Launch MIDI and listen to channel 4"
        },
        {
          "name": "loop",
          "body": "if (MIDI.read())                  // If we have received a message\n  {\n    digitalWrite(LED_BUILTIN, HIGH);\n    MIDI.sendNoteOn(42, 127, 1);    // Send a Note (pitch 42, velo 127 on channel 1)\n    delay(1000);                    // Wait for a second\n    MIDI.sendNoteOff(42, 0, 1);     // Stop the note\n    digitalWrite(LED_BUILTIN, LOW);"
        }
      ]
    },
    {
      "name": "HOST",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "QNEthernet.h",
        "lwip/altcp_tcp.h",
        "mbedtls.h",
        "lwip/altcp_tls.h",
        "lwip/apps/altcp_proxyconnect.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial"
        },
        {
          "name": "loop",
          "body": "// Read the response\n  if (client.connected()) {\n    int avail = client.available();\n    if (avail > 0) {\n      dataCount += avail;\n      for (int i = 0; i < avail; i++) {\n        putc(client.read(), stdout);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor.\");"
        },
        {
          "name": "loop",
          "body": "// check if a color reading is available\n  while (! APDS.colorAvailable()) {\n    delay(5);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor!\");"
        },
        {
          "name": "loop",
          "body": "if (APDS.gestureAvailable()) {\n    // a gesture was detected, read and print to Serial Monitor\n    int gesture = APDS.readGesture();\n\n    switch (gesture) {\n      case GESTURE_UP:\n        Serial.println(\"Detected UP gesture\");\n        break;\n\n      case GESTURE_DOWN:\n        Serial.println(\"Detected DOWN gesture\");\n        break;\n\n      case GESTURE_LEFT:\n        Serial.println(\"Detected LEFT gesture\");\n        break;\n\n      case GESTURE_RIGHT:\n        Serial.println(\"Detected RIGHT gesture\");\n        break;\n\n      default:\n        // ignore\n        break;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_APDS9960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!APDS.begin()) {\n    Serial.println(\"Error initializing APDS-9960 sensor!\");"
        },
        {
          "name": "loop",
          "body": "// check if a proximity reading is available\n  if (APDS.proximityAvailable()) {\n    // read the proximity\n    // - 0   => close\n    // - 255 => far\n    // - -1  => error\n    int proximity = APDS.readProximity();\n\n    // print value to the Serial Monitor\n    Serial.println(proximity);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduinoSound.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Open serial communications and wait for port to open:\n  // A baud rate of 115200 is used instead of 9600 for a faster data rate\n  // on non-native USB ports\n  Serial.begin(115200);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// check if a new analysis is available\n  if (amplitudeAnalyzer.available()) {\n    // read the new amplitude\n    int amplitude = amplitudeAnalyzer.read();\n\n    // print out the amplititude to the serial monitor\n    Serial.println(amplitude);"
        }
      ]
    },
    {
      "name": "ROUND_SAMPLE_INTERVAL",
      "keywords": [
        "digitalWrite",
        "delay",
        "Serial",
        "analogRead"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "fatalBlink",
          "body": "while (true) {\n    if (ERROR_LED_PIN >= 0) {\n      digitalWrite(ERROR_LED_PIN, HIGH);\n      delay(200);\n      digitalWrite(ERROR_LED_PIN, LOW);\n      delay(200);"
        },
        {
          "name": "adcInit",
          "body": "uint8_t adps;  // prescaler bits for ADCSRA\n  uint32_t ticks = F_CPU*SAMPLE_INTERVAL + 0.5;  // Sample interval cpu cycles.\n\n  if (ADC_REF & ~((1 << REFS0) | (1 << REFS1))) {\n    error(\"Invalid ADC reference\");"
        },
        {
          "name": "adcStart",
          "body": "// initialize ISR\n  isrBufNeeded = true;\n  isrOver = 0;\n  adcindex = 1;\n\n  // Clear any pending interrupt.\n  ADCSRA |= 1 << ADIF;\n\n  // Setup for first pin.\n  ADMUX = adcmux[0];\n  ADCSRB = adcsrb[0];\n  ADCSRA = adcsra[0];\n\n  // Enable timer1 interrupts.\n  timerError = false;\n  timerFlag = false;\n  TCNT1 = 0;\n  TIFR1 = 1 << OCF1B;\n  TIMSK1 = 1 << OCIE1B;"
        },
        {
          "name": "adcStop",
          "body": "TIMSK1 = 0;\n  ADCSRA = 0;"
        },
        {
          "name": "binaryToCsv",
          "body": "uint8_t lastPct = 0;\n  block_t buf;\n  metadata_t* pm;\n  uint32_t t0 = millis();\n  char csvName[13];\n  StdioStream csvStream;\n\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "checkOverrun",
          "body": "bool headerPrinted = false;\n  block_t buf;\n  uint32_t bgnBlock, endBlock;\n  uint32_t bn = 0;\n\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "dumpData",
          "body": "block_t buf;\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "logData",
          "body": "uint32_t bgnBlock, endBlock;\n\n  // Allocate extra buffer space.\n  block_t block[BUFFER_BLOCK_COUNT];\n\n  Serial.println();\n\n  // Initialize ADC and timer1.\n  adcInit((metadata_t*) &block[0]);\n\n  // Find unused file name.\n  if (BASE_NAME_SIZE > 6) {\n    error(\"FILE_BASE_NAME too long\");"
        },
        {
          "name": "setup",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// Read any Serial data.\n  do {\n    delay(10);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogWrite",
        "EEPROM",
        "analogRead"
      ],
      "libraries": [
        "Servo.h",
        "Firmata.h"
      ],
      "functions": [
        {
          "name": "analogWriteCallback",
          "body": "switch (pin) {\n    case 9: servo9.write(value); break;\n    case 10: servo10.write(value); break;\n    case 3:\n    case 5:\n    case 6:\n    case 11: // PWM pins\n      analogWrite(pin, value);\n      break;"
        },
        {
          "name": "reportAnalogCallback",
          "body": "if (value == 0) {\n    analogInputsToReport = analogInputsToReport & ~ (1 << pin);"
        },
        {
          "name": "setup",
          "body": "Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);\n  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);\n\n  servo9.attach(9);\n  servo10.attach(10);\n  Firmata.begin(57600);"
        },
        {
          "name": "loop",
          "body": "while (Firmata.available())\n    Firmata.processInput();\n  currentMillis = millis();\n  if (currentMillis - previousMillis > 20) {\n    previousMillis += 20;                   // run this every 20ms\n    for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) {\n      if ( analogInputsToReport & (1 << analogPin) )\n        Firmata.sendAnalog(analogPin, analogRead(analogPin));"
        }
      ]
    },
    {
      "name": "SD_CHIP_SELECT",
      "keywords": [
        "delay",
        "Serial",
        "Wire",
        "analogRead"
      ],
      "libraries": [
        "SPI.h",
        "Wire.h",
        "RTClib.h"
      ],
      "functions": [
        {
          "name": "dateTime",
          "body": "DateTime now = RTC.now();\n\n  // return date using FAT_DATE macro to format fields\n  *date = FAT_DATE(now.year(), now.month(), now.day());\n\n  // return time using FAT_TIME macro to format fields\n  *time = FAT_TIME(now.hour(), now.minute(), now.second());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial.\n  while (!Serial) {\n    yield();"
        },
        {
          "name": "loop",
          "body": "uint32_t m;\n\n  // wait for time to be a multiple of interval\n  do {\n    m = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//analog_out.period_ms(CHANNEL, PERIOD_MILLISECONDS);\n  analog_out.period_ms(0, 4);\n  analog_out.period_ms(1, 4);\n  analog_out.period_ms(2, 4);\n  analog_out.period_ms(3, 4);\n  \n  Serial.begin(9600);\n  Serial.println(\"Analog out test\");"
        },
        {
          "name": "loop",
          "body": "//analog_out.write(CHANNEL, OUTPUT_VOLTAGE_VALUE);\n  analog_out.write(0, counter);\n  analog_out.write(1, counter);\n  analog_out.write(2, counter);\n  analog_out.write(3, counter);\n  Serial.println(\"All channels set at \"+String(counter)+\"V\");\n  \n  counter = counter + 0.1;\n  //Maximum output value is 10.4V\n  if (counter >= 10.5)\n  {\n    counter = 0;\n    //Additional 100 ms delay introduced to manage 10.5V -> 0V fall time of 150 ms\n    delay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.set0_10V();"
        },
        {
          "name": "loop",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH0: \");\n  Serial.print(voltage_ch0, 3);\n  Serial.println(\"V\");\n\n  float raw_voltage_ch1 = analog_in.read(1);\n  float voltage_ch1 = (raw_voltage_ch1 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH1: \");\n  Serial.print(voltage_ch1, 3);\n  Serial.println(\"V\");\n\n  float raw_voltage_ch2 = analog_in.read(2);\n  float voltage_ch2 = (raw_voltage_ch2 * reference) / 65535 / res_divider;\n  Serial.print(\"Voltage CH2: \");\n  Serial.print(voltage_ch2, 3);\n  Serial.println(\"V\");\n  Serial.println();\n  delay(250);"
        }
      ]
    },
    {
      "name": "SENSE_RES",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.set4_20mA();"
        },
        {
          "name": "loop",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535;\n  float current_ch0 = (voltage_ch0 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH0: \");\n  Serial.print(current_ch0);\n  Serial.println(\"mA\");\n\n  float raw_voltage_ch1 = analog_in.read(1);\n  float voltage_ch1 = (raw_voltage_ch1 * reference) / 65535;\n  float current_ch1 = (voltage_ch1 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH1: \");\n  Serial.print(current_ch1);\n  Serial.println(\"mA\");\n  float raw_voltage_ch2 = analog_in.read(2);\n  float voltage_ch2 = (raw_voltage_ch2 * reference) / 65535;\n  float current_ch2 = (voltage_ch2 / SENSE_RES) * 1000;\n  Serial.print(\"Measured Current CH2: \");\n  Serial.print(current_ch2);\n  Serial.println(\"mA\");\n\n  Serial.println();\n  delay(250);"
        }
      ]
    },
    {
      "name": "REFERENCE_RES",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_MachineControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "analogReadResolution(16);\n\n  Serial.begin(9600);\n  analog_in.setNTC();"
        },
        {
          "name": "loop",
          "body": "float raw_voltage_ch0 = analog_in.read(0);\n  float voltage_ch0 = (raw_voltage_ch0 * reference) / 65535;\n  float resistance_ch0;\n  Serial.print(\"Resistance CH0: \");\n  if (voltage_ch0 < lowest_voltage) {\n    resistance_ch0 = ((-REFERENCE_RES) * voltage_ch0) / (voltage_ch0 - reference);\n    Serial.print(resistance_ch0);\n    Serial.println(\" ohm\");"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();\n\n    if (app.ready() && (millis() - ms > 30 * 1000 || ms == 0))\n    {\n        cnt++;\n        ms = millis();\n\n        Serial.println(\"App is authenticated as anonymous...\");\n        Firebase.printf(\"User UID: %s\\n\", app.getUid().c_str());\n\n        app.isAuthenticated();\n\n        if (cnt == 3)\n        {\n            Serial.println(\"Deleting anonymous user...\");\n            UserAccount user(API_KEY);\n            deleteUser(aClient, app, getAuth(user.idToken(app.getToken())), aResult_no_callback);"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\tWiFiManager wifiManager;\n\n\t// wifiManager.setAPCallback([this](WiFiManager* wifiManager) {\n\twifiManager.setAPCallback([&](WiFiManager* wifiManager) {\n\t\tSerial.printf(\"Entered config mode:ip=%s, ssid='%s'\\n\", \n                        WiFi.softAPIP().toString().c_str(), \n                        wifiManager->getConfigPortalSSID().c_str());\n\t\t_enteredConfigMode = true;"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (millis() - dataMillis > 5000 && signupOK && Firebase.ready())\n    {\n        dataMillis = millis();\n        String path = auth.token.uid.c_str(); //<- user uid\n        path += \"/test/int\";\n        Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, path, count++) ? \"ok\" : fbdo.errorReason().c_str());\n\n        if (count == 10)\n        {\n            Serial.print(\"Delete user... \");\n            if (Firebase.deleteUser(&config, &auth /* third argument can be the id token of active user to delete or leave it blank to delete current user */))\n            {\n                Serial.println(\"ok\");"
        }
      ]
    },
    {
      "name": "DEBUG",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "#if DEBUG\n  Serial.begin(115200);\n  BHY2.debug(Serial);\n#endif\n\n  BHY2.begin();"
        },
        {
          "name": "loop",
          "body": "// Update and then sleep\n  BHY2.update(100);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "BlynkSimpleEsp8266.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Blynk.begin(auth, ssid, pass);//官方服务器\n  //Blynk.begin(auth, ssid, pass, \"blynk-cloud.com\", 8080);//自建服务器域名模式\n  //Blynk.begin(auth, ssid, pass, IPAddress(192, 168, 31, 140), 8080);//自建服务器ip模式"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n    multi.addAP(WIFI_SSID, WIFI_PASSWORD);\n    multi.run();\n#else\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n#endif\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    unsigned long ms = millis();\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);\n#if defined(ARDUINO_RASPBERRY_PI_PICO_W)\n        if (millis() - ms > 10000)\n            break;\n#endif"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "DEBUG",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "#if DEBUG\n  Serial.begin(115200);\n  BHY2.debug(Serial);\n#endif\n\n  BHY2.begin();"
        },
        {
          "name": "loop",
          "body": "// Update and then sleep only for 1ms\n  BHY2.update(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "QNEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize Serial output\n  Serial.begin(115200);\n  while (!Serial && millis() < 4000) {\n    // Wait for Serial"
        },
        {
          "name": "setNetworkReady",
          "body": "networkReadyLatch = hasIP && hasLink && interfaceUp;\n\n  printf(\"Network is%s READY\\r\\n\", networkReadyLatch ? \"\" : \" NOT\");\n\n  // To successfully perform network startup tasks, test the latch\n  // somewhere in the main loop, and, if it is true, perform any\n  // network tasks and then set the latch to false. No network calls\n  // should be done from inside a listener.\n\n  // Similar logic could be applied for when the network is not ready.\n\n  // Servers technically only need the address state because they can\n  // be brought up and active even when there's no link or no active\n  // network interface, unlike clients and connections, which require\n  // all of an address, link, and active network interface."
        },
        {
          "name": "loop",
          "body": "// *** Main program code goes here\n\n  // Perform any network startup:\n  if (networkReadyLatch) {\n    // *** Do any network startup tasks that must run when the network\n    // *** comes up\n    networkReadyLatch = false;"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append array)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document\";\n        String fieldPath = \"appended_data\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // array value to append\n        Values::ArrayValue arrV(Values::IntegerValue((int)rand()));\n        arrV.add(Values::StringValue(\"word don't come easy \" + String(counter)));\n\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue(arrV);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, appendValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        Writes writes(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // Another array value to append\n        Values::ArrayValue arrV2(Values::DoubleValue((int)rand() * 1.234));\n        arrV2.add(Values::StringValue(\"never gonna give you up \" + String(counter)));\n        // Another append array object\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue2(arrV2);\n        // Another field transform\n        FieldTransform::FieldTransform fieldTransforms2(fieldPath, appendValue2);\n        // Another doc transform\n        DocumentTransform transform2(documentPath, fieldTransforms2);\n        // Add another Write object of another transform to the Writes object\n        writes.add(Write(transform2, Precondition()));\n\n        // All Writes, Write, DocumentTransform FieldTransform::xxx, and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append map value in document)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // Map value to append\n        Values::MapValue mapV(\"key\" + String(counter), Values::IntegerValue(counter));\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV));\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */));\n\n        // All Writes, Document and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append array)... \");\n\n        String documentPath = \"test_collection/test_document\";\n        String fieldPath = \"appended_map_array\";\n\n        // map in array value to append\n        Values::MapValue mapV(\"id\", Values::StringValue(\"item\" + String(counter)));\n        mapV.add(\"status\", Values::BooleanValue(counter % 2 == 0));\n\n        Values::ArrayValue arrV(mapV);\n\n        FieldTransform::AppendMissingElements<Values::ArrayValue> appendValue(arrV);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, appendValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        Writes writes(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // All Writes, Write, DocumentTransform FieldTransform::xxx, and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Commit a document (append map value in document)... \");\n\n        // test_collection is the collection id, test_document is the document id.\n        String documentPath = \"test_collection/test_document_map_value_timestamp\";\n\n        // If the document path contains space e.g. \"a b c/d e f\"\n        // It should encode the space as %20 then the path will be \"a%20b%20c/d%20e%20f\"\n\n        // Map value to append\n        Values::MapValue mapV(\"name\", Values::StringValue(\"value\" + String(counter)));\n        mapV.add(\"count\", Values::StringValue(String(counter)));\n\n        Values::MapValue mapV2(\"key\" + String(counter), mapV);\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV2));\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */));\n\n        String fieldPath = \"myMap.key\" + String(counter) + \".timestamp\";\n        // See https://firebase.google.com/docs/firestore/reference/rest/v1/Write#servervalue\n        FieldTransform::SetToServerValue setValue(FieldTransform::REQUEST_TIME);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, setValue);\n        DocumentTransform transform(documentPath, fieldTransforms);\n\n        writes.add(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // All Writes, DocumentTransform and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.commit(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial"
      ],
      "libraries": [
        "Arduino.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); \n\n  EEPROM.begin();                                               \n\n  EEPROM.write(0, test);                              // write data to address 0\n  test_recieve = EEPROM.read(0, test_size);           // read data from address 0, of ul size\n  Serial.println(test_recieve);\n\n  EEPROM.write(0 + test_size, test);                  // repeat, adding size to last address\n  test_recieve = EEPROM.read(0, test_size);\n  Serial.print(test_recieve);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "EE_FILE",
      "keywords": [
        "EEPROM",
        "delay"
      ],
      "libraries": [
        "MicroGamer.h",
        "MicroGamerMemoryCard.h",
        "MicroGamerTones.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "mg.begin();\n  mg.setFrameRate(40);\n  mg.initRandomSeed();"
        },
        {
          "name": "loop",
          "body": "// pause render until it's time for the next frame\n  if (!(mg.nextFrame()))\n    return;\n\n  //Title screen loop switches from title screen\n  //and high scores until FIRE is pressed\n  while (!start)\n  {\n    start = titleScreen();\n    if (!start)\n    {\n      start = displayHighScores(EE_FILE);"
        },
        {
          "name": "movePaddle",
          "body": "//Move right\n  if(xPaddle < WIDTH - 12)\n  {\n    if (mg.pressed(RIGHT_BUTTON))\n    {\n      xPaddle+=2;"
        },
        {
          "name": "moveBall",
          "body": "tick++;\n  if(released)\n  {\n    //Move ball\n    if (abs(dx)==2) {\n      xb += dx/2;\n      // 2x speed is really 1.5 speed\n      if (tick%2==0)\n        xb += dx/2;"
        },
        {
          "name": "drawBall",
          "body": "// mg.setCursor(0,0);\n  // mg.print(mg.cpuLoad());\n  // mg.print(\"  \");\n  mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n\n  moveBall();\n\n  mg.drawPixel(xb,   yb,   1);\n  mg.drawPixel(xb+1, yb,   1);\n  mg.drawPixel(xb,   yb+1, 1);\n  mg.drawPixel(xb+1, yb+1, 1);"
        },
        {
          "name": "drawPaddle",
          "body": "mg.drawRect(xPaddle, 63, 11, 1, 0);\n  movePaddle();\n  mg.drawRect(xPaddle, 63, 11, 1, 1);"
        },
        {
          "name": "drawGameOver",
          "body": "mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n  mg.setCursor(37, 42);\n  mg.print(\"Game Over\");\n  mg.setCursor(31, 56);\n  mg.print(\"Score: \");\n  mg.print(score);\n  mg.display();\n  delay(4000);"
        },
        {
          "name": "pause",
          "body": "paused = true;\n  //Draw pause to the screen\n  mg.setCursor(52, 45);\n  mg.print(\"PAUSE\");\n  mg.display();\n  while (paused)\n  {\n    delay(150);\n    //Unpause if FIRE is pressed\n    pad2 = mg.pressed(Y_BUTTON) || mg.pressed(X_BUTTON);\n    if (pad2 == true && oldpad2 == false && released)\n    {\n        mg.fillRect(52, 45, 30, 11, 0);\n\n        paused=false;"
        },
        {
          "name": "Score",
          "body": "score += (level*10);"
        },
        {
          "name": "newLevel",
          "body": "//Undraw paddle\n  mg.drawRect(xPaddle, 63, 11, 1, 0);\n\n  //Undraw ball\n  mg.drawPixel(xb,   yb,   0);\n  mg.drawPixel(xb+1, yb,   0);\n  mg.drawPixel(xb,   yb+1, 0);\n  mg.drawPixel(xb+1, yb+1, 0);\n\n  //Alter various variables to reset the game\n  xPaddle = 54;\n  yb = 60;\n  brickCount = 0;\n  released = false;\n\n  //Draws new bricks and resets their values\n  for (byte row = 0; row < 4; row++) {\n    for (byte column = 0; column < 13; column++)\n    {\n      isHit[row][column] = false;\n      mg.drawRect(10*column, 2+6*row, 8, 4, 1);"
        },
        {
          "name": "enterInitials",
          "body": "byte index = 0;\n\n  mg.clear();\n\n  initials[0] = ' ';\n  initials[1] = ' ';\n  initials[2] = ' ';\n\n  while (true)\n  {\n    mg.display();\n    mg.clear();\n\n    mg.setCursor(16,0);\n    mg.print(\"HIGH SCORE\");\n    sprintf(text_buffer, \"%u\", score);\n    mg.setCursor(88, 0);\n    mg.print(text_buffer);\n    mg.setCursor(56, 20);\n    mg.print(initials[0]);\n    mg.setCursor(64, 20);\n    mg.print(initials[1]);\n    mg.setCursor(72, 20);\n    mg.print(initials[2]);\n    for(byte i = 0; i < 3; i++)\n    {\n      mg.drawLine(56 + (i*8), 27, 56 + (i*8) + 6, 27, 1);"
        },
        {
          "name": "enterHighScore",
          "body": "// Each block of EEPROM has 7 high scores, and each high score entry\n  // is 5 bytes long:  3 bytes for initials and two bytes for score.\n  int address = file * 7 * 5 + EEPROM_STORAGE_SPACE_START;\n  byte hi, lo;\n  char tmpInitials[3];\n  unsigned int tmpScore = 0;\n\n  mem.load();\n\n  // High score processing\n  for(byte i = 0; i < 7; i++)\n  {\n    hi = mem.read(address + (5 * i));\n    lo = mem.read(address + (5 * i) + 1);\n    if ((hi == 0xFF) && (lo == 0xFF))\n    {\n      // The values are uninitialized, so treat this entry\n      // as a score of 0.\n      tmpScore = 0;"
        },
        {
          "name": "playTone",
          "body": "if (mg.audio.enabled() == true)\n  {\n    audio.tone( frequency, duration);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ArduTFLite.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize serial communications and wait for Serial Monitor to be opened\n  Serial.begin(9600);\n  while(!Serial);\n\n  Serial.println(\"Sine(x) function inference example.\");\n  Serial.println(\"Initializing TensorFlow Lite Micro Interpreter...\");\n  if (!modelInit(model, tensor_arena, kTensorArenaSize)){\n    Serial.println(\"Model initialization failed!\");\n    while(true);"
        },
        {
          "name": "loop",
          "body": "// Check if a value was sent from Serial Monitor\n  // if so, 'sanitize' the input and perform inference\n  if (Serial.available()){\n    String inputValue = Serial.readString();\n    float x = inputValue.toFloat(); // evaluates to zero if the user input is not a valid number\n    Serial.print(\"Your input value: \");\n    Serial.println(x);\n    // The model was trained in range 0 to 2*Pi\n    // if the value provided by user is not in this range\n    // the value is corrected substituting edge values\n    if (x<0) x = 0;\n    if (x >6.28) x = 6.28;\n    Serial.print(\"Adapted input value: \");\n    Serial.println(x);\n  \n    // Place the value in the model's input tensor\n    modelSetInput(x,0);\n\n    // Run inference, and report if an error occurs\n    if(!modelRunInference()){\n          Serial.println(\"RunInference Failed!\");\n          return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AccessoryShield.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Initialize Serial comunication\n  Serial.begin(9600);\n  // wait for the serial port to connect, Needed for USB native only\n  while(!Serial) ;\n  // initialize the Accessory Shield library\n  accessoryShield.begin();"
        },
        {
          "name": "loop",
          "body": "// get temperarture in degrees Celsius\n  tempC = accessoryShield.getTemperature(DHT11_TEMP_CELSIUS);\n  // convert temperature from Celsius to Fareneith \n  tempF = accessoryShield.convertTempCtoF(tempC);\n  // convert temperature from Celsius to Kelvin\n  tempK = accessoryShield.convertTempCtoK(tempC);\n  // check if we have got valid values\n  if((tempC != NAN) && (tempF != NAN) && (tempK != NAN)) {\n    // print temperature in degrees Celsius\n    Serial.print(\"Temperature in Celsius degrees : \");\n    Serial.print(tempC);\n    Serial.println(\" C\");\n    // print temperature in degrees Fareneith\n    Serial.print(\"Temperature in Fareneith degrees : \");\n    Serial.print(tempF);\n    Serial.println(\" F\");\n    // print temperature in degrees Kelvin\n    Serial.print(\"Temperature in Kelvin degrees : \");\n    Serial.print(tempK);\n    Serial.println(\" K\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onSwitchButtonChange",
          "body": "if (switchButton)\n  {\n    location = Location(latMov, lonMov);\n    color    = Color(hueRed, satRed, briRed);"
        },
        {
          "name": "onColorChange",
          "body": "Serial.print(\"Hue = \");\n  Serial.println(color.getValue().hue);\n  Serial.print(\"Sat = \");\n  Serial.println(color.getValue().sat);\n  Serial.print(\"Bri = \");\n  Serial.println(color.getValue().bri);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();\n  potentiometer = analogRead(A0);\n  seconds = millis() / 1000;"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "// When OTA is available, stay there until it completes.\n  // The rest of the loop() does not run and the sketch\n  // restarts automatically at the end of the OTA process.\n  while (block_for_ota) {\n    ArduinoCloud.update();\n    if (ota_started) {\n      Serial.print(\"Waiting for OTA to finish...\");\n      ota_started = false;"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "doThisOnConnect",
          "body": "/* add your custom code here */\n  Serial.println(\"Board successfully connected to Arduino IoT Cloud\");"
        },
        {
          "name": "doThisOnSync",
          "body": "/* add your custom code here */\n  Serial.println(\"Thing Properties synchronised\");"
        },
        {
          "name": "doThisOnDisconnect",
          "body": "/* add your custom code here */\n  Serial.println(\"Board disconnected from Arduino IoT Cloud\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "ATTN_PIN",
      "keywords": [
        "Serial",
        "analogRead",
        "digitalWrite"
      ],
      "libraries": [
        "Notecard.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize serial and wait up to 5 seconds for port to open */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();\n  potentiometer = analogRead(A0);\n  seconds = millis() / 1000;"
        },
        {
          "name": "onLedChange",
          "body": "Serial.print(\"LED set to \");\n  Serial.println(led);\n  digitalWrite(LED_BUILTIN, led);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "/* Initialize the serial port and wait up to 5 seconds for a connection */\n  Serial.begin(9600);\n  for(unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime <= 5000); ) {"
        },
        {
          "name": "setupOneShotSchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = startingFrom + ( DAYS * 1 );\n  ScheduleTimeType activePeriod = MINUTES * 5;\n\n  /* Warning: there is no cross check between until and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createOneShotScheduleConfiguration();\n\n  oneShot = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupMinuteSchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = startingFrom + ( DAYS * 1 );\n  ScheduleTimeType activePeriod = SECONDS * 15;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Minutes, repetitionPeriod);\n\n  minute = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupHourlySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = MINUTES * 20;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Hours, repetitionPeriod);\n\n  hourly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupDailySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = HOURS * 2;\n  unsigned int repetitionPeriod = 1;\n\n  /* Warning: there is no cross check between repetitionPeriod and activePeriod */\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createFixedDeltaScheduleConfiguration(ScheduleUnit::Days, repetitionPeriod);\n\n  daily = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupWeeklySchedule",
          "body": "unsigned int startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  unsigned int until = startingFrom + ( DAYS * 30 );\n  unsigned int executionPeriod = MINUTES * 3;\n\n  ScheduleWeeklyMask WeeklyMask = {\n    ScheduleState::Inactive,   /* Sunday */\n    ScheduleState::Active,     /* Monday */\n    ScheduleState::Inactive,   /* Tuesday */\n    ScheduleState::Active,     /* Wednesday */\n    ScheduleState::Inactive,   /* Thursday */\n    ScheduleState::Active,     /* Friday */\n    ScheduleState::Inactive,   /* Saturday */"
        },
        {
          "name": "setupMonthlySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 01 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2021 Nov 15 13:00:00\");\n  ScheduleTimeType activePeriod = DAYS * 1;\n  int dayOfMonth = 3;\n\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createMonthlyScheduleConfiguration(dayOfMonth);\n\n  monthly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "setupYearlySchedule",
          "body": "ScheduleTimeType startingFrom = TimeServiceClass::getTimeFromString(\"2021 Nov 06 17:00:00\");\n  ScheduleTimeType until = TimeServiceClass::getTimeFromString(\"2041 Nov 06 13:00:00\");\n  ScheduleTimeType activePeriod = DAYS * 2;\n  int dayOfMonth = 6;\n\n  ScheduleConfigurationType scheduleConfiguration =  Schedule::createYearlyScheduleConfiguration(ScheduleMonth::Nov, dayOfMonth);\n\n  yearly = Schedule(startingFrom, until, activePeriod, scheduleConfiguration);"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();\n\n  /* Print a message when the oneShot schedule is active */\n  if(oneShot.isActive()) {\n    Serial.println(\"One shot schedule is active\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  unsigned long serialBeginTime = millis();\n  while (!Serial && (millis() - serialBeginTime <= 5000));\n\n  Serial.println(\"Starting Arduino IoT Cloud Example\");\n\n  initProperties();\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n\n  ArduinoCloud.printDebugInfo();"
        },
        {
          "name": "loop",
          "body": "ArduinoCloud.update();"
        },
        {
          "name": "onBoolPropertyChange",
          "body": "Serial.println(\"'onBoolPropertyChange'\");"
        },
        {
          "name": "onIntPropertyChange",
          "body": "Serial.println(\"'onIntPropertyChange'\");"
        },
        {
          "name": "onFloatPropertyChange",
          "body": "Serial.println(\"'onFloatPropertyChange'\");"
        },
        {
          "name": "onStringPropertyChange",
          "body": "Serial.println(\"'onStringPropertyChange'\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Display.begin();\n  \n  Display.beginDraw();\n  Display.background(255, 255, 255);\n  Display.clear();\n  Display.fill(0x008184);\n  Display.circle(Display.width()/2, Display.height()/2, 300);\n  Display.stroke(255, 255, 255);\n  Display.noFill();\n  for (int i=0; i<30; i++) {\n    Display.circle((Display.width()/2)-55+5, Display.height()/2, 110-i);\n    Display.circle((Display.width()/2)+55-5, Display.height()/2, 110-i);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoMqttClient.h",
        "Arduino.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "ESP8266WiFi.h",
        "WiFi.h",
        "FirebaseJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "if (!mqttReady)\n        return;\n\n    mqttClient.poll();\n\n    if (millis() - lastMillis > 1000)\n    {\n        lastMillis = millis();\n\n        Serial.print(\"Sending message to topic: \");\n\n        Serial.println(topic);\n\n        FirebaseJson json;\n        json.add(\"abc\", count);\n        json.add(\"def\", count % 5 == 0);\n\n        json.toString(Serial);\n        Serial.println();\n\n        // send message, the Print interface can be used to set the message contents\n        mqttClient.beginMessage(topic);\n\n        json.toString(mqttClient);\n\n        mqttClient.endMessage();\n        count++;"
        }
      ]
    },
    {
      "name": "PROG_VERSION",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "TFT_eSPI.h",
        "Button2.h",
        "menu.h",
        "menuIO/serialIO.h",
        "menuIO/TFT_eSPIOut.h",
        "menuIO/chainStream.h",
        "menuIO/esp8266Out.h"
      ],
      "functions": [
        {
          "name": "button_init",
          "body": "btnUp.setLongClickHandler([](Button2 & b) {\n        // Select\n        unsigned int time = b.wasPressedFor();\n        if (time >= 1000) {\n          nav.doNav(enterCmd);"
        },
        {
          "name": "button_loop",
          "body": "// Check for button presses\n    btnUp.loop();\n    btnDwn.loop();"
        },
        {
          "name": "setup",
          "body": "//options=&myOptions;//can customize options\n  Serial.begin(115200); // Set Serial baudrate at 115200\n  while(!Serial);\n  Serial.flush();\n  Serial.println();\n  Serial.print(\"ARDUINOMENU DEMO V\");\n  Serial.print(PROG_VERSION);\n  Serial.println(\" FOR LILYGO TTGO T-DISPLAY\");\n\n  nav.idleTask=idle;//point a function to be used when menu is suspended\n  mainMenu[1].disable();\n  //outGfx.usePreview=true;//reserve one panel for preview?\n  //nav.showTitle=false;//show menu title?\n\n  //SPI.begin(); // Leave this commented or else there will be nothing shown on the screen.\n  gfx.init(); // Initialize the screen.\n\n  Serial.print(\"Configuring PWM for TFT backlight... \");\n  ledcSetup(pwmLedChannelTFT, pwmFreq, pwmResolution);\n  ledcAttachPin(TFT_BL, pwmLedChannelTFT);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Setting PWM for TFT backlight to default intensity... \");\n  ledcWrite(pwmLedChannelTFT, ledBacklight);\n  Serial.println(\"DONE\");\n\n  gfx.setRotation(1); // Rotate display a quarter clockwise\n\n  gfx.setTextSize(2);\n  gfx.setTextWrap(false);\n  gfx.fillScreen(Black);\n\n  Serial.print(\"Showing bootlogo... \");\n  gfx.setSwapBytes(true);\n  gfx.pushImage(0, 0,  240, 135, bootlogo);\n  delay(1000);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Initialize buttons... \");\n  button_init();\n  delay(1000);\n  Serial.println(\"DONE\");\n\n  Serial.print(\"Initialize external led... \");\n  if(LED_CTRL > 0){\n    pinMode(LED_CTRL,OUTPUT);\n    digitalWrite(LED_CTRL,ledCtrl);\n    delay(500);\n    Serial.println(\"DONE\");"
        },
        {
          "name": "loop",
          "body": "button_loop();\n  nav.poll();//this device only draws when needed\n\n  // External connected led\n  if(LED_CTRL > 0){ // Only set led state when a pinnumber for the external led has been provided.\n    digitalWrite(LED_CTRL,ledCtrl);"
        }
      ]
    },
    {
      "name": "NUM_GESTURES",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino_LSM9DS1.h",
        "Arduino_BMI270_BMM150.h",
        "ArduTFLite.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  // init IMU sensor\n  if (!IMU.begin()) {\n    Serial.println(\"IMU sensor init failed!\");\n    while (true); // stop program here."
        },
        {
          "name": "loop",
          "body": "float aX, aY, aZ, gX, gY, gZ;\n\n  // wait for a significant movement\n  while (true) {\n    if (IMU.accelerationAvailable()) {\n      // read linear acceleration\n      IMU.readAcceleration(aX, aY, aZ);\n\n      // compute absolute value of total acceleration\n      float aSum = fabs(aX) + fabs(aY) + fabs(aZ);\n\n      // if total absolute acceleration is over the threshold a gesture has started\n      if (aSum >= accelerationThreshold) {\n        samplesRead = 0; // init samples counter\n        break; // exit from waiting cycle"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    redkea.begin(ssid, pass, deviceID);"
        },
        {
          "name": "loop",
          "body": "redkea.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    redkea.begin(ssid, pass, deviceID);"
        },
        {
          "name": "loop",
          "body": "redkea.loop();"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "BlynkSimpleCurieBLE.h",
        "CurieBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  delay(1000);\n\n  blePeripheral.setLocalName(\"Blynk\");\n  blePeripheral.setDeviceName(\"Blynk\");\n  blePeripheral.setAppearance(384);\n\n  Blynk.begin(blePeripheral, auth);\n\n  blePeripheral.begin();\n\n  Serial.println(\"Waiting for connections...\");"
        },
        {
          "name": "loop",
          "body": "blePeripheral.poll();\n  Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "mySerial.begin(9600);\n  Debug.setDebugOutputStream(&mySerial);\n  Debug.setDebugLevel(DBG_VERBOSE);\n  Debug.timestampOn();"
        },
        {
          "name": "loop",
          "body": "DEBUG_VERBOSE(\"i = %d\", i);\n  i++;\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  Debug.timestampOn();"
        },
        {
          "name": "loop",
          "body": "DEBUG_INFO(\"i = %d\", i);\n  i++;\n  delay(1000);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet2.h",
        "BlynkSimpleEthernet2.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, \"blynk-cloud.com\", 80);\n  //Blynk.begin(auth, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, server_ip, 8080, arduino_ip, dns_ip, gateway_ip, subnet_mask, arduino_mac);\n  // Or like this:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80, arduino_ip, dns_ip, gateway_ip, subnet_mask, arduino_mac);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "GSM.h"
      ],
      "functions": [
        {
          "name": "connectNetwork",
          "body": "Serial.println(\"Connecting to GSM...\");\n  bool status = false;\n\n  // After starting the modem with GSM.begin()\n  // attach the shield to the GPRS network with the APN, login and password\n  while (status == false) {\n    if ((gsmAccess.begin(PINNUMBER) == GSM_READY) &\n        (gprs.attachGPRS(GPRS_APN, GPRS_LOGIN, GPRS_PASSWORD) == GPRS_READY)) {\n      status = true;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  delay(10);\n  Serial.println();\n  Serial.println();\n\n  connectNetwork();"
        },
        {
          "name": "loop",
          "body": "String response;\n\n  unsigned long value = millis();\n\n  // Send value to the cloud\n  // similar to Blynk.virtualWrite()\n\n  Serial.print(\"Sending value: \");\n  Serial.println(value);\n\n  if (httpRequest(\"GET\", String(\"/external/api/update?token=\") + BLYNK_AUTH_TOKEN + \"&pin=V2&value=\" + value, \"\", response)) {\n    if (response.length() != 0) {\n      Serial.print(\"WARNING: \");\n      Serial.println(response);"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "BlynkSimpleMKR1000.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFiNINA.h",
        "BlynkSimpleWiFiNINA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "BlynkMultiClient.h",
        "SPI.h",
        "Ethernet.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "connectEthernet",
          "body": "if (Ethernet.begin(ETH_MAC, 5000L, 500L)) {\n    Serial.print(\"Ethernet IP: \");\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "connectGPRS",
          "body": "bool gsmConnected = false;\n  bool gprsConnected = false;\n\n  const uint32_t tstart = millis();\n  while (millis() - tstart < 20000) {\n    if (gsmAccess.begin(SIM_PIN) == GSM_READY) {\n      gsmConnected = true;\n      break;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n\n  // Deselect the SD card\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH);\n\n  // Initialize Ethernet shield\n  Ethernet.init(MKRETH_CS);\n\n  connectEthernet();\n  connectGPRS();\n\n  // Setup Blynk\n  Blynk.addClient(\"ETH\", blynkEthernetClient, 80);\n  Blynk.addClient(\"GSM\", blynkGsmClient,      80);\n  Blynk.config(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  Ethernet.maintain();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "BlynkMultiClient.h",
        "SPI.h",
        "Ethernet.h",
        "ArduinoECCX08.h",
        "ArduinoBearSSL.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "connectEthernet",
          "body": "if (Ethernet.begin(ETH_MAC, 5000L, 500L)) {\n    Serial.print(\"Ethernet IP: \");\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "connectGPRS",
          "body": "bool gsmConnected = false;\n  bool gprsConnected = false;\n\n  const uint32_t tstart = millis();\n  while (millis() - tstart < 20000) {\n    if (gsmAccess.begin(SIM_PIN) == GSM_READY) {\n      gsmConnected = true;\n      break;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n\n  // Deselect the SD card\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH);\n\n  // Initialize Ethernet shield\n  Ethernet.init(MKRETH_CS);\n\n  // Enable NTP time helper (needed for SSL authentiction)\n  ArduinoBearSSL.onGetTime(ntpGetTime);\n\n  connectEthernet();\n  connectGPRS();\n\n  // Setup Blynk\n  Blynk.addClient(\"ETH\", blynkEthernetClientSSL,  443);\n  Blynk.addClient(\"GSM\", blynkGsmClientSSL,       443);\n\n  Blynk.config(BLYNK_AUTH_TOKEN);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  Ethernet.maintain();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "MKRGSM.h",
        "BlynkSimpleMKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, gsmAccess, gprs, client, pin, apn, user, pass);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "MKRNB.h",
        "BlynkSimpleMKRNB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n  Blynk.begin(BLYNK_AUTH_TOKEN, nbAccess, gprs, client, pin);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "BlynkSimpleEthernet.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Ethernet.init(MKRETH_CS);      // Init MKR ETH shield\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h",
        "Ethernet.h",
        "ArduinoECCX08.h",
        "ArduinoBearSSL.h",
        "BlynkSimpleEthernetSSL.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n\n  Ethernet.init(MKRETH_CS);      // Init MKR ETH shield\n\n  // Enable NTP time helper (needed for SSL authentiction)\n  ArduinoBearSSL.onGetTime(ntpGetTime);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);\n  // For more options, see Boards_Ethernet/Arduino_Ethernet_Manual example"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SoftwareSerial.h",
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  DebugSerial.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleStream.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Blynk will work through SoftwareSerial\n  // Do not read or write this serial manually in your sketch\n  SwSerial.begin(9600);\n  Blynk.begin(SwSerial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi.h",
        "BlynkSimpleWifi.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "WiFi101.h",
        "BlynkSimpleWiFiShield101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Bridge.h",
        "BlynkSimpleYun.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleStream.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  SerialUSB.begin(9600);\n\n  // Blynk will work through Serial\n  // Do not read or write this serial manually in your sketch\n  Serial.begin(9600);\n  Blynk.begin(Serial, auth);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "BLYNK_PRINT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiLink.h",
        "BlynkSimpleWiFiLink.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n  // You can also specify server:\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, \"blynk.cloud\", 80);\n  //Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass, IPAddress(192,168,1,100), 8080);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// start serial\n    Serial.begin(9600);\n    while(!Serial); // Wait for the serial port to come online\n\n    // Add some values to the buffer\n    for (int i = 65; i < 65 + 6; i++) {\n        buffer.push(i);"
        },
        {
          "name": "loop",
          "body": "// Nothing to do here"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCaptivePortal on \");  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCaptivePortalAdvanced on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_SC_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortalAdvanced_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the page.\n    return;"
        },
        {
          "name": "handleNotFound",
          "body": "if (captivePortal(request))\n  {\n    // If captive portal redirect instead of displaying the error page.\n    return;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncCaptivePortalAdvanced_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncCaptivePortal_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "request->send(200, \"text/html\", responseHTML);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncCaptivePortal_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // if DNSServer is started with \"*\" for domain name, it will reply with\n  // provided IP to all DNS request\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    Serial.println(\"\\nSending GET Request to \" + String(GET_ServerAddress));\n\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    //request.setReqHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCustomHeader on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    Serial.println(\"\\nSending GET Request to \" + String(GET_ServerAddress));\n\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    //request.setReqHeader(\"X-CUSTOM-HEADER\", \"custom_value\");\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncCustomHeader_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME) + \" using CYW43439 WiFi\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDNSServer on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(ARDUINO_BOARD);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncDNSServer_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains\n  // (e.g. sending ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients). Default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  server.onNotFound(handleNotFound);\n\n  server.begin();\n\n  Serial.print(F(\"AsyncDNSServer is @ IP : \"));\n  Serial.println(apIP);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncDNSServer_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME) + \" using CYW43439 WiFi\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDNSServerFull on \"); Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION);\n\n#if defined(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  if (ASYNC_DNS_SERVER_RP2040W_VERSION_INT < ASYNC_DNS_SERVER_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_DNS_SERVER_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_ENC.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_SC_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_SC_ETHERNET_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5500",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "USING_W5100",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_ESP32_Ethernet.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncDNSServerFull_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_ESP32_ETHERNET_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  DNS_LOGWARN(F(\"Default SPI pinout:\"));\n  DNS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  DNS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  DNS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  DNS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  DNS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  DNS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  DNS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  DNS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_DNS_WT32_ETH01_DEBUG_PORT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncDNSServer_WT32_ETH01.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "handleNotFound",
          "body": "String message = \"Hello World from \" + String(BOARD_NAME);\n  message += \"\\nURI: \";\n  message += request->url();\n\n  request->send(200, \"text/plain\", message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(\"\\nStarting AsyncDNSServerFull_WT32_ETH01 on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_UDP_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_DNS_SERVER_WT32_ETH01_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ///////////////////////////////////\n\n  /// To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  apIP = ETH.localIP();\n\n  ///////////////////////////////////\n\n  // modify TTL associated  with the domain name (in seconds)\n  // default is 60 seconds\n  dnsServer.setTTL(300);\n  // set which return code will be used for all other domains (e.g. sending\n  // ServerFailure instead of NonExistentDomain will reduce number of queries\n  // sent by clients)\n  // default is AsyncDNSReplyCode::NonExistentDomain\n  dnsServer.setErrorReplyCode(AsyncDNSReplyCode::ServerFailure);\n\n  // start DNS server for a specific domain name\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n\n  // simple HTTP server to see that DNS server is working\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from AsyncDNSServer running on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + dweetName + String(millis() / 1000)).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetGET on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "AsyncHTTPRequest_Impl_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + dweetName + String(millis() / 1000)).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      //Serial.println(request->responseText());\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n\n      request->setDebug(false);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetGET_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "analogRead",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    String postData = \"sensorValue=\";\n    postData += analogRead(A0);\n\n    Serial.println(\"\\nMaking new POST request\");\n\n    requestOpenResult = request.open(\"POST\", (POST_ServerAddress + dweetName + postData).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetPOST on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "analogRead",
        "Serial"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    String postData = \"sensorValue=\";\n    postData += analogRead(A0);\n\n    Serial.println(\"\\nMaking new POST request\");\n\n    requestOpenResult = request.open(\"POST\", (POST_ServerAddress + dweetName + postData).c_str() );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "parseResponse",
          "body": "/*\n    Typical response is:\n    {\"this\":\"succeeded\",\n    \"by\":\"getting\",\n    \"the\":\"dweets\",\n    \"with\":[{\"thing\":\"my-thing-name\",\n      \"created\":\"2016-02-16T05:10:36.589Z\",\n      \"content\":{\"sensorValue\":456"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    Serial.println();\n    AHTTP_LOGDEBUG(F(\"**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      String responseText = request->responseText();\n\n      Serial.println(\"\\n**************************************\");\n      //Serial.println(request->responseText());\n      Serial.println(responseText);\n      Serial.println(\"**************************************\");\n\n      parseResponse(responseText);\n\n      request->setDebug(false);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncDweetPOST_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "BOARD_TYPE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n       \n    client->printf(\"Hello Client %lu :)\", client->id());\n    client->ping();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n \n  Serial.printf(\"\\nStarting AsyncFSBrowser_STM32 on %s with %s\\n\", BOARD_NAME, SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n \n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n \n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT) \n  {\n    Serial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n    client->printf(\"Hello Client %lu :)\", client->id());\n    client->ping();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart AsyncFSBrowser_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n \n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n \n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  events.onConnect([](AsyncEventSourceClient * client) \n  {\n    client->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\n\t\tclient->printf(\"Hello Client %u :)\", client->id());\n\t\tclient->ping();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(F(\"\\nStart AsyncFSBrowser_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "LittleFS.h",
        "AsyncFSEditor_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\t\tclient->printf(\"Hello Client %ld :)\", client->id());\n\t\tclient->ping();"
        },
        {
          "name": "initFS",
          "body": "// Initialize LittleFS/SPIFFS file-system\n\tif (!LittleFS.begin())\n\t{\n\t\tLittleFS.format();\n\n\t\tif (!LittleFS.begin())\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tSerial.println(F(\"LittleFS failed!\"));\n\n\t\t\t\t// Stay forever here as useless to go further\n\t\t\t\tdelay(5000);"
        },
        {
          "name": "initWebServer",
          "body": "ws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart AsyncFSWebServer on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "LittleFS.h",
        "AsyncFSEditor_RP2040W.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onWsEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[%s][%u] connect\\n\", server->url(), client->id());\n\t\tclient->printf(\"Hello Client %ld :)\", client->id());\n\t\tclient->ping();"
        },
        {
          "name": "initFS",
          "body": "// Initialize LittleFS/SPIFFS file-system\n\tif (!LittleFS.begin())\n\t{\n\t\tLittleFS.format();\n\n\t\tif (!LittleFS.begin())\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tSerial.println(F(\"LittleFS failed!\"));\n\n\t\t\t\t// Stay forever here as useless to go further\n\t\t\t\tdelay(5000);"
        },
        {
          "name": "listDir",
          "body": "Dir dir = LittleFS.openDir(\"/\");\n\tSerial.println(F(\"Opening / directory\"));\n\n\twhile (dir.next())\n\t{\n\t\tString fileName = dir.fileName();\n\t\tsize_t fileSize = dir.fileSize();\n\t\tSerial.printf(\"FS File: %s, size: %s\\n\", fileName.c_str(), formatBytes(fileSize).c_str());"
        },
        {
          "name": "initWebServer",
          "body": "ws.onEvent(onWsEvent);\n\tserver.addHandler(&ws);\n\n\tevents.onConnect([](AsyncEventSourceClient * client)\n\t{\n\t\tclient->send(\"hello!\", NULL, millis(), 1000);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart AsyncFSWebServer_Complex on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "loop",
          "body": "ws.cleanupClients();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPMultiRequests using \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(F(\"Warning. Must use this example on Version equal or later than : \"));\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_ENC.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_ENC_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_ENC on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W5500.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W5500_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_W5500 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W6100.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_ESP32_W6100 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WT32_ETH01_isConnected())\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", requestAll[requestIndex] );\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.print(F(\"\\n***************\"));\n      Serial.print(requestName[ requestIndex ]);\n      Serial.println(F(\"***************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPMultiRequests_WT32_ETH01 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n    //requestOpenResult = request.open(\"GET\", \"http://213.188.196.246/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      Serial.println(\"Request sent\");\n\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPRequest_ESP using \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  WiFi.mode(WIFI_STA);\n\n  WiFi.begin(ssid, password);\n\n  Serial.print(F(\"Connecting to WiFi SSID: \"));\n  Serial.println(ssid);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(F(\".\"));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_ENC.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_ENC_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_ENC on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W5500.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W5500_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_W5500 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W5500_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_ESP32_W6100.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (ESP32_W6100_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP32_W6100 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_W6100_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "W5100lwIP.h",
        "ENC28J60lwIP.h",
        "WiFiClient.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (eth.connected())\n    Serial.print(F(\"H\"));        // H means connected to Ethernet\n  else\n    Serial.print(F(\"F\"));        // F means not connected to Ethernet\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n  eth.setDefault();\n\n  if (!eth.begin())\n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n\n    while (true)\n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP8266_Ethernet on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" using \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  initEthernet();\n\n  request.setDebug(false);\n\n  request.onReadyStateChange(requestCB);\n  ticker.attach(HTTP_REQUEST_INTERVAL, sendRequest);\n\n  ticker1.attach(HEARTBEAT_INTERVAL, heartBeatPrint);\n\n  // Send first request now\n  sendRequest();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFi.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  reqCount[index]--;\n  readySend[index] = false;\n\n  requestOpenResult = request[index].open(\"GET\", addreses[index][reqCount[index]]);\n\n  if (requestOpenResult)\n  {\n    // Only send() if open() returns true, or crash\n    Serial.print(\"\\nSending request: \");\n    request[index].send();"
        },
        {
          "name": "sendRequest0",
          "body": "sendRequest(0);"
        },
        {
          "name": "sendRequest1",
          "body": "sendRequest(1);"
        },
        {
          "name": "sendRequests",
          "body": "reqCount[0] = NUM_ENTRIES_SITE_0;\n  reqCount[1] = NUM_ENTRIES_SITE_1;"
        },
        {
          "name": "requestCB0",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "requestCB1",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_ESP_Multi on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  WiFi.mode(WIFI_STA);\n\n  WiFi.begin(ssid, password);\n\n  Serial.println(\"Connecting to WiFi SSID: \" + String(ssid));\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(1000);\n    Serial.print(\".\");"
        },
        {
          "name": "loop",
          "body": "for (int index = 0; index < NUM_DIFFERENT_SITES; index++)\n  {\n    if ((reqCount[index] > 0) && readySend[index])\n    {\n      sendRequestCB[index]();\n\n      // Don't send too fast\n      delay(1000);"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay",
        "EEPROM"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "AsyncHTTPRequest_Generic.h",
        "AsyncHTTPRequest_Impl_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn,\n              in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n#define HEARTBEAT_INTERVAL    10000L\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "loadConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"r\");\n  LOGERROR(F(\"LoadWiFiCfgFile \"));\n\n  memset(&WM_config,       0, sizeof(WM_config));\n\n  // New in v1.4.0\n  //memset(&WM_STA_IPconfig, 0, sizeof(WM_STA_IPconfig));\n  // New in v1.8.2\n  initSTAIPConfigStruct(WM_STA_IPconfig);\n  //////\n\n  if (file)\n  {\n    file.readBytes((char *) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.readBytes((char *) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));\n\n    // New in v1.4.0\n    displayIPConfigStruct(WM_STA_IPconfig);\n    //////"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    file.write((uint8_t*) &WM_config,   sizeof(WM_config));\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting AsyncHTTPRequest_ESP_WiFiManager using \"));\n  Serial.print(FS_Name);\n  Serial.print(F(\" on \"));\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(F(\"Warning. Must use this example on Version later than : \"));\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (WT32_ETH01_isConnected())\n    Serial.print(F(\"H\"));        // H means connected\n  else\n    Serial.print(F(\"F\"));        // F means not connected\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    //requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/Europe/London.txt\");\n    requestOpenResult = request.open(\"GET\", \"http://worldtimeapi.org/api/timezone/America/Toronto.txt\");\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncHTTPRequest_WT32_ETH01 on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "BUFFER_SIZE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n  \n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncMultiWebServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(ETH.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "BOARD_TYPE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(Ethernet.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n  request->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n  request->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart AsyncMultiWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  Serial.print(\"\\nConnected to network. IP = \");\n  Serial.println(Ethernet.localIP());\n\n  for (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n  {\n    multiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);  \n\n    if (multiServer[serverIndex])\n    {\n      Serial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "String message = createBuffer();\n\trequest->send(200, F(\"text/html\"), message);"
        },
        {
          "name": "handleNotFound",
          "body": "String message = createNotFoundBuffer(request);\n\trequest->send(404, F(\"text/plain\"), message);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(F(\"\\nStart AsyncMultiWebServer_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tSerial.print(\"\\nConnected to network. IP = \");\n\tSerial.println(ETH.localIP());\n\n\tfor (serverIndex = 0; serverIndex < NUM_SERVERS; serverIndex++)\n\t{\n\t\tmultiServer[serverIndex] = new AsyncWebServer(http_port[serverIndex]);\n\n\t\tif (multiServer[serverIndex])\n\t\t{\n\t\t\tSerial.printf(\"Initialize multiServer OK, serverIndex = %d, port = %d\\n\", serverIndex, http_port[serverIndex]);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncSimpleGET on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", GET_ServerAddress);\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncSimpleGET_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_ENC\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_W5500\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart AsyncSimpleServer_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_ESP32_W6100\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tSerial.print(F(\"\\nStart AsyncSimpleServer_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tIPAddress localIP = ETH.localIP();\n\n\tSerial.print(F(\"IP address: \"));\n\tSerial.println(localIP);\n\n\tserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", \"Hello, world from AsyncSimpleServer_WT32_ETH01\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Stepper.h"
      ],
      "functions": [
        {
          "name": "clockwise",
          "body": "stepCounter++;\n\tif (stepCounter >= numSteps) stepCounter = 0;\n\tsetOutput(stepCounter);"
        },
        {
          "name": "anticlockwise",
          "body": "stepCounter--;\n\tif (stepCounter < 0) stepCounter = numSteps - 1;\n\tsetOutput(stepCounter);"
        },
        {
          "name": "setOutput",
          "body": "digitalWrite(motorPin1, bitRead(stepsLookup[step], 0));\n\tdigitalWrite(motorPin2, bitRead(stepsLookup[step], 1));\n\tdigitalWrite(motorPin3, bitRead(stepsLookup[step], 2));\n\tdigitalWrite(motorPin4, bitRead(stepsLookup[step], 3));"
        },
        {
          "name": "rotateCW",
          "body": "stepper1.Rotate(90, AsyncStepper::CW, rotateCCW);"
        },
        {
          "name": "rotateCCW",
          "body": "stepper1.Rotate(90, AsyncStepper::CCW, rotateCW);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n\tpinMode(motorPin1, OUTPUT);\n\tpinMode(motorPin2, OUTPUT);\n\tpinMode(motorPin3, OUTPUT);\n\tpinMode(motorPin4, OUTPUT);\n\n\tstepper1.SetSpeedRpm(10);\n\tstepper1.RotateContinuos(AsyncStepper::CCW);"
        },
        {
          "name": "loop",
          "body": "stepper1.Update();"
        }
      ]
    },
    {
      "name": "ENABLE_ASYNC_TCP_CLIENT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "// The async task handler should run inside the main loop\n    // without blocking delay or bypassing with millis code blocks.\n\n    app.loop();\n\n    // To get the authentication time to live in seconds before expired.\n    // app.ttl();"
        },
        {
          "name": "asyncCB",
          "body": "// WARNING!\n    // Do not put your codes inside the callback and printResult.\n\n    printResult(aResult);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "AsyncTCPConnectCB",
          "body": ""
        },
        {
          "name": "AsyncTCPStatusCB",
          "body": "// Some asyn TCP client provides the server connected callback, you have to collect the required status from its callback\n    // and set it to status variable."
        },
        {
          "name": "AsyncTCPSendCB",
          "body": ""
        },
        {
          "name": "AsyncTCPReceiveCB",
          "body": "// Some asyn TCP client provides the data available callback, you have to collect the required data and status from its callback\n    // and provide the data here in case of data is ready and available to read.\n\n    // Please don't reallocate the buff, just copy data from async TCP client buffer to buff.\n    // After buff was set, set the filledSize and available."
        },
        {
          "name": "AsyncTCPStop",
          "body": ""
        }
      ]
    },
    {
      "name": "TCP_PORT",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "AsyncTCP_RP2040W.h"
      ],
      "functions": [
        {
          "name": "replyToServer",
          "body": "(void) arg;\n\n  Serial.println(\"\\n********************\");\n  Serial.println(\"New replyToServer\");\n\n  AsyncClient* client = reinterpret_cast<AsyncClient*>(arg);\n\n  // send reply\n  if (client->space() > REPLY_SIZE && client->canSend())\n  {\n    char message[REPLY_SIZE];\n    sprintf(message, \"This is from AsyncTCPClient @ %s\", WiFi.localIP().toString().c_str());\n    client->add(message, strlen(message));\n    client->send();\n\n    dataReceived = false;"
        },
        {
          "name": "handleData",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nData received from %s \\n\", client->remoteIP().toString().c_str());\n  Serial.write((uint8_t*)data, len);\n\n  lastCheck = millis();\n\n  dataReceived = true;"
        },
        {
          "name": "onConnect",
          "body": "(void) arg;\n\n  clientConnected = true;\n\n  Serial.printf(\"\\nAsyncTCPClient has been connected to Server %s, port %d \\n\", serverIP.toString().c_str(), TCP_PORT);\n\n  replyToServer(client);"
        },
        {
          "name": "onDisconnect",
          "body": "(void) arg;\n  (void) client;\n\n  Serial.printf(\"\\nAsyncTCPClient has been disconnected from Server %s, port %d \\n\", serverIP.toString().c_str(), TCP_PORT);\n\n  clientConnected = false;"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncTCP_Client on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "static unsigned long lastConnectCheck = CHECK_INTERVAL_MS;\n  \n  if (millis() - lastCheck > SEND_INTERVAL_MS)\n  {\n    if (clientConnected && dataReceived)\n    {\n      replyToServer(client);"
        }
      ]
    },
    {
      "name": "TCP_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncTCP_RP2040W.h",
        "vector"
      ],
      "functions": [
        {
          "name": "handleError",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nConnection error %s from client %s \\n\", client->errorToString(error), client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleData",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nData received from client %s \\n\", client->remoteIP().toString().c_str());\n  Serial.write((uint8_t*)data, len);\n\n  // reply to client\n  if (client->space() > REPLY_SIZE && client->canSend())\n  {\n    char reply[REPLY_SIZE];\n    sprintf(reply, \"You've connected to AsyncTCPServer @ %s\", serverIP.toString().c_str());\n    client->add(reply, strlen(reply));\n    client->send();"
        },
        {
          "name": "handleDisconnect",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nClient %s disconnected\\n\", client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleTimeOut",
          "body": "(void) arg;\n  (void) time;\n\n  Serial.printf(\"\\nClient ACK timeout ip: %s\\n\", client->remoteIP().toString().c_str());"
        },
        {
          "name": "handleNewClient",
          "body": "(void) arg;\n\n  Serial.printf(\"\\nNew client has been connected to server, IP: %s\", client->remoteIP().toString().c_str());\n\n  // add to list\n  clients.push_back(client);\n\n  // register events\n  client->onData(&handleData, NULL);\n  client->onError(&handleError, NULL);\n  client->onDisconnect(&handleDisconnect, NULL);\n  client->onTimeout(&handleTimeOut, NULL);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  serverIP = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(serverIP);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart AsyncTCP_Server on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n\n  ///////////////////////////////////\n\n  // check for the WiFi module:\n  if (WiFi.status() == WL_NO_MODULE)\n  {\n    Serial.println(\"Communication with WiFi module failed!\");\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "parsePacket",
          "body": "Serial.print(\"UDP Packet Type: \");\n  Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\", From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.print(\", Data: \");\n  Serial.write(packet.data(), packet.length());\n  Serial.println();\n  //reply to the client\n  packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart Async_UDPClient on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"Async_UDPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  if (udp.connect(remoteIPAddress, UDP_REMOTE_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket( packet);"
        },
        {
          "name": "loop",
          "body": "delay(10000);\n  //Send broadcast on port UDP_REMOTE_PORT = 1234\n  udp.broadcastTo(\"Anyone here?\", UDP_REMOTE_PORT);"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "parsePacket",
          "body": "Serial.print(\"UDP Packet Type: \");\n  Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\", From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.print(\", Data: \");\n  Serial.write(packet.data(), packet.length());\n  Serial.println();\n  //reply to the client\n  packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUDPMulticastServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"Async_UDPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n\n  if (udp.listenMulticast(IPAddress(239, 1, 2, 3), 1234))\n  {\n    Serial.print(\"UDP Listening on IP: \");\n    Serial.println(ETH.localIP());\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);"
        },
        {
          "name": "loop",
          "body": "delay(1000);\n  //Send multicast\n  udp.print(\"Anyone here?\");"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart Async_UdpServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUDPServer started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  if (udp.listen(1234))\n  {\n    Serial.print(\"UDP Listening on IP: \");\n    Serial.println(ETH.localIP());\n\n    udp.onPacket([](AsyncUDPPacket packet)\n    {\n      Serial.print(\"UDP Packet Type: \");\n      Serial.print(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n      Serial.print(\", From: \");\n      Serial.print(packet.remoteIP());\n      Serial.print(\":\");\n      Serial.print(packet.remotePort());\n      Serial.print(\", To: \");\n      Serial.print(packet.localIP());\n      Serial.print(\":\");\n      Serial.print(packet.localPort());\n      Serial.print(\", Length: \");\n      Serial.print(packet.length());\n      Serial.print(\", Data: \");\n      Serial.write(packet.data(), packet.length());\n      Serial.println();\n      //reply to the client\n      packet.printf(\"Got %u bytes of data\", packet.length());"
        },
        {
          "name": "loop",
          "body": "delay(1000);\n  //Send broadcast\n  udp.broadcast(\"Anyone here?\");"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h",
        "time.h"
      ],
      "functions": [
        {
          "name": "createNTPpacket",
          "body": "Serial.println(\"============= createNTPpacket =============\");\n\n  // set all bytes in the buffer to 0\n  memset(packetBuffer, 0, NTP_PACKET_SIZE);\n  // Initialize values needed to form NTP request\n  // (see URL above for details on the packets)\n\n  packetBuffer[0]   = 0b11100011;   // LI, Version, Mode\n  packetBuffer[1]   = 0;     // Stratum, or type of clock\n  packetBuffer[2]   = 6;     // Polling Interval\n  packetBuffer[3]   = 0xEC;  // Peer Clock Precision\n\n  // 8 bytes of zero for Root Delay & Root Dispersion\n  packetBuffer[12]  = 49;\n  packetBuffer[13]  = 0x4E;\n  packetBuffer[14]  = 49;\n  packetBuffer[15]  = 52;"
        },
        {
          "name": "parsePacket",
          "body": "struct tm  ts;\n  char       buf[80];\n\n  memcpy(packetBuffer, packet.data(), sizeof(packetBuffer));\n\n  Serial.print(\"Received UDP Packet Type: \");\n  Serial.println(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\"From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.println();\n\n  unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);\n  unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);\n\n  // combine the four bytes (two words) into a long integer\n  // this is NTP time (seconds since Jan 1 1900):\n  unsigned long secsSince1900 = highWord << 16 | lowWord;\n\n  Serial.print(F(\"Seconds since Jan 1 1900 = \"));\n  Serial.println(secsSince1900);\n\n  // now convert NTP time into )everyday time:\n  Serial.print(F(\"Epoch/Unix time = \"));\n\n  // Unix time starts on Jan 1 1970. In seconds, that's 2208988800:\n  const unsigned long seventyYears = 2208988800UL;\n\n  // subtract seventy years:\n  unsigned long epoch = secsSince1900 - seventyYears;\n  time_t epoch_t = epoch;   //secsSince1900 - seventyYears;\n\n  // print Unix time:\n  Serial.println(epoch);\n\n  // print the hour, minute and second:\n  Serial.print(F(\"The UTC/GMT time is \"));       // UTC is the time at Greenwich Meridian (GMT)\n\n  ts = *localtime(&epoch_t);\n  strftime(buf, sizeof(buf), \"%a %Y-%m-%d %H:%M:%S %Z\", &ts);\n  Serial.println(buf);"
        },
        {
          "name": "sendNTPPacket",
          "body": "createNTPpacket();\n  //Send unicast\n  Udp.write(packetBuffer, sizeof(packetBuffer));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUdpNTPClient on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUdpNTPClient started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  //NTP requests are to port NTP_REQUEST_PORT = 123\n  if (Udp.connect(timeServerIP, NTP_REQUEST_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    Udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);"
        },
        {
          "name": "loop",
          "body": "sendNTPPacket();\n\n  // wait 60 seconds before asking for the time again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "ASYNC_UDP_ESP32_ENC_DEBUG_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncUDP_ESP32_ENC.h",
        "time.h"
      ],
      "functions": [
        {
          "name": "sendACKPacket",
          "body": "Serial.println(\"============= sendACKPacket =============\");\n\n  // Send unicast ACK to the same remoteIP and remotePort we received the packet\n  // The AsyncUDP_STM32 library will take care of the correct IP and port based on pcb\n  Udp.write((uint8_t *) ReplyBuffer, sizeof(ReplyBuffer));"
        },
        {
          "name": "createNTPpacket",
          "body": "Serial.println(\"============= createNTPpacket =============\");\n\n  // set all bytes in the buffer to 0\n  memset(packetBuffer, 0, NTP_PACKET_SIZE);\n  // Initialize values needed to form NTP request\n  // (see URL above for details on the packets)\n\n  packetBuffer[0]   = 0b11100011;   // LI, Version, Mode\n  packetBuffer[1]   = 0;     // Stratum, or type of clock\n  packetBuffer[2]   = 6;     // Polling Interval\n  packetBuffer[3]   = 0xEC;  // Peer Clock Precision\n\n  // 8 bytes of zero for Root Delay & Root Dispersion\n  packetBuffer[12]  = 49;\n  packetBuffer[13]  = 0x4E;\n  packetBuffer[14]  = 49;\n  packetBuffer[15]  = 52;"
        },
        {
          "name": "sendNTPPacket",
          "body": "createNTPpacket();\n  //Send unicast\n  Udp.write(packetBuffer, sizeof(packetBuffer));"
        },
        {
          "name": "parsePacket",
          "body": "struct tm  ts;\n  char       buf[80];\n\n  memcpy(packetBuffer, packet.data(), sizeof(packetBuffer));\n\n  Serial.print(\"Received UDP Packet Type: \");\n  Serial.println(packet.isBroadcast() ? \"Broadcast\" : packet.isMulticast() ? \"Multicast\" : \"Unicast\");\n  Serial.print(\"From: \");\n  Serial.print(packet.remoteIP());\n  Serial.print(\":\");\n  Serial.print(packet.remotePort());\n  Serial.print(\", To: \");\n  Serial.print(packet.localIP());\n  Serial.print(\":\");\n  Serial.print(packet.localPort());\n  Serial.print(\", Length: \");\n  Serial.print(packet.length());\n  Serial.println();\n\n  unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);\n  unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);\n\n  // combine the four bytes (two words) into a long integer\n  // this is NTP time (seconds since Jan 1 1900):\n  unsigned long secsSince1900 = highWord << 16 | lowWord;\n\n  Serial.print(F(\"Seconds since Jan 1 1900 = \"));\n  Serial.println(secsSince1900);\n\n  // now convert NTP time into )everyday time:\n  Serial.print(F(\"Epoch/Unix time = \"));\n\n  // Unix time starts on Jan 1 1970. In seconds, that's 2208988800:\n  const unsigned long seventyYears = 2208988800UL;\n\n  // subtract seventy years:\n  unsigned long epoch = secsSince1900 - seventyYears;\n  time_t epoch_t = epoch;   //secsSince1900 - seventyYears;\n\n  // print Unix time:\n  Serial.println(epoch);\n\n  // print the hour, minute and second:\n  Serial.print(F(\"The UTC/GMT time is \"));       // UTC is the time at Greenwich Meridian (GMT)\n\n  ts = *localtime(&epoch_t);\n  strftime(buf, sizeof(buf), \"%a %Y-%m-%d %H:%M:%S %Z\", &ts);\n  Serial.println(buf);\n\n  // send a reply, to the IP address and port that sent us the packet we received\n  sendACKPacket();"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && (millis() < 5000));\n\n  Serial.print(F(\"\\nStart AsyncUDPSendReceive on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_ESP32_ENC_VERSION);\n  Serial.println(ASYNC_UDP_ESP32_ENC_VERSION);\n\n  Serial.setDebugOutput(true);\n\n  ET_LOGWARN(F(\"Default SPI pinout:\"));\n  ET_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  ET_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  ET_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  ET_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  ET_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  ET_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  ET_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  // Client address\n  Serial.print(\"AsyncUDPSendReceive started @ IP address: \");\n  Serial.println(ETH.localIP());\n\n  Serial.println(F(\"\\nStarting connection to server...\"));\n\n  //NTP requests are to port NTP_REQUEST_PORT = 123\n  if (Udp.connect(timeServerIP, NTP_REQUEST_PORT))\n  {\n    Serial.println(\"UDP connected\");\n\n    Udp.onPacket([](AsyncUDPPacket packet)\n    {\n      parsePacket(packet);"
        },
        {
          "name": "loop",
          "body": "sendNTPPacket();\n\n  // wait 60 seconds before asking for the time again\n  delay(60000);"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncHTTPRequest_RP2040W.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + GET_Location).c_str());\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGWARN(F(\"\\n**************************************\"));\n    AHTTP_LOGWARN1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncWebClientRepeating on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_RP2040W_VERSION_INT < ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_RP2040W_VERSION_MIN_TARGET);"
        },
        {
          "name": "sendRequestRepeat",
          "body": "static unsigned long sendRequest_timeout = 0;\n\n#define SEND_REQUEST_INTERVAL     60000L\n\n  // sendRequest every SEND_REQUEST_INTERVAL (60) seconds: we don't need to sendRequest frequently\n  if ((millis() > sendRequest_timeout) || (sendRequest_timeout == 0))\n  {\n    sendRequest();\n\n    sendRequest_timeout = millis() + SEND_REQUEST_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "sendRequestRepeat();"
        }
      ]
    },
    {
      "name": "ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "AsyncHTTPRequest_Generic.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "sendRequest",
          "body": "static bool requestOpenResult;\n\n  if (request.readyState() == readyStateUnsent || request.readyState() == readyStateDone)\n  {\n    requestOpenResult = request.open(\"GET\", (GET_ServerAddress + GET_Location).c_str());\n\n    if (requestOpenResult)\n    {\n      // Only send() if open() returns true, or crash\n      request.send();"
        },
        {
          "name": "requestCB",
          "body": "(void) optParm;\n\n  if (readyState == readyStateDone)\n  {\n    AHTTP_LOGDEBUG(F(\"\\n**************************************\"));\n    AHTTP_LOGDEBUG1(F(\"Response Code = \"), request->responseHTTPString());\n\n    if (request->responseHTTPcode() == 200)\n    {\n      Serial.println(F(\"\\n**************************************\"));\n      Serial.println(request->responseText());\n      Serial.println(F(\"**************************************\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(\"\\nStart AsyncWebClientRepeating_STM32 on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION);\n\n#if defined(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n\n  if (ASYNC_HTTP_REQUEST_GENERIC_VERSION_INT < ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ASYNC_HTTP_REQUEST_GENERIC_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "sendHTTPRequest.update();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "AsyncMqtt_Generic.h",
        "ESPAsyncWebServer.h"
      ],
      "functions": [
        {
          "name": "connectToWifi",
          "body": "Serial.println(\"Connecting to Wi-Fi...\");\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);"
        },
        {
          "name": "connectToMqtt",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "WiFiEvent",
          "body": "switch (event)\n  {\n#if USING_CORE_ESP32_CORE_V200_PLUS\n\n    case ARDUINO_EVENT_WIFI_READY:\n      Serial.println(\"WiFi ready\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_START:\n      Serial.println(\"WiFi STA starting\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_CONNECTED:\n      Serial.println(\"WiFi STA connected\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP6:\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP:\n      Serial.println(\"WiFi connected\");\n      Serial.print(\"IP address: \");\n      Serial.println(WiFi.localIP());\n      connectToMqtt();\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_LOST_IP:\n      Serial.println(\"WiFi lost IP\");\n      break;\n\n    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:\n      Serial.println(\"WiFi lost connection\");\n      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi\n      xTimerStart(wifiReconnectTimer, 0);\n      break;\n#else\n\n    case SYSTEM_EVENT_STA_GOT_IP:\n      Serial.println(\"WiFi connected\");\n      Serial.println(\"IP address: \");\n      Serial.println(WiFi.localIP());\n      connectToMqtt();\n      break;\n\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n      Serial.println(\"WiFi lost connection\");\n      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi\n      xTimerStart(wifiReconnectTimer, 0);\n      break;\n#endif\n\n    default:\n      break;"
        },
        {
          "name": "connectToMqttLoop",
          "body": "if (WiFi.status() == WL_CONNECTED)\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"ESP32 Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"ESP32 Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"ESP32 Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MQTT on \");\n  Serial.println(ARDUINO_BOARD);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  mqttReconnectTimer = xTimerCreate(\"mqttTimer\", pdMS_TO_TICKS(2000), pdFALSE, (void*)0,\n                                    reinterpret_cast<TimerCallbackFunction_t>(connectToMqtt));\n  wifiReconnectTimer = xTimerCreate(\"wifiTimer\", pdMS_TO_TICKS(10000), pdFALSE, (void*)0,\n                                    reinterpret_cast<TimerCallbackFunction_t>(connectToWifi));\n\n  WiFi.onEvent(WiFiEvent);\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToWifi();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from ESP32!\");"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) /*|| (checkstatus_timeout == 0)*/)\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCTCP_RP2040W_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WiFi.h",
        "Ticker.h",
        "AsyncMqtt_Generic.h",
        "AsyncWebServer_RP2040W.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"Connected to SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print the received signal strength:\n  long rssi = WiFi.RSSI();\n  Serial.print(\"Signal strength (RSSI):\");\n  Serial.print(rssi);\n  Serial.println(\" dBm\");"
        },
        {
          "name": "connectToMqttLoop",
          "body": "//if ( (WiFi.status() == WL_CONNECTED) && (WiFi.RSSI() != 0) )      // temporary workaround\n  if (isWiFiConnected())\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();"
        },
        {
          "name": "connectToMqtt",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"RP2040W Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"RP2040W Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"RP2040W Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MQTT_RP2040W on \");\n  Serial.println(BOARD_NAME);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  ///////////////////////////////////\n\n  connectToWifi();\n\n  ///////////////////////////////////\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToMqttTicker.start(); //start the ticker.\n\n  connectToMqtt();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello from RP2040W!\");"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\"H\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) /*|| (checkstatus_timeout == 0)*/)\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "connectToMqttTicker.update(); //update the ticker.\n  check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "createPage",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "handleRoot",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  // clear the String to start over\n  out = String();\n\n  createPage(out);\n\n  out += \"<html><body>\\r\\n<table><tr><th>INDEX</th><th>DATA</th></tr>\";\n\n  for (uint16_t lineIndex = 0; lineIndex < 500; lineIndex++)\n  {\n    out += \"<tr><td>\";\n    out += String(lineIndex);\n    out += \"</td><td>\";\n    out += \"ESP32_ENC_AsyncWebServer_SendChunked_ABCDEFGHIJKLMNOPQRSTUVWXYZ</td></tr>\";"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart AsyncWebServer_SendChunked on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "#define BUFFER_SIZE     400\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(3000);\n  char temp[70];\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_AdvancedWebServer on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCTCP_RP2040W_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n\n\tint sec = millis() / 1000;\n\tint min = sec / 60;\n\tint hr = min / 60;\n\tint day = hr / 24;\n\n\tsnprintf(temp, BUFFER_SIZE - 1,\n\t         \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='60'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n\tString message = \"File Not Found\\n\\n\";\n\n\tmessage += \"URI: \";\n\tmessage += request->url();\n\tmessage += \"\\nMethod: \";\n\tmessage += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n\tmessage += \"\\nArguments: \";\n\tmessage += request->args();\n\tmessage += \"\\n\";\n\n\tfor (uint8_t i = 0; i < request->args(); i++)\n\t{\n\t\tmessage += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n\tout.reserve(4000);\n\tchar temp[70];\n\n\tdigitalWrite(LED_BUILTIN, LED_ON);\n\n\tout += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n\tout += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n\tout += \"<g stroke=\\\"blue\\\">\\n\";\n\tint y = rand() % 130;\n\n\tfor (int x = 10; x < 300; x += 10)\n\t{\n\t\tint y2 = rand() % 130;\n\t\tsprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n\t\tout += temp;\n\t\ty = y2;"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);\n\n\t// print your board's country code\n\t// #define CYW43_COUNTRY(A, B, REV) ((unsigned char)(A) | ((unsigned char)(B) << 8) | ((REV) << 16))\n\tuint32_t myCountryCode = cyw43_arch_get_country_code();\n\n\tcountryCode[0] = myCountryCode & 0xFF;\n\tcountryCode[1] = (myCountryCode >> 8) & 0xFF;\n\n\tSerial.print(\"Country code: \");\n\tSerial.println(countryCode);"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n\tdigitalWrite(LED_BUILTIN, LED_OFF);\n\n\tSerial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStart Async_AdvancedWebServer_Country on \");\n\tSerial.print(BOARD_NAME);\n\tSerial.print(\" with \");\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n\tSerial.print(F(\".\"));\n\n\tif (num == 80)\n\t{\n\t\tSerial.println();\n\t\tnum = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n\t// Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n\tif ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n\t{\n\t\theartBeatPrint();\n\t\tcheckstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n\n#define BUFFER_SIZE     400\n\n  char temp[BUFFER_SIZE];\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(3000);\n  char temp[70];\n  \n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='60'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "PrintHeapData",
          "body": "static uint32_t maxFreeHeap = 0xFFFFFFFF;\n  static uint32_t totalHeap = ESP.getHeapSize();\n\n  uint32_t freeHeap  = ESP.getFreeHeap();\n\n  // Print and update only when larger heap\n  if (maxFreeHeap > freeHeap)\n  {\n    maxFreeHeap = freeHeap;\n\n    Serial.print(\"\\nHEAP DATA - \");\n    Serial.print(hIn);\n\n    Serial.print(\"  Max heap: \");\n    Serial.print(totalHeap);\n    Serial.print(\"  Free heap: \");\n    Serial.print(ESP.getFreeHeap());\n    Serial.print(\"  Used heap: \");\n    Serial.println(totalHeap - freeHeap);"
        },
        {
          "name": "PrintStringSize",
          "body": "static uint32_t count = 0;\n\n  // Print only when cStr length too large and corrupting memory or every (20 * 5) s\n  if ( (out.length() >= STRING_SIZE) || (++count > 20) )\n  {\n    Serial.print(\"\\nOut String Length=\");\n    Serial.println(out.length());\n\n    count = 0;"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MemoryIssues_SendArduinoString on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='10'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "PrintHeapData",
          "body": "static uint32_t maxFreeHeap = 0xFFFFFFFF;\n  static uint32_t totalHeap = ESP.getHeapSize();\n\n  uint32_t freeHeap  = ESP.getFreeHeap();\n\n  // Print and update only when larger heap\n  if (maxFreeHeap > freeHeap)\n  {\n    maxFreeHeap = freeHeap;\n\n    Serial.print(\"\\nHEAP DATA - \");\n    Serial.print(hIn);\n\n    Serial.print(\"  Max heap: \");\n    Serial.print(totalHeap);\n    Serial.print(\"  Free heap: \");\n    Serial.print(ESP.getFreeHeap());\n    Serial.print(\"  Used heap: \");\n    Serial.println(totalHeap - freeHeap);"
        },
        {
          "name": "PrintStringSize",
          "body": "Serial.print(\"\\nOut String Length=\");\n  Serial.println(strlen(cStr));"
        },
        {
          "name": "drawGraph",
          "body": "char temp[80];\n\n  cStr[0] = '\\0';\n\n  strcat(cStr, \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\");\n  strcat(cStr,\n         \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\");\n  strcat(cStr, \"<g stroke=\\\"blue\\\">\\n\");\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    strcat(cStr, temp);\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_MemoryIssues_Send_CString on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  cStr = (char *) malloc(CSTRING_SIZE);           // make a little larger than required\n\n  if (cStr == NULL)\n  {\n    Serial.println(\"Unable top Allocate RAM\");\n\n    for (;;);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    //Serial.println();\n    PrintStringSize(cStr);\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out = String();\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_SendChunked on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "pico/cyw43_arch.h",
        "Ticker.h",
        "AsyncMqtt_Generic.h",
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  Serial.print(\"SSID: \");\n  Serial.println(WiFi.SSID());\n\n  // print your board's IP address:\n  IPAddress ip = WiFi.localIP();\n  Serial.print(\"Local IP Address: \");\n  Serial.println(ip);\n\n  // print your board's country code\n  // #define CYW43_COUNTRY(A, B, REV) ((unsigned char)(A) | ((unsigned char)(B) << 8) | ((REV) << 16))\n  uint32_t myCountryCode = cyw43_arch_get_country_code();\n  char countryCode[3] = { 0, 0, 0"
        },
        {
          "name": "connectToMqttLoop",
          "body": "//if ( (WiFi.status() == WL_CONNECTED) && (WiFi.RSSI() != 0) )      // temporary workaround\n  if (isWiFiConnected())\n  {\n    if (!connectedMQTT)\n    {\n      mqttClient.connect();"
        },
        {
          "name": "connectToMqtt",
          "body": "Serial.println(\"Connecting to MQTT...\");\n  mqttClient.connect();"
        },
        {
          "name": "printSeparationLine",
          "body": "Serial.println(\"************************************************\");"
        },
        {
          "name": "onMqttConnect",
          "body": "Serial.print(\"Connected to MQTT broker: \");\n  Serial.print(MQTT_HOST);\n  Serial.print(\", port: \");\n  Serial.println(MQTT_PORT);\n  Serial.print(\"PubTopic: \");\n  Serial.println(PubTopic);\n\n  connectedMQTT = true;\n\n  printSeparationLine();\n  Serial.print(\"Session present: \");\n  Serial.println(sessionPresent);\n\n  uint16_t packetIdSub = mqttClient.subscribe(PubTopic, 2);\n  Serial.print(\"Subscribing at QoS 2, packetId: \");\n  Serial.println(packetIdSub);\n\n  mqttClient.publish(PubTopic, 0, true, \"RP2040W Test1\");\n  Serial.println(\"Publishing at QoS 0\");\n\n  uint16_t packetIdPub1 = mqttClient.publish(PubTopic, 1, true, \"RP2040W Test2\");\n  Serial.print(\"Publishing at QoS 1, packetId: \");\n  Serial.println(packetIdPub1);\n\n  uint16_t packetIdPub2 = mqttClient.publish(PubTopic, 2, true, \"RP2040W Test3\");\n  Serial.print(\"Publishing at QoS 2, packetId: \");\n  Serial.println(packetIdPub2);\n\n  printSeparationLine();"
        },
        {
          "name": "onMqttDisconnect",
          "body": "(void) reason;\n\n  connectedMQTT = false;\n\n  Serial.println(\"Disconnected from MQTT.\");"
        },
        {
          "name": "onMqttSubscribe",
          "body": "Serial.println(\"Subscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);\n  Serial.print(\"  qos: \");\n  Serial.println(qos);"
        },
        {
          "name": "onMqttUnsubscribe",
          "body": "Serial.println(\"Unsubscribe acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "onMqttPublish",
          "body": "Serial.println(\"Publish acknowledged.\");\n  Serial.print(\"  packetId: \");\n  Serial.println(packetId);"
        },
        {
          "name": "handleRoot",
          "body": "static uint32_t pageCount   = 0;\n  static uint32_t maxfreeHeap = 0;\n  static uint32_t minFreeHeap = 0xFFFFFFFF;\n  uint32_t curFreeHeap = rp2040.getFreeHeap();\n\n  if (maxfreeHeap < curFreeHeap)\n    maxfreeHeap = curFreeHeap;\n\n  if (minFreeHeap > curFreeHeap)\n    minFreeHeap = curFreeHeap;\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(LED_BUILTIN, LED_ON);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "out.reserve(STRING_SIZE);\n  char temp[70];\n\n  out = String();\n\n  digitalWrite(LED_BUILTIN, LED_ON);\n\n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"1810\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"1810\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 5000; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LED_OFF);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_SendChunked_MQTT on \");\n  Serial.print(BOARD_NAME);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNCTCP_RP2040W_VERSION);\n  Serial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n  Serial.println(ASYNC_MQTT_GENERIC_VERSION);\n\n  ///////////////////////////////////\n\n  connectToWifi();\n\n  ///////////////////////////////////\n\n  mqttClient.onConnect(onMqttConnect);\n  mqttClient.onDisconnect(onMqttDisconnect);\n  mqttClient.onSubscribe(onMqttSubscribe);\n  mqttClient.onUnsubscribe(onMqttUnsubscribe);\n  mqttClient.onMessage(onMqttMessage);\n  mqttClient.onPublish(onMqttPublish);\n\n  mqttClient.setServer(MQTT_HOST, MQTT_PORT);\n\n  connectToMqttTicker.start(); //start the ticker.\n\n  connectToMqtt();\n  \n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n\n  int sec = millis() / 1000;\n  int min = sec / 60;\n  int hr = min / 60;\n  int day = hr / 24;\n\n  snprintf(temp, BUFFER_SIZE - 1,\n           \"<html>\\\n<head>\\\n<meta http-equiv='refresh' content='5'/>\\\n<title>AsyncWebServer-%s</title>\\\n<style>\\\nbody { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088;"
        },
        {
          "name": "drawFavicon",
          "body": "AsyncWebServerResponse *response = request->beginResponse(200, \"image/x-icon\", favicon_ico_gz, favicon_ico_gz_len);\n  \n  response->addHeader(\"Content-Encoding\", \"gzip\");\n  request->send(response);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "drawGraph",
          "body": "String out;\n\n  out.reserve(4000);\n  char temp[80];\n\n  digitalWrite(led, 1);\n  \n  out += \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" width=\\\"310\\\" height=\\\"150\\\">\\n\";\n  out += \"<rect width=\\\"310\\\" height=\\\"150\\\" fill=\\\"rgb(250, 230, 210)\\\" stroke-width=\\\"2\\\" stroke=\\\"rgb(0, 0, 0)\\\" />\\n\";\n  out += \"<g stroke=\\\"blue\\\">\\n\";\n  int y = rand() % 130;\n\n  for (int x = 10; x < 300; x += 10)\n  {\n    int y2 = rand() % 130;\n    sprintf(temp, \"<line x1=\\\"%d\\\" y1=\\\"%d\\\" x2=\\\"%d\\\" y2=\\\"%d\\\" stroke-width=\\\"2\\\" />\\n\", x, 140 - y, x + 10, 140 - y2);\n    out += temp;\n    y = y2;"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer_favicon on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(\"\\nStarting Async_AutoConnectAP using \" + String(FS_Name));\n  Serial.println(\" on \" + String(ARDUINO_BOARD));\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ArduinoJson.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "saveConfigCallback",
          "body": "Serial.println(F(\"Should save config\"));\n  shouldSaveConfig = true;"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(PIN_LED, !digitalRead(PIN_LED));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFSParams using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  \n  static ulong currentMillis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  currentMillis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((currentMillis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = currentMillis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LED_ON);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFSParametersAndCustomIP using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFeedBack using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(PIN_LED, !digitalRead(PIN_LED));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(PIN_LED, OUTPUT);\n  \n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_AutoConnectWithFeedBackLED using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 ) \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnDRD-FS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnDRD-FS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(\"Got stored Credentials. Timeout 120s\");"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "delay",
        "EEPROM",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h",
        "map"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  AsyncWebServer webServer(HTTP_PORT);\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n  \n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr_Complex using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();\n\n  delay(1);"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      70000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n  \n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDRD_FS_MQTT_Ptr_Medium using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset_Multi using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "FS.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS\n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS\n  // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);\n#else\n  // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n  WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n#endif"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n  current_millis = millis();\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(PIN_LED, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnDoubleReset_TZ using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  drd->loop();\n\n  // put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  // initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnStartup using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwitch using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwitch\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwitch\");\n#endif\n\n    ESPAsync_wifiManager.setMinimumSignalQuality(-1);\n\n    // From v1.0.10 only\n    // Set config portal channel, default = 1. Use 0 => random channel from 1-13\n    ESPAsync_wifiManager.setConfigPortalChannel(0);\n    //////\n\n    //set custom ip for portal\n    //ESPAsync_wifiManager.setAPStaticIPConfig(IPAddress(192, 168, 100, 1), IPAddress(192, 168, 100, 1), IPAddress(255, 255, 255, 0));\n\n#if !USE_DHCP_IP    \n  #if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask, dns1IP, dns2IP);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    ESPAsync_wifiManager.setSTAStaticIPConfig(stationIP, gatewayIP, netMask);\n  #endif \n#endif       \n\n  // New from v1.1.1\n#if USING_CORS_FEATURE\n  ESPAsync_wifiManager.setCORSHeader(\"Your Access-Control-Allow-Origin\");\n#endif\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n   \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwichFS using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    AsyncWebServer webServer(HTTP_PORT);\n    AsyncDNSServer dnsServer;\n    \n    ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwitchFS\");\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.println(F(\"Opening configuration portal. \"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n   \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "OneButton.h",
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "publishMQTT",
          "body": "float some_number = 25.0 + (float) ( millis() % 100 ) /  100;\n\n    // For debug only\n    //Serial.print(F(\"Published Temp = \"));\n    //Serial.println(some_number);\n    \n    MQTT_connect();\n\n    if (Temperature->publish(some_number)) \n    {\n      Serial.print(F(\"T\"));        // T means publishing OK"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n  static ulong mqtt_publish_timeout = 0;\n  \n  ulong current_millis = millis();\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n#define PUBLISH_INTERVAL      60000L\n\n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "deleteOldInstances",
          "body": "// Delete previous instances\n  if (mqtt)\n  {\n    delete mqtt;\n    mqtt = NULL;\n    \n    Serial.println(F(\"Deleting old MQTT object\"));"
        },
        {
          "name": "createNewInstances",
          "body": "if (!client)\n  {\n    client = new WiFiClient;\n    \n    Serial.print(F(\"\\nCreating new WiFi client object : \"));\n    Serial.println(client? F(\"OK\") : F(\"failed\"));"
        },
        {
          "name": "handleClick",
          "body": "Serial.println(F(\"\\nButton clicked!\"));\n  wifi_manager();"
        },
        {
          "name": "handleDoubleClick",
          "body": "Serial.println(F(\"\\nButton double clicked!\"));"
        },
        {
          "name": "handleLongPressStop",
          "body": "Serial.println(F(\"\\nLong Button pressed!\"));\n  newConfigData();"
        },
        {
          "name": "wifi_manager",
          "body": "Serial.println(F(\"\\nConfig Portal requested.\"));\n  digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n  //Local intialization. Once its business is done, there is no need to keep it around\n  // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n  //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n  // Use this to personalize DHCP hostname (RFC952 conformed)\n  AsyncWebServer webServer(HTTP_PORT);\n\n#if ( USING_ESP32_S2 || USING_ESP32_C3 )\n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, NULL, \"ConfigOnSwichFS-MQTT\");\n#else\n  AsyncDNSServer dnsServer;\n  \n  ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"ConfigOnSwichFS-MQTT\");\n#endif\n\n  //Check if there is stored WiFi router/password credentials.\n  //If not found, device will remain in configuration mode until switched off via webserver.\n  Serial.print(F(\"Opening Configuration Portal. \"));\n  \n  Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n  Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n  \n  // From v1.1.1, Don't permit NULL password\n  if ( !initialConfig && (Router_SSID != \"\") && (Router_Pass != \"\") )\n  {\n    //If valid AP credential and not DRD, set timeout 120s.\n    ESPAsync_wifiManager.setConfigPortalTimeout(120);\n    Serial.println(F(\"Got stored Credentials. Timeout 120s\"));"
        },
        {
          "name": "newConfigData",
          "body": "Serial.println();\n  Serial.print(F(\"custom_AIO_SERVER: \")); \n  Serial.println(custom_AIO_SERVER);\n  Serial.print(F(\"custom_SERVERPORT: \")); \n  Serial.println(custom_AIO_SERVERPORT);\n  Serial.print(F(\"custom_USERNAME_KEY: \")); \n  Serial.println(custom_AIO_USERNAME);\n  Serial.print(F(\"custom_KEY: \")); \n  Serial.println(custom_AIO_KEY);\n  Serial.println();"
        },
        {
          "name": "MQTT_connect",
          "body": "int8_t ret;\n\n  MQTT_Pub_Topic = String(custom_AIO_USERNAME) + \"/feeds/Temperature\";\n\n  createNewInstances();\n\n  // Return if already connected\n  if (mqtt->connected()) \n  {\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigOnSwichFS_MQTT_Ptr using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// checking button state all the time\n  btn.tick();\n\n  // this is just for checking if we are connected to WiFi\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "FS.h",
        "ArduinoJson.h",
        "esp_wifi.h",
        "WiFi.h",
        "WiFiClient.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "ESP8266WiFi.h",
        "ESPAsyncDNSServer.h",
        "ESP8266WiFiMulti.h",
        "LittleFS.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "// Initialize the LED digital pin as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // Initialize trigger pins\n  pinMode(TRIGGER_PIN, INPUT_PULLUP);\n  pinMode(TRIGGER_PIN2, INPUT_PULLUP);\n  \n  // Put your setup code here, to run once\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ConfigPortalParamsOnSwitch using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// is configuration portal requested?\n  if ((digitalRead(TRIGGER_PIN) == LOW) || (digitalRead(TRIGGER_PIN2) == LOW))\n  {\n    Serial.println(F(\"\\nConfiguration portal requested.\"));\n    digitalWrite(LED_BUILTIN, LED_ON); // turn the LED on by making the voltage LOW to tell us we are in configuration mode.\n\n    //Local intialization. Once its business is done, there is no need to keep it around\n    // Use this to default DHCP hostname to ESP8266-XXXXXX or ESP32-XXXXXX\n    //ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer);\n    // Use this to personalize DHCP hostname (RFC952 conformed)\n    AsyncWebServer webServer(HTTP_PORT);\n    AsyncDNSServer dnsServer;\n  \n    ESPAsync_WiFiManager ESPAsync_wifiManager(&webServer, &dnsServer, \"AsyncCP-ParamsOnSW\");\n\n    //Check if there is stored WiFi router/password credentials.\n    //If not found, device will remain in configuration mode until switched off via webserver.\n    Serial.print(F(\"Opening configuration portal.\"));\n    \n    Router_SSID = ESPAsync_wifiManager.WiFi_SSID();\n    Router_Pass = ESPAsync_wifiManager.WiFi_Pass();\n\n    //Remove this line if you do not want to see WiFi password printed\n    Serial.println(\"ESP Self-Stored: SSID = \" + Router_SSID + \", Pass = \" + Router_Pass);\n    \n    // From v1.1.0, Don't permit NULL password\n    if ( (Router_SSID != \"\") && (Router_Pass != \"\") )\n    {\n      LOGERROR3(F(\"* Add SSID = \"), Router_SSID, F(\", PW = \"), Router_Pass);\n      wifiMulti.addAP(Router_SSID.c_str(), Router_Pass.c_str());\n      \n      ESPAsync_wifiManager.setConfigPortalTimeout(120); //If no access point name has been previously entered disable timeout.\n      Serial.println(F(\"Got ESP Self-Stored Credentials. Timeout 120s for Config Portal\"));"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "ESPmDNS.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP32_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "EEPROM",
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "WiFi.h",
        "WiFiClient.h",
        "ESPmDNS.h",
        "WiFiMulti.h",
        "LittleFS.h",
        "LITTLEFS.h",
        "SPIFFS.h",
        "FFat.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP_DoubleResetDetector.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, F(\", gatewayIP =\"), in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, F(\", dns2IP =\"), in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP32_FSWebServer_DRD using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "delay",
        "digitalWrite",
        "Serial",
        "EEPROM"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "ESPAsyncDNSServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "SPIFFSEditor.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP_FSWebServer using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n\n  if ( String(ESP_ASYNC_WIFIMANAGER_VERSION) < ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET )\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "MDNS.update();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET",
      "keywords": [
        "delay",
        "digitalWrite",
        "Serial",
        "EEPROM"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "WiFiClient.h",
        "ESPAsyncDNSServer.h",
        "ESP8266mDNS.h",
        "ESP8266WiFiMulti.h",
        "FS.h",
        "LittleFS.h",
        "SPIFFSEditor.h",
        "ESP_DoubleResetDetector.h",
        "ESP_WiFiManager.h",
        "ESPAsync_WiFiManager.h",
        "ESPAsync_WiFiManager-Impl.h"
      ],
      "functions": [
        {
          "name": "initAPIPConfigStruct",
          "body": "in_WM_AP_IPconfig._ap_static_ip   = APStaticIP;\n  in_WM_AP_IPconfig._ap_static_gw   = APStaticGW;\n  in_WM_AP_IPconfig._ap_static_sn   = APStaticSN;"
        },
        {
          "name": "initSTAIPConfigStruct",
          "body": "in_WM_STA_IPconfig._sta_static_ip   = stationIP;\n  in_WM_STA_IPconfig._sta_static_gw   = gatewayIP;\n  in_WM_STA_IPconfig._sta_static_sn   = netMask;\n#if USE_CONFIGURABLE_DNS  \n  in_WM_STA_IPconfig._sta_static_dns1 = dns1IP;\n  in_WM_STA_IPconfig._sta_static_dns2 = dns2IP;\n#endif"
        },
        {
          "name": "displayIPConfigStruct",
          "body": "LOGERROR3(F(\"stationIP =\"), in_WM_STA_IPconfig._sta_static_ip, \", gatewayIP =\", in_WM_STA_IPconfig._sta_static_gw);\n  LOGERROR1(F(\"netMask =\"), in_WM_STA_IPconfig._sta_static_sn);\n#if USE_CONFIGURABLE_DNS\n  LOGERROR3(F(\"dns1IP =\"), in_WM_STA_IPconfig._sta_static_dns1, \", dns2IP =\", in_WM_STA_IPconfig._sta_static_dns2);\n#endif"
        },
        {
          "name": "configWiFi",
          "body": "#if USE_CONFIGURABLE_DNS  \n    // Set static IP, Gateway, Subnetmask, DNS1 and DNS2. New in v1.0.5\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn, in_WM_STA_IPconfig._sta_static_dns1, in_WM_STA_IPconfig._sta_static_dns2);  \n  #else\n    // Set static IP, Gateway, Subnetmask, Use auto DNS1 and DNS2.\n    WiFi.config(in_WM_STA_IPconfig._sta_static_ip, in_WM_STA_IPconfig._sta_static_gw, in_WM_STA_IPconfig._sta_static_sn);\n  #endif"
        },
        {
          "name": "toggleLED",
          "body": "//toggle state\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));"
        },
        {
          "name": "printLocalTime",
          "body": "#if ESP8266\n  static time_t now;\n  \n  now = time(nullptr);\n  \n  if ( now > 1451602800 )\n  {\n    Serial.print(\"Local Date/Time: \");\n    Serial.print(ctime(&now));"
        },
        {
          "name": "heartBeatPrint",
          "body": "#if USE_ESP_WIFIMANAGER_NTP\n  printLocalTime();\n#else\n  static int num = 1;\n\n  if (WiFi.status() == WL_CONNECTED)\n    Serial.print(F(\"H\"));        // H means connected to WiFi\n  else\n    Serial.print(F(\"F\"));        // F means not connected to WiFi\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_WiFi",
          "body": "if ( (WiFi.status() != WL_CONNECTED) )\n  {\n    Serial.println(F(\"\\nWiFi lost. Call connectMultiWiFi in loop\"));\n    connectMultiWiFi();"
        },
        {
          "name": "check_status",
          "body": "static ulong checkstatus_timeout  = 0;\n  static ulong LEDstatus_timeout    = 0;\n  static ulong checkwifi_timeout    = 0;\n\n  static ulong current_millis;\n\n#define WIFICHECK_INTERVAL    1000L\n\n#if USE_ESP_WIFIMANAGER_NTP\n  #define HEARTBEAT_INTERVAL    60000L\n#else\n  #define HEARTBEAT_INTERVAL    10000L\n#endif\n\n#define LED_INTERVAL          2000L\n\n\n  current_millis = millis();\n  \n  // Check WiFi every WIFICHECK_INTERVAL (1) seconds.\n  if ((current_millis > checkwifi_timeout) || (checkwifi_timeout == 0))\n  {\n    check_WiFi();\n    checkwifi_timeout = current_millis + WIFICHECK_INTERVAL;"
        },
        {
          "name": "saveConfigData",
          "body": "File file = FileFS.open(CONFIG_FILENAME, \"w\");\n  LOGERROR(F(\"SaveWiFiCfgFile \"));\n\n  if (file)\n  {\n    WM_config.checksum = calcChecksum( (uint8_t*) &WM_config, sizeof(WM_config) - sizeof(WM_config.checksum) );\n    \n    file.write((uint8_t*) &WM_config, sizeof(WM_config));\n\n    displayIPConfigStruct(WM_STA_IPconfig);\n\n    // New in v1.4.0\n    file.write((uint8_t*) &WM_STA_IPconfig, sizeof(WM_STA_IPconfig));\n    //////\n\n    file.close();\n    LOGERROR(F(\"OK\"));"
        },
        {
          "name": "setup",
          "body": "//set led pin as output\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n\n  Serial.print(F(\"\\nStarting Async_ESP_FSWebServer_DRD using \")); Serial.print(FS_Name);\n  Serial.print(F(\" on \")); Serial.println(ARDUINO_BOARD);\n  Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION);\n  Serial.println(ESP_DOUBLE_RESET_DETECTOR_VERSION);\n\n#if defined(ESP_ASYNC_WIFIMANAGER_VERSION_INT)\n  if (ESP_ASYNC_WIFIMANAGER_VERSION_INT < ESP_ASYNC_WIFIMANAGER_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version later than : \");\n    Serial.println(ESP_ASYNC_WIFIMANAGER_VERSION_MIN_TARGET);"
        },
        {
          "name": "loop",
          "body": "// Call the double reset detector loop method every so often,\n  // so that it can recognise when the timeout expires.\n  // You can also call drd.stop() when you wish to no longer\n  // consider the next reset as a double reset.\n  if (drd)\n    drd->loop();\n  \n  MDNS.update();\n\n  check_status();"
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/plain\", String(\"Hello from Async_HelloServer on \") + ARDUINO_BOARD );"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_HelloServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/plain\", String(\"Hello from Async_HelloServer2 on \") + ARDUINO_BOARD );"
        },
        {
          "name": "handleNotFound",
          "body": "String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_HelloServer2 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/plain\", String(\"Hello from AsyncWebServer_STM32 on \") + BOARD_NAME );\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HelloServer2_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/plain\", String(\"Hello from AsyncWebServer_STM32_LAN8720 on \") + BOARD_NAME );\n  digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n\n  message += \"URI: \";\n  //message += server.uri();\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HelloServer_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStart Async_HTTPBasicAuth on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    if (!request->authenticate(www_username, www_password))\n    {\n      return request->requestAuthentication();"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  Serial.print(F(\".\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "loop",
          "body": "check_status();"
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_HTTPBasicAuth_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  //Ethernet.begin(mac[10]);\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    if (!request->authenticate(www_username, www_password))\n    {\n      return request->requestAuthentication();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/html\", postForms);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handlePlain",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleForm",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);;\n\n  Serial.print(F(\"\\nStart Async_PostServer on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "digitalWrite(led, 1);\n  request->send(200, \"text/html\", postForms);\n  digitalWrite(led, 0);"
        },
        {
          "name": "handlePlain",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleForm",
          "body": "if (request->method() != HTTP_POST)\n  {\n    digitalWrite(led, 1);\n    request->send(405, \"text/plain\", \"Method Not Allowed\");\n    digitalWrite(led, 0);"
        },
        {
          "name": "handleNotFound",
          "body": "digitalWrite(led, 1);\n  String message = \"File Not Found\\n\\n\";\n  message += \"URI: \";\n  message += request->url();\n  message += \"\\nMethod: \";\n  message += (request->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  message += \"\\nArguments: \";\n  message += request->args();\n  message += \"\\n\";\n  for (uint8_t i = 0; i < request->args(); i++)\n  {\n    message += \" \" + request->argName(i) + \": \" + request->arg(i) + \"\\n\";"
        },
        {
          "name": "setup",
          "body": "pinMode(led, OUTPUT);\n  digitalWrite(led, 0);\n\n  Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_PostServer_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    handleRoot(request);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_RegexPatterns on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_ENC on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_ENC on \" + String(ARDUINO_BOARD));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W5500.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_W5500 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W5500_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W5500_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W5500_Mac = W5500_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W5500_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_W5500 on \" + String(ARDUINO_BOARD));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_W6100.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(F(\"\\nStart Async_RegexPatterns_ESP32_W6100 on \"));\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_W6100_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI_HOST:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_W6100_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *W6100_Mac = W6100_Default_Mac);\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[millis() % NUMBER_OF_MAC] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_W6100_waitForConnect();\n\n  ///////////////////////////////////\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_ESP32_W6100 on \" + String(ARDUINO_BOARD));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart Async_RegexPatterns_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_STM32 on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_RegexPatterns_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_STM32_LAN8720 on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "ASYNCWEBSERVER_REGEX",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tSerial.print(F(\"\\nStart Async_RegexPatterns_WT32_ETH01 on \"));\n\tSerial.print(BOARD_NAME);\n\tSerial.print(F(\" with \"));\n\tSerial.println(SHIELD_TYPE);\n\tSerial.println(ASYNC_WEBSERVER_WT32_ETH01_VERSION);\n\n\t// To be called before ETH.begin()\n\tWT32_ETH01_onEvent();\n\n\t//bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO,\n\t//           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n\t//ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n\tETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n\t// Static IP, leave without this line to get IP via DHCP\n\t//bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n\tETH.config(myIP, myGW, mySN, myDNS);\n\n\tWT32_ETH01_waitForConnect();\n\n\tserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request)\n\t{\n\t\trequest->send(200, \"text/plain\", \"Hello, world from Async_RegexPatterns_WT32_ETH01 on \" + String(BOARD_NAME));"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_Ethernet.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "initEthernet",
          "body": "SPI.begin();\n  SPI.setClockDivider(SPI_CLOCK_DIV4);\n  SPI.setBitOrder(MSBFIRST);\n  SPI.setDataMode(SPI_MODE0);\n\n#if !USING_DHCP\n  eth.config(localIP, gateway, netMask, gateway);\n#endif\n  \n  eth.setDefault();\n  \n  if (!eth.begin()) \n  {\n    Serial.println(\"No Ethernet hardware ... Stop here\");\n    \n    while (true) \n    {\n      delay(1000);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial && millis() < 5000);\n\n  delay(200);\n\n  Serial.print(\"\\nStart Async_AdvancedWebServer on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ETHERNET_VERSION);\n\n  initEthernet();\n  \n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from \" SHIELD_TYPE);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  Serial.print(\"\\nStart Async_SimpleWebServer_STM32 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from LAN8742A\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNCWEBSERVER_STM32_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "AsyncWebServer_STM32.h"
      ],
      "functions": [
        {
          "name": "notFound",
          "body": "request->send(404, \"text/plain\", \"Not found\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStart Async_SimpleWebServer_STM32_LAN8720 on \"); Serial.print(BOARD_NAME);\n  Serial.print(\" with \"); Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_STM32_VERSION);\n\n#if (_ASYNCWEBSERVER_STM32_LOGLEVEL_ > 2)\n  Serial.print(\"STM32 Core version v\"); Serial.print(STM32_CORE_VERSION_MAJOR);\n  Serial.print(\".\"); Serial.print(STM32_CORE_VERSION_MINOR); \n  Serial.print(\".\"); Serial.println(STM32_CORE_VERSION_PATCH);\n#endif\n\n  // start the ethernet connection and the server\n  // Use random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  // Use DHCP dynamic IP and random mac\n  Ethernet.begin(mac[index]);\n\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) \n  {\n    request->send(200, \"text/plain\", \"Hello, world from LAN8720\");"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_ASYNC_WEBSERVER_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncTCP.h",
        "AsyncWebServer_ESP32_SC_ENC.h"
      ],
      "functions": [
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/html\", webpageCont);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  delay(500);\n\n  Serial.print(\"\\nStarting Async_WebSocketsServer on \");\n  Serial.print(ARDUINO_BOARD);\n  Serial.print(\" with \");\n  Serial.println(SHIELD_TYPE);\n  Serial.println(ASYNC_WEBSERVER_ESP32_SC_ENC_VERSION);\n\n  AWS_LOGWARN(F(\"Default SPI pinout:\"));\n  AWS_LOGWARN1(F(\"SPI Host:\"), ETH_SPI_HOST);\n  AWS_LOGWARN1(F(\"MOSI:\"), MOSI_GPIO);\n  AWS_LOGWARN1(F(\"MISO:\"), MISO_GPIO);\n  AWS_LOGWARN1(F(\"SCK:\"),  SCK_GPIO);\n  AWS_LOGWARN1(F(\"CS:\"),   CS_GPIO);\n  AWS_LOGWARN1(F(\"INT:\"),  INT_GPIO);\n  AWS_LOGWARN1(F(\"SPI Clock (MHz):\"), SPI_CLOCK_MHZ);\n  AWS_LOGWARN(F(\"=========================\"));\n\n  ///////////////////////////////////\n\n  // To be called before ETH.begin()\n  ESP32_ENC_onEvent();\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n\n  //bool begin(int MISO_GPIO, int MOSI_GPIO, int SCLK_GPIO, int CS_GPIO, int INT_GPIO, int SPI_CLOCK_MHZ,\n  //           int SPI_HOST, uint8_t *ENC28J60_Mac = ENC28J60_Default_Mac);\n  //ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST );\n  ETH.begin( MISO_GPIO, MOSI_GPIO, SCK_GPIO, CS_GPIO, INT_GPIO, SPI_CLOCK_MHZ, ETH_SPI_HOST, mac[index] );\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  //ETH.config(myIP, myGW, mySN, myDNS);\n\n  ESP32_ENC_waitForConnect();\n\n  ///////////////////////////////////\n\n  ws.onEvent(onWsEvent);\n  server.addHandler(&ws);\n\n  server.on(\"/\", handleRoot);\n  server.begin();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "_RP2040W_AWS_LOGLEVEL_",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "AsyncWebServer_RP2040W.h"
      ],
      "functions": [
        {
          "name": "onEvent",
          "body": "if (type == WS_EVT_CONNECT)\n\t{\n\t\tSerial.printf(\"ws[Server: %s][ClientID: %u] WSClient connected\\n\", server->url(), client->id());\n\n\t\tglobalClient = client;\n\t\t//client->text(\"Hello from RP2040W Server\");"
        },
        {
          "name": "handleRoot",
          "body": "request->send(200, \"text/html\", webpageCont);"
        },
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n\tSerial.print(\"SSID: \");\n\tSerial.println(WiFi.SSID());\n\n\t// print your board's IP address:\n\tIPAddress ip = WiFi.localIP();\n\tSerial.print(\"Local IP Address: \");\n\tSerial.println(ip);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n\twhile (!Serial && millis() < 5000);\n\n\tdelay(200);\n\n\tSerial.print(\"\\nStarting Async_WebSocketsServer_Xtreme on \");\n\tSerial.println(BOARD_NAME);\n\tSerial.println(ASYNCTCP_RP2040W_VERSION);\n\tSerial.println(ASYNC_WEBSERVER_RP2040W_VERSION);\n\n\t///////////////////////////////////\n\n\t// check for the WiFi module:\n\tif (WiFi.status() == WL_NO_MODULE)\n\t{\n\t\tSerial.println(\"Communication with WiFi module failed!\");\n\n\t\t// don't continue\n\t\twhile (true);"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n\tSerial.print(F(\".\"));\n\n\tif (num == 80)\n\t{\n\t\tSerial.println();\n\t\tnum = 1;"
        },
        {
          "name": "sendStatus",
          "body": "static unsigned long sendStatus_timeout  = 1000;\n\tstatic unsigned long checkstatus_timeout = 1000;\n\n#define STATUS_CHECK_INTERVAL     10000L\n\n#define SEND_INTERVAL             30L\n\n\t// Send status report every SEND_INTERVAL (30) millis\n\tif (millis() > sendStatus_timeout)\n\t{\n\t\t//if (globalClient != NULL && globalClient->status() == WS_CONNECTED)\n\t\t// Sending only when gessage_queue not full\n\t\tif (globalClient != NULL && globalClient->status() == WS_CONNECTED && globalClient->canSend())\n\t\t{\n\t\t\tString POTvalString = String(rand() % 256);\n\n\t\t\tJSONtxt = \"{\\\"POT\\\":\\\"\" + POTvalString + \"\\\""
        },
        {
          "name": "loop",
          "body": "sendStatus();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "seesaw_spectrum.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  \n  while (!Serial) delay(10);   // wait until serial port is opened\n  Serial.println(\"A\");\n  \n  if (!ss.begin()) {\n    Serial.println(\"seesaw not found!\");\n    while(1) delay(10);"
        },
        {
          "name": "loop",
          "body": "ss.getData(); // Pull audio spectrum data from device\n  // Print contents of each of the 64 spectrum bins...\n  for (uint8_t i=0; i<64; i++) {\n    Serial.print(ss.getLevel(i));\n    Serial.write(' ');"
        }
      ]
    },
    {
      "name": "DEBUG_ETHERNET_WEBSERVER_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting Authorization on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();"
        },
        {
          "name": "loop",
          "body": "if (WT32_ETH01_isConnected())\n  {\n    HTTPClient http;\n\n    Serial.print(\"[HTTP] begin...\\n\");\n\n    http.begin(\"http://user:password@192.168.2.112/test.html\");\n\n    /*\n      // or\n      http.begin(\"http://192.168.2.112/test.html\");\n      http.setAuthorization(\"user\", \"password\");\n      // or\n      http.begin(\"http://192.168.2.112/test.html\");\n      http.setAuthorization(\"dXNlcjpwYXN3b3Jk\");\n    */\n\n    Serial.print(\"[HTTP] GET...\\n\");\n    // start connection and send HTTP header\n    int httpCode = http.GET();\n\n    // httpCode will be negative on error\n    if (httpCode > 0) \n    {\n      // HTTP header has been send and Server response header has been handled\n      Serial.printf(\"[HTTP] GET... code: %d\\n\", httpCode);\n\n      // file found at server\n      if (httpCode == HTTP_CODE_OK) \n      {\n        String payload = http.getString();\n        Serial.println(payload);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n    Serial.begin(115200);\n\n    //WiFiManager\n    //Local intialization. Once its business is done, there is no need to keep it around\n    WiFiManager wifiManager;\n    //reset saved settings\n    //wifiManager.resetSettings();\n    \n    //set custom ip for portal\n    //wifiManager.setAPStaticIPConfig(IPAddress(10,0,1,1), IPAddress(10,0,1,1), IPAddress(255,255,255,0));\n\n    //fetches ssid and pass from eeprom and tries to connect\n    //if it does not connect it starts an access point with the specified name\n    //here  \"AutoConnectAP\"\n    //and goes into a blocking loop awaiting configuration\n    wifiManager.autoConnect(\"AutoConnectAP\");\n    //or use this for auto generated name ESP + ChipID\n    //wifiManager.autoConnect();\n\n    \n    //if you get here you have connected to the WiFi\n    Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP    \n    // put your setup code here, to run once:\n    Serial.begin(115200);\n    \n    //reset settings - wipe credentials for testing\n    //wm.resetSettings();\n\n    wm.setConfigPortalBlocking(false);\n    wm.setConfigPortalTimeout(60);\n    //automatically connect using saved credentials if they exist\n    //If connection fails it starts an access point with the specified name\n    if(wm.autoConnect(\"AutoConnectAP\")){\n        Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "body": "wm.process();\n    // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "WiFi.mode(WIFI_STA); // explicitly set mode, esp defaults to STA+AP    \n    // put your setup code here, to run once:\n    Serial.begin(115200);\n    \n    //reset settings - wipe credentials for testing\n    //wm.resetSettings();\n    wm.addParameter(&custom_mqtt_server);\n    wm.setConfigPortalBlocking(false);\n    wm.setSaveParamsCallback(saveParamsCallback);\n\n    //automatically connect using saved credentials if they exist\n    //If connection fails it starts an access point with the specified name\n    if(wm.autoConnect(\"AutoConnectAP\")){\n        Serial.println(\"connected...yeey :)\");"
        },
        {
          "name": "loop",
          "body": "wm.process();\n    // put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //clean FS, for testing\n  //SPIFFS.format();\n\n  //read configuration from FS json\n  Serial.println(\"mounting FS...\");\n\n  if (SPIFFS.begin()) {\n    Serial.println(\"mounted file system\");\n    if (SPIFFS.exists(\"/config.json\")) {\n      //file exists, reading and loading\n      Serial.println(\"reading config file\");\n      File configFile = SPIFFS.open(\"/config.json\", \"r\");\n      if (configFile) {\n        Serial.println(\"opened config file\");\n        size_t size = configFile.size();\n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[size]);\n\n        configFile.readBytes(buf.get(), size);\n        DynamicJsonBuffer jsonBuffer;\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        json.printTo(Serial);\n        if (json.success()) {\n          Serial.println(\"\\nparsed json\");\n\n          strcpy(mqtt_server, json[\"mqtt_server\"]);\n          strcpy(mqtt_port, json[\"mqtt_port\"]);\n          strcpy(blynk_token, json[\"blynk_token\"]);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "ArduinoJson.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //clean FS, for testing\n  //SPIFFS.format();\n\n  //read configuration from FS json\n  Serial.println(\"mounting FS...\");\n\n  if (SPIFFS.begin()) {\n    Serial.println(\"mounted file system\");\n    if (SPIFFS.exists(\"/config.json\")) {\n      //file exists, reading and loading\n      Serial.println(\"reading config file\");\n      File configFile = SPIFFS.open(\"/config.json\", \"r\");\n      if (configFile) {\n        Serial.println(\"opened config file\");\n        size_t size = configFile.size();\n        // Allocate a buffer to store contents of the file.\n        std::unique_ptr<char[]> buf(new char[size]);\n\n        configFile.readBytes(buf.get(), size);\n        DynamicJsonBuffer jsonBuffer;\n        JsonObject& json = jsonBuffer.parseObject(buf.get());\n        json.printTo(Serial);\n        if (json.success()) {\n          Serial.println(\"\\nparsed json\");\n\n          strcpy(mqtt_server, json[\"mqtt_server\"]);\n          strcpy(mqtt_port, json[\"mqtt_port\"]);\n          strcpy(blynk_token, json[\"blynk_token\"]);\n\n          if(json[\"ip\"]) {\n            Serial.println(\"setting custom ip from config\");\n            //static_ip = json[\"ip\"];\n            strcpy(static_ip, json[\"ip\"]);\n            strcpy(static_gw, json[\"gateway\"]);\n            strcpy(static_sn, json[\"subnet\"]);\n            //strcat(static_ip, json[\"ip\"]);\n            //static_gw = json[\"gateway\"];\n            //static_sn = json[\"subnet\"];\n            Serial.println(static_ip);\n/*            Serial.println(\"converting ip\");\n            IPAddress ip = ipFromCharArray(static_ip);\n            Serial.println(ip);*/"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  wifiManager.setAPCallback(configModeCallback);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if(!wifiManager.autoConnect()) {\n    Serial.println(\"failed to connect and hit timeout\");\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h",
        "Ticker.h"
      ],
      "functions": [
        {
          "name": "tick",
          "body": "//toggle state\n  int state = digitalRead(BUILTIN_LED);  // get the current state of GPIO1 pin\n  digitalWrite(BUILTIN_LED, !state);     // set pin to the opposite state"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //set led pin as output\n  pinMode(BUILTIN_LED, OUTPUT);\n  // start ticker with 0.5 because we start in AP mode and try to connect\n  ticker.attach(0.6, tick);\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode\n  wifiManager.setAPCallback(configModeCallback);\n\n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect()) {\n    Serial.println(\"failed to connect and hit timeout\");\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(1000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //exit after config instead of connecting\n  wifiManager.setBreakAfterConfig(true);\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n\n  //tries to connect to last known settings\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\" with password \"password\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect, we should reset as see if it connects\");\n    delay(3000);\n    ESP.reset();\n    delay(5000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "FS.h",
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println();\n\n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //set static ip\n  //block1 should be used for ESP8266 core 2.1.0 or newer, otherwise use block2\n\n  //start-block1\n  //IPAddress _ip,_gw,_sn;\n  //_ip.fromString(static_ip);\n  //_gw.fromString(static_gw);\n  //_sn.fromString(static_sn);\n  //end-block1\n\n  //start-block2\n  IPAddress _ip = IPAddress(10, 0, 1, 78);\n  IPAddress _gw = IPAddress(10, 0, 1, 1);\n  IPAddress _sn = IPAddress(255, 255, 255, 0);\n  //end-block2\n  \n  wifiManager.setSTAStaticIPConfig(_ip, _gw, _sn);\n\n\n  //tries to connect to last known settings\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\" with password \"password\"\n  //and goes into a blocking loop awaiting configuration\n  if (!wifiManager.autoConnect(\"AutoConnectAP\", \"password\")) {\n    Serial.println(\"failed to connect, we should reset as see if it connects\");\n    delay(3000);\n    ESP.reset();\n    delay(5000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ESP8266WiFi.h",
        "DNSServer.h",
        "ESP8266WebServer.h",
        "WiFiManager.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  Serial.begin(115200);\n  \n  //WiFiManager\n  //Local intialization. Once its business is done, there is no need to keep it around\n  WiFiManager wifiManager;\n  //reset settings - for testing\n  //wifiManager.resetSettings();\n\n  //sets timeout until configuration portal gets turned off\n  //useful to make it all retry or go to sleep\n  //in seconds\n  wifiManager.setTimeout(180);\n  \n  //fetches ssid and pass and tries to connect\n  //if it does not connect it starts an access point with the specified name\n  //here  \"AutoConnectAP\"\n  //and goes into a blocking loop awaiting configuration\n  if(!wifiManager.autoConnect(\"AutoConnectAP\")) {\n    Serial.println(\"failed to connect and hit timeout\");\n    delay(3000);\n    //reset and try again, or maybe put it to deep sleep\n    ESP.reset();\n    delay(5000);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "digitalWrite",
        "Serial"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "SPI.begin();\n  pinMode(amisStepPin, OUTPUT);\n  delay(1);\n\n  stepper.init(amisSlaveSelect);\n  stepper.resetSettings();\n  stepper.setCurrentMilliamps(132);\n  stepper.enableDriver();"
        },
        {
          "name": "loop",
          "body": "takeSteps();\n  checkDriver();"
        },
        {
          "name": "takeSteps",
          "body": "// Don't take any steps if there is an issue.\n  if (stepperSettingsProblem || stepperNonLatchedFlags || stepperLatchedFlags)\n  {\n    return;"
        },
        {
          "name": "checkDriver",
          "body": "// Every 20 ms, perform some checks.\n  static uint16_t lastCheckTime = 0;\n  if ((uint16_t)(millis() - lastCheckTime) >= 20)\n  {\n    // Read back the configuration of the driver and make sure it\n    // is correct.\n    if (!stepperSettingsProblem && !stepper.verifySettings())\n    {\n      // We have detected the settings on the driver do not match\n      // the desired settings we chose earlier in this sketch.\n      // It is likely that stepper motor power has been lost or\n      // that communication with the driver is not working.\n      stepperSettingsProblem = true;\n      Serial.println(F(\"Could not verify settings; driver power might be off.\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "your_edge_impulse_inferencing.h",
        "eloquent_esp32cam.h",
        "eloquent_esp32cam/car.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___AUTONOMOUS CAR___\");\n\n    // replace with your board\n    camera.pinout.freenove_s3();\n    camera.brownout.disable();\n    camera.resolution.yolo();\n    camera.pixformat.rgb565();\n\n    // how many millis motors will run\n    // to follow given object\n    fomoCar.defaultDuration(100);\n    fomoCar.stop();\n\n    // if you mounted the camera \"backward\"\n    // (see video), you have to reverse the motors\n    // left.reverse();\n    // right.reverse();\n\n    // init camera\n    while (!camera.begin().isOk())\n        Serial.println(camera.exception.toString());\n\n    Serial.println(\"Camera OK\");\n    Serial.println(\"Put object in front of camera\");"
        },
        {
          "name": "loop",
          "body": "// capture picture\n    if (!camera.capture().isOk()) {\n        Serial.println(camera.exception.toString());\n        return;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "LiquidCrystal.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);"
        },
        {
          "name": "loop",
          "body": "// set the cursor to (0,0):\n  lcd.setCursor(0, 0);\n  // print from 0 to 9:\n  for (int thisChar = 0; thisChar < 10; thisChar++) {\n    lcd.print(thisChar);\n    delay(500);"
        }
      ]
    },
    {
      "name": "Serial",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "fatalBlink",
          "body": "while (true) {\n    if (ERROR_LED_PIN >= 0) {\n      digitalWrite(ERROR_LED_PIN, HIGH);\n      delay(200);\n      digitalWrite(ERROR_LED_PIN, LOW);\n      delay(200);"
        },
        {
          "name": "errorHalt",
          "body": "// Print minimal error data.\n  // sd.errorPrint(&Serial);\n  // Print extended error info - uses extra bytes of flash.\n  sd.printSdError(&Serial);\n  // Try to save data.\n  binFile.close();\n  fatalBlink();"
        },
        {
          "name": "printUnusedStack",
          "body": "Serial.print(F(\"\\nUnused stack: \"));\n  Serial.println(UnusedStack());"
        },
        {
          "name": "dateTime",
          "body": "DateTime now = rtc.now();\n\n  // Return date using FS_DATE macro to format fields.\n  *date = FS_DATE(now.year(), now.month(), now.day());\n\n  // Return time using FS_TIME macro to format fields.\n  *time = FS_TIME(now.hour(), now.minute(), now.second());\n\n  // Return low time bits in units of 10 ms.\n  *ms10 = now.second() & 1 ? 100 : 0;"
        },
        {
          "name": "adcInit",
          "body": "uint8_t adps;  // prescaler bits for ADCSRA\n  uint32_t ticks = F_CPU*SAMPLE_INTERVAL + 0.5;  // Sample interval cpu cycles.\n\n  if (ADC_REF & ~((1 << REFS0) | (1 << REFS1))) {\n    error(\"Invalid ADC reference\");"
        },
        {
          "name": "adcStart",
          "body": "// initialize ISR\n  adcindex = 1;\n  isrBuf = nullptr;\n  isrOver = 0;\n  isrStop = false;\n\n  // Clear any pending interrupt.\n  ADCSRA |= 1 << ADIF;\n\n  // Setup for first pin.\n  ADMUX = adcmux[0];\n  ADCSRB = adcsrb[0];\n  ADCSRA = adcsra[0];\n\n  // Enable timer1 interrupts.\n  timerError = false;\n  timerFlag = false;\n  TCNT1 = 0;\n  TIFR1 = 1 << OCF1B;\n  TIMSK1 = 1 << OCIE1B;"
        },
        {
          "name": "adcStop",
          "body": "TIMSK1 = 0;\n  ADCSRA = 0;"
        },
        {
          "name": "binaryToCsv",
          "body": "uint8_t lastPct = 0;\n  block_t* pd;\n  metadata_t* pm;\n  uint32_t t0 = millis();\n  // Use fast buffered print class.\n  BufferedPrint<file_t, 64> bp(&csvFile);\n  block_t binBuffer[FIFO_DIM];\n\n  assert(sizeof(block_t) == sizeof(metadata_t));\n  binFile.rewind();\n  uint32_t tPct = millis();\n  bool doMeta = true;\n  while (!Serial.available()) {\n    pd = binBuffer;\n    int nb = binFile.read(binBuffer, sizeof(binBuffer));\n    if (nb < 0) {\n      error(\"read binFile failed\");"
        },
        {
          "name": "clearSerialInput",
          "body": "uint32_t m = micros();\n  do {\n    if (Serial.read() >= 0) {\n      m = micros();"
        },
        {
          "name": "createBinFile",
          "body": "binFile.close();\n  while (sd.exists(binName)) {\n    char* p = strchr(binName, '.');\n    if (!p) {\n      error(\"no dot in filename\");"
        },
        {
          "name": "logData",
          "body": "uint32_t t0;\n  uint32_t t1;\n  uint32_t overruns =0;\n  uint32_t count = 0;\n  uint32_t maxLatencyUsec = 0;\n  size_t maxFifoUse = 0;\n  block_t fifoBuffer[FIFO_DIM];\n\n  adcInit((metadata_t*)fifoBuffer);\n  // Write metadata.\n  if (sizeof(metadata_t) != binFile.write(fifoBuffer, sizeof(metadata_t))) {\n    error(\"Write metadata failed\");"
        },
        {
          "name": "openBinFile",
          "body": "char name[NAME_DIM];\n  clearSerialInput();\n  Serial.println(F(\"Enter file name\"));\n  if (!serialReadLine(name, sizeof(name))) {\n    return;"
        },
        {
          "name": "printData",
          "body": "block_t buf;\n  if (!binFile.isOpen()) {\n    Serial.println(F(\"No current binary file\"));\n    return;"
        },
        {
          "name": "setup",
          "body": "if (ERROR_LED_PIN >= 0) {\n    pinMode(ERROR_LED_PIN, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "printUnusedStack();\n  // Read any Serial data.\n  clearSerialInput();\n  Serial.println();\n  Serial.println(F(\"type:\"));\n  Serial.println(F(\"b - open existing bin file\"));\n  Serial.println(F(\"c - convert file to csv\"));\n  Serial.println(F(\"l - list files\"));\n  Serial.println(F(\"p - print data to Serial\"));\n  Serial.println(F(\"r - record ADC data\"));\n\n  while(!Serial.available()) {\n    yield();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "ContinuousStepper.h",
        "ContinuousStepper/Tickers/AnalogWriteFrequency.hpp"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "stepper.begin(/*step=*/2, /*dir=*/3); // ⚠️ step pin must support PWM\n\n  stepper.spin(200);"
        },
        {
          "name": "loop",
          "body": "stepper.loop();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (gsmAccess.status() != GSM_READY || gprs.status() != GPRS_READY) {\n    connectGSM();"
        },
        {
          "name": "connectGSM",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((gsmAccess.begin(pinnumber) != GSM_READY) ||\n         (gprs.attachGPRS(gprs_apn, gprs_login, gprs_password) != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "MKRNB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (nbAccess.status() != NB_READY || gprs.status() != GPRS_READY) {\n    connectNB();"
        },
        {
          "name": "connectNB",
          "body": "Serial.println(\"Attempting to connect to the cellular network\");\n\n  while ((nbAccess.begin(pinnumber) != NB_READY) ||\n         (gprs.attachGPRS() != GPRS_READY)) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(1000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoBearSSL.h",
        "ArduinoECCX08.h",
        "utility/ECCX08SelfSignedCert.h",
        "ArduinoMqttClient.h",
        "WiFiNINA.h",
        "WiFi101.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!ECCX08.begin()) {\n    Serial.println(\"No ECCX08 present!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "if (WiFi.status() != WL_CONNECTED) {\n    connectWiFi();"
        },
        {
          "name": "connectWiFi",
          "body": "Serial.print(\"Attempting to connect to SSID: \");\n  Serial.print(ssid);\n  Serial.print(\" \");\n\n  while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n    // failed, retry\n    Serial.print(\".\");\n    delay(5000);"
        },
        {
          "name": "connectMQTT",
          "body": "Serial.print(\"Attempting to MQTT broker: \");\n  Serial.print(broker);\n  Serial.println(\" \");\n\n  while (!mqttClient.connect(broker, 8883)) {\n    // failed, retry\n    Serial.print(\".\");\n    Serial.println(mqttClient.connectError());\n    delay(5000);"
        },
        {
          "name": "publishMessage",
          "body": "Serial.println(\"Publishing message\");\n\n  // send message, the Print interface can be used to set the message contents\n  mqttClient.beginMessage(\"devices/\" + deviceId + \"/messages/events/\");\n  mqttClient.print(\"hello \");\n  mqttClient.print(millis());\n  mqttClient.endMessage();"
        },
        {
          "name": "onMessageReceived",
          "body": "// we received a message, print out the topic and contents\n  Serial.print(\"Received a message with topic '\");\n  Serial.print(mqttClient.messageTopic());\n  Serial.print(\"', length \");\n  Serial.print(messageSize);\n  Serial.println(\" bytes:\");\n\n  // use the Stream interface to print the contents\n  while (mqttClient.available()) {\n    Serial.print((char)mqttClient.read());"
        }
      ]
    },
    {
      "name": "BLYNK_USE_DIRECT_CONNECT",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BlynkSimpleBLEPeripheral.h",
        "BLEPeripheral.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  SerialBLE.setLocalName(\"Blynk\");\n  SerialBLE.setDeviceName(\"Blynk\");\n  SerialBLE.setAppearance(0x0080);\n  SerialBLE.begin();\n\n  Serial.println(\"Waiting for connections...\");\n\n  Blynk.begin(SerialBLE, auth);"
        },
        {
          "name": "loop",
          "body": "SerialBLE.poll();\n\n  if (SerialBLE) {    // If BLE is connected...\n    Blynk.run();"
        }
      ]
    },
    {
      "name": "BHY_DFU_FW_PATH",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(3000);\n\n  char crc = 0;\n  for (int i = 0; i < fw_bin_len; i++) {\n    crc = crc ^ fw_bin[i];"
        },
        {
          "name": "loop",
          "body": "delay(100);"
        }
      ]
    },
    {
      "name": "BLYNK_PIN_FORCED_CONFIG",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_Blynk on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n  \n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BUTTON_PIN",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite",
        "attachInterrupt"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "emailOnButtonPress",
          "body": "//isButtonPressed = !digitalRead(BUTTON_PIN); // Invert state, since button is \"Active LOW\"\n\n  if ( !isButtonPressed && !digitalRead(BUTTON_PIN)) // You can write any condition to trigger e-mail sending\n  {\n    isButtonPressed = true;\n    count++;\n    Serial.println(\"Button pressed\");"
        },
        {
          "name": "processButton",
          "body": "// *** WARNING: You are limited to send ONLY ONE E-MAIL PER 5 SECONDS! ***\n  // Let's send an e-mail when you press the button\n  // connected to digital pin BUTTON_PIN (2) on your Arduino\n  static String body;\n\n  if (isButtonPressed) // You can write any condition to trigger e-mail sending\n  {\n    body = String(\"You pushed the button \") + count + \" times.\";\n\n    // This can be seen in the Serial Monitor\n    Serial.println(body);\n\n    Blynk.email(\"your_email@gmail.com\", \"Subject: Button Logger\", body);\n\n    isButtonPressed = false;"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_Blynk_Email on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "DHT_PIN",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "DHT.h"
      ],
      "functions": [
        {
          "name": "readAndSendData",
          "body": "float temperature = dht.readTemperature();\n  float humidity    = dht.readHumidity();\n\n  if (Blynk.connected())\n  {\n    if (!isnan(temperature) && !isnan(humidity))\n    {\n      Blynk.virtualWrite(V17, String(temperature, 1));\n      Blynk.virtualWrite(V18, String(humidity, 1));"
        },
        {
          "name": "heartBeatPrint",
          "body": "static int num = 1;\n\n  if (Blynk.connected())\n    Serial.print(F(\"B\"));\n  else\n    Serial.print(F(\"F\"));\n\n  if (num == 80)\n  {\n    Serial.println();\n    num = 1;"
        },
        {
          "name": "check_status",
          "body": "static unsigned long checkstatus_timeout = 0;\n\n#define STATUS_CHECK_INTERVAL     60000L\n\n  // Send status report every STATUS_REPORT_INTERVAL (60) seconds: we don't need to send updates frequently if there is no status change.\n  if ((millis() > checkstatus_timeout) || (checkstatus_timeout == 0))\n  {\n    heartBeatPrint();\n    checkstatus_timeout = millis() + STATUS_CHECK_INTERVAL;"
        },
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(115200);\n  while (!Serial);\n\n  delay(200);\n  \n  Serial.print(F(\"\\nStart BI_Ethernet_WM_Config on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" using \")); Serial.println(SHIELD_TYPE);\n  Serial.println(BLYNK_ETHERNET_STM32_WM_VERSION);\n\n  dht.begin();\n\n#if !(USE_BUILTIN_ETHERNET || USE_UIP_ETHERNET)\n  pinMode(SDCARD_CS, OUTPUT);\n  digitalWrite(SDCARD_CS, HIGH); // Deselect the SD card\n#endif\n\n#if USE_BLYNK_WM\n  Blynk.begin();\n#else\n#if USE_LOCAL_SERVER\n  Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#else\n  Blynk.begin(auth);\n  // You can also specify server:\n  //Blynk.begin(auth, server, BLYNK_HARDWARE_PORT);\n#endif\n#endif\n\n  if (Blynk.connected())\n  {\n#if USE_BLYNK_WM\n    Serial.print(F(\"Conn2Blynk: server = \"));\n    Serial.print(Blynk.getServerName());\n    Serial.print(F(\", port = \"));\n    Serial.println(Blynk.getHWPort());\n    Serial.print(F(\"Token = \"));\n    Serial.println(Blynk.getToken());\n#endif\n    Serial.print(F(\"IP = \"));\n    Serial.println(Ethernet.localIP());"
        },
        {
          "name": "displayCredentials",
          "body": "Serial.println(F(\"\\nYour stored Credentials :\"));\n\n  for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n  {\n    Serial.print(myMenuItems[i].displayName);\n    Serial.print(F(\" = \"));\n    Serial.println(myMenuItems[i].pdata);"
        },
        {
          "name": "loop",
          "body": "Blynk.run();\n  timer.run();\n  check_status();\n\n#if (USE_BLYNK_WM && USE_DYNAMIC_PARAMETERS)\n  static bool displayedCredentials = false;\n\n  if (!displayedCredentials)\n  {\n    for (uint16_t i = 0; i < NUM_MENU_ITEMS; i++)\n    {\n      if (!strlen(myMenuItems[i].pdata))\n      {\n        break;"
        }
      ]
    },
    {
      "name": "BMX_CYCLE",
      "keywords": [
        "Wire",
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "everytime.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set LED as output and turn it off\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  // initialize serial pport\n  Serial.begin(SERIAL_BAUD);\n\n  // Wait for serial port to settle\n  while (!Serial) {\n    delay(10);"
        },
        {
          "name": "loop",
          "body": "// get Temperature\n  every(BMX_CYCLE) {\n    climateSensor.takeForcedMeasurement();\n    Serial.println(\" \");\n\n    // // uncomment this block to print temperature - int32_t\n    // g_temperature = climateSensor.getTemperatureCelsius();\n    // Serial.print(\"Temperature: \");\n    // Serial.print(g_temperature/100);\n    // Serial.print(\".\");\n    // Serial.print(g_temperature%100);\n    // Serial.println(\" °C\");\n\n    // uncomment this block to print temperature - float\n    g_temperatureFloat = climateSensor.getTemperatureCelsiusAsFloat(true);\n    Serial.print(\"Temperature: \");\n    Serial.print(g_temperatureFloat);\n    Serial.println(\" °C\");\n\n    // // uncomment this block to print pressure - uint32_t\n    // g_pressure = climateSensor.getPressure();\n    // Serial.print(\"Pressure: \");\n    // Serial.print(g_pressure/100);\n    // Serial.print(\".\");\n    // Serial.print(g_pressure%100);\n    // Serial.println(\" hPa\");\n\n    // uncomment this block to print pressure - float\n    g_pressureFloat = climateSensor.getPressureAsFloat();\n    Serial.print(\"Pressure: \");\n    Serial.print(g_pressureFloat);\n    Serial.println(\" hPa\");\n\n    // // uncomment this block to print humidity - uint32_t\n    // g_humidity = climateSensor.getRelativeHumidity();\n    // Serial.print(\"Humidity: \");\n    // Serial.print(g_humidity/100);\n    // Serial.print(\".\");\n    // Serial.print(g_humidity%100);\n    // Serial.println(\" %rh\");\n\n    // uncomment this block to print humidity - float\n    g_humidityFloat = climateSensor.getRelativeHumidityAsFloat();\n    Serial.print(\"Humidity: \");\n    Serial.print(g_humidityFloat);\n    Serial.println(\" %rh\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_1000MS);     // Set the standby time to 1 second (1000ms)\n  bmp280.startNormalConversion();                 // Start NORMAL continuous conversion\n  \n  xTaskCreatePinnedToCore(                        // Kick-off \"TaskOne\" pinned to core 1\n    taskOne,\n    \"TaskOne\",\n    10000,\n    NULL,\n    1,\n    NULL,\n    1);"
        },
        {
          "name": "taskOne",
          "body": "while(true)\n  {\n    if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n    {\n      Serial.print(temperature);                    // Display the results    \n      Serial.print(F(\"*C   \"));\n      Serial.print(pressure);    \n      Serial.print(F(\"hPa   \"));\n      Serial.print(altitude);\n      Serial.println(F(\"m\"));"
        },
        {
          "name": "loop",
          "body": "delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin(BMP280_I2C_ALT_ADDR);              // Default initialisation with alternative I2C address (0x76), place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4"
        },
        {
          "name": "loop",
          "body": "bmp280.startForcedConversion();                 // Start BMP280 forced conversion (if we're in SLEEP_MODE)\n  if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4"
        },
        {
          "name": "loop",
          "body": "bmp280.startForcedConversion();                 // Start BMP280 forced conversion (if we're in SLEEP_MODE)\n  if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                           // Initialise the serial port\n  bmp280.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  //bmp280.setPresOversampling(OVERSAMPLING_X4);    // Set the pressure oversampling to X4\n  //bmp280.setTempOversampling(OVERSAMPLING_X1);    // Set the temperature oversampling to X1\n  //bmp280.setIIRFilter(IIR_FILTER_4);              // Set the IIR filter to setting 4\n  bmp280.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(temperature);                    // Display the results    \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "BMP280_DEV.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);                             // Initialise the serial port\n  bmp280_1.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280_1.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280_1.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE \n  bmp280_2.begin();                                 // Default initialisation, place the BMP280 into SLEEP_MODE \n  bmp280_2.setTimeStandby(TIME_STANDBY_2000MS);     // Set the standby time to 2 seconds\n  bmp280_2.startNormalConversion();                 // Start BMP280 continuous conversion in NORMAL_MODE"
        },
        {
          "name": "loop",
          "body": "if (bmp280_1.getMeasurements(temperature, pressure, altitude))    // Check if the measurement is complete\n  {\n    Serial.print(F(\"BMP280_1 \"));                                   // Display the results   \n    Serial.print(temperature);                       \n    Serial.print(F(\"*C   \"));\n    Serial.print(pressure);    \n    Serial.print(F(\"hPa   \"));\n    Serial.print(altitude);\n    Serial.println(F(\"m\"));"
        }
      ]
    },
    {
      "name": "SERIAL_BAUD",
      "keywords": [
        "Wire",
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// set LED as output and turn it off\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  // initialize serial pport\n  Serial.begin(SERIAL_BAUD);\n\n  // Wait for serial port to settle\n  while (!Serial) {\n    delay(10);"
        },
        {
          "name": "loop",
          "body": "// get Temperature\n  delay(2000);\n  climateSensor.takeForcedMeasurement();\n  g_temperature = climateSensor.getTemperatureCelsius();\n  Serial.println(\" \");\n  Serial.print(\"Temperature: \");\n  Serial.print(g_temperature/100);\n  Serial.print(\".\");\n  Serial.print(g_temperature%100);\n  Serial.println(\" °C\");"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin(D2, D3);\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  \n\t//wait for the measurement to finish\n\tdo\n\t{\n\t\tdelay(100);"
        }
      ]
    },
    {
      "name": "PIN_CS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "BMx280SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tSPI.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and chip select pin.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "PIN_CS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "SPI.h",
        "BMx280SPIClass.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tSPI.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and chip select pin.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "AsyncDelay.h",
        "SoftWire.h",
        "BMx280MI.h"
      ],
      "functions": [
        {
          "name": "writeRegister",
          "body": "sw.startWait(address_, SoftWire::writeMode);\n\t\t\tsw.llWrite(reg);\n\t\t\tsw.llWrite(data);\n\t\t\tsw.stop();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\t\n\t//SoftWire setup\n\tsw.setDelay_us(5);\n\tsw.setTimeout_ms(100);\n\tsw.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280TwoWire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "I2C_ADDRESS",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "Wire.h",
        "BMx280MI.h"
      ],
      "functions": [
        {
          "name": "writeRegister",
          "body": "Wire1.beginTransmission(address_);\n\t\t\tWire1.write(reg);\n\t\t\tWire1.write(data);\n\t\t\tWire1.endTransmission();"
        },
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n\tSerial.begin(9600);\n\n\t//wait for serial connection to open (only necessary on some boards)\n\twhile (!Serial);\n\n\tWire1.begin();\n\n\t//begin() checks the Interface, reads the sensor ID (to differentiate between BMP280 and BME280)\n\t//and reads compensation parameters.\n\tif (!bmx280.begin())\n\t{\n\t\tSerial.println(\"begin() failed. check your BMx280 Interface and I2C Address.\");\n\t\twhile (1);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n\n\tdelay(1000);\n\n\t//start a measurement\n\tif (!bmx280.measure())\n\t{\n\t\tSerial.println(\"could not start measurement, is a measurement already running?\");\n\t\treturn;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// debug port\n  Serial.begin(115200);\n  while(!Serial);\n\n  BHY2Host.begin();\n\n  bsec.begin();"
        },
        {
          "name": "loop",
          "body": "static auto printTime = millis();\n  BHY2Host.update();\n\n  if (millis() - printTime >= 1000) {\n    printTime = millis();\n    Serial.println(bsec.toString());"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  BHY2.begin();\n  sensortec.bhy2_bsec2_setConfigString(BSEC2CONFIG, sizeof(BSEC2CONFIG)/sizeof(BSEC2CONFIG[0]));\n  bsec2.begin();"
        },
        {
          "name": "loop",
          "body": "// Update function should be continuously polled\n  BHY2.update(100);\n\n  if (bsec2.getNewDataFlag()) {\n    bsec2.setNewDataFlag(false);\n\n    Serial.println(bsec2.toString());"
        }
      ]
    },
    {
      "name": "CONFIG_BSEC2_USE_DEAULT_HP",
      "keywords": [
        "Serial"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while(!Serial);\n\n  BHY2.begin();\n  sensortec.bhy2_bsec2_setHP((uint8_t*)BSEC2HP_TEMP, sizeof(BSEC2HP_TEMP), (uint8_t*)BSEC2HP_DUR, sizeof(BSEC2HP_DUR)); \n  \n  bsec2Collector.begin();"
        },
        {
          "name": "loop",
          "body": "static auto last_index = 0;\n\n  // Update function should be continuously polled\n  BHY2.update();\n\n  if (last_index != bsec2Collector.gas_index()) {\n    last_index = bsec2Collector.gas_index();\n    Serial.println(String((uint32_t)bsec2Collector.timestamp()) + \" \" \n              + String(bsec2Collector.temperature()) + \" \" \n              + String(bsec2Collector.pressure()) + \" \" \n              + String(bsec2Collector.humidity()) + \" \" \n              + String(bsec2Collector.gas()) + \" \" \n              + String(bsec2Collector.gas_index()) \n              );"
        }
      ]
    },
    {
      "name": "L_EN",
      "keywords": [
        "Serial",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "BTS7960.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);                       //begin the serial monitor for output\n  motor1.begin();                           //This method will set the motor driver pins as output\n  motor1.enable();                          //This method will set the L_EN and R_EN to HIGH or digitalWrite them to +5v/3v depending on your mcu"
        },
        {
          "name": "loop",
          "body": "for(int i=0; i<=255; i=i+10)\n  {\n    motor1.pwm = i;                         //Set the speed, by default the speed is set to 255 you can change it \n    motor1.front();                         //front functions should turn the motor in clockwise direction\n    delay(500);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": ""
        },
        {
          "name": "loop",
          "body": "motorController.Enable();\n\n  for(int speed = 0 ; speed < 255; speed+=10)\n  {\n\tmotorController.TurnLeft(speed);\n\tdelay(100);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "Serial",
        "delay"
      ],
      "libraries": [
        "INA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(GREEN_LED_PIN, OUTPUT);        // Make the internal LED an output pin\n  digitalWrite(GREEN_LED_PIN, true);     // Turn on the LED\n  pinMode(INA_ALERT_PIN, INPUT_PULLUP);  // Declare pin with internal pull-up resistor\n  *digitalPinToPCMSK(INA_ALERT_PIN) |= bit(digitalPinToPCMSKbit(INA_ALERT_PIN));  // Enable PCMSK\n  PCIFR |= bit(digitalPinToPCICRbit(INA_ALERT_PIN));  // clear any outstanding interrupt\n  PCICR |= bit(digitalPinToPCICRbit(INA_ALERT_PIN));  // enable interrupt for the group\n  Serial.begin(SERIAL_SPEED);\n#ifdef __AVR_ATmega32U4__  // If this is a 32U4 processor, wait 2 seconds for initialization\n  delay(2000);\n#endif\n  Serial.print(F(\"\\n\\nBackground INA Read V1.0.5\\n\"));\n  uint8_t devicesFound = 0;\n  while (deviceNumber == UINT8_MAX)  // Loop until we find the first device\n  {\n    devicesFound = INA.begin(1, 100000);  // +/- 1 Amps maximum for 0.1 Ohm resistor\n    for (uint8_t i = 0; i < devicesFound; i++) {\n      /* Change the \"INA226\" in the following statement to whatever device you have attached\n         and want to measure */\n      if (strcmp(INA.getDeviceName(i), \"INA226\") == 0) {\n        deviceNumber = i;\n        INA.reset(deviceNumber);  // Reset device to default settings\n        break;"
        },
        {
          "name": "loop",
          "body": "/*!\n   @brief    Arduino method for the main program loop\n   @details  This is the main program for the Arduino IDE, it is called in an infinite loop. The\n             INA226 measurements are triggered by the interrupt handler each time a conversion is\n             ready and stored in variables. The main program doesn't call any INA library functions,\n             that is done in the interrupt handler. Each time 10 readings have been collected the\n             program will output the averaged values and measurements resume from that point onwards\n   @return   void\n  */\n  static long lastMillis = millis();  // Store the last time we printed something\n  if (readings >= 10) {\n    Serial.print(F(\"Averaging readings taken over \"));\n    Serial.print((float)(millis() - lastMillis) / 1000, 2);\n    Serial.print(F(\" seconds.\\nBus voltage:   \"));\n    Serial.print((float)sumBusMillVolts / readings / 1000.0, 4);\n    Serial.print(F(\"V\\nBus amperage:  \"));\n    Serial.print((float)sumBusMicroAmps / readings / 1000.0, 4);\n    Serial.print(F(\"mA\\n\\n\"));\n    lastMillis = millis();\n    cli();  // Disable interrupts to reset values\n    readings        = 0;\n    sumBusMillVolts = 0;\n    sumBusMicroAmps = 0;\n    sei();  // Enable interrupts again"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "attachInterrupt",
        "Serial",
        "delay"
      ],
      "libraries": [
        "INA.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "/*!\n   @brief    Arduino method called once at startup to initialize the system\n   @details  This is an Arduino IDE method which is called first upon boot or restart. It is only\n             called one time and then control goes to the main \"loop()\" method, from which control\n             never returns\n   @return   void\n  */\n  pinMode(INA_ALERT_PIN, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(INA_ALERT_PIN), InterruptHandler, FALLING);\n  Serial.begin(SERIAL_SPEED);\n  Serial.print(F(\"\\n\\nBackground INA Read V1.0.1\\n\"));\n  uint8_t devicesFound = 0;\n  while (deviceNumber == UINT8_MAX)  // Loop until we find the first device\n  {\n    devicesFound = INA.begin(1, 100000);  // +/- 1 Amps maximum for 0.1 Ohm resistor\n    Serial.println(INA.getDeviceName(devicesFound - 1));\n    for (uint8_t i = 0; i < devicesFound; i++) {\n      /* Change the \"INA226\" in the following statement to whatever device you have attached and\n         want to measure */\n      if (strcmp(INA.getDeviceName(i), \"INA219\") == 0) {\n        deviceNumber = i;\n        INA.reset(deviceNumber);  // Reset device to default settings\n        break;"
        },
        {
          "name": "loop",
          "body": "/*!\n   @brief    Arduino method for the main program loop\n   @details  This is the main program for the Arduino IDE, it is called in an infinite loop. The\n             INA226 measurements are triggered by the interrupt handler each time a conversion is\n             ready and stored in variables. The main program doesn't call any INA library functions,\n             that is done in the interrupt handler. Each time 10 readings have been collected the\n             program will output the averaged values and measurements resume from that point onwards\n   @return   void\n  */\n  static long lastMillis = millis();  // Store the last time we printed something\n  if (readings >= 10) {\n    Serial.print(F(\"Averaging readings taken over \"));\n    Serial.print((float)(millis() - lastMillis) / 1000, 2);\n    Serial.print(F(\" seconds.\\nBus voltage:   \"));\n    Serial.print((float)sumBusMillVolts / readings / 1000.0, 4);\n    Serial.print(F(\"V\\nBus amperage:  \"));\n    Serial.print((float)sumBusMicroAmps / readings / 1000.0, 4);\n    Serial.print(F(\"mA\\n\\n\"));\n    lastMillis = millis();\n    cli();  // Disable interrupts to reset values\n    readings        = 0;\n    sumBusMillVolts = 0;\n    sumBusMicroAmps = 0;\n    sei();  // Enable interrupts again"
        }
      ]
    },
    {
      "name": "USE_SD_H",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SD.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {"
        },
        {
          "name": "loop",
          "body": "// nothing happens after setup"
        }
      ]
    },
    {
      "name": "BUTTON_A_PIN",
      "keywords": [],
      "libraries": [
        "LovyanGFX.hpp"
      ],
      "functions": [
        {
          "name": "create_maze",
          "body": "sp.clear(0);\n  sp.setColor(1);\n  sp.fillRect(0,                0, sp.width(), 16);\n  sp.fillRect(0, sp.height() - 16, sp.width(), 16);\n  sp.fillRect(            0, 0, 16, sp.height()-16);\n  sp.fillRect(sp.width()-16, 0, 16, sp.height()-16);\n  sp.setColor(3);\n  for (int y = 1; y < sp.height(); y += 2)\n  {\n    for (int x = 1; x < sp.width(); x += 2)\n    {\n      sp.writePixel(x, y);\n      int xx = x;\n      int yy = y;\n      do\n      {\n        xx = x;\n        yy = y;\n        switch (random(4)) {\n        case 0: xx = x + 1; break;\n        case 1: xx = x - 1; break;\n        case 2: yy = y + 1; break;\n        case 3: yy = y - 1; break;"
        },
        {
          "name": "draw",
          "body": "draw_count += draw_cycle;\n  std::uint_fast8_t blink = 127+abs(((int)(draw_count<<1) & 255)-128);\n  sp.setPaletteColor(1, 127, 127, blink);\n  sp.setPaletteColor(2, 127, blink, 127);\n\n  float fx = (cx - ox);\n  float fy = (cy - oy);\n  float len = sqrtf(fx * fx + fy * fy) * zoom;\n  float theta = atan2f(fx, fy) + rad;\n  sp.pushRotateZoom(px - sinf(theta) * len, py - cosf(theta) * len, angle, zoom, zoom);"
        },
        {
          "name": "game_init",
          "body": "px = lcd.width()>>1;\n  py = lcd.height()/3;\n\n  create_maze();\n  ox = sp.getPivotX();\n  oy = sp.getPivotY();\n\n  cx = (sp.width() >>1);\n  cy = (sp.height()>>1);\n  cr = 0.2;\n  zoom = zoom_min;"
        },
        {
          "name": "setup",
          "body": "lgfx::lgfxPinMode(BUTTON_A_PIN, lgfx::pin_mode_t::input);\n  lgfx::lgfxPinMode(BUTTON_B_PIN, lgfx::pin_mode_t::input);\n\n  lcd.init();\n  lcd.startWrite();\n  lcd.setColorDepth(16);\n  sp.setColorDepth(2);\n  sp.createSprite(257, 257);\n  game_init();"
        },
        {
          "name": "loop",
          "body": "if (!game_main())\n  {\n    lcd.fillCircle(px, py, roundf(cr*zoom), 0xFFFF00U);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "MKRGSM.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for Leonardo only"
        },
        {
          "name": "loop",
          "body": "// Get current band\n  String bandName = band.getBand(); // Get and print band name\n  Serial.print(\"Current band:\");\n  Serial.println(bandName);\n  Serial.println(\"Want to change the band you’re on?\");\n  String newBandName;\n  newBandName = askUser();\n  // Tell the user what we are about to do…\n  Serial.print(\"\\nConfiguring band \");\n  Serial.println(newBandName);\n  // Change the band\n  bool operationSuccess;\n  operationSuccess = band.setBand(newBandName);\n  // Tell the user if the operation was OK\n  if (operationSuccess) {\n    Serial.println(\"Success\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "analogRead",
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Wire.h",
        "LiquidCrystal_I2C.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  lcd.begin(16, 2);\n  pinMode(btnIncrease, INPUT_PULLUP);\n  pinMode(btnDecrease, INPUT_PULLUP);\n  pinMode(kipas, OUTPUT);\n  pinMode(heater, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "int s = analogRead(A1);\n  float v = (s * 5.0) / 1023.0;\n  float suhu = v * 100.0;\n\n  // Debounce for btnIncrease\n  if (digitalRead(btnIncrease) == LOW && (millis() - lastDebounceTime1) > debounceDelay) {\n    while (digitalRead(btnIncrease) == LOW);\n    sp++;\n    lastDebounceTime1 = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_LPS22HB.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial);\n\n  if (!BARO.begin()) {\n    Serial.println(\"Failed to initialize pressure sensor!\");\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// read the sensor value\n  float pressure = BARO.readPressure();\n\n  // print the sensor value\n  Serial.print(\"Pressure = \");\n  Serial.print(pressure);\n  Serial.println(\" kPa\");\n\n  float temperature = BARO.readTemperature();\n\n  // print the sensor value\n  Serial.print(\"Temperature = \");\n  Serial.print(temperature);\n  Serial.println(\" C\");\n\n  // print an empty line\n  Serial.println();\n\n  // wait 1 second to print again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "Serial",
        "delay"
      ],
      "libraries": [
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n    while (!Serial);\n    myBarometer.init();"
        },
        {
          "name": "loop",
          "body": "temperature = myBarometer.bmp085GetTemperature(\n                      myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n    pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n\n    /*\n        To specify a more accurate altitude, enter the correct mean sea level\n        pressure level.  For example, if the current pressure level is 1019.00 hPa\n        enter 101900 since we include two decimal places in the integer value。\n    */\n    altitude = myBarometer.calcAltitude(101900);\n\n    atm = pressure / 101325;\n\n    Serial.print(\"Temperature: \");\n    Serial.print(temperature, 2); //display 2 decimal places\n    Serial.println(\" Celsius\");\n\n    Serial.print(\"Pressure: \");\n    Serial.print(pressure, 0); //whole number only.\n    Serial.println(\" Pa\");\n\n    Serial.print(\"Ralated Atmosphere: \");\n    Serial.println(atm, 4); //display 4 decimal places\n\n    Serial.print(\"Altitude: \");\n    Serial.print(altitude, 2); //display 2 decimal places\n    Serial.println(\" m\");\n\n    Serial.println();\n\n    delay(1000); //wait a second and get values again."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "digitalWrite"
      ],
      "libraries": [
        "LwIP.h",
        "STM32Ethernet.h",
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// start the SPI library:\n  SPI.begin();\n\n  // start the Ethernet connection and the server:\n  Ethernet.begin(ip);\n  server.begin();\n\n  // initialize the  data ready and chip select pins:\n  pinMode(dataReadyPin, INPUT);\n  pinMode(chipSelectPin, OUTPUT);\n\n  Serial.begin(9600);\n\n  //Configure SCP1000 for low noise configuration:\n  writeRegister(0x02, 0x2D);\n  writeRegister(0x01, 0x03);\n  writeRegister(0x03, 0x02);\n\n  // give the sensor and Ethernet shield time to set up:\n  delay(1000);\n\n  //Set the sensor to high resolution mode tp start readings:\n  writeRegister(0x03, 0x0A);"
        },
        {
          "name": "loop",
          "body": "// check for a reading no more than once a second.\n  if (millis() - lastReadingTime > 1000) {\n    // if there's a reading ready, read it:\n    // don't do anything until the data ready pin is high:\n    if (digitalRead(dataReadyPin) == HIGH) {\n      getData();\n      // timestamp the last time you got a reading:\n      lastReadingTime = millis();"
        },
        {
          "name": "getData",
          "body": "Serial.println(\"Getting reading\");\n  //Read the temperature data\n  int tempData = readRegister(0x21, 2);\n\n  // convert the temperature to celsius and display it:\n  temperature = (float)tempData / 20.0;\n\n  //Read the pressure data highest 3 bits:\n  byte  pressureDataHigh = readRegister(0x1F, 1);\n  pressureDataHigh &= 0b00000111; //you only needs bits 2 to 0\n\n  //Read the pressure data lower 16 bits:\n  unsigned int pressureDataLow = readRegister(0x20, 2);\n  //combine the two parts into one 19-bit number:\n  pressure = ((pressureDataHigh << 16) | pressureDataLow) / 4;\n\n  Serial.print(\"Temperature: \");\n  Serial.print(temperature);\n  Serial.println(\" degrees C\");\n  Serial.print(\"Pressure: \" + String(pressure));\n  Serial.println(\" Pa\");"
        },
        {
          "name": "listenForEthernetClients",
          "body": "// listen for incoming clients\n  EthernetClient client = server.available();\n  if (client) {\n    Serial.println(\"Got a client\");\n    // an http request ends with a blank line\n    bool currentLineIsBlank = true;\n    while (client.connected()) {\n      if (client.available()) {\n        char c = client.read();\n        // if you've gotten to the end of the line (received a newline\n        // character) and the line is blank, the http request has ended,\n        // so you can send a reply\n        if (c == '\\n' && currentLineIsBlank) {\n          // send a standard http response header\n          client.println(\"HTTP/1.1 200 OK\");\n          client.println(\"Content-Type: text/html\");\n          client.println();\n          // print the current readings, in HTML format:\n          client.print(\"Temperature: \");\n          client.print(temperature);\n          client.print(\" degrees C\");\n          client.println(\"<br />\");\n          client.print(\"Pressure: \" + String(pressure));\n          client.print(\" Pa\");\n          client.println(\"<br />\");\n          break;"
        },
        {
          "name": "writeRegister",
          "body": "// SCP1000 expects the register name in the upper 6 bits\n  // of the byte:\n  registerName <<= 2;\n  // command (read or write) goes in the lower two bits:\n  registerName |= 0b00000010; //Write command\n\n  // take the chip select low to select the device:\n  digitalWrite(chipSelectPin, LOW);\n\n  SPI.transfer(registerName); //Send register location\n  SPI.transfer(registerValue); //Send value to record into register\n\n  // take the chip select high to de-select:\n  digitalWrite(chipSelectPin, HIGH);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "SPI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "DATABASE_URL",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(100);\n  Serial.println();\n\n  Serial.print(\"Connecting to Wi-Fi\");\n  int status = WL_IDLE_STATUS;\n  while (status != WL_CONNECTED)\n  {\n    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    Serial.print(\".\");\n    delay(100);"
        },
        {
          "name": "loop",
          "body": ""
        }
      ]
    },
    {
      "name": "SSID_MAX_LEN",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite",
        "analogWrite"
      ],
      "libraries": [
        "EEPROM.h",
        "AsyncTCP.h",
        "ESPAsyncWebServer.h",
        "WiFi.h",
        "PubSubClient.h",
        "ArduinoOTA.h",
        "dynaHTML.h"
      ],
      "functions": [
        {
          "name": "dynaCallback",
          "body": "Serial.println(\"YOUR CALLBACK WORKED!!!!!!!!!!\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyconfigData.wifi_pw);\n    Serial.println(MyconfigData.mqtt_server);\n    Serial.println(MyconfigData.sensorname);\n    Serial.println(MyconfigData.sensorstatus);\n    Serial.println(MyconfigData.mqtt_id);\n    Serial.println(MyconfigData.mqtt_key);\n    Serial.println(MyconfigData.usb_power);\n    saveconfigtoEE(MyconfigData);\n    // if we are updating data, force a refresh of the SSID\n    MyAPdata.crc32 = 8675309; // If your CRC based on your bssid and channel happen to be Jennys number, CALL HER!\n    saveAPEE(MyAPdata);\n    delay(1000);\n    ESP.restart();"
        },
        {
          "name": "OTAinit",
          "body": "// Port defaults to 3232\n    // ArduinoOTA.setPort(3232);\n\n    // Hostname defaults to esp3232-[MAC]\n    ArduinoOTA.setHostname(MyconfigData.sensorname);\n\n    // No authentication by default\n    ArduinoOTA.setPassword(OTA_PASSDW);\n\n    // Password can be set with it's md5 value as well\n    // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3\n    // ArduinoOTA.setPasswordHash(\"21232f297a57a5a743894a0e4a801fc3\");\n\n    ArduinoOTA\n        .onStart([]()\n                 {\n      String type;\n      if (ArduinoOTA.getCommand() == U_FLASH)\n        type = \"sketch\";\n      else // U_SPIFFS\n        type = \"filesystem\";\n\n      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()\n      Serial.println(\"Start updating \" + type);"
        },
        {
          "name": "saveconfigtoEE",
          "body": "EEPROM.put(eepromstart, MyconfigData);\n    JumpStart();\n    boolean ok2 = EEPROM.commit();\n    Serial.println(ok2);"
        },
        {
          "name": "saveAPEE",
          "body": "EEPROM.put(eepromapstart, MyAPData);\n    boolean ok2 = EEPROM.commit();"
        },
        {
          "name": "chkColdStart",
          "body": "EEPROM.get(eepromcoldstart, ColdStart);\n    if (ColdStart.One == 0x45 && ColdStart.Two == 0x72)\n    {\n        hasConfig = true;"
        },
        {
          "name": "JumpStart",
          "body": "ColdStart.One = 0x45;\n    ColdStart.Two = 0x72;\n    EEPROM.put(eepromcoldstart, ColdStart);"
        },
        {
          "name": "setup_wifi",
          "body": "// We start by connecting to a WiFi network\n    WiFi.persistent(true);\n    WiFi.mode(WIFI_STA);\n\n    // delay(200);\n    // WiFi.config(staticIP, subnet, gateway, dns);\n    // WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    if (apValid)\n    {\n        Serial.println(\"Using BSSID data\");\n        // The BSSID data was good, make a quick connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw, MyAPdata.channel, MyAPdata.bssid, true);"
        },
        {
          "name": "reconnect",
          "body": "if (WiFi.status() != WL_CONNECTED)\n    {\n        return;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_CONFIG, OUTPUT);  // Initialize the BUILTIN_LED pin as an output\n    pinMode(GPIO4, INPUT_PULLUP); // If this pin is LOW, then REPROGRAM by setting up the Access Point.\n    Serial.begin(115200);\n    EEPROM.begin(EEPROM_SIZE);\n    delay(10);\n    MyconfigData = getConfigData();\n    delay(10);\n    MyAPdata = getAPData();\n    delay(10);\n    chkColdStart();\n    Serial.println(\"Config/ap data\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyAPdata.crc32);\n\n    if (hasConfig == false or digitalRead(GPIO4) == LOW)\n    {\n        configmode = CONFIG;\n\n        WiFi.mode(WIFI_AP_STA);\n        WiFi.softAP(ssidAP, passwordAP);\n        IPAddress IP = WiFi.softAPIP();\n\n        dHTML.setCallback(dynaCallback);\n        uint16_t tot = dHTML.setMenuItems(mallItem, NUM_MENU_ITEMS);\n\n        server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request)\n                  { dHTML.handleRequest(request);"
        },
        {
          "name": "loop",
          "body": "if (configmode == RUN)\n    {\n        if (!client.connected())\n        {\n            reconnect();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "printWifiStatus",
          "body": "// print the SSID of the network you're attached to:\n  // you're connected now, so print out the data\n  Serial.print(F(\"You're connected to the network, IP = \"));\n  Serial.println(WiFi.localIP());\n\n  Serial.print(F(\"SSID: \"));\n  Serial.print(WiFi.SSID());\n\n  // print the received signal strength:\n  int32_t rssi = WiFi.RSSI();\n  Serial.print(F(\", Signal strength (RSSI):\"));\n  Serial.print(rssi);\n  Serial.println(F(\" dBm\"));"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  while (!Serial && millis() < 5000);\n\n  Serial.print(F(\"\\nStarting BasicAuthGet on \"));\n  Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \"));\n  Serial.println(SHIELD_TYPE);\n  Serial.println(WIFI_WEBSERVER_VERSION);\n\n#if WIFI_USING_ESP_AT\n\n  // initialize serial for ESP module\n  EspSerial.begin(115200);\n  // initialize ESP module\n  WiFi.init(&EspSerial);\n\n  Serial.println(F(\"WiFi shield init done\"));\n\n#endif\n\n#if !(ESP32 || ESP8266)\n\n  // check for the presence of the shield\n#if USE_WIFI_NINA\n\n  if (WiFi.status() == WL_NO_MODULE)\n#else\n  if (WiFi.status() == WL_NO_SHIELD)\n#endif\n  {\n    Serial.println(F(\"WiFi shield not present\"));\n\n    // don't continue\n    while (true);"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"making GET request with HTTP basic authentication\");\n  httpClient.beginRequest();\n  httpClient.get(\"/secure\");\n  httpClient.sendBasicAuth(\"username\", \"password\"); // send the username and password for authentication\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n\n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  delay(2000);\n\n  Serial.print(\"\\nStarting BasicAuthGet_LAN8720 on \" + String(BOARD_NAME));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(ETHERNET_WEBSERVER_STM32_VERSION);\n\n  // start the ethernet connection and the server:\n  // Use DHCP dynamic IP and random mac\n  uint16_t index = millis() % NUMBER_OF_MAC;\n  // Use Static IP\n  //Ethernet.begin(mac[index], ip);\n  Ethernet.begin(mac[index]);\n\n  Serial.print(F(\"Using mac index = \"));\n  Serial.println(index);\n\n  Serial.print(F(\"Connected! IP address: \"));\n  Serial.println(Ethernet.localIP());"
        },
        {
          "name": "loop",
          "body": "Serial.println(\"making GET request with HTTP basic authentication\");\n  httpClient.beginRequest();\n  httpClient.get(\"/secure\");\n  httpClient.sendBasicAuth(\"username\", \"password\"); // send the username and password for authentication\n  httpClient.endRequest();\n\n  // read the status code and body of the response\n  int statusCode = httpClient.responseStatusCode();\n  String response = httpClient.responseBody();\n\n  Serial.print(\"Status code: \");\n  Serial.println(statusCode);\n  Serial.print(\"Response: \");\n  Serial.println(response);\n  \n  Serial.println(\"Wait five seconds\");\n  delay(5000);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n  if (Firebase.ready() && (millis() - sendDataPrevMillis > 15000 || sendDataPrevMillis == 0))\n  {\n    sendDataPrevMillis = millis();\n\n    Serial.printf(\"Set bool... %s\\n\", Firebase.setBool(fbdo, \"/test/bool\", count % 2 == 0) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get bool... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\") ? fbdo.to<bool>() ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    bool bVal;\n    Serial.printf(\"Get bool ref... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\", &bVal) ? bVal ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get int... %s\\n\", Firebase.getInt(fbdo, \"/test/int\") ? String(fbdo.to<int>()).c_str() : fbdo.errorReason().c_str());\n\n    int iVal = 0;\n    Serial.printf(\"Get int ref... %s\\n\", Firebase.getInt(fbdo, \"/test/int\", &iVal) ? String(iVal).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set float... %s\\n\", Firebase.setFloat(fbdo, \"/test/float\", count + 10.2) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get float... %s\\n\", Firebase.getFloat(fbdo, \"/test/float\") ? String(fbdo.to<float>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set double... %s\\n\", Firebase.setDouble(fbdo, \"/test/double\", count + 35.517549723765) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get double... %s\\n\", Firebase.getDouble(fbdo, \"/test/double\") ? String(fbdo.to<double>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set string... %s\\n\", Firebase.setString(fbdo, \"/test/string\", \"Hello World!\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get string... %s\\n\", Firebase.getString(fbdo, \"/test/string\") ? fbdo.to<const char *>() : fbdo.errorReason().c_str());\n\n    // For the usage of FirebaseJson, see examples/FirebaseJson/BasicUsage/Create_Edit_Parse.ino\n    FirebaseJson json;\n\n    if (count == 0)\n    {\n      json.set(\"value/round/\" + String(count), \"cool!\");\n      json.set(\"vaue/ts/.sv\", \"timestamp\");\n      Serial.printf(\"Set json... %s\\n\", Firebase.set(fbdo, \"/test/json\", json) ? \"ok\" : fbdo.errorReason().c_str());"
        }
      ]
    },
    {
      "name": "API_KEY",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "FirebaseESP32.h",
        "addons/TokenHelper.h",
        "addons/RTDBHelper.h"
      ],
      "functions": [
        {
          "name": "WiFiEvent",
          "body": "// Do not run any function here to prevent stack overflow or nested interrupt\n#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)\n\n    switch (event)\n    {\n    case ARDUINO_EVENT_ETH_START:\n        Serial.println(\"ETH Started\");\n        // set eth hostname here\n        ETH.setHostname(\"esp32-ethernet\");\n        break;\n    case ARDUINO_EVENT_ETH_CONNECTED:\n        Serial.println(\"ETH Connected\");\n        break;\n    case ARDUINO_EVENT_ETH_GOT_IP:\n        Serial.print(\"ETH MAC: \");\n        Serial.print(ETH.macAddress());\n        Serial.print(\", IPv4: \");\n        Serial.print(ETH.localIP());\n        if (ETH.fullDuplex())\n        {\n            Serial.print(\", FULL_DUPLEX\");"
        },
        {
          "name": "setupFirebase",
          "body": "if (firebaseConfigReady)\n        return;\n\n    firebaseConfigReady = true;\n\n    // For the following credentials, see examples/Authentications/SignInAsUser/EmailPassword/EmailPassword.ino\n\n    /* Assign the api key (required) */\n    config.api_key = API_KEY;\n\n    /* Assign the user sign in credentials */\n    auth.user.email = USER_EMAIL;\n    auth.user.password = USER_PASSWORD;\n\n    /* Assign the RTDB URL (required) */\n    config.database_url = DATABASE_URL;\n\n    /* Assign the callback function for the long running token generation task */\n    config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h\n\n    // Comment or pass false value when WiFi reconnection will control by your code or third party library e.g. WiFiManager\n    Firebase.reconnectNetwork(true);\n\n    // Since v4.4.x, BearSSL engine was used, the SSL buffer need to be set.\n    // Large data transmission may require larger RX buffer, otherwise connection issue or data read time out can be occurred.\n    fbdo.setBSSLBufferSize(4096 /* Rx buffer size in bytes from 512 - 16384 */, 1024 /* Tx buffer size in bytes from 512 - 16384 */);\n\n    // Or use legacy authenticate method\n    // config.database_url = DATABASE_URL;\n    // config.signer.tokens.legacy_token = \"<database secret>\";\n\n    // To connect without auth in Test Mode, see Authentications/TestMode/TestMode.ino\n\n    Firebase.begin(&config, &auth);"
        },
        {
          "name": "testFirebase",
          "body": "Serial.printf(\"Set bool... %s\\n\", Firebase.setBool(fbdo, \"/test/bool\", count % 2 == 0) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get bool... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\") ? fbdo.to<bool>() ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    bool bVal;\n    Serial.printf(\"Get bool ref... %s\\n\", Firebase.getBool(fbdo, \"/test/bool\", &bVal) ? bVal ? \"true\" : \"false\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set int... %s\\n\", Firebase.setInt(fbdo, \"/test/int\", count) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get int... %s\\n\", Firebase.getInt(fbdo, \"/test/int\") ? String(fbdo.to<int>()).c_str() : fbdo.errorReason().c_str());\n\n    int iVal = 0;\n    Serial.printf(\"Get int ref... %s\\n\", Firebase.getInt(fbdo, \"/test/int\", &iVal) ? String(iVal).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set float... %s\\n\", Firebase.setFloat(fbdo, \"/test/float\", count + 10.2) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get float... %s\\n\", Firebase.getFloat(fbdo, \"/test/float\") ? String(fbdo.to<float>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set double... %s\\n\", Firebase.setDouble(fbdo, \"/test/double\", count + 35.517549723765) ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get double... %s\\n\", Firebase.getDouble(fbdo, \"/test/double\") ? String(fbdo.to<double>()).c_str() : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Set string... %s\\n\", Firebase.setString(fbdo, \"/test/string\", \"Hello World!\") ? \"ok\" : fbdo.errorReason().c_str());\n\n    Serial.printf(\"Get string... %s\\n\", Firebase.getString(fbdo, \"/test/string\") ? fbdo.to<const char *>() : fbdo.errorReason().c_str());\n\n    // For the usage of FirebaseJson, see examples/FirebaseJson/BasicUsage/Create_Edit_Parse.ino\n    FirebaseJson json;\n\n    if (count == 0)\n    {\n        json.set(\"value/round/\" + String(count), \"cool!\");\n        json.set(\"vaue/ts/.sv\", \"timestamp\");\n        Serial.printf(\"Set json... %s\\n\", Firebase.set(fbdo, \"/test/json\", json) ? \"ok\" : fbdo.errorReason().c_str());"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    Serial.println();\n    Serial.printf(\"Firebase Client v%s\\n\\n\", FIREBASE_CLIENT_VERSION);\n    WiFi.onEvent(WiFiEvent);\n    ETH.begin(ETH_ADDR, ETH_POWER_PIN, ETH_MDC_PIN, ETH_MDIO_PIN, ETH_TYPE, ETH_CLK_MODE);"
        },
        {
          "name": "loop",
          "body": "// Firebase.ready() should be called repeatedly to handle authentication tasks.\n\n    if (eth_connected && (millis() - sendDataPrevMillis > 30000 || sendDataPrevMillis == 0))\n    {\n        sendDataPrevMillis = millis();\n        setupFirebase();\n        if (Firebase.ready())\n            testFirebase();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [],
      "libraries": [
        "ContinuousStepper.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// If using a stepper driver, with STEP and DIR pins\n  stepper.begin(/*step=*/2, /*dir=*/3);\n\n  // If using a four-wire stepper:\n  // stepper.begin(8, 10, 9, 11);\n\n  stepper.spin(200);"
        },
        {
          "name": "loop",
          "body": "stepper.loop();"
        }
      ]
    },
    {
      "name": "DEBUG_ETHERNET_WEBSERVER_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting BasicHttpClient on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();"
        },
        {
          "name": "loop",
          "body": "if (WT32_ETH01_isConnected()) \n  {\n    HTTPClient http;\n\n    Serial.print(\"[HTTP] begin...\\n\");\n    // configure traged server and url\n    //http.begin(\"https://www.howsmyssl.com/a/check\", ca); //HTTPS\n    http.begin(\"http://example.com/index.html\"); //HTTP\n\n    Serial.print(\"[HTTP] GET...\\n\");\n    // start connection and send HTTP header\n    int httpCode = http.GET();\n\n    // httpCode will be negative on error\n    if (httpCode > 0) \n    {\n      // HTTP header has been send and Server response header has been handled\n      Serial.printf(\"[HTTP] GET... code: %d\\n\", httpCode);\n\n      // file found at server\n      if (httpCode == HTTP_CODE_OK) \n      {\n        String payload = http.getString();\n        Serial.println(payload);"
        }
      ]
    },
    {
      "name": "DEBUG_ETHERNET_WEBSERVER_PORT",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h",
        "HTTPClient.h",
        "WiFiClientSecure.h"
      ],
      "functions": [
        {
          "name": "setClock",
          "body": "configTime(0, 0, \"pool.ntp.org\");\n\n  Serial.print(F(\"Waiting for NTP time sync: \"));\n  time_t nowSecs = time(nullptr);\n\n  while (nowSecs < 8 * 3600 * 2)\n  {\n    delay(500);\n    Serial.print(F(\".\"));\n    yield();\n    nowSecs = time(nullptr);"
        },
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial);\n\n  // Using this if Serial debugging is not necessary or not using Serial port\n  //while (!Serial && (millis() < 3000));\n\n  Serial.print(\"\\nStarting BasicHttpsClient on \" + String(ARDUINO_BOARD));\n  Serial.println(\" with \" + String(SHIELD_TYPE));\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n\n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n\n  setClock();"
        },
        {
          "name": "loop",
          "body": "if (WT32_ETH01_isConnected())\n  {\n    WiFiClientSecure *client = new WiFiClientSecure;\n\n    if (client) \n    {\n      client -> setCACert(rootCACertificate);\n\n      {\n        // Add a scoping block for HTTPClient https to make sure it is destroyed before WiFiClientSecure *client is\n        HTTPClient https;\n\n        Serial.print(\"[HTTPS] begin...\\n\");\n        if (https.begin(*client, \"https://jigsaw.w3.org/HTTP/connection.html\")) \n        {  \n          // HTTPS\n          Serial.print(\"[HTTPS] GET...\\n\");\n          // start connection and send HTTP header\n          int httpCode = https.GET();\n\n          // httpCode will be negative on error\n          if (httpCode > 0) \n          {\n            // HTTP header has been send and Server response header has been handled\n            Serial.printf(\"[HTTPS] GET... code: %d\\n\", httpCode);\n\n            // file found at server\n            if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) \n            {\n              String payload = https.getString();\n              Serial.println(payload);"
        }
      ]
    },
    {
      "name": "SSID_MAX_LEN",
      "keywords": [
        "EEPROM",
        "Serial",
        "delay",
        "digitalWrite",
        "analogWrite"
      ],
      "libraries": [
        "ESP_EEPROM.h",
        "ESPAsyncTCP.h",
        "ESPAsyncWebServer.h",
        "ESP8266WiFi.h",
        "PubSubClient.h",
        "ArduinoOTA.h",
        "dynaHTML.h"
      ],
      "functions": [
        {
          "name": "dynaCallback",
          "body": "Serial.println(\"YOUR CALLBACK WORKED!!!!!!!!!!\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyconfigData.wifi_pw);\n    Serial.println(MyconfigData.mqtt_server);\n    Serial.println(MyconfigData.sensorname);\n    Serial.println(MyconfigData.sensorstatus);\n    Serial.println(MyconfigData.mqtt_id);\n    Serial.println(MyconfigData.mqtt_key);\n    Serial.println(MyconfigData.usb_power);\n    saveconfigtoEE(MyconfigData);\n    // if we are updating data, force a refresh of the SSID\n    MyAPdata.crc32 = 8675309; // If your CRC based on your bssid and channel happen to be Jennys number, CALL HER!\n    saveAPEE(MyAPdata);\n    delay(1000);\n    ESP.restart();"
        },
        {
          "name": "OTAinit",
          "body": "// Port defaults to 8266\n    ArduinoOTA.setPort(8266);\n\n    // Hostname defaults to esp8266-[ChipID]\n    // ArduinoOTA.setHostname(\"DOOR-FRONT-ESP\");\n    ArduinoOTA.setHostname(MyconfigData.sensorname);\n    // if (DEBUG == false) {\n    //  Comment to: No authentication by default\n    ArduinoOTA.setPassword(OTA_PASSDW);\n    // Password can be set with it's md5 value as well\n    // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3\n    // ArduinoOTA.setPasswordHash(\"21232f297a57a5a743894a0e4a801fc3\");\n    //"
        },
        {
          "name": "saveconfigtoEE",
          "body": "EEPROM.put(eepromstart, MyconfigData);\n    JumpStart();\n    boolean ok2 = EEPROM.commit();\n    Serial.println(ok2);"
        },
        {
          "name": "saveAPEE",
          "body": "EEPROM.put(eepromapstart, MyAPData);\n    boolean ok2 = EEPROM.commit();"
        },
        {
          "name": "chkColdStart",
          "body": "EEPROM.get(eepromcoldstart, ColdStart);\n    if (ColdStart.One == 0x45 && ColdStart.Two == 0x72)\n    {\n        hasConfig = true;"
        },
        {
          "name": "JumpStart",
          "body": "ColdStart.One = 0x45;\n    ColdStart.Two = 0x72;\n    EEPROM.put(eepromcoldstart, ColdStart);"
        },
        {
          "name": "setup_wifi",
          "body": "// We start by connecting to a WiFi network\n    WiFi.persistent(true);\n    WiFi.mode(WIFI_STA);\n    WiFi.forceSleepWake();\n    // delay(200);\n    // WiFi.config(staticIP, subnet, gateway, dns);\n    // WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw);\n    if (apValid)\n    {\n        Serial.println(\"Using BSSID data\");\n        // The BSSID data was good, make a quick connection\n        WiFi.begin(MyconfigData.wifi_ssid, MyconfigData.wifi_pw, MyAPdata.channel, MyAPdata.bssid, true);"
        },
        {
          "name": "reconnect",
          "body": "if (WiFi.status() != WL_CONNECTED)\n    {\n        return;"
        },
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT); // Initialize the BUILTIN_LED pin as an output\n    pinMode(GPIO4, INPUT_PULLUP); // If this pin is LOW, then REPROGRAM by setting up the Access Point.\n    Serial.begin(115200);\n    EEPROM.begin(EEPROM_SIZE);\n    delay(10);\n    MyconfigData = getConfigData();\n    delay(10);\n    MyAPdata = getAPData();\n    delay(10);\n    chkColdStart();\n    Serial.println(\"Config/ap data\");\n    Serial.println(MyconfigData.wifi_ssid);\n    Serial.println(MyAPdata.crc32);\n\n    if (hasConfig == false or digitalRead(GPIO4) == LOW)\n    {\n        configmode = CONFIG;\n\n        WiFi.mode(WIFI_AP_STA);\n        WiFi.softAP(ssidAP, passwordAP);\n        IPAddress IP = WiFi.softAPIP();\n\n        dHTML.setCallback(dynaCallback);\n        uint16_t tot = dHTML.setMenuItems(mallItem, NUM_MENU_ITEMS);\n\n        server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request)\n                  { dHTML.handleRequest(request);"
        },
        {
          "name": "loop",
          "body": "if (configmode == RUN)\n    {\n        if (!client.connected())\n        {\n            reconnect();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "SPI.h",
        "AMIS30543.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "SPI.begin();\n  stepper.init(amisSlaveSelect);\n\n  // Drive the NXT/STEP and DIR pins low initially.\n  digitalWrite(amisStepPin, LOW);\n  pinMode(amisStepPin, OUTPUT);\n  digitalWrite(amisDirPin, LOW);\n  pinMode(amisDirPin, OUTPUT);\n\n  // Give the driver some time to power up.\n  delay(1);\n\n  // Reset the driver to its default settings.\n  stepper.resetSettings();\n\n  // Set the current limit.  You should change the number here to\n  // an appropriate value for your particular system.\n  stepper.setCurrentMilliamps(132);\n\n  // Set the number of microsteps that correspond to one full step.\n  stepper.setStepMode(32);\n\n  // Enable the motor outputs.\n  stepper.enableDriver();"
        },
        {
          "name": "loop",
          "body": "// Step in the default direction 1000 times.\n  setDirection(0);\n  for (unsigned int x = 0; x < 1000; x++)\n  {\n    step();"
        },
        {
          "name": "step",
          "body": "// The NXT/STEP minimum high pulse width is 2 microseconds.\n  digitalWrite(amisStepPin, HIGH);\n  delayMicroseconds(3);\n  digitalWrite(amisStepPin, LOW);\n  delayMicroseconds(3);\n\n  // The delay here controls the stepper motor's speed.  You can\n  // increase the delay to make the stepper motor go slower.  If\n  // you decrease the delay, the stepper motor will go fast, but\n  // there is a limit to how fast it can go before it starts\n  // missing steps.\n  delayMicroseconds(2000);"
        },
        {
          "name": "setDirection",
          "body": "// The NXT/STEP pin must not change for at least 0.5\n  // microseconds before and after changing the DIR pin.\n  delayMicroseconds(1);\n  digitalWrite(amisDirPin, dir);\n  delayMicroseconds(1);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Adafruit_SleepyDog.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  while (!Serial)\n    delay(10);\n  // wait for Arduino Serial Monitor (native USB boards)\n\n  Serial.println(\"Adafruit Watchdog Library Demo!\");\n  Serial.println();\n\n  // First a normal example of using the watchdog timer.\n  // Enable the watchdog by calling Watchdog.enable() as below.\n  // This will turn on the watchdog timer with a ~4 second timeout\n  // before reseting the Arduino. The estimated actual milliseconds\n  // before reset (in milliseconds) is returned.\n  // Make sure to reset the watchdog before the countdown expires or\n  // the Arduino will reset!\n  int countdownMS = Watchdog.enable(4000);\n  Serial.print(\"Enabled the watchdog with max countdown of \");\n  Serial.print(countdownMS, DEC);\n  Serial.println(\" milliseconds!\");\n  Serial.println();\n\n  // Now loop a few times and periodically reset the watchdog.\n  Serial.println(\"Looping ten times while resetting the watchdog...\");\n  for (int i = 1; i <= 10; ++i) {\n    Serial.print(\"Loop #\");\n    Serial.println(i, DEC);\n    delay(1000);\n    // Reset watchdog with every loop to make sure the sketch keeps running.\n    // If you comment out this call watch what happens in about 4 iterations!\n    Watchdog.reset();"
        },
        {
          "name": "loop",
          "body": "// We'll never actually get to the loop because the watchdog will reset in\n  // the setup function.\n  Serial.println(\"You shouldn't see this message.\");\n  delay(1000);"
        }
      ]
    },
    {
      "name": "BLYNK_TEMPLATE_ID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// Debug console\n  Serial.begin(9600);\n\n  // Set ESP8266 baud rate\n  EspSerial.begin(ESP8266_BAUD);\n  delay(10);\n\n  //Connect to Blynk\n  DBlynk.begin(tempID, deviceName, auth, ssid, pass);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  DBlynk.run();\n  \n  //Set counter index to virtual pin V0 \n  DBlynk.virtualWrite(V0, gsCounter_Index);\n\n  gsCounter_Index++;\n  if(gsCounter_Index > 100) //if counter index more than 100, reset to 0\n  {\n    gsCounter_Index = 0;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "MIDI.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "pinMode(LED_BUILTIN, OUTPUT);\n    MIDI.begin(4);                      // Launch MIDI and listen to channel 4"
        },
        {
          "name": "loop",
          "body": "if (MIDI.read())                    // If we have received a message\n    {\n        digitalWrite(LED_BUILTIN, HIGH);\n        MIDI.sendNoteOn(42, 127, 1);    // Send a Note (pitch 42, velo 127 on channel 1)\n        delay(1000);\t\t            // Wait for a second\n        MIDI.sendNoteOff(42, 0, 1);     // Stop the note\n        digitalWrite(LED_BUILTIN, LOW);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && !taskCompleted)\n    {\n        taskCompleted = true;\n\n        Serial.println(\"Get multiple documents...\");\n\n        BatchGetDocumentOptions options;\n        options.documents(\"info/countries\");\n        options.documents(\"a0/b0\");\n        options.documents(\"test_collection/test_document\");\n        options.mask(DocumentMask(\"Singapore.population,key1\"));\n\n        // You can set the content of options object directly with options.setContent(\"your content\")\n\n        String payload = Docs.batchGet(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), options);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino.h",
        "WiFi.h",
        "ESP8266WiFi.h",
        "WiFiNINA.h",
        "WiFi101.h",
        "WiFiS3.h",
        "WiFiC3.h",
        "WiFi.h",
        "FirebaseClient.h",
        "WiFiClientSecure.h",
        "WiFiSSLClient.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    Serial.print(\"Connecting to Wi-Fi\");\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        Serial.print(\".\");\n        delay(300);"
        },
        {
          "name": "loop",
          "body": "authHandler();\n\n    Docs.loop();\n\n    if (app.ready() && (millis() - dataMillis > 60000 || dataMillis == 0))\n    {\n        dataMillis = millis();\n        counter++;\n\n        Serial.println(\"Batch write documents... \");\n\n        String documentPath = \"test_collection/test_document_map_value\";\n\n        Values::MapValue mapV(\"name\", Values::StringValue(\"value\" + String(counter)));\n        mapV.add(\"count\", Values::StringValue(String(counter)));\n\n        Values::MapValue mapV2(\"key\" + String(counter), mapV);\n\n        Document<Values::Value> updateDoc;\n        updateDoc.setName(documentPath);\n        updateDoc.add(\"myMap\", Values::Value(mapV2));\n\n        Values::MapValue labels;\n\n        Writes writes(Write(DocumentMask(\"myMap.key\" + String(counter)) /* updateMask */, updateDoc, Precondition() /* currentDocument precondition */), Values::MapValue() /* Labels */);\n\n        String documentPath2 = \"test_collection/test_document_timestamp\";\n        String fieldPath = \"myTime\";\n        FieldTransform::SetToServerValue setValue(FieldTransform::REQUEST_TIME);\n        FieldTransform::FieldTransform fieldTransforms(fieldPath, setValue);\n        DocumentTransform transform(documentPath2, fieldTransforms);\n\n        writes.add(Write(transform, Precondition() /* currentDocument precondition */));\n\n        // Serial.println(writes);\n\n        // All Writes, DocumentTransform and Values::xxxx objects can be printed on Serial port\n\n        // You can set the content of write and writes objects directly with write.setContent(\"your content\") and writes.setContent(\"your content\")\n\n        String payload = Docs.batchWrite(aClient, Firestore::Parent(FIREBASE_PROJECT_ID), writes);\n\n        if (aClient.lastError().code() == 0)\n            Serial.println(payload);\n        else\n            printError(aClient.lastError().code(), aClient.lastError().message());"
        },
        {
          "name": "authHandler",
          "body": "// Blocking authentication handler with timeout\n    unsigned long ms = millis();\n    while (app.isInitialized() && !app.ready() && millis() - ms < 120 * 1000)\n    {\n        // The JWT token processor required for ServiceAuth and CustomAuth authentications.\n        // JWT is a static object of JWTClass and it's not thread safe.\n        // In multi-threaded operations (multi-FirebaseApp), you have to define JWTClass for each FirebaseApp,\n        // and set it to the FirebaseApp via FirebaseApp::setJWTProcessor(<JWTClass>), before calling initializeApp.\n        JWT.loop(app.getAuth());\n        printResult(aResult_no_callback);"
        },
        {
          "name": "timeStatusCB",
          "body": "#if defined(ESP8266) || defined(ESP32) || defined(CORE_ARDUINO_PICO)\n    if (time(nullptr) < FIREBASE_DEFAULT_TS)\n    {\n\n        configTime(3 * 3600, 0, \"pool.ntp.org\");\n        while (time(nullptr) < FIREBASE_DEFAULT_TS)\n        {\n            delay(100);"
        },
        {
          "name": "printResult",
          "body": "if (aResult.isEvent())\n    {\n        Firebase.printf(\"Event task: %s, msg: %s, code: %d\\n\", aResult.uid().c_str(), aResult.appEvent().message().c_str(), aResult.appEvent().code());"
        },
        {
          "name": "printError",
          "body": "Firebase.printf(\"Error, msg: %s, code: %d\\n\", msg.c_str(), code);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Arduino_PMIC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "// Enable the Charger\n  if (!PMIC.enableCharge()) {\n    Serial.println(\"Error enabling Charge mode\");"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "attachInterrupt",
        "delay"
      ],
      "libraries": [
        "Arduino_PMIC.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only"
        },
        {
          "name": "loop",
          "body": "if (millis() - time_last_interrupt > 100) {\n    // Enable the Charger\n    if (!PMIC.enableCharge()) {\n      Serial.println(\"Error enabling Charge mode\");"
        },
        {
          "name": "batteryConnected",
          "body": "time_last_interrupt = millis();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "digitalWrite",
        "analogRead"
      ],
      "libraries": [
        "ArduinoBLE.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);    // initialize serial communication\n  while (!Serial);\n\n  pinMode(LED_BUILTIN, OUTPUT); // initialize the built-in LED pin to indicate when a central is connected\n\n  // begin initialization\n  if (!BLE.begin()) {\n    Serial.println(\"starting BLE failed!\");\n\n    while (1);"
        },
        {
          "name": "loop",
          "body": "// wait for a Bluetooth® Low Energy central\n  BLEDevice central = BLE.central();\n\n  // if a central is connected to the peripheral:\n  if (central) {\n    Serial.print(\"Connected to central: \");\n    // print the central's BT address:\n    Serial.println(central.address());\n    // turn on the LED to indicate the connection:\n    digitalWrite(LED_BUILTIN, HIGH);\n\n    // check the battery level every 200ms\n    // while the central is connected:\n    while (central.connected()) {\n      long currentMillis = millis();\n      // if 200ms have passed, check the battery level:\n      if (currentMillis - previousMillis >= 200) {\n        previousMillis = currentMillis;\n        updateBatteryLevel();"
        },
        {
          "name": "updateBatteryLevel",
          "body": "/* Read the current voltage level on the A0 analog input pin.\n     This is used here to simulate the charge level of a battery.\n  */\n  int battery = analogRead(A0);\n  int batteryLevel = map(battery, 0, 1023, 0, 100);\n\n  if (batteryLevel != oldBatteryLevel) {      // if the battery level has changed\n    Serial.print(\"Battery Level % is now: \"); // print it\n    Serial.println(batteryLevel);\n    batteryLevelChar.writeValue(batteryLevel);  // and update the battery level characteristic\n    oldBatteryLevel = batteryLevel;           // save the level for next comparison"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay",
        "Wire"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n\n    const uint32_t startNow { millis() + 2500"
        },
        {
          "name": "loop",
          "body": "if (millis() > printNow) {\n        auto vbat = Power.getVBat();\n        Serial.print(\"Battery Voltage: \");\n        Serial.println(vbat);\n\n        auto solarStatus = Power.getSolarChargerStatus();\n        Serial.print(\"Solar Panel Charger Status: \");\n        Serial.println(solarStatus ? \"OK\" : \"Error\");\n\n        auto fiveVoltsStatus = Power.get5VoltStatus();\n        Serial.print(\"5V Power Rail Status: \");\n        Serial.println(fiveVoltsStatus ? \"OK\" : \"Error\");\n\n        printNow = millis() + printInterval;"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "ArduinoMotorCarrier.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(115200);\n  //while (!Serial);\n\n  if (controller.begin())\n  {\n    Serial.print(\"Nano Motor Shield connected, firmware version \");\n    Serial.println(controller.getFWVersion());"
        },
        {
          "name": "loop",
          "body": "batteryVoltage = battery.getRaw()/236.0;\n  Serial.print(\"Battery voltage: \");\n  Serial.print(batteryVoltage,3);\n  //Serial.println(\"V\");\n  Serial.print(\"V, Raw \");\n  Serial.println(battery.getRaw());\n  delay(5000); //wait for a few seconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Wire",
        "delay"
      ],
      "libraries": [
        "ArduinoRobot.h",
        "Wire.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize the robot\n  Robot.begin();\n\n  // initialize the sound speaker\n  Robot.beginSpeaker();"
        },
        {
          "name": "loop",
          "body": "Robot.beep(BEEP_SIMPLE);\n  delay(1000);\n  Robot.beep(BEEP_DOUBLE);\n  delay(1000);\n  Robot.beep(BEEP_LONG);\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "RadioLib.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n\n  // initialize SX1278 with default settings\n  Serial.print(F(\"[SX1278] Initializing ... \"));\n  int state = radio.beginFSK();\n\n  // when using one of the non-LoRa modules for AFSK\n  // (RF69, CC1101, Si4432 etc.), use the basic begin() method\n  // int state = radio.begin();\n\n  if(state == RADIOLIB_ERR_NONE) {\n    Serial.println(F(\"success!\"));"
        },
        {
          "name": "loop",
          "body": "Serial.print(F(\"[Bell 202] Sending data ... \"));\n\n  // send out idle condition for 500 ms\n  bell.idle();\n  delay(500);\n\n  // BellClient supports all methods of the Serial class\n\n  // Arduino String class\n  String aStr = \"Arduino String\";\n  bell.println(aStr);\n\n  // character array (C-String)\n  bell.println(\"C-String\");\n\n  // string saved in flash\n  bell.println(F(\"Flash String\"));\n\n  // character\n  bell.println('c');\n\n  // byte\n  // formatting DEC/HEX/OCT/BIN is supported for\n  // any integer type (byte/int/long)\n  bell.println(255, HEX);\n\n  // integer number\n  int i = 1000;\n  bell.println(i);\n\n  // floating point number\n  float f = -3.1415;\n  bell.println(f, 3);\n\n  // ITA2-encoded string\n  ITA2String str(\"HELLO WORLD!\");\n  bell.print(str);\n\n  // turn the transmitter off\n  bell.standby();\n\n  Serial.println(F(\"done!\"));\n\n  // wait for a second before transmitting again\n  delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "MIDI.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "handleNoteOn",
          "body": "gTime_stop = micros();\n\n    const unsigned long diff = gTime_stop - gTime_start;\n    gTime_sum += diff;\n\n    if (diff > gTime_max) gTime_max = diff;\n    if (diff < gTime_min) gTime_min = diff;\n\n    if (gCounter++ >= 1000)\n    {\n        const unsigned long average = gTime_sum / (float)gCounter;\n\n        Serial.println(\"Time to receive NoteOn: \");\n\n        Serial.print(\"Average: \");\n        Serial.print(average);\n        Serial.println(\" microsecs\");\n\n        Serial.print(\"Min:     \");\n        Serial.print(gTime_min);\n        Serial.println(\" microsecs\");\n\n        Serial.print(\"Max:     \");\n        Serial.print(gTime_max);\n        Serial.println(\" microsecs\");\n\n        gCounter = 0;\n        gTime_sum = 0;\n        gTime_max = 0;\n        gTime_min = -1;\n\n        midiBench.turnThruOff();"
        },
        {
          "name": "setup",
          "body": "midiBench.setHandleNoteOn(handleNoteOn);\n    midiBench.begin();\n\n    Serial.begin(115200);\n    while(!Serial);\n    Serial.println(\"Arduino Ready\");\n\n    midiBench.sendNoteOn(69,127,1);"
        },
        {
          "name": "loop",
          "body": "gTime_start = micros();\n    midiBench.read();"
        }
      ]
    },
    {
      "name": "WIFI_SSID",
      "keywords": [
        "digitalWrite",
        "delay",
        "analogRead"
      ],
      "libraries": [
        "ObloqAdafruit.h",
        "SoftwareSerial.h"
      ],
      "functions": [
        {
          "name": "mensajeRecibido",
          "body": "if(topic==\"lampara\"){\n      if(mensaje==\"ON\"){\n        digitalWrite(13,1);"
        },
        {
          "name": "setup",
          "body": "softSerial.begin(9600);\n    olq.setMsgHandle(mensajeRecibido);\n    olq.subscribe(\"lampara\");"
        },
        {
          "name": "loop",
          "body": "olq.update();\n\n    // no usar delay!, chequear el tiempo transcurrido con millis()\n    if(millis() - millisAnterior > 5000)\n    {\n        olq.publish(\"temperatura\", analogRead(A0));\n        millisAnterior =  millis();"
        }
      ]
    },
    {
      "name": "BREATH_THRESHOLD",
      "keywords": [
        "delay",
        "Serial"
      ],
      "libraries": [
        "Adafruit_CircuitPlayground.h"
      ],
      "functions": [
        {
          "name": "playNote",
          "body": "// Check if the slide switch is off or the candles have been blown out\n  // and stop immediately without playing anything.\n  if (!CircuitPlayground.slideSwitch() || lit < 0) {\n    return;"
        },
        {
          "name": "waitBreath",
          "body": "float peakToPeak = measurePeak(milliseconds);\n  // Serial.println(peakToPeak);\n  while (peakToPeak >= BREATH_THRESHOLD) {\n    // Decrement the number of lit candles and keep it from going below\n    // the value -1 (a sentinel that indicates all the candles are blown out\n    // and no music playback, etc. should occur anymore).\n    lit = max(lit-1, -1);\n    // For the simple solid color animation (i.e. no flickering) only update\n    // the pixels when the lit pixel count changes.  This allows the tone\n    // playback to sound better because the pixels don't need to be updated\n    // during delays and music note playback (the pixel writing messes with\n    // interrupts that drive tone playback and cause scratchier sounding tones).\n    if (animation == SOLID) {\n      showLitSolid();"
        },
        {
          "name": "celebrateSong",
          "body": "// Play a little charge melody, from:\n  //  https://en.wikipedia.org/wiki/Charge_(fanfare)\n  // Note the explicit boolean parameters in particular the measure=false\n  // at the end.  This means the notes will play without any breath measurement\n  // logic.  Without this false value playNote will try to keep waiting for candles\n  // to blow out during the celebration song!\n  playNote(NOTE_G4, EIGHTH_TRIPLE, true, false);\n  playNote(NOTE_C5, EIGHTH_TRIPLE, true, false);\n  playNote(NOTE_E5, EIGHTH_TRIPLE, false, false);\n  playNote(NOTE_G5, EIGHTH, true, false);\n  playNote(NOTE_E5, SIXTEENTH, false);\n  playNote(NOTE_G5, HALF, false);"
        },
        {
          "name": "animatePixels",
          "body": "switch (animation) {\n    case FLICKER:\n      showLitFlicker(current);\n      break;\n    case RAINBOW:\n      showLitRainbow(current);\n      break;\n    // Ignore the SOLID case as it has no animation.\n    // This makes the audio smoother since it doesn't get interrupted by\n    // NeoPixel writing like the other animations.  The pixels are instead\n    // changed only once when the number of lit candles changes (see the\n    // waitBreath function's loop).\n    default: break;"
        },
        {
          "name": "setPixelHSV",
          "body": "// Convert HSV to RGB\n  float r, g, b = 0.0;\n  HSVtoRGB(&r, &g, &b, h, s, v);\n  // Lookup gamma correct RGB colors (also convert from 0...1.0 RGB range to 0...255 byte range).\n  uint8_t r1 = pgm_read_byte(&gamma8[int(r*255.0)]);\n  uint8_t g1 = pgm_read_byte(&gamma8[int(g*255.0)]);\n  uint8_t b1 = pgm_read_byte(&gamma8[int(b*255.0)]);\n  // Set the color of the pixel.\n  CircuitPlayground.strip.setPixelColor(i, r1, g1, b1);"
        },
        {
          "name": "showLitRainbow",
          "body": "// Convert time from milliseconds to seconds.\n  float t = current/1000.0;\n  // Loop through each pixel and compute its color.\n  for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit, so compute its hue from the sine wave\n      // equation and set the color accordingly.  Notice the frequency\n      // is scaled down by 10 to 'slow down' the rainbow flicker animation.\n      // This lets the same random frequencies be shared between fast candle\n      // flame effects and this slower rainbow flicker effect.\n      float x  = sin(2.0*PI*frequencies[i]/10.0*t + phases[i]);\n      // Interpolate the sine wave between all 360 degree hue values.\n      float h = lerp(x, -1.0, 1.0, 0.0, 360.0);\n      setPixelHSV(i, h, 1.0, 1.0);"
        },
        {
          "name": "showLitFlicker",
          "body": "// First determine the low and high bounds of the flicker hues.\n  // These are +/- 10 degrees of the specified target hue and will\n  // wrap around to the start/end as appropriate.\n  float lowHue = fmod(FLAME_HUE - 10.0, 360.0);\n  float highHue = fmod(FLAME_HUE + 10.0, 360.0);\n  // Convert time from milliseconds to seconds.\n  float t = current/1000.0;\n  // Loop through each pixel and compute its color.\n  for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit, so compute its hue by composing\n      // a low frequency / slowly changing sine wave with a high\n      // frequency / fast changing cosine wave.  This means the candle will\n      // pulse and jump around in an organice but random looking way.\n      // The frequencies and phases of the waves are randomly generated at\n      // startup in the setup function.\n      // Low frequency wave is a sine wave with random freuqency between 1 and 4,\n      // and offset by a random phase to keep pixels from all starting at the same\n      // color:\n      float lowFreq  = sin(2.0*PI*frequencies[i]*t + phases[i]);\n      // High frequency is a faster changing cosine wave that uses a different\n      // pixel's random frequency.\n      float highFreq = cos(3.0*PI*frequencies[(i+5)%10]*t);\n      // Add the low and high frequency waves together, then interpolate their value\n      // to a hue that's +/-20% of the configured target hue.\n      float h = lerp(lowFreq+highFreq, -2.0, 2.0, lowHue, highHue);\n      setPixelHSV(i, h, 1.0, 1.0);"
        },
        {
          "name": "showLitSolid",
          "body": "for (int i=0; i<10; ++i) {\n    if (i < lit) {\n      // This pixel should be lit.\n      setPixelHSV(i, FLAME_HUE, 1.0, 1.0);"
        },
        {
          "name": "HSVtoRGB",
          "body": "int i;\n  float f, p, q, t;\n  if( s == 0 ) {\n    // achromatic (grey)\n    *r = *g = *b = v;\n    return;"
        },
        {
          "name": "setup",
          "body": "// Initialize serial output and Circuit Playground library.\n  Serial.begin(115200);\n  CircuitPlayground.begin();\n  // Check if a button is being pressed at startup and change the\n  // animation mode accordingly.\n  if (CircuitPlayground.leftButton()) {\n    // Rainbow animation on left button press at startup.\n    animation = RAINBOW;"
        },
        {
          "name": "loop",
          "body": "// Play happy birthday tune, from:\n  //  http://www.irish-folk-songs.com/happy-birthday-tin-whistle-sheet-music.html#.WXFJMtPytBw\n  // Inside each playNote call it will play a note and drive the NeoPixel animation\n  // and check for a breath against the sound sensor.  Once all the candles are blown out\n  // the playNote calls will stop playing music.\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_E4, QUARTER);       // Bar 1\n  playNote(NOTE_D4, QUARTER);\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_FS4, HALF);         // Bar 2\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_E4, QUARTER);       // Bar 3\n  playNote(NOTE_D4, QUARTER);\n  playNote(NOTE_A4, QUARTER);\n  playNote(NOTE_G4, HALF);          // Bar 4\n  playNote(NOTE_D4, EIGHTH, true);\n  playNote(NOTE_D4, EIGHTH);\n  playNote(NOTE_D5, QUARTER);       // Bar 5\n  playNote(NOTE_B4, QUARTER);\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_FS4, QUARTER);      // Bar 6\n  playNote(NOTE_E4, QUARTER);\n  playNote(NOTE_C5, EIGHTH, true);\n  playNote(NOTE_C5, EIGHTH);\n  playNote(NOTE_B4, QUARTER);       // Bar 7\n  playNote(NOTE_G4, QUARTER);\n  playNote(NOTE_A4, QUARTER);\n  playNote(NOTE_G4, HALF);          // Bar 8\n  // One second pause before repeating the loop and playing\n  // the tune again.  Use waitBreath instead of delay so the\n  // pixel animation and breath check continues to happen.\n  waitBreath(1000);"
        }
      ]
    },
    {
      "name": "FLASH_TYPE",
      "keywords": [
        "Serial",
        "delay"
      ],
      "libraries": [
        "Audio.h",
        "Adafruit_Keypad.h",
        "Adafruit_SPIFlash_FatFs.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600); // open the serial\n\n  customKeypad.begin();\n\n  // Audio connections require memory to work.  For more\n  // detailed information, see the MemoryAndCpuUsage example\n  AudioMemory(40); //this is WAY more tha nwe need\n  // Initialize flash library and check its chip ID.\n  if (!flash.begin()) {\n    while(1){\n      Serial.println(\"Error, failed to initialize flash chip!\");\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "customKeypad.tick();\n  \n  while(customKeypad.available())\n  {\n    keypadEvent e = customKeypad.read();\n    if(e.bit.EVENT == KEY_JUST_PRESSED){\n        if(e.bit.KEY == 1){\n          //Bitcrusher BitDepth\n          if (current_CrushBits >= 2) { //eachtime you press it, deduct 1 bit from the settings.\n              current_CrushBits--;"
        }
      ]
    },
    {
      "name": "ENABLE_DEBUG",
      "keywords": [
        "Serial"
      ],
      "libraries": [
        "WebServer_WT32_ETH01.h"
      ],
      "functions": [
        {
          "name": "setupETH",
          "body": "Serial.print(\"[ETH]: Connecting\");\n  \n  // To be called before ETH.begin()\n  WT32_ETH01_onEvent();\n\n  //bool begin(uint8_t phy_addr=ETH_PHY_ADDR, int power=ETH_PHY_POWER, int mdc=ETH_PHY_MDC, int mdio=ETH_PHY_MDIO, \n  //           eth_phy_type_t type=ETH_PHY_TYPE, eth_clock_mode_t clk_mode=ETH_CLK_MODE);\n  //ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER, ETH_PHY_MDC, ETH_PHY_MDIO, ETH_PHY_TYPE, ETH_CLK_MODE);\n  ETH.begin(ETH_PHY_ADDR, ETH_PHY_POWER);\n\n  // Static IP, leave without this line to get IP via DHCP\n  //bool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = 0, IPAddress dns2 = 0);\n  ETH.config(myIP, myGW, mySN, myDNS);\n\n  WT32_ETH01_waitForConnect();\n  \n  Serial.print(\"[ETH]: IP-Address is \");\n  Serial.println(ETH.localIP());"
        },
        {
          "name": "setupSinricPro",
          "body": "// get a new Blinds device from SinricPro\n  SinricProBlinds &myBlinds = SinricPro[BLINDS_ID];\n  myBlinds.onPowerState(onPowerState);\n  myBlinds.onSetPosition(onSetPosition);\n  myBlinds.onAdjustPosition(onAdjustPosition);\n\n  // setup SinricPro\n  SinricPro.onConnected([]() \n  {\n    Serial.println(\"Connected to SinricPro\");"
        },
        {
          "name": "setup",
          "body": "Serial.begin(BAUD_RATE); \n  while (!Serial);\n  \n  Serial.print(F(\"\\nStart Blinds on \")); Serial.print(BOARD_NAME);\n  Serial.print(F(\" with \")); Serial.println(SHIELD_TYPE);\n  Serial.println(WEBSERVER_WT32_ETH01_VERSION);\n  Serial.println(SINRICPRO_VERSION_STR);\n  \n  setupETH();\n  setupSinricPro();"
        },
        {
          "name": "loop",
          "body": "SinricPro.handle();"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay"
      ],
      "libraries": [
        "EduIntro.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "//nothing here"
        },
        {
          "name": "loop",
          "body": "led.on();       // set the LED on\n  delay(1000);    // wait for a second\n  led.off();      // set the LED off\n  delay(1000);    // wait for a second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "analogRead",
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// put your setup code here, to run once:\n  randomSeed(analogRead(0));\n\n#ifdef CORE_CM7\n  bootM4();\n  myLED = LEDB; // built-in blue LED\n#endif\n#ifdef CORE_CM4\n  myLED = LEDG; // built-in greeen LED\n#endif\n  pinMode(myLED, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "// put your main code here, to run repeatedly:\n  digitalWrite(myLED, LOW); // turn the LED on\n  delay(200);\n  digitalWrite(myLED, HIGH); // turn the LED off\n  delay( rand() % 2000 + 1000); // wait for a random amount of time between 1 and 3 seconds."
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "delay",
        "Serial",
        "digitalWrite"
      ],
      "libraries": [
        "loopTimer.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial.begin(9600);\n  for (int i = 10; i > 0; i--) {\n    Serial.println(i);\n    delay(500);"
        },
        {
          "name": "blinkLed13",
          "body": "digitalWrite(led, HIGH);   // turn the led on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(led, LOW);    // turn the led off by making the voltage LOW\n  delay(1000);                       // wait for a second"
        },
        {
          "name": "loop",
          "body": "loopTimer.check(Serial);\n  blinkLed13(); // call the method to blink the led"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n    pinMode(LEDG, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(LEDG, LOW); // turn the LED on (LOW is the voltage level)\n    delay(500); // wait for half a second\n    digitalWrite(LEDG, HIGH); // turn the LED off by making the voltage HIGH\n    delay(500); // wait for half a second"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [
        "Arduino_EdgeControl.h"
      ],
      "functions": [
        {
          "name": "setup",
          "body": "Serial1.begin(9600);\n      pinMode(LED_BUILTIN, OUTPUT);\n      digitalWrite(LED_BUILTIN, LOW);\n\n      delay(1000);"
        },
        {
          "name": "loop",
          "body": "if (Serial1.available()) {\n        auto c = Serial1.read();\n        digitalWrite(LED_BUILTIN, c);"
        },
        {
          "name": "setup",
          "body": "EdgeControl.begin();\n    Power.on(PWR_3V3);\n    Power.on(PWR_VBAT);\n    Power.on(PWR_MKR2);\n\n    // Wait for MKR to power on\n    delay(5000);\n\n    SerialMKR2.begin(115200);\n    while (!SerialMKR2) {\n        delay(500);"
        },
        {
          "name": "loop",
          "body": "SerialMKR2.write(led);\n    led = !led;\n    delay(1000);"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n  bootM4();\n  pinMode(LEDR, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(LEDR, LOW); // turn the red LED on (LOW is the voltage level)\n  delay(200); // wait for 200 milliseconds\n  digitalWrite(LEDR, HIGH); // turn the LED off by setting the voltage HIGH\n  delay(200); // wait for 200 milliseconds"
        }
      ]
    },
    {
      "name": "Unnamed Template",
      "keywords": [
        "digitalWrite",
        "delay"
      ],
      "libraries": [],
      "functions": [
        {
          "name": "setup",
          "body": "// initialize digital pin LED_BUILTIN as an output.\n  pinMode(LEDR, OUTPUT);"
        },
        {
          "name": "loop",
          "body": "digitalWrite(LEDR, HIGH); // turn the LED off (HIGH is the voltage level)\n  delay(200); // wait for 200 milliseconds\n  digitalWrite(LEDR, LOW); // turn the LED on by making the voltage LOW\n  delay(200); // wait for 200 milliseconds"
        }
      ]
    }
  ],
  "vocab": [
    "Serial",
    "delay",
    "Wire",
    "analogRead",
    "digitalWrite",
    "analogWrite",
    "attachInterrupt",
    "EEPROM"
  ]
}